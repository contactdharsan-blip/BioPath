import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/3dmol/build/3Dmol.js
var require_Dmol = __commonJS({
  "node_modules/3dmol/build/3Dmol.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["3Dmol"] = factory();
      else
        root["3Dmol"] = factory();
    })(exports, () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = {
            /***/
            "./node_modules/iobuffer/lib-esm/IOBuffer.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                IOBuffer: () => (
                  /* binding */
                  IOBuffer
                )
                /* harmony export */
              });
              var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./text */
                "./node_modules/iobuffer/lib-esm/text.js"
              );
              const defaultByteLength = 1024 * 8;
              const hostBigEndian = (() => {
                const array = new Uint8Array(4);
                const view = new Uint32Array(array.buffer);
                return !((view[0] = 1) & array[0]);
              })();
              const typedArrays = {
                int8: globalThis.Int8Array,
                uint8: globalThis.Uint8Array,
                int16: globalThis.Int16Array,
                uint16: globalThis.Uint16Array,
                int32: globalThis.Int32Array,
                uint32: globalThis.Uint32Array,
                uint64: globalThis.BigUint64Array,
                int64: globalThis.BigInt64Array,
                float32: globalThis.Float32Array,
                float64: globalThis.Float64Array
              };
              class IOBuffer {
                /**
                 * Reference to the internal ArrayBuffer object.
                 */
                buffer;
                /**
                 * Byte length of the internal ArrayBuffer.
                 */
                byteLength;
                /**
                 * Byte offset of the internal ArrayBuffer.
                 */
                byteOffset;
                /**
                 * Byte length of the internal ArrayBuffer.
                 */
                length;
                /**
                 * The current offset of the buffer's pointer.
                 */
                offset;
                lastWrittenByte;
                littleEndian;
                _data;
                _mark;
                _marks;
                /**
                 * Create a new IOBuffer.
                 * @param data - The data to construct the IOBuffer with.
                 * If data is a number, it will be the new buffer's length<br>
                 * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
                 * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
                 * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
                 * @param options - An object for the options.
                 * @returns A new IOBuffer instance.
                 */
                constructor(data = defaultByteLength, options = {}) {
                  let dataIsGiven = false;
                  if (typeof data === "number") {
                    data = new ArrayBuffer(data);
                  } else {
                    dataIsGiven = true;
                    this.lastWrittenByte = data.byteLength;
                  }
                  const offset = options.offset ? options.offset >>> 0 : 0;
                  const byteLength = data.byteLength - offset;
                  let dvOffset = offset;
                  if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
                    if (data.byteLength !== data.buffer.byteLength) {
                      dvOffset = data.byteOffset + offset;
                    }
                    data = data.buffer;
                  }
                  if (dataIsGiven) {
                    this.lastWrittenByte = byteLength;
                  } else {
                    this.lastWrittenByte = 0;
                  }
                  this.buffer = data;
                  this.length = byteLength;
                  this.byteLength = byteLength;
                  this.byteOffset = dvOffset;
                  this.offset = 0;
                  this.littleEndian = true;
                  this._data = new DataView(this.buffer, dvOffset, byteLength);
                  this._mark = 0;
                  this._marks = [];
                }
                /**
                 * Checks if the memory allocated to the buffer is sufficient to store more
                 * bytes after the offset.
                 * @param byteLength - The needed memory in bytes.
                 * @returns `true` if there is sufficient space and `false` otherwise.
                 */
                available(byteLength = 1) {
                  return this.offset + byteLength <= this.length;
                }
                /**
                 * Check if little-endian mode is used for reading and writing multi-byte
                 * values.
                 * @returns `true` if little-endian mode is used, `false` otherwise.
                 */
                isLittleEndian() {
                  return this.littleEndian;
                }
                /**
                 * Set little-endian mode for reading and writing multi-byte values.
                 * @returns This.
                 */
                setLittleEndian() {
                  this.littleEndian = true;
                  return this;
                }
                /**
                 * Check if big-endian mode is used for reading and writing multi-byte values.
                 * @returns `true` if big-endian mode is used, `false` otherwise.
                 */
                isBigEndian() {
                  return !this.littleEndian;
                }
                /**
                 * Switches to big-endian mode for reading and writing multi-byte values.
                 * @returns This.
                 */
                setBigEndian() {
                  this.littleEndian = false;
                  return this;
                }
                /**
                 * Move the pointer n bytes forward.
                 * @param n - Number of bytes to skip.
                 * @returns This.
                 */
                skip(n = 1) {
                  this.offset += n;
                  return this;
                }
                /**
                 * Move the pointer n bytes backward.
                 * @param n - Number of bytes to move back.
                 * @returns This.
                 */
                back(n = 1) {
                  this.offset -= n;
                  return this;
                }
                /**
                 * Move the pointer to the given offset.
                 * @param offset - The offset to move to.
                 * @returns This.
                 */
                seek(offset) {
                  this.offset = offset;
                  return this;
                }
                /**
                 * Store the current pointer offset.
                 * @see {@link IOBuffer#reset}
                 * @returns This.
                 */
                mark() {
                  this._mark = this.offset;
                  return this;
                }
                /**
                 * Move the pointer back to the last pointer offset set by mark.
                 * @see {@link IOBuffer#mark}
                 * @returns This.
                 */
                reset() {
                  this.offset = this._mark;
                  return this;
                }
                /**
                 * Push the current pointer offset to the mark stack.
                 * @see {@link IOBuffer#popMark}
                 * @returns This.
                 */
                pushMark() {
                  this._marks.push(this.offset);
                  return this;
                }
                /**
                 * Pop the last pointer offset from the mark stack, and set the current
                 * pointer offset to the popped value.
                 * @see {@link IOBuffer#pushMark}
                 * @returns This.
                 */
                popMark() {
                  const offset = this._marks.pop();
                  if (offset === void 0) {
                    throw new Error("Mark stack empty");
                  }
                  this.seek(offset);
                  return this;
                }
                /**
                 * Move the pointer offset back to 0.
                 * @returns This.
                 */
                rewind() {
                  this.offset = 0;
                  return this;
                }
                /**
                 * Make sure the buffer has sufficient memory to write a given byteLength at
                 * the current pointer offset.
                 * If the buffer's memory is insufficient, this method will create a new
                 * buffer (a copy) with a length that is twice (byteLength + current offset).
                 * @param byteLength - The needed memory in bytes.
                 * @returns This.
                 */
                ensureAvailable(byteLength = 1) {
                  if (!this.available(byteLength)) {
                    const lengthNeeded = this.offset + byteLength;
                    const newLength = lengthNeeded * 2;
                    const newArray = new Uint8Array(newLength);
                    newArray.set(new Uint8Array(this.buffer));
                    this.buffer = newArray.buffer;
                    this.length = newLength;
                    this.byteLength = newLength;
                    this._data = new DataView(this.buffer);
                  }
                  return this;
                }
                /**
                 * Read a byte and return false if the byte's value is 0, or true otherwise.
                 * Moves pointer forward by one byte.
                 * @returns The read boolean.
                 */
                readBoolean() {
                  return this.readUint8() !== 0;
                }
                /**
                 * Read a signed 8-bit integer and move pointer forward by 1 byte.
                 * @returns The read byte.
                 */
                readInt8() {
                  return this._data.getInt8(this.offset++);
                }
                /**
                 * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
                 * @returns The read byte.
                 */
                readUint8() {
                  return this._data.getUint8(this.offset++);
                }
                /**
                 * Alias for {@link IOBuffer#readUint8}.
                 * @returns The read byte.
                 */
                readByte() {
                  return this.readUint8();
                }
                /**
                 * Read `n` bytes and move pointer forward by `n` bytes.
                 * @param n - Number of bytes to read.
                 * @returns The read bytes.
                 */
                readBytes(n = 1) {
                  return this.readArray(n, "uint8");
                }
                /**
                 * Creates an array of corresponding to the type `type` and size `size`.
                 * For example type `uint8` will create a `Uint8Array`.
                 * @param size - size of the resulting array
                 * @param type - number type of elements to read
                 * @returns The read array.
                 */
                readArray(size, type) {
                  const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
                  const offset = this.byteOffset + this.offset;
                  const slice = this.buffer.slice(offset, offset + bytes);
                  if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
                    const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
                    slice2.reverse();
                    const returnArray2 = new typedArrays[type](slice2.buffer);
                    this.offset += bytes;
                    returnArray2.reverse();
                    return returnArray2;
                  }
                  const returnArray = new typedArrays[type](slice);
                  this.offset += bytes;
                  return returnArray;
                }
                /**
                 * Read a 16-bit signed integer and move pointer forward by 2 bytes.
                 * @returns The read value.
                 */
                readInt16() {
                  const value = this._data.getInt16(this.offset, this.littleEndian);
                  this.offset += 2;
                  return value;
                }
                /**
                 * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
                 * @returns The read value.
                 */
                readUint16() {
                  const value = this._data.getUint16(this.offset, this.littleEndian);
                  this.offset += 2;
                  return value;
                }
                /**
                 * Read a 32-bit signed integer and move pointer forward by 4 bytes.
                 * @returns The read value.
                 */
                readInt32() {
                  const value = this._data.getInt32(this.offset, this.littleEndian);
                  this.offset += 4;
                  return value;
                }
                /**
                 * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
                 * @returns The read value.
                 */
                readUint32() {
                  const value = this._data.getUint32(this.offset, this.littleEndian);
                  this.offset += 4;
                  return value;
                }
                /**
                 * Read a 32-bit floating number and move pointer forward by 4 bytes.
                 * @returns The read value.
                 */
                readFloat32() {
                  const value = this._data.getFloat32(this.offset, this.littleEndian);
                  this.offset += 4;
                  return value;
                }
                /**
                 * Read a 64-bit floating number and move pointer forward by 8 bytes.
                 * @returns The read value.
                 */
                readFloat64() {
                  const value = this._data.getFloat64(this.offset, this.littleEndian);
                  this.offset += 8;
                  return value;
                }
                /**
                 * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
                 * @returns The read value.
                 */
                readBigInt64() {
                  const value = this._data.getBigInt64(this.offset, this.littleEndian);
                  this.offset += 8;
                  return value;
                }
                /**
                 * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
                 * @returns The read value.
                 */
                readBigUint64() {
                  const value = this._data.getBigUint64(this.offset, this.littleEndian);
                  this.offset += 8;
                  return value;
                }
                /**
                 * Read a 1-byte ASCII character and move pointer forward by 1 byte.
                 * @returns The read character.
                 */
                readChar() {
                  return String.fromCharCode(this.readInt8());
                }
                /**
                 * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
                 * @param n - Number of characters to read.
                 * @returns The read characters.
                 */
                readChars(n = 1) {
                  let result = "";
                  for (let i = 0; i < n; i++) {
                    result += this.readChar();
                  }
                  return result;
                }
                /**
                 * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
                 * forward by `n` bytes.
                 * @param n - Number of bytes to read.
                 * @returns The decoded string.
                 */
                readUtf8(n = 1) {
                  return (0, _text__WEBPACK_IMPORTED_MODULE_0__.decode)(this.readBytes(n));
                }
                /**
                 * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
                 * forward by `n` bytes.
                 * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
                 * @param n - Number of bytes to read.
                 * @param encoding - The encoding to use. Default is 'utf8'.
                 * @returns The decoded string.
                 */
                decodeText(n = 1, encoding = "utf8") {
                  return (0, _text__WEBPACK_IMPORTED_MODULE_0__.decode)(this.readBytes(n), encoding);
                }
                /**
                 * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
                 * forward by 1 byte.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeBoolean(value) {
                  this.writeUint8(value ? 255 : 0);
                  return this;
                }
                /**
                 * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeInt8(value) {
                  this.ensureAvailable(1);
                  this._data.setInt8(this.offset++, value);
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
                 * byte.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeUint8(value) {
                  this.ensureAvailable(1);
                  this._data.setUint8(this.offset++, value);
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * An alias for {@link IOBuffer#writeUint8}.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeByte(value) {
                  return this.writeUint8(value);
                }
                /**
                 * Write all elements of `bytes` as uint8 values and move pointer forward by
                 * `bytes.length` bytes.
                 * @param bytes - The array of bytes to write.
                 * @returns This.
                 */
                writeBytes(bytes) {
                  this.ensureAvailable(bytes.length);
                  for (let i = 0; i < bytes.length; i++) {
                    this._data.setUint8(this.offset++, bytes[i]);
                  }
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 16-bit signed integer and move pointer forward by 2
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeInt16(value) {
                  this.ensureAvailable(2);
                  this._data.setInt16(this.offset, value, this.littleEndian);
                  this.offset += 2;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeUint16(value) {
                  this.ensureAvailable(2);
                  this._data.setUint16(this.offset, value, this.littleEndian);
                  this.offset += 2;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 32-bit signed integer and move pointer forward by 4
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeInt32(value) {
                  this.ensureAvailable(4);
                  this._data.setInt32(this.offset, value, this.littleEndian);
                  this.offset += 4;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeUint32(value) {
                  this.ensureAvailable(4);
                  this._data.setUint32(this.offset, value, this.littleEndian);
                  this.offset += 4;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 32-bit floating number and move pointer forward by 4
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeFloat32(value) {
                  this.ensureAvailable(4);
                  this._data.setFloat32(this.offset, value, this.littleEndian);
                  this.offset += 4;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 64-bit floating number and move pointer forward by 8
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeFloat64(value) {
                  this.ensureAvailable(8);
                  this._data.setFloat64(this.offset, value, this.littleEndian);
                  this.offset += 8;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 64-bit signed bigint and move pointer forward by 8
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeBigInt64(value) {
                  this.ensureAvailable(8);
                  this._data.setBigInt64(this.offset, value, this.littleEndian);
                  this.offset += 8;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
                 * bytes.
                 * @param value - The value to write.
                 * @returns This.
                 */
                writeBigUint64(value) {
                  this.ensureAvailable(8);
                  this._data.setBigUint64(this.offset, value, this.littleEndian);
                  this.offset += 8;
                  this._updateLastWrittenByte();
                  return this;
                }
                /**
                 * Write the charCode of `str`'s first character as an 8-bit unsigned integer
                 * and move pointer forward by 1 byte.
                 * @param str - The character to write.
                 * @returns This.
                 */
                writeChar(str) {
                  return this.writeUint8(str.charCodeAt(0));
                }
                /**
                 * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
                 * and move pointer forward by `str.length` bytes.
                 * @param str - The characters to write.
                 * @returns This.
                 */
                writeChars(str) {
                  for (let i = 0; i < str.length; i++) {
                    this.writeUint8(str.charCodeAt(i));
                  }
                  return this;
                }
                /**
                 * UTF-8 encode and write `str` to the current pointer offset and move pointer
                 * forward according to the encoded length.
                 * @param str - The string to write.
                 * @returns This.
                 */
                writeUtf8(str) {
                  return this.writeBytes((0, _text__WEBPACK_IMPORTED_MODULE_0__.encode)(str));
                }
                /**
                 * Export a Uint8Array view of the internal buffer.
                 * The view starts at the byte offset and its length
                 * is calculated to stop at the last written byte or the original length.
                 * @returns A new Uint8Array view.
                 */
                toArray() {
                  return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
                }
                /**
                 *  Get the total number of bytes written so far, regardless of the current offset.
                 * @returns - Total number of bytes.
                 */
                getWrittenByteLength() {
                  return this.lastWrittenByte - this.byteOffset;
                }
                /**
                 * Update the last written byte offset
                 * @private
                 */
                _updateLastWrittenByte() {
                  if (this.offset > this.lastWrittenByte) {
                    this.lastWrittenByte = this.offset;
                  }
                }
              }
            },
            /***/
            "./node_modules/iobuffer/lib-esm/text.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                decode: () => (
                  /* binding */
                  decode
                ),
                /* harmony export */
                encode: () => (
                  /* binding */
                  encode
                )
                /* harmony export */
              });
              function decode(bytes, encoding = "utf8") {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(bytes);
              }
              const encoder = new TextEncoder();
              function encode(str) {
                return encoder.encode(str);
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/data.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                nonRecord: () => (
                  /* binding */
                  nonRecord
                ),
                /* harmony export */
                record: () => (
                  /* binding */
                  record
                )
                /* harmony export */
              });
              var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./types */
                "./node_modules/netcdfjs/lib-esm/types.js"
              );
              function nonRecord(buffer, variable) {
                const type = (0, _types__WEBPACK_IMPORTED_MODULE_0__.str2num)(variable.type);
                const size = variable.size / (0, _types__WEBPACK_IMPORTED_MODULE_0__.num2bytes)(type);
                const data = new Array(size);
                for (let i = 0; i < size; i++) {
                  data[i] = (0, _types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, 1);
                }
                return data;
              }
              function record(buffer, variable, recordDimension) {
                const type = (0, _types__WEBPACK_IMPORTED_MODULE_0__.str2num)(variable.type);
                const width = variable.size ? variable.size / (0, _types__WEBPACK_IMPORTED_MODULE_0__.num2bytes)(type) : 1;
                const size = recordDimension.length;
                const data = new Array(size);
                const step = recordDimension.recordStep;
                if (step) {
                  for (let i = 0; i < size; i++) {
                    const currentOffset = buffer.offset;
                    data[i] = (0, _types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, width);
                    buffer.seek(currentOffset + step);
                  }
                } else {
                  throw new Error("recordDimension.recordStep is undefined");
                }
                return data;
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/header.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                header: () => (
                  /* binding */
                  header
                )
                /* harmony export */
              });
              var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./types */
                "./node_modules/netcdfjs/lib-esm/types.js"
              );
              var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils */
                "./node_modules/netcdfjs/lib-esm/utils.js"
              );
              const ZERO = 0;
              const NC_DIMENSION = 10;
              const NC_VARIABLE = 11;
              const NC_ATTRIBUTE = 12;
              const NC_UNLIMITED = 0;
              function header(buffer, version) {
                const header2 = { version };
                const recordDimension = {
                  length: buffer.readUint32()
                };
                const dimList = dimensionsList(buffer);
                if (!Array.isArray(dimList)) {
                  recordDimension.id = dimList.recordId;
                  recordDimension.name = dimList.recordName;
                  header2.dimensions = dimList.dimensions;
                }
                header2.globalAttributes = attributesList(buffer);
                const variables = variablesList(buffer, recordDimension?.id, version);
                if (!Array.isArray(variables)) {
                  header2.variables = variables.variables;
                  recordDimension.recordStep = variables.recordStep;
                }
                header2.recordDimension = recordDimension;
                return header2;
              }
              function dimensionsList(buffer) {
                const result = {};
                let recordId, recordName;
                const dimList = buffer.readUint32();
                let dimensions;
                if (dimList === ZERO) {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, "wrong empty tag for list of dimensions");
                  return [];
                } else {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(dimList !== NC_DIMENSION, "wrong tag for list of dimensions");
                  const dimensionSize = buffer.readUint32();
                  dimensions = new Array(dimensionSize);
                  for (let dim = 0; dim < dimensionSize; dim++) {
                    const name = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);
                    const size = buffer.readUint32();
                    if (size === NC_UNLIMITED) {
                      recordId = dim;
                      recordName = name;
                    }
                    dimensions[dim] = {
                      name,
                      size
                    };
                  }
                }
                if (recordId !== void 0) {
                  result.recordId = recordId;
                }
                if (recordName !== void 0) {
                  result.recordName = recordName;
                }
                result.dimensions = dimensions;
                return result;
              }
              function attributesList(buffer) {
                const gAttList = buffer.readUint32();
                let attributes;
                if (gAttList === ZERO) {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, "wrong empty tag for list of attributes");
                  return [];
                } else {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(gAttList !== NC_ATTRIBUTE, "wrong tag for list of attributes");
                  const attributeSize = buffer.readUint32();
                  attributes = new Array(attributeSize);
                  for (let gAtt = 0; gAtt < attributeSize; gAtt++) {
                    const name = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);
                    const type = buffer.readUint32();
                    (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(type < 1 || type > 6, `non valid type ${type}`);
                    const size = buffer.readUint32();
                    const value = (0, _types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, size);
                    (0, _utils__WEBPACK_IMPORTED_MODULE_1__.padding)(buffer);
                    attributes[gAtt] = {
                      name,
                      type: (0, _types__WEBPACK_IMPORTED_MODULE_0__.num2str)(type),
                      value
                    };
                  }
                }
                return attributes;
              }
              function variablesList(buffer, recordId, version) {
                const varList = buffer.readUint32();
                let recordStep = 0;
                let variables;
                if (varList === ZERO) {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, "wrong empty tag for list of variables");
                  return [];
                } else {
                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(varList !== NC_VARIABLE, "wrong tag for list of variables");
                  const variableSize = buffer.readUint32();
                  variables = new Array(variableSize);
                  for (let v = 0; v < variableSize; v++) {
                    const name = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);
                    const dimensionality = buffer.readUint32();
                    const dimensionsIds = new Array(dimensionality);
                    for (let dim = 0; dim < dimensionality; dim++) {
                      dimensionsIds[dim] = buffer.readUint32();
                    }
                    const attributes = attributesList(buffer);
                    const type = buffer.readUint32();
                    (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(type < 1 && type > 6, `non valid type ${type}`);
                    const varSize = buffer.readUint32();
                    let offset = buffer.readUint32();
                    if (version === 2) {
                      (0, _utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(offset > 0, "offsets larger than 4GB not supported");
                      offset = buffer.readUint32();
                    }
                    let record = false;
                    if (typeof recordId !== "undefined" && dimensionsIds[0] === recordId) {
                      recordStep += varSize;
                      record = true;
                    }
                    variables[v] = {
                      name,
                      dimensions: dimensionsIds,
                      attributes,
                      type: (0, _types__WEBPACK_IMPORTED_MODULE_0__.num2str)(type),
                      size: varSize,
                      offset,
                      record
                    };
                  }
                }
                return {
                  variables,
                  recordStep
                };
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/index.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                NetCDFReader: () => (
                  /* reexport safe */
                  _parser__WEBPACK_IMPORTED_MODULE_0__.NetCDFReader
                )
                /* harmony export */
              });
              var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./parser */
                "./node_modules/netcdfjs/lib-esm/parser.js"
              );
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/parser.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                NetCDFReader: () => (
                  /* binding */
                  NetCDFReader
                )
                /* harmony export */
              });
              var iobuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! iobuffer */
                "./node_modules/iobuffer/lib-esm/IOBuffer.js"
              );
              var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./data */
                "./node_modules/netcdfjs/lib-esm/data.js"
              );
              var _header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./header */
                "./node_modules/netcdfjs/lib-esm/header.js"
              );
              var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./toString */
                "./node_modules/netcdfjs/lib-esm/toString.js"
              );
              var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./utils */
                "./node_modules/netcdfjs/lib-esm/utils.js"
              );
              class NetCDFReader {
                constructor(data) {
                  this.toString = _toString__WEBPACK_IMPORTED_MODULE_3__.toString;
                  const buffer = new iobuffer__WEBPACK_IMPORTED_MODULE_0__.IOBuffer(data);
                  buffer.setBigEndian();
                  (0, _utils__WEBPACK_IMPORTED_MODULE_4__.notNetcdf)(buffer.readChars(3) !== "CDF", "should start with CDF");
                  const version = buffer.readByte();
                  (0, _utils__WEBPACK_IMPORTED_MODULE_4__.notNetcdf)(version > 2, "unknown version");
                  this.header = (0, _header__WEBPACK_IMPORTED_MODULE_2__.header)(buffer, version);
                  this.buffer = buffer;
                }
                /**
                 * @return - Version for the NetCDF format
                 */
                get version() {
                  if (this.header.version === 1) {
                    return "classic format";
                  } else {
                    return "64-bit offset format";
                  }
                }
                /**
                 * @return {object} - Metadata for the record dimension
                 *  * `length`: Number of elements in the record dimension
                 *  * `id`: Id number in the list of dimensions for the record dimension
                 *  * `name`: String with the name of the record dimension
                 *  * `recordStep`: Number with the record variables step size
                 */
                get recordDimension() {
                  return this.header.recordDimension;
                }
                /**
                 * @return - Array - List of dimensions with:
                 *  * `name`: String with the name of the dimension
                 *  * `size`: Number with the size of the dimension
                 */
                get dimensions() {
                  return this.header.dimensions;
                }
                /**
                 * @return - Array - List of global attributes with:
                 *  * `name`: String with the name of the attribute
                 *  * `type`: String with the type of the attribute
                 *  * `value`: A number or string with the value of the attribute
                 */
                get globalAttributes() {
                  return this.header.globalAttributes;
                }
                /**
                 * Returns the value of an attribute
                 * @param - AttributeName
                 * @return - Value of the attributeName or null
                 */
                getAttribute(attributeName) {
                  const attribute = this.globalAttributes.find((val) => val.name === attributeName);
                  if (attribute)
                    return attribute.value;
                  return null;
                }
                /**
                 * Returns the value of a variable as a string
                 * @param - variableName
                 * @return - Value of the variable as a string or null
                 */
                getDataVariableAsString(variableName) {
                  const variable = this.getDataVariable(variableName);
                  if (variable)
                    return variable.join("");
                  return null;
                }
                get variables() {
                  return this.header.variables;
                }
                /**
                 * Retrieves the data for a given variable
                 * @param variableName - Name of the variable to search or variable object
                 * @return The variable values
                 */
                getDataVariable(variableName) {
                  let variable;
                  if (typeof variableName === "string") {
                    variable = this.header.variables.find((val) => {
                      return val.name === variableName;
                    });
                  } else {
                    variable = variableName;
                  }
                  if (variable === void 0) {
                    throw new Error("Not a valid NetCDF v3.x file: variable not found");
                  }
                  this.buffer.seek(variable.offset);
                  if (variable.record) {
                    return (0, _data__WEBPACK_IMPORTED_MODULE_1__.record)(this.buffer, variable, this.header.recordDimension);
                  } else {
                    return (0, _data__WEBPACK_IMPORTED_MODULE_1__.nonRecord)(this.buffer, variable);
                  }
                }
                /**
                 * Check if a dataVariable exists
                 * @param variableName - Name of the variable to find
                 * @return boolean
                 */
                dataVariableExists(variableName) {
                  const variable = this.header.variables.find((val) => {
                    return val.name === variableName;
                  });
                  return variable !== void 0;
                }
                /**
                 * Check if an attribute exists
                 * @param attributeName - Name of the attribute to find
                 * @return boolean
                 */
                attributeExists(attributeName) {
                  const attribute = this.globalAttributes.find((val) => val.name === attributeName);
                  return attribute !== void 0;
                }
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/toString.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                toString: () => (
                  /* binding */
                  toString
                )
                /* harmony export */
              });
              function toString() {
                const result = [];
                result.push("DIMENSIONS");
                for (const dimension of this.dimensions) {
                  result.push(`  ${dimension.name.padEnd(30)} = size: ${dimension.size}`);
                }
                result.push("");
                result.push("GLOBAL ATTRIBUTES");
                for (const attribute of this.globalAttributes) {
                  result.push(`  ${attribute.name.padEnd(30)} = ${attribute.value}`);
                }
                const variables = JSON.parse(JSON.stringify(this.variables));
                result.push("");
                result.push("VARIABLES:");
                for (const variable of variables) {
                  variable.value = this.getDataVariable(variable);
                  let stringify = JSON.stringify(variable.value);
                  if (stringify.length > 50)
                    stringify = stringify.substring(0, 50);
                  if (!isNaN(variable.value.length)) {
                    stringify += ` (length: ${variable.value.length})`;
                  }
                  result.push(`  ${variable.name.padEnd(30)} = ${stringify}`);
                }
                return result.join("\n");
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/types.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                num2bytes: () => (
                  /* binding */
                  num2bytes
                ),
                /* harmony export */
                num2str: () => (
                  /* binding */
                  num2str
                ),
                /* harmony export */
                readType: () => (
                  /* binding */
                  readType
                ),
                /* harmony export */
                str2num: () => (
                  /* binding */
                  str2num
                )
                /* harmony export */
              });
              const types = {
                BYTE: 1,
                CHAR: 2,
                SHORT: 3,
                INT: 4,
                FLOAT: 5,
                DOUBLE: 6
              };
              function num2str(type) {
                switch (Number(type)) {
                  case types.BYTE:
                    return "byte";
                  case types.CHAR:
                    return "char";
                  case types.SHORT:
                    return "short";
                  case types.INT:
                    return "int";
                  case types.FLOAT:
                    return "float";
                  case types.DOUBLE:
                    return "double";
                  default:
                    return "undefined";
                }
              }
              function num2bytes(type) {
                switch (Number(type)) {
                  case types.BYTE:
                    return 1;
                  case types.CHAR:
                    return 1;
                  case types.SHORT:
                    return 2;
                  case types.INT:
                    return 4;
                  case types.FLOAT:
                    return 4;
                  case types.DOUBLE:
                    return 8;
                  default:
                    return -1;
                }
              }
              function str2num(type) {
                switch (String(type)) {
                  case "byte":
                    return types.BYTE;
                  case "char":
                    return types.CHAR;
                  case "short":
                    return types.SHORT;
                  case "int":
                    return types.INT;
                  case "float":
                    return types.FLOAT;
                  case "double":
                    return types.DOUBLE;
                  /* istanbul ignore next */
                  default:
                    return -1;
                }
              }
              function readNumber(size, bufferReader) {
                if (size !== 1) {
                  const numbers = new Array(size);
                  for (let i = 0; i < size; i++) {
                    numbers[i] = bufferReader();
                  }
                  return numbers;
                } else {
                  return bufferReader();
                }
              }
              function readType(buffer, type, size) {
                switch (type) {
                  case types.BYTE:
                    return Array.from(buffer.readBytes(size));
                  case types.CHAR:
                    return trimNull(buffer.readChars(size));
                  case types.SHORT:
                    return readNumber(size, buffer.readInt16.bind(buffer));
                  case types.INT:
                    return readNumber(size, buffer.readInt32.bind(buffer));
                  case types.FLOAT:
                    return readNumber(size, buffer.readFloat32.bind(buffer));
                  case types.DOUBLE:
                    return readNumber(size, buffer.readFloat64.bind(buffer));
                  default:
                    throw new Error(`non valid type ${type}`);
                }
              }
              function trimNull(value) {
                if (value.charCodeAt(value.length - 1) === 0) {
                  return value.substring(0, value.length - 1);
                }
                return value;
              }
            },
            /***/
            "./node_modules/netcdfjs/lib-esm/utils.js"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                notNetcdf: () => (
                  /* binding */
                  notNetcdf
                ),
                /* harmony export */
                padding: () => (
                  /* binding */
                  padding
                ),
                /* harmony export */
                readName: () => (
                  /* binding */
                  readName
                )
                /* harmony export */
              });
              function notNetcdf(statement, reason) {
                if (statement) {
                  throw new TypeError(`Not a valid NetCDF v3.x file: ${reason}`);
                }
              }
              function padding(buffer) {
                if (buffer.offset % 4 !== 0) {
                  buffer.skip(4 - buffer.offset % 4);
                }
              }
              function readName(buffer) {
                const nameLength = buffer.readUint32();
                const name = buffer.readChars(nameLength);
                padding(buffer);
                return name;
              }
            },
            /***/
            "./node_modules/pako/dist/pako.esm.mjs"(__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Deflate: () => (
                  /* binding */
                  Deflate_1
                ),
                /* harmony export */
                Inflate: () => (
                  /* binding */
                  Inflate_1
                ),
                /* harmony export */
                constants: () => (
                  /* binding */
                  constants_1
                ),
                /* harmony export */
                "default": () => (
                  /* binding */
                  pako
                ),
                /* harmony export */
                deflate: () => (
                  /* binding */
                  deflate_1
                ),
                /* harmony export */
                deflateRaw: () => (
                  /* binding */
                  deflateRaw_1
                ),
                /* harmony export */
                gzip: () => (
                  /* binding */
                  gzip_1
                ),
                /* harmony export */
                inflate: () => (
                  /* binding */
                  inflate_1
                ),
                /* harmony export */
                inflateRaw: () => (
                  /* binding */
                  inflateRaw_1
                ),
                /* harmony export */
                ungzip: () => (
                  /* binding */
                  ungzip_1
                )
                /* harmony export */
              });
              const Z_FIXED$1 = 4;
              const Z_BINARY = 0;
              const Z_TEXT = 1;
              const Z_UNKNOWN$1 = 2;
              function zero$1(buf) {
                let len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              }
              const STORED_BLOCK = 0;
              const STATIC_TREES = 1;
              const DYN_TREES = 2;
              const MIN_MATCH$1 = 3;
              const MAX_MATCH$1 = 258;
              const LENGTH_CODES$1 = 29;
              const LITERALS$1 = 256;
              const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
              const D_CODES$1 = 30;
              const BL_CODES$1 = 19;
              const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
              const MAX_BITS$1 = 15;
              const Buf_size = 16;
              const MAX_BL_BITS = 7;
              const END_BLOCK = 256;
              const REP_3_6 = 16;
              const REPZ_3_10 = 17;
              const REPZ_11_138 = 18;
              const extra_lbits = (
                /* extra bits for each length code */
                new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
              );
              const extra_dbits = (
                /* extra bits for each distance code */
                new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
              );
              const extra_blbits = (
                /* extra bits for each bit length code */
                new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
              );
              const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              const DIST_CODE_LEN = 512;
              const static_ltree = new Array((L_CODES$1 + 2) * 2);
              zero$1(static_ltree);
              const static_dtree = new Array(D_CODES$1 * 2);
              zero$1(static_dtree);
              const _dist_code = new Array(DIST_CODE_LEN);
              zero$1(_dist_code);
              const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
              zero$1(_length_code);
              const base_length = new Array(LENGTH_CODES$1);
              zero$1(base_length);
              const base_dist = new Array(D_CODES$1);
              zero$1(base_dist);
              function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree;
                this.extra_bits = extra_bits;
                this.extra_base = extra_base;
                this.elems = elems;
                this.max_length = max_length;
                this.has_stree = static_tree && static_tree.length;
              }
              let static_l_desc;
              let static_d_desc;
              let static_bl_desc;
              function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree;
                this.max_code = 0;
                this.stat_desc = stat_desc;
              }
              const d_code = (dist) => {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
              };
              const put_short = (s, w) => {
                s.pending_buf[s.pending++] = w & 255;
                s.pending_buf[s.pending++] = w >>> 8 & 255;
              };
              const send_bits = (s, value, length) => {
                if (s.bi_valid > Buf_size - length) {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  put_short(s, s.bi_buf);
                  s.bi_buf = value >> Buf_size - s.bi_valid;
                  s.bi_valid += length - Buf_size;
                } else {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  s.bi_valid += length;
                }
              };
              const send_code = (s, c, tree) => {
                send_bits(
                  s,
                  tree[c * 2],
                  tree[c * 2 + 1]
                  /*.Len*/
                );
              };
              const bi_reverse = (code, len) => {
                let res = 0;
                do {
                  res |= code & 1;
                  code >>>= 1;
                  res <<= 1;
                } while (--len > 0);
                return res >>> 1;
              };
              const bi_flush = (s) => {
                if (s.bi_valid === 16) {
                  put_short(s, s.bi_buf);
                  s.bi_buf = 0;
                  s.bi_valid = 0;
                } else if (s.bi_valid >= 8) {
                  s.pending_buf[s.pending++] = s.bi_buf & 255;
                  s.bi_buf >>= 8;
                  s.bi_valid -= 8;
                }
              };
              const gen_bitlen = (s, desc) => {
                const tree = desc.dyn_tree;
                const max_code = desc.max_code;
                const stree = desc.stat_desc.static_tree;
                const has_stree = desc.stat_desc.has_stree;
                const extra = desc.stat_desc.extra_bits;
                const base = desc.stat_desc.extra_base;
                const max_length = desc.stat_desc.max_length;
                let h;
                let n, m;
                let bits;
                let xbits;
                let f;
                let overflow = 0;
                for (bits = 0; bits <= MAX_BITS$1; bits++) {
                  s.bl_count[bits] = 0;
                }
                tree[s.heap[s.heap_max] * 2 + 1] = 0;
                for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
                  n = s.heap[h];
                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                  if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                  }
                  tree[n * 2 + 1] = bits;
                  if (n > max_code) {
                    continue;
                  }
                  s.bl_count[bits]++;
                  xbits = 0;
                  if (n >= base) {
                    xbits = extra[n - base];
                  }
                  f = tree[n * 2];
                  s.opt_len += f * (bits + xbits);
                  if (has_stree) {
                    s.static_len += f * (stree[n * 2 + 1] + xbits);
                  }
                }
                if (overflow === 0) {
                  return;
                }
                do {
                  bits = max_length - 1;
                  while (s.bl_count[bits] === 0) {
                    bits--;
                  }
                  s.bl_count[bits]--;
                  s.bl_count[bits + 1] += 2;
                  s.bl_count[max_length]--;
                  overflow -= 2;
                } while (overflow > 0);
                for (bits = max_length; bits !== 0; bits--) {
                  n = s.bl_count[bits];
                  while (n !== 0) {
                    m = s.heap[--h];
                    if (m > max_code) {
                      continue;
                    }
                    if (tree[m * 2 + 1] !== bits) {
                      s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                      tree[m * 2 + 1] = bits;
                    }
                    n--;
                  }
                }
              };
              const gen_codes = (tree, max_code, bl_count) => {
                const next_code = new Array(MAX_BITS$1 + 1);
                let code = 0;
                let bits;
                let n;
                for (bits = 1; bits <= MAX_BITS$1; bits++) {
                  code = code + bl_count[bits - 1] << 1;
                  next_code[bits] = code;
                }
                for (n = 0; n <= max_code; n++) {
                  let len = tree[n * 2 + 1];
                  if (len === 0) {
                    continue;
                  }
                  tree[n * 2] = bi_reverse(next_code[len]++, len);
                }
              };
              const tr_static_init = () => {
                let n;
                let bits;
                let length;
                let code;
                let dist;
                const bl_count = new Array(MAX_BITS$1 + 1);
                length = 0;
                for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
                  base_length[code] = length;
                  for (n = 0; n < 1 << extra_lbits[code]; n++) {
                    _length_code[length++] = code;
                  }
                }
                _length_code[length - 1] = code;
                dist = 0;
                for (code = 0; code < 16; code++) {
                  base_dist[code] = dist;
                  for (n = 0; n < 1 << extra_dbits[code]; n++) {
                    _dist_code[dist++] = code;
                  }
                }
                dist >>= 7;
                for (; code < D_CODES$1; code++) {
                  base_dist[code] = dist << 7;
                  for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                    _dist_code[256 + dist++] = code;
                  }
                }
                for (bits = 0; bits <= MAX_BITS$1; bits++) {
                  bl_count[bits] = 0;
                }
                n = 0;
                while (n <= 143) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                while (n <= 255) {
                  static_ltree[n * 2 + 1] = 9;
                  n++;
                  bl_count[9]++;
                }
                while (n <= 279) {
                  static_ltree[n * 2 + 1] = 7;
                  n++;
                  bl_count[7]++;
                }
                while (n <= 287) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
                for (n = 0; n < D_CODES$1; n++) {
                  static_dtree[n * 2 + 1] = 5;
                  static_dtree[n * 2] = bi_reverse(n, 5);
                }
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
              };
              const init_block = (s) => {
                let n;
                for (n = 0; n < L_CODES$1; n++) {
                  s.dyn_ltree[n * 2] = 0;
                }
                for (n = 0; n < D_CODES$1; n++) {
                  s.dyn_dtree[n * 2] = 0;
                }
                for (n = 0; n < BL_CODES$1; n++) {
                  s.bl_tree[n * 2] = 0;
                }
                s.dyn_ltree[END_BLOCK * 2] = 1;
                s.opt_len = s.static_len = 0;
                s.sym_next = s.matches = 0;
              };
              const bi_windup = (s) => {
                if (s.bi_valid > 8) {
                  put_short(s, s.bi_buf);
                } else if (s.bi_valid > 0) {
                  s.pending_buf[s.pending++] = s.bi_buf;
                }
                s.bi_buf = 0;
                s.bi_valid = 0;
              };
              const smaller = (tree, n, m, depth) => {
                const _n2 = n * 2;
                const _m2 = m * 2;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
              };
              const pqdownheap = (s, tree, k) => {
                const v = s.heap[k];
                let j = k << 1;
                while (j <= s.heap_len) {
                  if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                    j++;
                  }
                  if (smaller(tree, v, s.heap[j], s.depth)) {
                    break;
                  }
                  s.heap[k] = s.heap[j];
                  k = j;
                  j <<= 1;
                }
                s.heap[k] = v;
              };
              const compress_block = (s, ltree, dtree) => {
                let dist;
                let lc;
                let sx = 0;
                let code;
                let extra;
                if (s.sym_next !== 0) {
                  do {
                    dist = s.pending_buf[s.sym_buf + sx++] & 255;
                    dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
                    lc = s.pending_buf[s.sym_buf + sx++];
                    if (dist === 0) {
                      send_code(s, lc, ltree);
                    } else {
                      code = _length_code[lc];
                      send_code(s, code + LITERALS$1 + 1, ltree);
                      extra = extra_lbits[code];
                      if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                      }
                      dist--;
                      code = d_code(dist);
                      send_code(s, code, dtree);
                      extra = extra_dbits[code];
                      if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                      }
                    }
                  } while (sx < s.sym_next);
                }
                send_code(s, END_BLOCK, ltree);
              };
              const build_tree = (s, desc) => {
                const tree = desc.dyn_tree;
                const stree = desc.stat_desc.static_tree;
                const has_stree = desc.stat_desc.has_stree;
                const elems = desc.stat_desc.elems;
                let n, m;
                let max_code = -1;
                let node;
                s.heap_len = 0;
                s.heap_max = HEAP_SIZE$1;
                for (n = 0; n < elems; n++) {
                  if (tree[n * 2] !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;
                  } else {
                    tree[n * 2 + 1] = 0;
                  }
                }
                while (s.heap_len < 2) {
                  node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                  tree[node * 2] = 1;
                  s.depth[node] = 0;
                  s.opt_len--;
                  if (has_stree) {
                    s.static_len -= stree[node * 2 + 1];
                  }
                }
                desc.max_code = max_code;
                for (n = s.heap_len >> 1; n >= 1; n--) {
                  pqdownheap(s, tree, n);
                }
                node = elems;
                do {
                  n = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = s.heap[s.heap_len--];
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                  m = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[--s.heap_max] = n;
                  s.heap[--s.heap_max] = m;
                  tree[node * 2] = tree[n * 2] + tree[m * 2];
                  s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                  tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = node++;
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[
                  1
                  /*SMALLEST*/
                ];
                gen_bitlen(s, desc);
                gen_codes(tree, max_code, s.bl_count);
              };
              const scan_tree = (s, tree, max_code) => {
                let n;
                let prevlen = -1;
                let curlen;
                let nextlen = tree[0 * 2 + 1];
                let count = 0;
                let max_count = 7;
                let min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                tree[(max_code + 1) * 2 + 1] = 65535;
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    s.bl_tree[curlen * 2] += count;
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      s.bl_tree[curlen * 2]++;
                    }
                    s.bl_tree[REP_3_6 * 2]++;
                  } else if (count <= 10) {
                    s.bl_tree[REPZ_3_10 * 2]++;
                  } else {
                    s.bl_tree[REPZ_11_138 * 2]++;
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              };
              const send_tree = (s, tree, max_code) => {
                let n;
                let prevlen = -1;
                let curlen;
                let nextlen = tree[0 * 2 + 1];
                let count = 0;
                let max_count = 7;
                let min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    do {
                      send_code(s, curlen, s.bl_tree);
                    } while (--count !== 0);
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      send_code(s, curlen, s.bl_tree);
                      count--;
                    }
                    send_code(s, REP_3_6, s.bl_tree);
                    send_bits(s, count - 3, 2);
                  } else if (count <= 10) {
                    send_code(s, REPZ_3_10, s.bl_tree);
                    send_bits(s, count - 3, 3);
                  } else {
                    send_code(s, REPZ_11_138, s.bl_tree);
                    send_bits(s, count - 11, 7);
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              };
              const build_bl_tree = (s) => {
                let max_blindex;
                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                build_tree(s, s.bl_desc);
                for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
                  if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                    break;
                  }
                }
                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                return max_blindex;
              };
              const send_all_trees = (s, lcodes, dcodes, blcodes) => {
                let rank2;
                send_bits(s, lcodes - 257, 5);
                send_bits(s, dcodes - 1, 5);
                send_bits(s, blcodes - 4, 4);
                for (rank2 = 0; rank2 < blcodes; rank2++) {
                  send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
                }
                send_tree(s, s.dyn_ltree, lcodes - 1);
                send_tree(s, s.dyn_dtree, dcodes - 1);
              };
              const detect_data_type = (s) => {
                let block_mask = 4093624447;
                let n;
                for (n = 0; n <= 31; n++, block_mask >>>= 1) {
                  if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                    return Z_BINARY;
                  }
                }
                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                  return Z_TEXT;
                }
                for (n = 32; n < LITERALS$1; n++) {
                  if (s.dyn_ltree[n * 2] !== 0) {
                    return Z_TEXT;
                  }
                }
                return Z_BINARY;
              };
              let static_init_done = false;
              const _tr_init$1 = (s) => {
                if (!static_init_done) {
                  tr_static_init();
                  static_init_done = true;
                }
                s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                s.bi_buf = 0;
                s.bi_valid = 0;
                init_block(s);
              };
              const _tr_stored_block$1 = (s, buf, stored_len, last) => {
                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                bi_windup(s);
                put_short(s, stored_len);
                put_short(s, ~stored_len);
                if (stored_len) {
                  s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
                }
                s.pending += stored_len;
              };
              const _tr_align$1 = (s) => {
                send_bits(s, STATIC_TREES << 1, 3);
                send_code(s, END_BLOCK, static_ltree);
                bi_flush(s);
              };
              const _tr_flush_block$1 = (s, buf, stored_len, last) => {
                let opt_lenb, static_lenb;
                let max_blindex = 0;
                if (s.level > 0) {
                  if (s.strm.data_type === Z_UNKNOWN$1) {
                    s.strm.data_type = detect_data_type(s);
                  }
                  build_tree(s, s.l_desc);
                  build_tree(s, s.d_desc);
                  max_blindex = build_bl_tree(s);
                  opt_lenb = s.opt_len + 3 + 7 >>> 3;
                  static_lenb = s.static_len + 3 + 7 >>> 3;
                  if (static_lenb <= opt_lenb) {
                    opt_lenb = static_lenb;
                  }
                } else {
                  opt_lenb = static_lenb = stored_len + 5;
                }
                if (stored_len + 4 <= opt_lenb && buf !== -1) {
                  _tr_stored_block$1(s, buf, stored_len, last);
                } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
                  send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                  compress_block(s, static_ltree, static_dtree);
                } else {
                  send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                  send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                  compress_block(s, s.dyn_ltree, s.dyn_dtree);
                }
                init_block(s);
                if (last) {
                  bi_windup(s);
                }
              };
              const _tr_tally$1 = (s, dist, lc) => {
                s.pending_buf[s.sym_buf + s.sym_next++] = dist;
                s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
                s.pending_buf[s.sym_buf + s.sym_next++] = lc;
                if (dist === 0) {
                  s.dyn_ltree[lc * 2]++;
                } else {
                  s.matches++;
                  dist--;
                  s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
                  s.dyn_dtree[d_code(dist) * 2]++;
                }
                return s.sym_next === s.sym_end;
              };
              var _tr_init_1 = _tr_init$1;
              var _tr_stored_block_1 = _tr_stored_block$1;
              var _tr_flush_block_1 = _tr_flush_block$1;
              var _tr_tally_1 = _tr_tally$1;
              var _tr_align_1 = _tr_align$1;
              var trees = {
                _tr_init: _tr_init_1,
                _tr_stored_block: _tr_stored_block_1,
                _tr_flush_block: _tr_flush_block_1,
                _tr_tally: _tr_tally_1,
                _tr_align: _tr_align_1
              };
              const adler32 = (adler, buf, len, pos) => {
                let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
                while (len !== 0) {
                  n = len > 2e3 ? 2e3 : len;
                  len -= n;
                  do {
                    s1 = s1 + buf[pos++] | 0;
                    s2 = s2 + s1 | 0;
                  } while (--n);
                  s1 %= 65521;
                  s2 %= 65521;
                }
                return s1 | s2 << 16 | 0;
              };
              var adler32_1 = adler32;
              const makeTable = () => {
                let c, table = [];
                for (var n = 0; n < 256; n++) {
                  c = n;
                  for (var k = 0; k < 8; k++) {
                    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                  }
                  table[n] = c;
                }
                return table;
              };
              const crcTable = new Uint32Array(makeTable());
              const crc32 = (crc, buf, len, pos) => {
                const t = crcTable;
                const end = pos + len;
                crc ^= -1;
                for (let i = pos; i < end; i++) {
                  crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
                }
                return crc ^ -1;
              };
              var crc32_1 = crc32;
              var messages = {
                2: "need dictionary",
                /* Z_NEED_DICT       2  */
                1: "stream end",
                /* Z_STREAM_END      1  */
                0: "",
                /* Z_OK              0  */
                "-1": "file error",
                /* Z_ERRNO         (-1) */
                "-2": "stream error",
                /* Z_STREAM_ERROR  (-2) */
                "-3": "data error",
                /* Z_DATA_ERROR    (-3) */
                "-4": "insufficient memory",
                /* Z_MEM_ERROR     (-4) */
                "-5": "buffer error",
                /* Z_BUF_ERROR     (-5) */
                "-6": "incompatible version"
                /* Z_VERSION_ERROR (-6) */
              };
              var constants$2 = {
                /* Allowed flush values; see deflate() and inflate() below for details */
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                /* Return codes for the compression/decompression functions. Negative values
                * are errors, positive values are used for special but normal events.
                */
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                //Z_VERSION_ERROR: -6,
                /* compression levels */
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                /* Possible values of the data_type field (though see inflate()) */
                Z_BINARY: 0,
                Z_TEXT: 1,
                //Z_ASCII:                1, // = Z_TEXT (deprecated)
                Z_UNKNOWN: 2,
                /* The deflate compression method */
                Z_DEFLATED: 8
                //Z_NULL:                 null // Use -1 or null inline, depending on var type
              };
              const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
              const {
                Z_NO_FLUSH: Z_NO_FLUSH$2,
                Z_PARTIAL_FLUSH,
                Z_FULL_FLUSH: Z_FULL_FLUSH$1,
                Z_FINISH: Z_FINISH$3,
                Z_BLOCK: Z_BLOCK$1,
                Z_OK: Z_OK$3,
                Z_STREAM_END: Z_STREAM_END$3,
                Z_STREAM_ERROR: Z_STREAM_ERROR$2,
                Z_DATA_ERROR: Z_DATA_ERROR$2,
                Z_BUF_ERROR: Z_BUF_ERROR$1,
                Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
                Z_FILTERED,
                Z_HUFFMAN_ONLY,
                Z_RLE,
                Z_FIXED,
                Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
                Z_UNKNOWN,
                Z_DEFLATED: Z_DEFLATED$2
              } = constants$2;
              const MAX_MEM_LEVEL = 9;
              const MAX_WBITS$1 = 15;
              const DEF_MEM_LEVEL = 8;
              const LENGTH_CODES = 29;
              const LITERALS = 256;
              const L_CODES = LITERALS + 1 + LENGTH_CODES;
              const D_CODES = 30;
              const BL_CODES = 19;
              const HEAP_SIZE = 2 * L_CODES + 1;
              const MAX_BITS = 15;
              const MIN_MATCH = 3;
              const MAX_MATCH = 258;
              const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
              const PRESET_DICT = 32;
              const INIT_STATE = 42;
              const GZIP_STATE = 57;
              const EXTRA_STATE = 69;
              const NAME_STATE = 73;
              const COMMENT_STATE = 91;
              const HCRC_STATE = 103;
              const BUSY_STATE = 113;
              const FINISH_STATE = 666;
              const BS_NEED_MORE = 1;
              const BS_BLOCK_DONE = 2;
              const BS_FINISH_STARTED = 3;
              const BS_FINISH_DONE = 4;
              const OS_CODE = 3;
              const err = (strm, errorCode) => {
                strm.msg = messages[errorCode];
                return errorCode;
              };
              const rank = (f) => {
                return f * 2 - (f > 4 ? 9 : 0);
              };
              const zero = (buf) => {
                let len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              };
              const slide_hash = (s) => {
                let n, m;
                let p;
                let wsize = s.w_size;
                n = s.hash_size;
                p = n;
                do {
                  m = s.head[--p];
                  s.head[p] = m >= wsize ? m - wsize : 0;
                } while (--n);
                n = wsize;
                p = n;
                do {
                  m = s.prev[--p];
                  s.prev[p] = m >= wsize ? m - wsize : 0;
                } while (--n);
              };
              let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
              let HASH = HASH_ZLIB;
              const flush_pending = (strm) => {
                const s = strm.state;
                let len = s.pending;
                if (len > strm.avail_out) {
                  len = strm.avail_out;
                }
                if (len === 0) {
                  return;
                }
                strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
                strm.next_out += len;
                s.pending_out += len;
                strm.total_out += len;
                strm.avail_out -= len;
                s.pending -= len;
                if (s.pending === 0) {
                  s.pending_out = 0;
                }
              };
              const flush_block_only = (s, last) => {
                _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
                s.block_start = s.strstart;
                flush_pending(s.strm);
              };
              const put_byte = (s, b) => {
                s.pending_buf[s.pending++] = b;
              };
              const putShortMSB = (s, b) => {
                s.pending_buf[s.pending++] = b >>> 8 & 255;
                s.pending_buf[s.pending++] = b & 255;
              };
              const read_buf = (strm, buf, start, size) => {
                let len = strm.avail_in;
                if (len > size) {
                  len = size;
                }
                if (len === 0) {
                  return 0;
                }
                strm.avail_in -= len;
                buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
                if (strm.state.wrap === 1) {
                  strm.adler = adler32_1(strm.adler, buf, len, start);
                } else if (strm.state.wrap === 2) {
                  strm.adler = crc32_1(strm.adler, buf, len, start);
                }
                strm.next_in += len;
                strm.total_in += len;
                return len;
              };
              const longest_match = (s, cur_match) => {
                let chain_length = s.max_chain_length;
                let scan = s.strstart;
                let match;
                let len;
                let best_len = s.prev_length;
                let nice_match = s.nice_match;
                const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                const _win = s.window;
                const wmask = s.w_mask;
                const prev = s.prev;
                const strend = s.strstart + MAX_MATCH;
                let scan_end1 = _win[scan + best_len - 1];
                let scan_end = _win[scan + best_len];
                if (s.prev_length >= s.good_match) {
                  chain_length >>= 2;
                }
                if (nice_match > s.lookahead) {
                  nice_match = s.lookahead;
                }
                do {
                  match = cur_match;
                  if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                    continue;
                  }
                  scan += 2;
                  match++;
                  do {
                  } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                  len = MAX_MATCH - (strend - scan);
                  scan = strend - MAX_MATCH;
                  if (len > best_len) {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match) {
                      break;
                    }
                    scan_end1 = _win[scan + best_len - 1];
                    scan_end = _win[scan + best_len];
                  }
                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                if (best_len <= s.lookahead) {
                  return best_len;
                }
                return s.lookahead;
              };
              const fill_window = (s) => {
                const _w_size = s.w_size;
                let n, more, str;
                do {
                  more = s.window_size - s.lookahead - s.strstart;
                  if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                    s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
                    s.match_start -= _w_size;
                    s.strstart -= _w_size;
                    s.block_start -= _w_size;
                    if (s.insert > s.strstart) {
                      s.insert = s.strstart;
                    }
                    slide_hash(s);
                    more += _w_size;
                  }
                  if (s.strm.avail_in === 0) {
                    break;
                  }
                  n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                  s.lookahead += n;
                  if (s.lookahead + s.insert >= MIN_MATCH) {
                    str = s.strstart - s.insert;
                    s.ins_h = s.window[str];
                    s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
                    while (s.insert) {
                      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                      s.prev[str & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = str;
                      str++;
                      s.insert--;
                      if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                      }
                    }
                  }
                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
              };
              const deflate_stored = (s, flush) => {
                let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
                let len, left, have, last = 0;
                let used = s.strm.avail_in;
                do {
                  len = 65535;
                  have = s.bi_valid + 42 >> 3;
                  if (s.strm.avail_out < have) {
                    break;
                  }
                  have = s.strm.avail_out - have;
                  left = s.strstart - s.block_start;
                  if (len > left + s.strm.avail_in) {
                    len = left + s.strm.avail_in;
                  }
                  if (len > have) {
                    len = have;
                  }
                  if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
                    break;
                  }
                  last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
                  _tr_stored_block(s, 0, 0, last);
                  s.pending_buf[s.pending - 4] = len;
                  s.pending_buf[s.pending - 3] = len >> 8;
                  s.pending_buf[s.pending - 2] = ~len;
                  s.pending_buf[s.pending - 1] = ~len >> 8;
                  flush_pending(s.strm);
                  if (left) {
                    if (left > len) {
                      left = len;
                    }
                    s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
                    s.strm.next_out += left;
                    s.strm.avail_out -= left;
                    s.strm.total_out += left;
                    s.block_start += left;
                    len -= left;
                  }
                  if (len) {
                    read_buf(s.strm, s.strm.output, s.strm.next_out, len);
                    s.strm.next_out += len;
                    s.strm.avail_out -= len;
                    s.strm.total_out += len;
                  }
                } while (last === 0);
                used -= s.strm.avail_in;
                if (used) {
                  if (used >= s.w_size) {
                    s.matches = 2;
                    s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
                    s.strstart = s.w_size;
                    s.insert = s.strstart;
                  } else {
                    if (s.window_size - s.strstart <= used) {
                      s.strstart -= s.w_size;
                      s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                      if (s.matches < 2) {
                        s.matches++;
                      }
                      if (s.insert > s.strstart) {
                        s.insert = s.strstart;
                      }
                    }
                    s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
                    s.strstart += used;
                    s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
                  }
                  s.block_start = s.strstart;
                }
                if (s.high_water < s.strstart) {
                  s.high_water = s.strstart;
                }
                if (last) {
                  return BS_FINISH_DONE;
                }
                if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
                  return BS_BLOCK_DONE;
                }
                have = s.window_size - s.strstart;
                if (s.strm.avail_in > have && s.block_start >= s.w_size) {
                  s.block_start -= s.w_size;
                  s.strstart -= s.w_size;
                  s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                  if (s.matches < 2) {
                    s.matches++;
                  }
                  have += s.w_size;
                  if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                  }
                }
                if (have > s.strm.avail_in) {
                  have = s.strm.avail_in;
                }
                if (have) {
                  read_buf(s.strm, s.window, s.strstart, have);
                  s.strstart += have;
                  s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
                }
                if (s.high_water < s.strstart) {
                  s.high_water = s.strstart;
                }
                have = s.bi_valid + 42 >> 3;
                have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
                min_block = have > s.w_size ? s.w_size : have;
                left = s.strstart - s.block_start;
                if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
                  len = left > have ? have : left;
                  last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
                  _tr_stored_block(s, s.block_start, len, last);
                  s.block_start += len;
                  flush_pending(s.strm);
                }
                return last ? BS_FINISH_STARTED : BS_NEED_MORE;
              };
              const deflate_fast = (s, flush) => {
                let hash_head;
                let bflush;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                      s.match_length--;
                      do {
                        s.strstart++;
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      } while (--s.match_length !== 0);
                      s.strstart++;
                    } else {
                      s.strstart += s.match_length;
                      s.match_length = 0;
                      s.ins_h = s.window[s.strstart];
                      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                    }
                  } else {
                    bflush = _tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH$3) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.sym_next) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              };
              const deflate_slow = (s, flush) => {
                let hash_head;
                let bflush;
                let max_insert;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  s.prev_length = s.match_length;
                  s.prev_match = s.match_start;
                  s.match_length = MIN_MATCH - 1;
                  if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                    if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                      s.match_length = MIN_MATCH - 1;
                    }
                  }
                  if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    max_insert = s.strstart + s.lookahead - MIN_MATCH;
                    bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do {
                      if (++s.strstart <= max_insert) {
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      }
                    } while (--s.prev_length !== 0);
                    s.match_available = 0;
                    s.match_length = MIN_MATCH - 1;
                    s.strstart++;
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  } else if (s.match_available) {
                    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
                    if (bflush) {
                      flush_block_only(s, false);
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  } else {
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                  }
                }
                if (s.match_available) {
                  bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
                  s.match_available = 0;
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH$3) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.sym_next) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              };
              const deflate_rle = (s, flush) => {
                let bflush;
                let prev;
                let scan, strend;
                const _win = s.window;
                for (; ; ) {
                  if (s.lookahead <= MAX_MATCH) {
                    fill_window(s);
                    if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  s.match_length = 0;
                  if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                    scan = s.strstart - 1;
                    prev = _win[scan];
                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                      strend = s.strstart + MAX_MATCH;
                      do {
                      } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                      s.match_length = MAX_MATCH - (strend - scan);
                      if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                      }
                    }
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                  } else {
                    bflush = _tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH$3) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.sym_next) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              };
              const deflate_huff = (s, flush) => {
                let bflush;
                for (; ; ) {
                  if (s.lookahead === 0) {
                    fill_window(s);
                    if (s.lookahead === 0) {
                      if (flush === Z_NO_FLUSH$2) {
                        return BS_NEED_MORE;
                      }
                      break;
                    }
                  }
                  s.match_length = 0;
                  bflush = _tr_tally(s, 0, s.window[s.strstart]);
                  s.lookahead--;
                  s.strstart++;
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH$3) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.sym_next) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              };
              function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func;
              }
              const configuration_table = [
                /*      good lazy nice chain */
                new Config(0, 0, 0, 0, deflate_stored),
                /* 0 store only */
                new Config(4, 4, 8, 4, deflate_fast),
                /* 1 max speed, no lazy matches */
                new Config(4, 5, 16, 8, deflate_fast),
                /* 2 */
                new Config(4, 6, 32, 32, deflate_fast),
                /* 3 */
                new Config(4, 4, 16, 16, deflate_slow),
                /* 4 lazy matches */
                new Config(8, 16, 32, 32, deflate_slow),
                /* 5 */
                new Config(8, 16, 128, 128, deflate_slow),
                /* 6 */
                new Config(8, 32, 128, 256, deflate_slow),
                /* 7 */
                new Config(32, 128, 258, 1024, deflate_slow),
                /* 8 */
                new Config(32, 258, 258, 4096, deflate_slow)
                /* 9 max compression */
              ];
              const lm_init = (s) => {
                s.window_size = 2 * s.w_size;
                zero(s.head);
                s.max_lazy_match = configuration_table[s.level].max_lazy;
                s.good_match = configuration_table[s.level].good_length;
                s.nice_match = configuration_table[s.level].nice_length;
                s.max_chain_length = configuration_table[s.level].max_chain;
                s.strstart = 0;
                s.block_start = 0;
                s.lookahead = 0;
                s.insert = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                s.ins_h = 0;
              };
              function DeflateState() {
                this.strm = null;
                this.status = 0;
                this.pending_buf = null;
                this.pending_buf_size = 0;
                this.pending_out = 0;
                this.pending = 0;
                this.wrap = 0;
                this.gzhead = null;
                this.gzindex = 0;
                this.method = Z_DEFLATED$2;
                this.last_flush = -1;
                this.w_size = 0;
                this.w_bits = 0;
                this.w_mask = 0;
                this.window = null;
                this.window_size = 0;
                this.prev = null;
                this.head = null;
                this.ins_h = 0;
                this.hash_size = 0;
                this.hash_bits = 0;
                this.hash_mask = 0;
                this.hash_shift = 0;
                this.block_start = 0;
                this.match_length = 0;
                this.prev_match = 0;
                this.match_available = 0;
                this.strstart = 0;
                this.match_start = 0;
                this.lookahead = 0;
                this.prev_length = 0;
                this.max_chain_length = 0;
                this.max_lazy_match = 0;
                this.level = 0;
                this.strategy = 0;
                this.good_match = 0;
                this.nice_match = 0;
                this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
                this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
                this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
                zero(this.dyn_ltree);
                zero(this.dyn_dtree);
                zero(this.bl_tree);
                this.l_desc = null;
                this.d_desc = null;
                this.bl_desc = null;
                this.bl_count = new Uint16Array(MAX_BITS + 1);
                this.heap = new Uint16Array(2 * L_CODES + 1);
                zero(this.heap);
                this.heap_len = 0;
                this.heap_max = 0;
                this.depth = new Uint16Array(2 * L_CODES + 1);
                zero(this.depth);
                this.sym_buf = 0;
                this.lit_bufsize = 0;
                this.sym_next = 0;
                this.sym_end = 0;
                this.opt_len = 0;
                this.static_len = 0;
                this.matches = 0;
                this.insert = 0;
                this.bi_buf = 0;
                this.bi_valid = 0;
              }
              const deflateStateCheck = (strm) => {
                if (!strm) {
                  return 1;
                }
                const s = strm.state;
                if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
                s.status !== GZIP_STATE && //#endif
                s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
                  return 1;
                }
                return 0;
              };
              const deflateResetKeep = (strm) => {
                if (deflateStateCheck(strm)) {
                  return err(strm, Z_STREAM_ERROR$2);
                }
                strm.total_in = strm.total_out = 0;
                strm.data_type = Z_UNKNOWN;
                const s = strm.state;
                s.pending = 0;
                s.pending_out = 0;
                if (s.wrap < 0) {
                  s.wrap = -s.wrap;
                }
                s.status = //#ifdef GZIP
                s.wrap === 2 ? GZIP_STATE : (
                  //#endif
                  s.wrap ? INIT_STATE : BUSY_STATE
                );
                strm.adler = s.wrap === 2 ? 0 : 1;
                s.last_flush = -2;
                _tr_init(s);
                return Z_OK$3;
              };
              const deflateReset = (strm) => {
                const ret = deflateResetKeep(strm);
                if (ret === Z_OK$3) {
                  lm_init(strm.state);
                }
                return ret;
              };
              const deflateSetHeader = (strm, head) => {
                if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
                  return Z_STREAM_ERROR$2;
                }
                strm.state.gzhead = head;
                return Z_OK$3;
              };
              const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
                if (!strm) {
                  return Z_STREAM_ERROR$2;
                }
                let wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION$1) {
                  level = 6;
                }
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else if (windowBits > 15) {
                  wrap = 2;
                  windowBits -= 16;
                }
                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
                  return err(strm, Z_STREAM_ERROR$2);
                }
                if (windowBits === 8) {
                  windowBits = 9;
                }
                const s = new DeflateState();
                strm.state = s;
                s.strm = strm;
                s.status = INIT_STATE;
                s.wrap = wrap;
                s.gzhead = null;
                s.w_bits = windowBits;
                s.w_size = 1 << s.w_bits;
                s.w_mask = s.w_size - 1;
                s.hash_bits = memLevel + 7;
                s.hash_size = 1 << s.hash_bits;
                s.hash_mask = s.hash_size - 1;
                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                s.window = new Uint8Array(s.w_size * 2);
                s.head = new Uint16Array(s.hash_size);
                s.prev = new Uint16Array(s.w_size);
                s.lit_bufsize = 1 << memLevel + 6;
                s.pending_buf_size = s.lit_bufsize * 4;
                s.pending_buf = new Uint8Array(s.pending_buf_size);
                s.sym_buf = s.lit_bufsize;
                s.sym_end = (s.lit_bufsize - 1) * 3;
                s.level = level;
                s.strategy = strategy;
                s.method = method;
                return deflateReset(strm);
              };
              const deflateInit = (strm, level) => {
                return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
              };
              const deflate$2 = (strm, flush) => {
                if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
                  return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
                }
                const s = strm.state;
                if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
                  return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
                }
                const old_flush = s.last_flush;
                s.last_flush = flush;
                if (s.pending !== 0) {
                  flush_pending(strm);
                  if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                  }
                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
                  return err(strm, Z_BUF_ERROR$1);
                }
                if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                  return err(strm, Z_BUF_ERROR$1);
                }
                if (s.status === INIT_STATE && s.wrap === 0) {
                  s.status = BUSY_STATE;
                }
                if (s.status === INIT_STATE) {
                  let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
                  let level_flags = -1;
                  if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                    level_flags = 0;
                  } else if (s.level < 6) {
                    level_flags = 1;
                  } else if (s.level === 6) {
                    level_flags = 2;
                  } else {
                    level_flags = 3;
                  }
                  header |= level_flags << 6;
                  if (s.strstart !== 0) {
                    header |= PRESET_DICT;
                  }
                  header += 31 - header % 31;
                  putShortMSB(s, header);
                  if (s.strstart !== 0) {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 65535);
                  }
                  strm.adler = 1;
                  s.status = BUSY_STATE;
                  flush_pending(strm);
                  if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                  }
                }
                if (s.status === GZIP_STATE) {
                  strm.adler = 0;
                  put_byte(s, 31);
                  put_byte(s, 139);
                  put_byte(s, 8);
                  if (!s.gzhead) {
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                    put_byte(s, OS_CODE);
                    s.status = BUSY_STATE;
                    flush_pending(strm);
                    if (s.pending !== 0) {
                      s.last_flush = -1;
                      return Z_OK$3;
                    }
                  } else {
                    put_byte(
                      s,
                      (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                    );
                    put_byte(s, s.gzhead.time & 255);
                    put_byte(s, s.gzhead.time >> 8 & 255);
                    put_byte(s, s.gzhead.time >> 16 & 255);
                    put_byte(s, s.gzhead.time >> 24 & 255);
                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                    put_byte(s, s.gzhead.os & 255);
                    if (s.gzhead.extra && s.gzhead.extra.length) {
                      put_byte(s, s.gzhead.extra.length & 255);
                      put_byte(s, s.gzhead.extra.length >> 8 & 255);
                    }
                    if (s.gzhead.hcrc) {
                      strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
                    }
                    s.gzindex = 0;
                    s.status = EXTRA_STATE;
                  }
                }
                if (s.status === EXTRA_STATE) {
                  if (s.gzhead.extra) {
                    let beg = s.pending;
                    let left = (s.gzhead.extra.length & 65535) - s.gzindex;
                    while (s.pending + left > s.pending_buf_size) {
                      let copy = s.pending_buf_size - s.pending;
                      s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                      s.pending = s.pending_buf_size;
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }
                      s.gzindex += copy;
                      flush_pending(strm);
                      if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                      }
                      beg = 0;
                      left -= copy;
                    }
                    let gzhead_extra = new Uint8Array(s.gzhead.extra);
                    s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
                    s.pending += left;
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    s.gzindex = 0;
                  }
                  s.status = NAME_STATE;
                }
                if (s.status === NAME_STATE) {
                  if (s.gzhead.name) {
                    let beg = s.pending;
                    let val;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                          s.last_flush = -1;
                          return Z_OK$3;
                        }
                        beg = 0;
                      }
                      if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    s.gzindex = 0;
                  }
                  s.status = COMMENT_STATE;
                }
                if (s.status === COMMENT_STATE) {
                  if (s.gzhead.comment) {
                    let beg = s.pending;
                    let val;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                          s.last_flush = -1;
                          return Z_OK$3;
                        }
                        beg = 0;
                      }
                      if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                  }
                  s.status = HCRC_STATE;
                }
                if (s.status === HCRC_STATE) {
                  if (s.gzhead.hcrc) {
                    if (s.pending + 2 > s.pending_buf_size) {
                      flush_pending(strm);
                      if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                      }
                    }
                    put_byte(s, strm.adler & 255);
                    put_byte(s, strm.adler >> 8 & 255);
                    strm.adler = 0;
                  }
                  s.status = BUSY_STATE;
                  flush_pending(strm);
                  if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                  }
                }
                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
                  let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                  if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                    s.status = FINISH_STATE;
                  }
                  if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                    }
                    return Z_OK$3;
                  }
                  if (bstate === BS_BLOCK_DONE) {
                    if (flush === Z_PARTIAL_FLUSH) {
                      _tr_align(s);
                    } else if (flush !== Z_BLOCK$1) {
                      _tr_stored_block(s, 0, 0, false);
                      if (flush === Z_FULL_FLUSH$1) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                          s.strstart = 0;
                          s.block_start = 0;
                          s.insert = 0;
                        }
                      }
                    }
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                      return Z_OK$3;
                    }
                  }
                }
                if (flush !== Z_FINISH$3) {
                  return Z_OK$3;
                }
                if (s.wrap <= 0) {
                  return Z_STREAM_END$3;
                }
                if (s.wrap === 2) {
                  put_byte(s, strm.adler & 255);
                  put_byte(s, strm.adler >> 8 & 255);
                  put_byte(s, strm.adler >> 16 & 255);
                  put_byte(s, strm.adler >> 24 & 255);
                  put_byte(s, strm.total_in & 255);
                  put_byte(s, strm.total_in >> 8 & 255);
                  put_byte(s, strm.total_in >> 16 & 255);
                  put_byte(s, strm.total_in >> 24 & 255);
                } else {
                  putShortMSB(s, strm.adler >>> 16);
                  putShortMSB(s, strm.adler & 65535);
                }
                flush_pending(strm);
                if (s.wrap > 0) {
                  s.wrap = -s.wrap;
                }
                return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
              };
              const deflateEnd = (strm) => {
                if (deflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$2;
                }
                const status = strm.state.status;
                strm.state = null;
                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
              };
              const deflateSetDictionary = (strm, dictionary) => {
                let dictLength = dictionary.length;
                if (deflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$2;
                }
                const s = strm.state;
                const wrap = s.wrap;
                if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
                  return Z_STREAM_ERROR$2;
                }
                if (wrap === 1) {
                  strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
                }
                s.wrap = 0;
                if (dictLength >= s.w_size) {
                  if (wrap === 0) {
                    zero(s.head);
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                  let tmpDict = new Uint8Array(s.w_size);
                  tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
                  dictionary = tmpDict;
                  dictLength = s.w_size;
                }
                const avail = strm.avail_in;
                const next = strm.next_in;
                const input = strm.input;
                strm.avail_in = dictLength;
                strm.next_in = 0;
                strm.input = dictionary;
                fill_window(s);
                while (s.lookahead >= MIN_MATCH) {
                  let str = s.strstart;
                  let n = s.lookahead - (MIN_MATCH - 1);
                  do {
                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                  } while (--n);
                  s.strstart = str;
                  s.lookahead = MIN_MATCH - 1;
                  fill_window(s);
                }
                s.strstart += s.lookahead;
                s.block_start = s.strstart;
                s.insert = s.lookahead;
                s.lookahead = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                strm.next_in = next;
                strm.input = input;
                strm.avail_in = avail;
                s.wrap = wrap;
                return Z_OK$3;
              };
              var deflateInit_1 = deflateInit;
              var deflateInit2_1 = deflateInit2;
              var deflateReset_1 = deflateReset;
              var deflateResetKeep_1 = deflateResetKeep;
              var deflateSetHeader_1 = deflateSetHeader;
              var deflate_2$1 = deflate$2;
              var deflateEnd_1 = deflateEnd;
              var deflateSetDictionary_1 = deflateSetDictionary;
              var deflateInfo = "pako deflate (from Nodeca project)";
              var deflate_1$2 = {
                deflateInit: deflateInit_1,
                deflateInit2: deflateInit2_1,
                deflateReset: deflateReset_1,
                deflateResetKeep: deflateResetKeep_1,
                deflateSetHeader: deflateSetHeader_1,
                deflate: deflate_2$1,
                deflateEnd: deflateEnd_1,
                deflateSetDictionary: deflateSetDictionary_1,
                deflateInfo
              };
              const _has = (obj, key) => {
                return Object.prototype.hasOwnProperty.call(obj, key);
              };
              var assign = function(obj) {
                const sources = Array.prototype.slice.call(arguments, 1);
                while (sources.length) {
                  const source = sources.shift();
                  if (!source) {
                    continue;
                  }
                  if (typeof source !== "object") {
                    throw new TypeError(source + "must be non-object");
                  }
                  for (const p in source) {
                    if (_has(source, p)) {
                      obj[p] = source[p];
                    }
                  }
                }
                return obj;
              };
              var flattenChunks = (chunks) => {
                let len = 0;
                for (let i = 0, l = chunks.length; i < l; i++) {
                  len += chunks[i].length;
                }
                const result = new Uint8Array(len);
                for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
                  let chunk = chunks[i];
                  result.set(chunk, pos);
                  pos += chunk.length;
                }
                return result;
              };
              var common = {
                assign,
                flattenChunks
              };
              let STR_APPLY_UIA_OK = true;
              try {
                String.fromCharCode.apply(null, new Uint8Array(1));
              } catch (__) {
                STR_APPLY_UIA_OK = false;
              }
              const _utf8len = new Uint8Array(256);
              for (let q = 0; q < 256; q++) {
                _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
              }
              _utf8len[254] = _utf8len[254] = 1;
              var string2buf = (str) => {
                if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
                  return new TextEncoder().encode(str);
                }
                let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                  c = str.charCodeAt(m_pos);
                  if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                      c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                      m_pos++;
                    }
                  }
                  buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                }
                buf = new Uint8Array(buf_len);
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                  c = str.charCodeAt(m_pos);
                  if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                      c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                      m_pos++;
                    }
                  }
                  if (c < 128) {
                    buf[i++] = c;
                  } else if (c < 2048) {
                    buf[i++] = 192 | c >>> 6;
                    buf[i++] = 128 | c & 63;
                  } else if (c < 65536) {
                    buf[i++] = 224 | c >>> 12;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                  } else {
                    buf[i++] = 240 | c >>> 18;
                    buf[i++] = 128 | c >>> 12 & 63;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                  }
                }
                return buf;
              };
              const buf2binstring = (buf, len) => {
                if (len < 65534) {
                  if (buf.subarray && STR_APPLY_UIA_OK) {
                    return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
                  }
                }
                let result = "";
                for (let i = 0; i < len; i++) {
                  result += String.fromCharCode(buf[i]);
                }
                return result;
              };
              var buf2string = (buf, max) => {
                const len = max || buf.length;
                if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
                  return new TextDecoder().decode(buf.subarray(0, max));
                }
                let i, out;
                const utf16buf = new Array(len * 2);
                for (out = 0, i = 0; i < len; ) {
                  let c = buf[i++];
                  if (c < 128) {
                    utf16buf[out++] = c;
                    continue;
                  }
                  let c_len = _utf8len[c];
                  if (c_len > 4) {
                    utf16buf[out++] = 65533;
                    i += c_len - 1;
                    continue;
                  }
                  c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
                  while (c_len > 1 && i < len) {
                    c = c << 6 | buf[i++] & 63;
                    c_len--;
                  }
                  if (c_len > 1) {
                    utf16buf[out++] = 65533;
                    continue;
                  }
                  if (c < 65536) {
                    utf16buf[out++] = c;
                  } else {
                    c -= 65536;
                    utf16buf[out++] = 55296 | c >> 10 & 1023;
                    utf16buf[out++] = 56320 | c & 1023;
                  }
                }
                return buf2binstring(utf16buf, out);
              };
              var utf8border = (buf, max) => {
                max = max || buf.length;
                if (max > buf.length) {
                  max = buf.length;
                }
                let pos = max - 1;
                while (pos >= 0 && (buf[pos] & 192) === 128) {
                  pos--;
                }
                if (pos < 0) {
                  return max;
                }
                if (pos === 0) {
                  return max;
                }
                return pos + _utf8len[buf[pos]] > max ? pos : max;
              };
              var strings = {
                string2buf,
                buf2string,
                utf8border
              };
              function ZStream() {
                this.input = null;
                this.next_in = 0;
                this.avail_in = 0;
                this.total_in = 0;
                this.output = null;
                this.next_out = 0;
                this.avail_out = 0;
                this.total_out = 0;
                this.msg = "";
                this.state = null;
                this.data_type = 2;
                this.adler = 0;
              }
              var zstream = ZStream;
              const toString$1 = Object.prototype.toString;
              const {
                Z_NO_FLUSH: Z_NO_FLUSH$1,
                Z_SYNC_FLUSH,
                Z_FULL_FLUSH,
                Z_FINISH: Z_FINISH$2,
                Z_OK: Z_OK$2,
                Z_STREAM_END: Z_STREAM_END$2,
                Z_DEFAULT_COMPRESSION,
                Z_DEFAULT_STRATEGY,
                Z_DEFLATED: Z_DEFLATED$1
              } = constants$2;
              function Deflate$1(options) {
                this.options = common.assign({
                  level: Z_DEFAULT_COMPRESSION,
                  method: Z_DEFLATED$1,
                  chunkSize: 16384,
                  windowBits: 15,
                  memLevel: 8,
                  strategy: Z_DEFAULT_STRATEGY
                }, options || {});
                let opt = this.options;
                if (opt.raw && opt.windowBits > 0) {
                  opt.windowBits = -opt.windowBits;
                } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
                  opt.windowBits += 16;
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new zstream();
                this.strm.avail_out = 0;
                let status = deflate_1$2.deflateInit2(
                  this.strm,
                  opt.level,
                  opt.method,
                  opt.windowBits,
                  opt.memLevel,
                  opt.strategy
                );
                if (status !== Z_OK$2) {
                  throw new Error(messages[status]);
                }
                if (opt.header) {
                  deflate_1$2.deflateSetHeader(this.strm, opt.header);
                }
                if (opt.dictionary) {
                  let dict;
                  if (typeof opt.dictionary === "string") {
                    dict = strings.string2buf(opt.dictionary);
                  } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
                    dict = new Uint8Array(opt.dictionary);
                  } else {
                    dict = opt.dictionary;
                  }
                  status = deflate_1$2.deflateSetDictionary(this.strm, dict);
                  if (status !== Z_OK$2) {
                    throw new Error(messages[status]);
                  }
                  this._dict_set = true;
                }
              }
              Deflate$1.prototype.push = function(data, flush_mode) {
                const strm = this.strm;
                const chunkSize = this.options.chunkSize;
                let status, _flush_mode;
                if (this.ended) {
                  return false;
                }
                if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
                else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
                if (typeof data === "string") {
                  strm.input = strings.string2buf(data);
                } else if (toString$1.call(data) === "[object ArrayBuffer]") {
                  strm.input = new Uint8Array(data);
                } else {
                  strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                for (; ; ) {
                  if (strm.avail_out === 0) {
                    strm.output = new Uint8Array(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                  }
                  if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                    strm.avail_out = 0;
                    continue;
                  }
                  status = deflate_1$2.deflate(strm, _flush_mode);
                  if (status === Z_STREAM_END$2) {
                    if (strm.next_out > 0) {
                      this.onData(strm.output.subarray(0, strm.next_out));
                    }
                    status = deflate_1$2.deflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return status === Z_OK$2;
                  }
                  if (strm.avail_out === 0) {
                    this.onData(strm.output);
                    continue;
                  }
                  if (_flush_mode > 0 && strm.next_out > 0) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                    strm.avail_out = 0;
                    continue;
                  }
                  if (strm.avail_in === 0) break;
                }
                return true;
              };
              Deflate$1.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
              };
              Deflate$1.prototype.onEnd = function(status) {
                if (status === Z_OK$2) {
                  this.result = common.flattenChunks(this.chunks);
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
              };
              function deflate$1(input, options) {
                const deflator = new Deflate$1(options);
                deflator.push(input, true);
                if (deflator.err) {
                  throw deflator.msg || messages[deflator.err];
                }
                return deflator.result;
              }
              function deflateRaw$1(input, options) {
                options = options || {};
                options.raw = true;
                return deflate$1(input, options);
              }
              function gzip$1(input, options) {
                options = options || {};
                options.gzip = true;
                return deflate$1(input, options);
              }
              var Deflate_1$1 = Deflate$1;
              var deflate_2 = deflate$1;
              var deflateRaw_1$1 = deflateRaw$1;
              var gzip_1$1 = gzip$1;
              var constants$1 = constants$2;
              var deflate_1$1 = {
                Deflate: Deflate_1$1,
                deflate: deflate_2,
                deflateRaw: deflateRaw_1$1,
                gzip: gzip_1$1,
                constants: constants$1
              };
              const BAD$1 = 16209;
              const TYPE$1 = 16191;
              var inffast = function inflate_fast(strm, start) {
                let _in;
                let last;
                let _out;
                let beg;
                let end;
                let dmax;
                let wsize;
                let whave;
                let wnext;
                let s_window;
                let hold;
                let bits;
                let lcode;
                let dcode;
                let lmask;
                let dmask;
                let here;
                let op;
                let len;
                let dist;
                let from;
                let from_source;
                let input, output;
                const state = strm.state;
                _in = strm.next_in;
                input = strm.input;
                last = _in + (strm.avail_in - 5);
                _out = strm.next_out;
                output = strm.output;
                beg = _out - (start - strm.avail_out);
                end = _out + (strm.avail_out - 257);
                dmax = state.dmax;
                wsize = state.wsize;
                whave = state.whave;
                wnext = state.wnext;
                s_window = state.window;
                hold = state.hold;
                bits = state.bits;
                lcode = state.lencode;
                dcode = state.distcode;
                lmask = (1 << state.lenbits) - 1;
                dmask = (1 << state.distbits) - 1;
                top:
                  do {
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = lcode[hold & lmask];
                    dolen:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op === 0) {
                          output[_out++] = here & 65535;
                        } else if (op & 16) {
                          len = here & 65535;
                          op &= 15;
                          if (op) {
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                            len += hold & (1 << op) - 1;
                            hold >>>= op;
                            bits -= op;
                          }
                          if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                          here = dcode[hold & dmask];
                          dodist:
                            for (; ; ) {
                              op = here >>> 24;
                              hold >>>= op;
                              bits -= op;
                              op = here >>> 16 & 255;
                              if (op & 16) {
                                dist = here & 65535;
                                op &= 15;
                                if (bits < op) {
                                  hold += input[_in++] << bits;
                                  bits += 8;
                                  if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                  }
                                }
                                dist += hold & (1 << op) - 1;
                                if (dist > dmax) {
                                  strm.msg = "invalid distance too far back";
                                  state.mode = BAD$1;
                                  break top;
                                }
                                hold >>>= op;
                                bits -= op;
                                op = _out - beg;
                                if (dist > op) {
                                  op = dist - op;
                                  if (op > whave) {
                                    if (state.sane) {
                                      strm.msg = "invalid distance too far back";
                                      state.mode = BAD$1;
                                      break top;
                                    }
                                  }
                                  from = 0;
                                  from_source = s_window;
                                  if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = 0;
                                      if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                      }
                                    }
                                  } else {
                                    from += wnext - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  }
                                  while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                  }
                                  if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                      output[_out++] = from_source[from++];
                                    }
                                  }
                                } else {
                                  from = _out - dist;
                                  do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                  } while (len > 2);
                                  if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                      output[_out++] = output[from++];
                                    }
                                  }
                                }
                              } else if ((op & 64) === 0) {
                                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                continue dodist;
                              } else {
                                strm.msg = "invalid distance code";
                                state.mode = BAD$1;
                                break top;
                              }
                              break;
                            }
                        } else if ((op & 64) === 0) {
                          here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dolen;
                        } else if (op & 32) {
                          state.mode = TYPE$1;
                          break top;
                        } else {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD$1;
                          break top;
                        }
                        break;
                      }
                  } while (_in < last && _out < end);
                len = bits >> 3;
                _in -= len;
                bits -= len << 3;
                hold &= (1 << bits) - 1;
                strm.next_in = _in;
                strm.next_out = _out;
                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
                state.hold = hold;
                state.bits = bits;
                return;
              };
              const MAXBITS = 15;
              const ENOUGH_LENS$1 = 852;
              const ENOUGH_DISTS$1 = 592;
              const CODES$1 = 0;
              const LENS$1 = 1;
              const DISTS$1 = 2;
              const lbase = new Uint16Array([
                /* Length codes 257..285 base */
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                19,
                23,
                27,
                31,
                35,
                43,
                51,
                59,
                67,
                83,
                99,
                115,
                131,
                163,
                195,
                227,
                258,
                0,
                0
              ]);
              const lext = new Uint8Array([
                /* Length codes 257..285 extra */
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                16,
                72,
                78
              ]);
              const dbase = new Uint16Array([
                /* Distance codes 0..29 base */
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577,
                0,
                0
              ]);
              const dext = new Uint8Array([
                /* Distance codes 0..29 extra */
                16,
                16,
                16,
                16,
                17,
                17,
                18,
                18,
                19,
                19,
                20,
                20,
                21,
                21,
                22,
                22,
                23,
                23,
                24,
                24,
                25,
                25,
                26,
                26,
                27,
                27,
                28,
                28,
                29,
                29,
                64,
                64
              ]);
              const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
                const bits = opts.bits;
                let len = 0;
                let sym = 0;
                let min = 0, max = 0;
                let root = 0;
                let curr = 0;
                let drop = 0;
                let left = 0;
                let used = 0;
                let huff = 0;
                let incr;
                let fill;
                let low;
                let mask;
                let next;
                let base = null;
                let match;
                const count = new Uint16Array(MAXBITS + 1);
                const offs = new Uint16Array(MAXBITS + 1);
                let extra = null;
                let here_bits, here_op, here_val;
                for (len = 0; len <= MAXBITS; len++) {
                  count[len] = 0;
                }
                for (sym = 0; sym < codes; sym++) {
                  count[lens[lens_index + sym]]++;
                }
                root = bits;
                for (max = MAXBITS; max >= 1; max--) {
                  if (count[max] !== 0) {
                    break;
                  }
                }
                if (root > max) {
                  root = max;
                }
                if (max === 0) {
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  opts.bits = 1;
                  return 0;
                }
                for (min = 1; min < max; min++) {
                  if (count[min] !== 0) {
                    break;
                  }
                }
                if (root < min) {
                  root = min;
                }
                left = 1;
                for (len = 1; len <= MAXBITS; len++) {
                  left <<= 1;
                  left -= count[len];
                  if (left < 0) {
                    return -1;
                  }
                }
                if (left > 0 && (type === CODES$1 || max !== 1)) {
                  return -1;
                }
                offs[1] = 0;
                for (len = 1; len < MAXBITS; len++) {
                  offs[len + 1] = offs[len] + count[len];
                }
                for (sym = 0; sym < codes; sym++) {
                  if (lens[lens_index + sym] !== 0) {
                    work[offs[lens[lens_index + sym]]++] = sym;
                  }
                }
                if (type === CODES$1) {
                  base = extra = work;
                  match = 20;
                } else if (type === LENS$1) {
                  base = lbase;
                  extra = lext;
                  match = 257;
                } else {
                  base = dbase;
                  extra = dext;
                  match = 0;
                }
                huff = 0;
                sym = 0;
                len = min;
                next = table_index;
                curr = root;
                drop = 0;
                low = -1;
                used = 1 << root;
                mask = used - 1;
                if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                  return 1;
                }
                for (; ; ) {
                  here_bits = len - drop;
                  if (work[sym] + 1 < match) {
                    here_op = 0;
                    here_val = work[sym];
                  } else if (work[sym] >= match) {
                    here_op = extra[work[sym] - match];
                    here_val = base[work[sym] - match];
                  } else {
                    here_op = 32 + 64;
                    here_val = 0;
                  }
                  incr = 1 << len - drop;
                  fill = 1 << curr;
                  min = fill;
                  do {
                    fill -= incr;
                    table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                  } while (fill !== 0);
                  incr = 1 << len - 1;
                  while (huff & incr) {
                    incr >>= 1;
                  }
                  if (incr !== 0) {
                    huff &= incr - 1;
                    huff += incr;
                  } else {
                    huff = 0;
                  }
                  sym++;
                  if (--count[len] === 0) {
                    if (len === max) {
                      break;
                    }
                    len = lens[lens_index + work[sym]];
                  }
                  if (len > root && (huff & mask) !== low) {
                    if (drop === 0) {
                      drop = root;
                    }
                    next += min;
                    curr = len - drop;
                    left = 1 << curr;
                    while (curr + drop < max) {
                      left -= count[curr + drop];
                      if (left <= 0) {
                        break;
                      }
                      curr++;
                      left <<= 1;
                    }
                    used += 1 << curr;
                    if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                      return 1;
                    }
                    low = huff & mask;
                    table[low] = root << 24 | curr << 16 | next - table_index | 0;
                  }
                }
                if (huff !== 0) {
                  table[next + huff] = len - drop << 24 | 64 << 16 | 0;
                }
                opts.bits = root;
                return 0;
              };
              var inftrees = inflate_table;
              const CODES = 0;
              const LENS = 1;
              const DISTS = 2;
              const {
                Z_FINISH: Z_FINISH$1,
                Z_BLOCK,
                Z_TREES,
                Z_OK: Z_OK$1,
                Z_STREAM_END: Z_STREAM_END$1,
                Z_NEED_DICT: Z_NEED_DICT$1,
                Z_STREAM_ERROR: Z_STREAM_ERROR$1,
                Z_DATA_ERROR: Z_DATA_ERROR$1,
                Z_MEM_ERROR: Z_MEM_ERROR$1,
                Z_BUF_ERROR,
                Z_DEFLATED
              } = constants$2;
              const HEAD = 16180;
              const FLAGS = 16181;
              const TIME = 16182;
              const OS = 16183;
              const EXLEN = 16184;
              const EXTRA = 16185;
              const NAME = 16186;
              const COMMENT = 16187;
              const HCRC = 16188;
              const DICTID = 16189;
              const DICT = 16190;
              const TYPE = 16191;
              const TYPEDO = 16192;
              const STORED = 16193;
              const COPY_ = 16194;
              const COPY = 16195;
              const TABLE = 16196;
              const LENLENS = 16197;
              const CODELENS = 16198;
              const LEN_ = 16199;
              const LEN = 16200;
              const LENEXT = 16201;
              const DIST = 16202;
              const DISTEXT = 16203;
              const MATCH = 16204;
              const LIT = 16205;
              const CHECK = 16206;
              const LENGTH = 16207;
              const DONE = 16208;
              const BAD = 16209;
              const MEM = 16210;
              const SYNC = 16211;
              const ENOUGH_LENS = 852;
              const ENOUGH_DISTS = 592;
              const MAX_WBITS = 15;
              const DEF_WBITS = MAX_WBITS;
              const zswap32 = (q) => {
                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
              };
              function InflateState() {
                this.strm = null;
                this.mode = 0;
                this.last = false;
                this.wrap = 0;
                this.havedict = false;
                this.flags = 0;
                this.dmax = 0;
                this.check = 0;
                this.total = 0;
                this.head = null;
                this.wbits = 0;
                this.wsize = 0;
                this.whave = 0;
                this.wnext = 0;
                this.window = null;
                this.hold = 0;
                this.bits = 0;
                this.length = 0;
                this.offset = 0;
                this.extra = 0;
                this.lencode = null;
                this.distcode = null;
                this.lenbits = 0;
                this.distbits = 0;
                this.ncode = 0;
                this.nlen = 0;
                this.ndist = 0;
                this.have = 0;
                this.next = null;
                this.lens = new Uint16Array(320);
                this.work = new Uint16Array(288);
                this.lendyn = null;
                this.distdyn = null;
                this.sane = 0;
                this.back = 0;
                this.was = 0;
              }
              const inflateStateCheck = (strm) => {
                if (!strm) {
                  return 1;
                }
                const state = strm.state;
                if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
                  return 1;
                }
                return 0;
              };
              const inflateResetKeep = (strm) => {
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                const state = strm.state;
                strm.total_in = strm.total_out = state.total = 0;
                strm.msg = "";
                if (state.wrap) {
                  strm.adler = state.wrap & 1;
                }
                state.mode = HEAD;
                state.last = 0;
                state.havedict = 0;
                state.flags = -1;
                state.dmax = 32768;
                state.head = null;
                state.hold = 0;
                state.bits = 0;
                state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
                state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
                state.sane = 1;
                state.back = -1;
                return Z_OK$1;
              };
              const inflateReset = (strm) => {
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                const state = strm.state;
                state.wsize = 0;
                state.whave = 0;
                state.wnext = 0;
                return inflateResetKeep(strm);
              };
              const inflateReset2 = (strm, windowBits) => {
                let wrap;
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                const state = strm.state;
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else {
                  wrap = (windowBits >> 4) + 5;
                  if (windowBits < 48) {
                    windowBits &= 15;
                  }
                }
                if (windowBits && (windowBits < 8 || windowBits > 15)) {
                  return Z_STREAM_ERROR$1;
                }
                if (state.window !== null && state.wbits !== windowBits) {
                  state.window = null;
                }
                state.wrap = wrap;
                state.wbits = windowBits;
                return inflateReset(strm);
              };
              const inflateInit2 = (strm, windowBits) => {
                if (!strm) {
                  return Z_STREAM_ERROR$1;
                }
                const state = new InflateState();
                strm.state = state;
                state.strm = strm;
                state.window = null;
                state.mode = HEAD;
                const ret = inflateReset2(strm, windowBits);
                if (ret !== Z_OK$1) {
                  strm.state = null;
                }
                return ret;
              };
              const inflateInit = (strm) => {
                return inflateInit2(strm, DEF_WBITS);
              };
              let virgin = true;
              let lenfix, distfix;
              const fixedtables = (state) => {
                if (virgin) {
                  lenfix = new Int32Array(512);
                  distfix = new Int32Array(32);
                  let sym = 0;
                  while (sym < 144) {
                    state.lens[sym++] = 8;
                  }
                  while (sym < 256) {
                    state.lens[sym++] = 9;
                  }
                  while (sym < 280) {
                    state.lens[sym++] = 7;
                  }
                  while (sym < 288) {
                    state.lens[sym++] = 8;
                  }
                  inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
                  sym = 0;
                  while (sym < 32) {
                    state.lens[sym++] = 5;
                  }
                  inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
                  virgin = false;
                }
                state.lencode = lenfix;
                state.lenbits = 9;
                state.distcode = distfix;
                state.distbits = 5;
              };
              const updatewindow = (strm, src, end, copy) => {
                let dist;
                const state = strm.state;
                if (state.window === null) {
                  state.wsize = 1 << state.wbits;
                  state.wnext = 0;
                  state.whave = 0;
                  state.window = new Uint8Array(state.wsize);
                }
                if (copy >= state.wsize) {
                  state.window.set(src.subarray(end - state.wsize, end), 0);
                  state.wnext = 0;
                  state.whave = state.wsize;
                } else {
                  dist = state.wsize - state.wnext;
                  if (dist > copy) {
                    dist = copy;
                  }
                  state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
                  copy -= dist;
                  if (copy) {
                    state.window.set(src.subarray(end - copy, end), 0);
                    state.wnext = copy;
                    state.whave = state.wsize;
                  } else {
                    state.wnext += dist;
                    if (state.wnext === state.wsize) {
                      state.wnext = 0;
                    }
                    if (state.whave < state.wsize) {
                      state.whave += dist;
                    }
                  }
                }
                return 0;
              };
              const inflate$2 = (strm, flush) => {
                let state;
                let input, output;
                let next;
                let put;
                let have, left;
                let hold;
                let bits;
                let _in, _out;
                let copy;
                let from;
                let from_source;
                let here = 0;
                let here_bits, here_op, here_val;
                let last_bits, last_op, last_val;
                let len;
                let ret;
                const hbuf = new Uint8Array(4);
                let opts;
                let n;
                const order = (
                  /* permutation of code lengths */
                  new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                );
                if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
                  return Z_STREAM_ERROR$1;
                }
                state = strm.state;
                if (state.mode === TYPE) {
                  state.mode = TYPEDO;
                }
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                _in = have;
                _out = left;
                ret = Z_OK$1;
                inf_leave:
                  for (; ; ) {
                    switch (state.mode) {
                      case HEAD:
                        if (state.wrap === 0) {
                          state.mode = TYPEDO;
                          break;
                        }
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.wrap & 2 && hold === 35615) {
                          if (state.wbits === 0) {
                            state.wbits = 15;
                          }
                          state.check = 0;
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32_1(state.check, hbuf, 2, 0);
                          hold = 0;
                          bits = 0;
                          state.mode = FLAGS;
                          break;
                        }
                        if (state.head) {
                          state.head.done = false;
                        }
                        if (!(state.wrap & 1) || /* check if zlib header allowed */
                        (((hold & 255) << 8) + (hold >> 8)) % 31) {
                          strm.msg = "incorrect header check";
                          state.mode = BAD;
                          break;
                        }
                        if ((hold & 15) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        hold >>>= 4;
                        bits -= 4;
                        len = (hold & 15) + 8;
                        if (state.wbits === 0) {
                          state.wbits = len;
                        }
                        if (len > 15 || len > state.wbits) {
                          strm.msg = "invalid window size";
                          state.mode = BAD;
                          break;
                        }
                        state.dmax = 1 << state.wbits;
                        state.flags = 0;
                        strm.adler = state.check = 1;
                        state.mode = hold & 512 ? DICTID : TYPE;
                        hold = 0;
                        bits = 0;
                        break;
                      case FLAGS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.flags = hold;
                        if ((state.flags & 255) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        if (state.flags & 57344) {
                          strm.msg = "unknown header flags set";
                          state.mode = BAD;
                          break;
                        }
                        if (state.head) {
                          state.head.text = hold >> 8 & 1;
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32_1(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = TIME;
                      /* falls through */
                      case TIME:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.time = hold;
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          hbuf[2] = hold >>> 16 & 255;
                          hbuf[3] = hold >>> 24 & 255;
                          state.check = crc32_1(state.check, hbuf, 4, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = OS;
                      /* falls through */
                      case OS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.xflags = hold & 255;
                          state.head.os = hold >> 8;
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32_1(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = EXLEN;
                      /* falls through */
                      case EXLEN:
                        if (state.flags & 1024) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length = hold;
                          if (state.head) {
                            state.head.extra_len = hold;
                          }
                          if (state.flags & 512 && state.wrap & 4) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32_1(state.check, hbuf, 2, 0);
                          }
                          hold = 0;
                          bits = 0;
                        } else if (state.head) {
                          state.head.extra = null;
                        }
                        state.mode = EXTRA;
                      /* falls through */
                      case EXTRA:
                        if (state.flags & 1024) {
                          copy = state.length;
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy) {
                            if (state.head) {
                              len = state.head.extra_len - state.length;
                              if (!state.head.extra) {
                                state.head.extra = new Uint8Array(state.head.extra_len);
                              }
                              state.head.extra.set(
                                input.subarray(
                                  next,
                                  // extra field is limited to 65536 bytes
                                  // - no need for additional size check
                                  next + copy
                                ),
                                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                len
                              );
                            }
                            if (state.flags & 512 && state.wrap & 4) {
                              state.check = crc32_1(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                          }
                          if (state.length) {
                            break inf_leave;
                          }
                        }
                        state.length = 0;
                        state.mode = NAME;
                      /* falls through */
                      case NAME:
                        if (state.flags & 2048) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.name += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;
                      /* falls through */
                      case COMMENT:
                        if (state.flags & 4096) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.comment += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.comment = null;
                        }
                        state.mode = HCRC;
                      /* falls through */
                      case HCRC:
                        if (state.flags & 512) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (state.wrap & 4 && hold !== (state.check & 65535)) {
                            strm.msg = "header crc mismatch";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        if (state.head) {
                          state.head.hcrc = state.flags >> 9 & 1;
                          state.head.done = true;
                        }
                        strm.adler = state.check = 0;
                        state.mode = TYPE;
                        break;
                      case DICTID:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        strm.adler = state.check = zswap32(hold);
                        hold = 0;
                        bits = 0;
                        state.mode = DICT;
                      /* falls through */
                      case DICT:
                        if (state.havedict === 0) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          return Z_NEED_DICT$1;
                        }
                        strm.adler = state.check = 1;
                        state.mode = TYPE;
                      /* falls through */
                      case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case TYPEDO:
                        if (state.last) {
                          hold >>>= bits & 7;
                          bits -= bits & 7;
                          state.mode = CHECK;
                          break;
                        }
                        while (bits < 3) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.last = hold & 1;
                        hold >>>= 1;
                        bits -= 1;
                        switch (hold & 3) {
                          case 0:
                            state.mode = STORED;
                            break;
                          case 1:
                            fixedtables(state);
                            state.mode = LEN_;
                            if (flush === Z_TREES) {
                              hold >>>= 2;
                              bits -= 2;
                              break inf_leave;
                            }
                            break;
                          case 2:
                            state.mode = TABLE;
                            break;
                          case 3:
                            strm.msg = "invalid block type";
                            state.mode = BAD;
                        }
                        hold >>>= 2;
                        bits -= 2;
                        break;
                      case STORED:
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                          strm.msg = "invalid stored block lengths";
                          state.mode = BAD;
                          break;
                        }
                        state.length = hold & 65535;
                        hold = 0;
                        bits = 0;
                        state.mode = COPY_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case COPY_:
                        state.mode = COPY;
                      /* falls through */
                      case COPY:
                        copy = state.length;
                        if (copy) {
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy > left) {
                            copy = left;
                          }
                          if (copy === 0) {
                            break inf_leave;
                          }
                          output.set(input.subarray(next, next + copy), put);
                          have -= copy;
                          next += copy;
                          left -= copy;
                          put += copy;
                          state.length -= copy;
                          break;
                        }
                        state.mode = TYPE;
                        break;
                      case TABLE:
                        while (bits < 14) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.nlen = (hold & 31) + 257;
                        hold >>>= 5;
                        bits -= 5;
                        state.ndist = (hold & 31) + 1;
                        hold >>>= 5;
                        bits -= 5;
                        state.ncode = (hold & 15) + 4;
                        hold >>>= 4;
                        bits -= 4;
                        if (state.nlen > 286 || state.ndist > 30) {
                          strm.msg = "too many length or distance symbols";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = LENLENS;
                      /* falls through */
                      case LENLENS:
                        while (state.have < state.ncode) {
                          while (bits < 3) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.lens[order[state.have++]] = hold & 7;
                          hold >>>= 3;
                          bits -= 3;
                        }
                        while (state.have < 19) {
                          state.lens[order[state.have++]] = 0;
                        }
                        state.lencode = state.lendyn;
                        state.lenbits = 7;
                        opts = { bits: state.lenbits };
                        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid code lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = CODELENS;
                      /* falls through */
                      case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                          for (; ; ) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (here_val < 16) {
                            hold >>>= here_bits;
                            bits -= here_bits;
                            state.lens[state.have++] = here_val;
                          } else {
                            if (here_val === 16) {
                              n = here_bits + 2;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                              }
                              len = state.lens[state.have - 1];
                              copy = 3 + (hold & 3);
                              hold >>>= 2;
                              bits -= 2;
                            } else if (here_val === 17) {
                              n = here_bits + 3;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 3 + (hold & 7);
                              hold >>>= 3;
                              bits -= 3;
                            } else {
                              n = here_bits + 7;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 11 + (hold & 127);
                              hold >>>= 7;
                              bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                              strm.msg = "invalid bit length repeat";
                              state.mode = BAD;
                              break;
                            }
                            while (copy--) {
                              state.lens[state.have++] = len;
                            }
                          }
                        }
                        if (state.mode === BAD) {
                          break;
                        }
                        if (state.lens[256] === 0) {
                          strm.msg = "invalid code -- missing end-of-block";
                          state.mode = BAD;
                          break;
                        }
                        state.lenbits = 9;
                        opts = { bits: state.lenbits };
                        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid literal/lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.distbits = 6;
                        state.distcode = state.distdyn;
                        opts = { bits: state.distbits };
                        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        state.distbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid distances set";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case LEN_:
                        state.mode = LEN;
                      /* falls through */
                      case LEN:
                        if (have >= 6 && left >= 258) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          inffast(strm, _out);
                          put = strm.next_out;
                          output = strm.output;
                          left = strm.avail_out;
                          next = strm.next_in;
                          input = strm.input;
                          have = strm.avail_in;
                          hold = state.hold;
                          bits = state.bits;
                          if (state.mode === TYPE) {
                            state.back = -1;
                          }
                          break;
                        }
                        state.back = 0;
                        for (; ; ) {
                          here = state.lencode[hold & (1 << state.lenbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (here_op && (here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                          state.mode = LIT;
                          break;
                        }
                        if (here_op & 32) {
                          state.back = -1;
                          state.mode = TYPE;
                          break;
                        }
                        if (here_op & 64) {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD;
                          break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;
                      /* falls through */
                      case LENEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        state.was = state.length;
                        state.mode = DIST;
                      /* falls through */
                      case DIST:
                        for (; ; ) {
                          here = state.distcode[hold & (1 << state.distbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        if (here_op & 64) {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break;
                        }
                        state.offset = here_val;
                        state.extra = here_op & 15;
                        state.mode = DISTEXT;
                      /* falls through */
                      case DISTEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.offset += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        if (state.offset > state.dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = MATCH;
                      /* falls through */
                      case MATCH:
                        if (left === 0) {
                          break inf_leave;
                        }
                        copy = _out - left;
                        if (state.offset > copy) {
                          copy = state.offset - copy;
                          if (copy > state.whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break;
                            }
                          }
                          if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                          } else {
                            from = state.wnext - copy;
                          }
                          if (copy > state.length) {
                            copy = state.length;
                          }
                          from_source = state.window;
                        } else {
                          from_source = output;
                          from = put - state.offset;
                          copy = state.length;
                        }
                        if (copy > left) {
                          copy = left;
                        }
                        left -= copy;
                        state.length -= copy;
                        do {
                          output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) {
                          state.mode = LEN;
                        }
                        break;
                      case LIT:
                        if (left === 0) {
                          break inf_leave;
                        }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;
                      case CHECK:
                        if (state.wrap) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold |= input[next++] << bits;
                            bits += 8;
                          }
                          _out -= left;
                          strm.total_out += _out;
                          state.total += _out;
                          if (state.wrap & 4 && _out) {
                            strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                            state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                          }
                          _out = left;
                          if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = LENGTH;
                      /* falls through */
                      case LENGTH:
                        if (state.wrap && state.flags) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                            strm.msg = "incorrect length check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = DONE;
                      /* falls through */
                      case DONE:
                        ret = Z_STREAM_END$1;
                        break inf_leave;
                      case BAD:
                        ret = Z_DATA_ERROR$1;
                        break inf_leave;
                      case MEM:
                        return Z_MEM_ERROR$1;
                      case SYNC:
                      /* falls through */
                      default:
                        return Z_STREAM_ERROR$1;
                    }
                  }
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
                  if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
                }
                _in -= strm.avail_in;
                _out -= strm.avail_out;
                strm.total_in += _in;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
                  state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
                }
                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
                  ret = Z_BUF_ERROR;
                }
                return ret;
              };
              const inflateEnd = (strm) => {
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                let state = strm.state;
                if (state.window) {
                  state.window = null;
                }
                strm.state = null;
                return Z_OK$1;
              };
              const inflateGetHeader = (strm, head) => {
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                const state = strm.state;
                if ((state.wrap & 2) === 0) {
                  return Z_STREAM_ERROR$1;
                }
                state.head = head;
                head.done = false;
                return Z_OK$1;
              };
              const inflateSetDictionary = (strm, dictionary) => {
                const dictLength = dictionary.length;
                let state;
                let dictid;
                let ret;
                if (inflateStateCheck(strm)) {
                  return Z_STREAM_ERROR$1;
                }
                state = strm.state;
                if (state.wrap !== 0 && state.mode !== DICT) {
                  return Z_STREAM_ERROR$1;
                }
                if (state.mode === DICT) {
                  dictid = 1;
                  dictid = adler32_1(dictid, dictionary, dictLength, 0);
                  if (dictid !== state.check) {
                    return Z_DATA_ERROR$1;
                  }
                }
                ret = updatewindow(strm, dictionary, dictLength, dictLength);
                if (ret) {
                  state.mode = MEM;
                  return Z_MEM_ERROR$1;
                }
                state.havedict = 1;
                return Z_OK$1;
              };
              var inflateReset_1 = inflateReset;
              var inflateReset2_1 = inflateReset2;
              var inflateResetKeep_1 = inflateResetKeep;
              var inflateInit_1 = inflateInit;
              var inflateInit2_1 = inflateInit2;
              var inflate_2$1 = inflate$2;
              var inflateEnd_1 = inflateEnd;
              var inflateGetHeader_1 = inflateGetHeader;
              var inflateSetDictionary_1 = inflateSetDictionary;
              var inflateInfo = "pako inflate (from Nodeca project)";
              var inflate_1$2 = {
                inflateReset: inflateReset_1,
                inflateReset2: inflateReset2_1,
                inflateResetKeep: inflateResetKeep_1,
                inflateInit: inflateInit_1,
                inflateInit2: inflateInit2_1,
                inflate: inflate_2$1,
                inflateEnd: inflateEnd_1,
                inflateGetHeader: inflateGetHeader_1,
                inflateSetDictionary: inflateSetDictionary_1,
                inflateInfo
              };
              function GZheader() {
                this.text = 0;
                this.time = 0;
                this.xflags = 0;
                this.os = 0;
                this.extra = null;
                this.extra_len = 0;
                this.name = "";
                this.comment = "";
                this.hcrc = 0;
                this.done = false;
              }
              var gzheader = GZheader;
              const toString = Object.prototype.toString;
              const {
                Z_NO_FLUSH,
                Z_FINISH,
                Z_OK,
                Z_STREAM_END,
                Z_NEED_DICT,
                Z_STREAM_ERROR,
                Z_DATA_ERROR,
                Z_MEM_ERROR
              } = constants$2;
              function Inflate$1(options) {
                this.options = common.assign({
                  chunkSize: 1024 * 64,
                  windowBits: 15,
                  to: ""
                }, options || {});
                const opt = this.options;
                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
                  opt.windowBits = -opt.windowBits;
                  if (opt.windowBits === 0) {
                    opt.windowBits = -15;
                  }
                }
                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
                  opt.windowBits += 32;
                }
                if (opt.windowBits > 15 && opt.windowBits < 48) {
                  if ((opt.windowBits & 15) === 0) {
                    opt.windowBits |= 15;
                  }
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new zstream();
                this.strm.avail_out = 0;
                let status = inflate_1$2.inflateInit2(
                  this.strm,
                  opt.windowBits
                );
                if (status !== Z_OK) {
                  throw new Error(messages[status]);
                }
                this.header = new gzheader();
                inflate_1$2.inflateGetHeader(this.strm, this.header);
                if (opt.dictionary) {
                  if (typeof opt.dictionary === "string") {
                    opt.dictionary = strings.string2buf(opt.dictionary);
                  } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                    opt.dictionary = new Uint8Array(opt.dictionary);
                  }
                  if (opt.raw) {
                    status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
                    if (status !== Z_OK) {
                      throw new Error(messages[status]);
                    }
                  }
                }
              }
              Inflate$1.prototype.push = function(data, flush_mode) {
                const strm = this.strm;
                const chunkSize = this.options.chunkSize;
                const dictionary = this.options.dictionary;
                let status, _flush_mode, last_avail_out;
                if (this.ended) return false;
                if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
                else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
                if (toString.call(data) === "[object ArrayBuffer]") {
                  strm.input = new Uint8Array(data);
                } else {
                  strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                for (; ; ) {
                  if (strm.avail_out === 0) {
                    strm.output = new Uint8Array(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                  }
                  status = inflate_1$2.inflate(strm, _flush_mode);
                  if (status === Z_NEED_DICT && dictionary) {
                    status = inflate_1$2.inflateSetDictionary(strm, dictionary);
                    if (status === Z_OK) {
                      status = inflate_1$2.inflate(strm, _flush_mode);
                    } else if (status === Z_DATA_ERROR) {
                      status = Z_NEED_DICT;
                    }
                  }
                  while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
                    inflate_1$2.inflateReset(strm);
                    status = inflate_1$2.inflate(strm, _flush_mode);
                  }
                  switch (status) {
                    case Z_STREAM_ERROR:
                    case Z_DATA_ERROR:
                    case Z_NEED_DICT:
                    case Z_MEM_ERROR:
                      this.onEnd(status);
                      this.ended = true;
                      return false;
                  }
                  last_avail_out = strm.avail_out;
                  if (strm.next_out) {
                    if (strm.avail_out === 0 || status === Z_STREAM_END) {
                      if (this.options.to === "string") {
                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        let tail = strm.next_out - next_out_utf8;
                        let utf8str = strings.buf2string(strm.output, next_out_utf8);
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                        this.onData(utf8str);
                      } else {
                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                      }
                    }
                  }
                  if (status === Z_OK && last_avail_out === 0) continue;
                  if (status === Z_STREAM_END) {
                    status = inflate_1$2.inflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return true;
                  }
                  if (strm.avail_in === 0) break;
                }
                return true;
              };
              Inflate$1.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
              };
              Inflate$1.prototype.onEnd = function(status) {
                if (status === Z_OK) {
                  if (this.options.to === "string") {
                    this.result = this.chunks.join("");
                  } else {
                    this.result = common.flattenChunks(this.chunks);
                  }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
              };
              function inflate$1(input, options) {
                const inflator = new Inflate$1(options);
                inflator.push(input);
                if (inflator.err) throw inflator.msg || messages[inflator.err];
                return inflator.result;
              }
              function inflateRaw$1(input, options) {
                options = options || {};
                options.raw = true;
                return inflate$1(input, options);
              }
              var Inflate_1$1 = Inflate$1;
              var inflate_2 = inflate$1;
              var inflateRaw_1$1 = inflateRaw$1;
              var ungzip$1 = inflate$1;
              var constants = constants$2;
              var inflate_1$1 = {
                Inflate: Inflate_1$1,
                inflate: inflate_2,
                inflateRaw: inflateRaw_1$1,
                ungzip: ungzip$1,
                constants
              };
              const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
              const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
              var Deflate_1 = Deflate;
              var deflate_1 = deflate;
              var deflateRaw_1 = deflateRaw;
              var gzip_1 = gzip;
              var Inflate_1 = Inflate;
              var inflate_1 = inflate;
              var inflateRaw_1 = inflateRaw;
              var ungzip_1 = ungzip;
              var constants_1 = constants$2;
              var pako = {
                Deflate: Deflate_1,
                deflate: deflate_1,
                deflateRaw: deflateRaw_1,
                gzip: gzip_1,
                Inflate: Inflate_1,
                inflate: inflate_1,
                inflateRaw: inflateRaw_1,
                ungzip: ungzip_1,
                constants: constants_1
              };
            },
            /***/
            "./node_modules/upng-js/UPNG.js"(module2, __unused_webpack_exports, __webpack_require__2) {
              ;
              (function() {
                var UPNG = {};
                var pako;
                if (true) {
                  module2.exports = UPNG;
                } else {
                }
                if (true) {
                  pako = __webpack_require__2(
                    /*! pako */
                    "./node_modules/upng-js/node_modules/pako/index.js"
                  );
                } else {
                }
                function log() {
                  if (typeof process == "undefined" || true) console.log.apply(console, arguments);
                }
                (function(UPNG2, pako2) {
                  UPNG2.toRGBA8 = function(out) {
                    var w = out.width, h = out.height;
                    if (out.tabs.acTL == null) return [UPNG2.toRGBA8.decodeImage(out.data, w, h, out).buffer];
                    var frms = [];
                    if (out.frames[0].data == null) out.frames[0].data = out.data;
                    var img, empty = new Uint8Array(w * h * 4);
                    for (var i = 0; i < out.frames.length; i++) {
                      var frm = out.frames[i];
                      var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
                      var fdata = UPNG2.toRGBA8.decodeImage(frm.data, fw, fh, out);
                      if (i == 0) img = fdata;
                      else if (frm.blend == 0) UPNG2._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
                      else if (frm.blend == 1) UPNG2._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
                      frms.push(img.buffer);
                      img = img.slice(0);
                      if (frm.dispose == 0) {
                      } else if (frm.dispose == 1) UPNG2._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
                      else if (frm.dispose == 2) {
                        var pi = i - 1;
                        while (out.frames[pi].dispose == 2) pi--;
                        img = new Uint8Array(frms[pi]).slice(0);
                      }
                    }
                    return frms;
                  };
                  UPNG2.toRGBA8.decodeImage = function(data, w, h, out) {
                    var area = w * h, bpp = UPNG2.decode._getBPP(out);
                    var bpl = Math.ceil(w * bpp / 8);
                    var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
                    var ctype = out.ctype, depth = out.depth;
                    var rs = UPNG2._bin.readUshort;
                    if (ctype == 6) {
                      var qarea = area << 2;
                      if (depth == 8) for (var i = 0; i < qarea; i++) {
                        bf[i] = data[i];
                      }
                      if (depth == 16) for (var i = 0; i < qarea; i++) {
                        bf[i] = data[i << 1];
                      }
                    } else if (ctype == 2) {
                      var ts = out.tabs["tRNS"], tr = -1, tg = -1, tb = -1;
                      if (ts) {
                        tr = ts[0];
                        tg = ts[1];
                        tb = ts[2];
                      }
                      if (depth == 8) for (var i = 0; i < area; i++) {
                        var qi = i << 2, ti = i * 3;
                        bf[qi] = data[ti];
                        bf[qi + 1] = data[ti + 1];
                        bf[qi + 2] = data[ti + 2];
                        bf[qi + 3] = 255;
                        if (tr != -1 && data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;
                      }
                      if (depth == 16) for (var i = 0; i < area; i++) {
                        var qi = i << 2, ti = i * 6;
                        bf[qi] = data[ti];
                        bf[qi + 1] = data[ti + 2];
                        bf[qi + 2] = data[ti + 4];
                        bf[qi + 3] = 255;
                        if (tr != -1 && rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;
                      }
                    } else if (ctype == 3) {
                      var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
                      if (depth == 1) for (var y = 0; y < h; y++) {
                        var s0 = y * bpl, t0 = y * w;
                        for (var i = 0; i < w; i++) {
                          var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
                          bf[qi] = p[cj];
                          bf[qi + 1] = p[cj + 1];
                          bf[qi + 2] = p[cj + 2];
                          bf[qi + 3] = j < tl ? ap[j] : 255;
                        }
                      }
                      if (depth == 2) for (var y = 0; y < h; y++) {
                        var s0 = y * bpl, t0 = y * w;
                        for (var i = 0; i < w; i++) {
                          var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
                          bf[qi] = p[cj];
                          bf[qi + 1] = p[cj + 1];
                          bf[qi + 2] = p[cj + 2];
                          bf[qi + 3] = j < tl ? ap[j] : 255;
                        }
                      }
                      if (depth == 4) for (var y = 0; y < h; y++) {
                        var s0 = y * bpl, t0 = y * w;
                        for (var i = 0; i < w; i++) {
                          var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
                          bf[qi] = p[cj];
                          bf[qi + 1] = p[cj + 1];
                          bf[qi + 2] = p[cj + 2];
                          bf[qi + 3] = j < tl ? ap[j] : 255;
                        }
                      }
                      if (depth == 8) for (var i = 0; i < area; i++) {
                        var qi = i << 2, j = data[i], cj = 3 * j;
                        bf[qi] = p[cj];
                        bf[qi + 1] = p[cj + 1];
                        bf[qi + 2] = p[cj + 2];
                        bf[qi + 3] = j < tl ? ap[j] : 255;
                      }
                    } else if (ctype == 4) {
                      if (depth == 8) for (var i = 0; i < area; i++) {
                        var qi = i << 2, di = i << 1, gr = data[di];
                        bf[qi] = gr;
                        bf[qi + 1] = gr;
                        bf[qi + 2] = gr;
                        bf[qi + 3] = data[di + 1];
                      }
                      if (depth == 16) for (var i = 0; i < area; i++) {
                        var qi = i << 2, di = i << 2, gr = data[di];
                        bf[qi] = gr;
                        bf[qi + 1] = gr;
                        bf[qi + 2] = gr;
                        bf[qi + 3] = data[di + 2];
                      }
                    } else if (ctype == 0) {
                      var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
                      if (depth == 1) for (var i = 0; i < area; i++) {
                        var gr = 255 * (data[i >> 3] >> 7 - (i & 7) & 1), al = gr == tr * 255 ? 0 : 255;
                        bf32[i] = al << 24 | gr << 16 | gr << 8 | gr;
                      }
                      if (depth == 2) for (var i = 0; i < area; i++) {
                        var gr = 85 * (data[i >> 2] >> 6 - ((i & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
                        bf32[i] = al << 24 | gr << 16 | gr << 8 | gr;
                      }
                      if (depth == 4) for (var i = 0; i < area; i++) {
                        var gr = 17 * (data[i >> 1] >> 4 - ((i & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
                        bf32[i] = al << 24 | gr << 16 | gr << 8 | gr;
                      }
                      if (depth == 8) for (var i = 0; i < area; i++) {
                        var gr = data[i], al = gr == tr ? 0 : 255;
                        bf32[i] = al << 24 | gr << 16 | gr << 8 | gr;
                      }
                      if (depth == 16) for (var i = 0; i < area; i++) {
                        var gr = data[i << 1], al = rs(data, i << 1) == tr ? 0 : 255;
                        bf32[i] = al << 24 | gr << 16 | gr << 8 | gr;
                      }
                    }
                    return bf;
                  };
                  UPNG2.decode = function(buff) {
                    var data = new Uint8Array(buff), offset = 8, bin = UPNG2._bin, rUs = bin.readUshort, rUi = bin.readUint;
                    var out = { tabs: {}, frames: [] };
                    var dd = new Uint8Array(data.length), doff = 0;
                    var fd, foff = 0;
                    var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
                    for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw "The input is not a PNG file!";
                    while (offset < data.length) {
                      var len = bin.readUint(data, offset);
                      offset += 4;
                      var type = bin.readASCII(data, offset, 4);
                      offset += 4;
                      if (type == "IHDR") {
                        UPNG2.decode._IHDR(data, offset, out);
                      } else if (type == "IDAT") {
                        for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];
                        doff += len;
                      } else if (type == "acTL") {
                        out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };
                        fd = new Uint8Array(data.length);
                      } else if (type == "fcTL") {
                        if (foff != 0) {
                          var fr = out.frames[out.frames.length - 1];
                          fr.data = UPNG2.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
                          foff = 0;
                        }
                        var rct = { x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8) };
                        var del = rUs(data, offset + 22);
                        del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
                        var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data[offset + 24], blend: data[offset + 25] };
                        out.frames.push(frm);
                      } else if (type == "fdAT") {
                        for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];
                        foff += len - 4;
                      } else if (type == "pHYs") {
                        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
                      } else if (type == "cHRM") {
                        out.tabs[type] = [];
                        for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));
                      } else if (type == "tEXt") {
                        if (out.tabs[type] == null) out.tabs[type] = {};
                        var nz = bin.nextZero(data, offset);
                        var keyw = bin.readASCII(data, offset, nz - offset);
                        var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);
                        out.tabs[type][keyw] = text;
                      } else if (type == "iTXt") {
                        if (out.tabs[type] == null) out.tabs[type] = {};
                        var nz = 0, off = offset;
                        nz = bin.nextZero(data, off);
                        var keyw = bin.readASCII(data, off, nz - off);
                        off = nz + 1;
                        var cflag = data[off], cmeth = data[off + 1];
                        off += 2;
                        nz = bin.nextZero(data, off);
                        var ltag = bin.readASCII(data, off, nz - off);
                        off = nz + 1;
                        nz = bin.nextZero(data, off);
                        var tkeyw = bin.readUTF8(data, off, nz - off);
                        off = nz + 1;
                        var text = bin.readUTF8(data, off, len - (off - offset));
                        out.tabs[type][keyw] = text;
                      } else if (type == "PLTE") {
                        out.tabs[type] = bin.readBytes(data, offset, len);
                      } else if (type == "hIST") {
                        var pl = out.tabs["PLTE"].length / 3;
                        out.tabs[type] = [];
                        for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));
                      } else if (type == "tRNS") {
                        if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);
                        else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);
                        else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
                      } else if (type == "gAMA") out.tabs[type] = bin.readUint(data, offset) / 1e5;
                      else if (type == "sRGB") out.tabs[type] = data[offset];
                      else if (type == "bKGD") {
                        if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data, offset)];
                        else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
                        else if (out.ctype == 3) out.tabs[type] = data[offset];
                      } else if (type == "IEND") {
                        if (foff != 0) {
                          var fr = out.frames[out.frames.length - 1];
                          fr.data = UPNG2.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
                          foff = 0;
                        }
                        out.data = UPNG2.decode._decompress(out, dd, out.width, out.height);
                        break;
                      }
                      offset += len;
                      var crc = bin.readUint(data, offset);
                      offset += 4;
                    }
                    delete out.compress;
                    delete out.interlace;
                    delete out.filter;
                    return out;
                  };
                  UPNG2.decode._decompress = function(out, dd, w, h) {
                    if (out.compress == 0) dd = UPNG2.decode._inflate(dd);
                    if (out.interlace == 0) dd = UPNG2.decode._filterZero(dd, out, 0, w, h);
                    else if (out.interlace == 1) dd = UPNG2.decode._readInterlace(dd, out);
                    return dd;
                  };
                  UPNG2.decode._inflate = function(data) {
                    return pako2["inflate"](data);
                  };
                  UPNG2.decode._readInterlace = function(data, out) {
                    var w = out.width, h = out.height;
                    var bpp = UPNG2.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
                    var img = new Uint8Array(h * bpl);
                    var di = 0;
                    var starting_row = [0, 0, 4, 0, 2, 0, 1];
                    var starting_col = [0, 4, 0, 2, 0, 1, 0];
                    var row_increment = [8, 8, 8, 4, 4, 2, 2];
                    var col_increment = [8, 8, 4, 4, 2, 2, 1];
                    var pass = 0;
                    while (pass < 7) {
                      var ri = row_increment[pass], ci = col_increment[pass];
                      var sw = 0, sh = 0;
                      var cr = starting_row[pass];
                      while (cr < h) {
                        cr += ri;
                        sh++;
                      }
                      var cc = starting_col[pass];
                      while (cc < w) {
                        cc += ci;
                        sw++;
                      }
                      var bpll = Math.ceil(sw * bpp / 8);
                      UPNG2.decode._filterZero(data, out, di, sw, sh);
                      var y = 0, row = starting_row[pass];
                      while (row < h) {
                        var col = starting_col[pass];
                        var cdi = di + y * bpll << 3;
                        while (col < w) {
                          if (bpp == 1) {
                            var val = data[cdi >> 3];
                            val = val >> 7 - (cdi & 7) & 1;
                            img[row * bpl + (col >> 3)] |= val << 7 - ((col & 3) << 0);
                          }
                          if (bpp == 2) {
                            var val = data[cdi >> 3];
                            val = val >> 6 - (cdi & 7) & 3;
                            img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
                          }
                          if (bpp == 4) {
                            var val = data[cdi >> 3];
                            val = val >> 4 - (cdi & 7) & 15;
                            img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
                          }
                          if (bpp >= 8) {
                            var ii = row * bpl + col * cbpp;
                            for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];
                          }
                          cdi += bpp;
                          col += ci;
                        }
                        y++;
                        row += ri;
                      }
                      if (sw * sh != 0) di += sh * (1 + bpll);
                      pass = pass + 1;
                    }
                    return img;
                  };
                  UPNG2.decode._getBPP = function(out) {
                    var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
                    return noc * out.depth;
                  };
                  UPNG2.decode._filterZero = function(data, out, off, w, h) {
                    var bpp = UPNG2.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG2.decode._paeth;
                    bpp = Math.ceil(bpp / 8);
                    for (var y = 0; y < h; y++) {
                      var i = off + y * bpl, di = i + y + 1;
                      var type = data[di - 1];
                      if (type == 0) for (var x = 0; x < bpl; x++) data[i + x] = data[di + x];
                      else if (type == 1) {
                        for (var x = 0; x < bpp; x++) data[i + x] = data[di + x];
                        for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp] & 255;
                      } else if (y == 0) {
                        for (var x = 0; x < bpp; x++) data[i + x] = data[di + x];
                        if (type == 2) for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] & 255;
                        if (type == 3) for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpp] >> 1) & 255;
                        if (type == 4) for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] + paeth(data[i + x - bpp], 0, 0) & 255;
                      } else {
                        if (type == 2) {
                          for (var x = 0; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl] & 255;
                        }
                        if (type == 3) {
                          for (var x = 0; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >> 1) & 255;
                          for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >> 1) & 255;
                        }
                        if (type == 4) {
                          for (var x = 0; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0) & 255;
                          for (var x = bpp; x < bpl; x++) data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]) & 255;
                        }
                      }
                    }
                    return data;
                  };
                  UPNG2.decode._paeth = function(a, b, c) {
                    var p = a + b - c, pa = Math.abs(p - a), pb = Math.abs(p - b), pc = Math.abs(p - c);
                    if (pa <= pb && pa <= pc) return a;
                    else if (pb <= pc) return b;
                    return c;
                  };
                  UPNG2.decode._IHDR = function(data, offset, out) {
                    var bin = UPNG2._bin;
                    out.width = bin.readUint(data, offset);
                    offset += 4;
                    out.height = bin.readUint(data, offset);
                    offset += 4;
                    out.depth = data[offset];
                    offset++;
                    out.ctype = data[offset];
                    offset++;
                    out.compress = data[offset];
                    offset++;
                    out.filter = data[offset];
                    offset++;
                    out.interlace = data[offset];
                    offset++;
                  };
                  UPNG2._bin = {
                    nextZero: function(data, p) {
                      while (data[p] != 0) p++;
                      return p;
                    },
                    readUshort: function(buff, p) {
                      return buff[p] << 8 | buff[p + 1];
                    },
                    writeUshort: function(buff, p, n) {
                      buff[p] = n >> 8 & 255;
                      buff[p + 1] = n & 255;
                    },
                    readUint: function(buff, p) {
                      return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
                    },
                    writeUint: function(buff, p, n) {
                      buff[p] = n >> 24 & 255;
                      buff[p + 1] = n >> 16 & 255;
                      buff[p + 2] = n >> 8 & 255;
                      buff[p + 3] = n & 255;
                    },
                    readASCII: function(buff, p, l) {
                      var s = "";
                      for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);
                      return s;
                    },
                    writeASCII: function(data, p, s) {
                      for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);
                    },
                    readBytes: function(buff, p, l) {
                      var arr = [];
                      for (var i = 0; i < l; i++) arr.push(buff[p + i]);
                      return arr;
                    },
                    pad: function(n) {
                      return n.length < 2 ? "0" + n : n;
                    },
                    readUTF8: function(buff, p, l) {
                      var s = "", ns;
                      for (var i = 0; i < l; i++) s += "%" + UPNG2._bin.pad(buff[p + i].toString(16));
                      try {
                        ns = decodeURIComponent(s);
                      } catch (e) {
                        return UPNG2._bin.readASCII(buff, p, l);
                      }
                      return ns;
                    }
                  };
                  UPNG2._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
                    var w = Math.min(sw, tw), h = Math.min(sh, th);
                    var si = 0, ti = 0;
                    for (var y = 0; y < h; y++)
                      for (var x = 0; x < w; x++) {
                        if (xoff >= 0 && yoff >= 0) {
                          si = y * sw + x << 2;
                          ti = (yoff + y) * tw + xoff + x << 2;
                        } else {
                          si = (-yoff + y) * sw - xoff + x << 2;
                          ti = y * tw + x << 2;
                        }
                        if (mode == 0) {
                          tb[ti] = sb[si];
                          tb[ti + 1] = sb[si + 1];
                          tb[ti + 2] = sb[si + 2];
                          tb[ti + 3] = sb[si + 3];
                        } else if (mode == 1) {
                          var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
                          var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
                          var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
                          tb[ti + 3] = 255 * oa;
                          tb[ti + 0] = (fr + br * ifa) * ioa;
                          tb[ti + 1] = (fg + bg * ifa) * ioa;
                          tb[ti + 2] = (fb + bb * ifa) * ioa;
                        } else if (mode == 2) {
                          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
                          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
                          if (fa == ba && fr == br && fg == bg && fb == bb) {
                            tb[ti] = 0;
                            tb[ti + 1] = 0;
                            tb[ti + 2] = 0;
                            tb[ti + 3] = 0;
                          } else {
                            tb[ti] = fr;
                            tb[ti + 1] = fg;
                            tb[ti + 2] = fb;
                            tb[ti + 3] = fa;
                          }
                        } else if (mode == 3) {
                          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
                          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
                          if (fa == ba && fr == br && fg == bg && fb == bb) continue;
                          if (fa < 220 && ba > 20) return false;
                        }
                      }
                    return true;
                  };
                  UPNG2.encode = function(bufs, w, h, ps, dels, forbidPlte) {
                    if (ps == null) ps = 0;
                    if (forbidPlte == null) forbidPlte = false;
                    var data = new Uint8Array(bufs[0].byteLength * bufs.length + 100);
                    var wr = [137, 80, 78, 71, 13, 10, 26, 10];
                    for (var i = 0; i < 8; i++) data[i] = wr[i];
                    var offset = 8, bin = UPNG2._bin, crc = UPNG2.crc.crc, wUi = bin.writeUint, wUs = bin.writeUshort, wAs = bin.writeASCII;
                    var nimg = UPNG2.encode.compressPNG(bufs, w, h, ps, forbidPlte);
                    wUi(data, offset, 13);
                    offset += 4;
                    wAs(data, offset, "IHDR");
                    offset += 4;
                    wUi(data, offset, w);
                    offset += 4;
                    wUi(data, offset, h);
                    offset += 4;
                    data[offset] = nimg.depth;
                    offset++;
                    data[offset] = nimg.ctype;
                    offset++;
                    data[offset] = 0;
                    offset++;
                    data[offset] = 0;
                    offset++;
                    data[offset] = 0;
                    offset++;
                    wUi(data, offset, crc(data, offset - 17, 17));
                    offset += 4;
                    wUi(data, offset, 1);
                    offset += 4;
                    wAs(data, offset, "sRGB");
                    offset += 4;
                    data[offset] = 1;
                    offset++;
                    wUi(data, offset, crc(data, offset - 5, 5));
                    offset += 4;
                    var anim = bufs.length > 1;
                    if (anim) {
                      wUi(data, offset, 8);
                      offset += 4;
                      wAs(data, offset, "acTL");
                      offset += 4;
                      wUi(data, offset, bufs.length);
                      offset += 4;
                      wUi(data, offset, 0);
                      offset += 4;
                      wUi(data, offset, crc(data, offset - 12, 12));
                      offset += 4;
                    }
                    if (nimg.ctype == 3) {
                      var dl = nimg.plte.length;
                      wUi(data, offset, dl * 3);
                      offset += 4;
                      wAs(data, offset, "PLTE");
                      offset += 4;
                      for (var i = 0; i < dl; i++) {
                        var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >> 8 & 255, b = c >> 16 & 255;
                        data[offset + ti + 0] = r;
                        data[offset + ti + 1] = g;
                        data[offset + ti + 2] = b;
                      }
                      offset += dl * 3;
                      wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));
                      offset += 4;
                      if (nimg.gotAlpha) {
                        wUi(data, offset, dl);
                        offset += 4;
                        wAs(data, offset, "tRNS");
                        offset += 4;
                        for (var i = 0; i < dl; i++) data[offset + i] = nimg.plte[i] >> 24 & 255;
                        offset += dl;
                        wUi(data, offset, crc(data, offset - dl - 4, dl + 4));
                        offset += 4;
                      }
                    }
                    var fi = 0;
                    for (var j = 0; j < nimg.frames.length; j++) {
                      var fr = nimg.frames[j];
                      if (anim) {
                        wUi(data, offset, 26);
                        offset += 4;
                        wAs(data, offset, "fcTL");
                        offset += 4;
                        wUi(data, offset, fi++);
                        offset += 4;
                        wUi(data, offset, fr.rect.width);
                        offset += 4;
                        wUi(data, offset, fr.rect.height);
                        offset += 4;
                        wUi(data, offset, fr.rect.x);
                        offset += 4;
                        wUi(data, offset, fr.rect.y);
                        offset += 4;
                        wUs(data, offset, dels[j]);
                        offset += 2;
                        wUs(data, offset, 1e3);
                        offset += 2;
                        data[offset] = fr.dispose;
                        offset++;
                        data[offset] = fr.blend;
                        offset++;
                        wUi(data, offset, crc(data, offset - 30, 30));
                        offset += 4;
                      }
                      var imgd = fr.cimg, dl = imgd.length;
                      wUi(data, offset, dl + (j == 0 ? 0 : 4));
                      offset += 4;
                      var ioff = offset;
                      wAs(data, offset, j == 0 ? "IDAT" : "fdAT");
                      offset += 4;
                      if (j != 0) {
                        wUi(data, offset, fi++);
                        offset += 4;
                      }
                      for (var i = 0; i < dl; i++) data[offset + i] = imgd[i];
                      offset += dl;
                      wUi(data, offset, crc(data, ioff, offset - ioff));
                      offset += 4;
                    }
                    wUi(data, offset, 0);
                    offset += 4;
                    wAs(data, offset, "IEND");
                    offset += 4;
                    wUi(data, offset, crc(data, offset - 4, 4));
                    offset += 4;
                    return data.buffer.slice(0, offset);
                  };
                  UPNG2.encode.compressPNG = function(bufs, w, h, ps, forbidPlte) {
                    var out = UPNG2.encode.compress(bufs, w, h, ps, false, forbidPlte);
                    for (var i = 0; i < bufs.length; i++) {
                      var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height, bpl = frm.bpl, bpp = frm.bpp;
                      var fdata = new Uint8Array(nh * bpl + nh);
                      frm.cimg = UPNG2.encode._filterZero(frm.img, nh, bpp, bpl, fdata);
                    }
                    return out;
                  };
                  UPNG2.encode.compress = function(bufs, w, h, ps, forGIF, forbidPlte) {
                    if (forbidPlte == null) forbidPlte = false;
                    var ctype = 6, depth = 8, bpp = 4, alphaAnd = 255;
                    for (var j = 0; j < bufs.length; j++) {
                      var img = new Uint8Array(bufs[j]), ilen = img.length;
                      for (var i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];
                    }
                    var gotAlpha = alphaAnd != 255;
                    var cmap = {}, plte = [];
                    if (bufs.length != 0) {
                      cmap[0] = 0;
                      plte.push(0);
                      if (ps != 0) ps--;
                    }
                    if (ps != 0) {
                      var qres = UPNG2.quantize(bufs, ps, forGIF);
                      bufs = qres.bufs;
                      for (var i = 0; i < qres.plte.length; i++) {
                        var c = qres.plte[i].est.rgba;
                        if (cmap[c] == null) {
                          cmap[c] = plte.length;
                          plte.push(c);
                        }
                      }
                    } else {
                      for (var j = 0; j < bufs.length; j++) {
                        var img32 = new Uint32Array(bufs[j]), ilen = img32.length;
                        for (var i = 0; i < ilen; i++) {
                          var c = img32[i];
                          if ((i < w || c != img32[i - 1] && c != img32[i - w]) && cmap[c] == null) {
                            cmap[c] = plte.length;
                            plte.push(c);
                            if (plte.length >= 300) break;
                          }
                        }
                      }
                    }
                    var brute = gotAlpha ? forGIF : false;
                    var cc = plte.length;
                    if (cc <= 256 && forbidPlte == false) {
                      if (cc <= 2) depth = 1;
                      else if (cc <= 4) depth = 2;
                      else if (cc <= 16) depth = 4;
                      else depth = 8;
                      if (forGIF) depth = 8;
                      gotAlpha = true;
                    }
                    var frms = [];
                    for (var j = 0; j < bufs.length; j++) {
                      var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
                      var nx = 0, ny = 0, nw = w, nh = h, blend = 0;
                      if (j != 0 && !brute) {
                        var tlim = forGIF || j == 1 || frms[frms.length - 2].dispose == 2 ? 1 : 2, tstp = 0, tarea = 1e9;
                        for (var it = 0; it < tlim; it++) {
                          var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);
                          var mix = w, miy = h, max = -1, may = -1;
                          for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {
                            var i = y * w + x;
                            if (cimg32[i] != p32[i]) {
                              if (x < mix) mix = x;
                              if (x > max) max = x;
                              if (y < miy) miy = y;
                              if (y > may) may = y;
                            }
                          }
                          var sarea = max == -1 ? 1 : (max - mix + 1) * (may - miy + 1);
                          if (sarea < tarea) {
                            tarea = sarea;
                            tstp = it;
                            if (max == -1) {
                              nx = ny = 0;
                              nw = nh = 1;
                            } else {
                              nx = mix;
                              ny = miy;
                              nw = max - mix + 1;
                              nh = may - miy + 1;
                            }
                          }
                        }
                        var pimg = new Uint8Array(bufs[j - 1 - tstp]);
                        if (tstp == 1) frms[frms.length - 1].dispose = 2;
                        var nimg = new Uint8Array(nw * nh * 4), nimg32 = new Uint32Array(nimg.buffer);
                        UPNG2._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);
                        if (UPNG2._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3)) {
                          UPNG2._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 2);
                          blend = 1;
                        } else {
                          UPNG2._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);
                          blend = 0;
                        }
                        cimg = nimg;
                        cimg32 = new Uint32Array(cimg.buffer);
                      }
                      var bpl = 4 * nw;
                      if (cc <= 256 && forbidPlte == false) {
                        bpl = Math.ceil(depth * nw / 8);
                        var nimg = new Uint8Array(bpl * nh);
                        for (var y = 0; y < nh; y++) {
                          var i = y * bpl, ii = y * nw;
                          if (depth == 8) for (var x = 0; x < nw; x++) nimg[i + x] = cmap[cimg32[ii + x]];
                          else if (depth == 4) for (var x = 0; x < nw; x++) nimg[i + (x >> 1)] |= cmap[cimg32[ii + x]] << 4 - (x & 1) * 4;
                          else if (depth == 2) for (var x = 0; x < nw; x++) nimg[i + (x >> 2)] |= cmap[cimg32[ii + x]] << 6 - (x & 3) * 2;
                          else if (depth == 1) for (var x = 0; x < nw; x++) nimg[i + (x >> 3)] |= cmap[cimg32[ii + x]] << 7 - (x & 7) * 1;
                        }
                        cimg = nimg;
                        ctype = 3;
                        bpp = 1;
                      } else if (gotAlpha == false && bufs.length == 1) {
                        var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
                        for (var i = 0; i < area; i++) {
                          var ti = i * 3, qi = i * 4;
                          nimg[ti] = cimg[qi];
                          nimg[ti + 1] = cimg[qi + 1];
                          nimg[ti + 2] = cimg[qi + 2];
                        }
                        cimg = nimg;
                        ctype = 2;
                        bpp = 3;
                        bpl = 3 * nw;
                      }
                      frms.push({ rect: { x: nx, y: ny, width: nw, height: nh }, img: cimg, bpl, bpp, blend, dispose: brute ? 1 : 0 });
                    }
                    return { ctype, depth, plte, gotAlpha, frames: frms };
                  };
                  UPNG2.encode._filterZero = function(img, h, bpp, bpl, data) {
                    var fls = [];
                    for (var t = 0; t < 5; t++) {
                      if (h * bpl > 5e5 && (t == 2 || t == 3 || t == 4)) continue;
                      for (var y = 0; y < h; y++) UPNG2.encode._filterLine(data, img, y, bpl, bpp, t);
                      fls.push(pako2["deflate"](data));
                      if (bpp == 1) break;
                    }
                    var ti, tsize = 1e9;
                    for (var i = 0; i < fls.length; i++) if (fls[i].length < tsize) {
                      ti = i;
                      tsize = fls[i].length;
                    }
                    return fls[ti];
                  };
                  UPNG2.encode._filterLine = function(data, img, y, bpl, bpp, type) {
                    var i = y * bpl, di = i + y, paeth = UPNG2.decode._paeth;
                    data[di] = type;
                    di++;
                    if (type == 0) for (var x = 0; x < bpl; x++) data[di + x] = img[i + x];
                    else if (type == 1) {
                      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];
                      for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;
                    } else if (y == 0) {
                      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];
                      if (type == 2) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x];
                      if (type == 3) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;
                      if (type == 4) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;
                    } else {
                      if (type == 2) {
                        for (var x = 0; x < bpl; x++) data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;
                      }
                      if (type == 3) {
                        for (var x = 0; x < bpp; x++) data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;
                        for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;
                      }
                      if (type == 4) {
                        for (var x = 0; x < bpp; x++) data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;
                        for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;
                      }
                    }
                  };
                  UPNG2.crc = {
                    table: (function() {
                      var tab = new Uint32Array(256);
                      for (var n = 0; n < 256; n++) {
                        var c = n;
                        for (var k = 0; k < 8; k++) {
                          if (c & 1) c = 3988292384 ^ c >>> 1;
                          else c = c >>> 1;
                        }
                        tab[n] = c;
                      }
                      return tab;
                    })(),
                    update: function(c, buf, off, len) {
                      for (var i = 0; i < len; i++) c = UPNG2.crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;
                      return c;
                    },
                    crc: function(b, o, l) {
                      return UPNG2.crc.update(4294967295, b, o, l) ^ 4294967295;
                    }
                  };
                  UPNG2.quantize = function(bufs, ps, roundAlpha) {
                    var imgs = [], totl = 0;
                    for (var i = 0; i < bufs.length; i++) {
                      imgs.push(UPNG2.encode.alphaMul(new Uint8Array(bufs[i]), roundAlpha));
                      totl += bufs[i].byteLength;
                    }
                    var nimg = new Uint8Array(totl), nimg32 = new Uint32Array(nimg.buffer), noff = 0;
                    for (var i = 0; i < imgs.length; i++) {
                      var img = imgs[i], il = img.length;
                      for (var j = 0; j < il; j++) nimg[noff + j] = img[j];
                      noff += il;
                    }
                    var root = { i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null };
                    root.bst = UPNG2.quantize.stats(nimg, root.i0, root.i1);
                    root.est = UPNG2.quantize.estats(root.bst);
                    var leafs = [root];
                    while (leafs.length < ps) {
                      var maxL = 0, mi = 0;
                      for (var i = 0; i < leafs.length; i++) if (leafs[i].est.L > maxL) {
                        maxL = leafs[i].est.L;
                        mi = i;
                      }
                      if (maxL < 1e-3) break;
                      var node = leafs[mi];
                      var s0 = UPNG2.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
                      var ln = { i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null };
                      ln.bst = UPNG2.quantize.stats(nimg, ln.i0, ln.i1);
                      ln.est = UPNG2.quantize.estats(ln.bst);
                      var rn = { i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null };
                      rn.bst = { R: [], m: [], N: node.bst.N - ln.bst.N };
                      for (var i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];
                      for (var i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];
                      rn.est = UPNG2.quantize.estats(rn.bst);
                      node.left = ln;
                      node.right = rn;
                      leafs[mi] = ln;
                      leafs.push(rn);
                    }
                    leafs.sort(function(a2, b2) {
                      return b2.bst.N - a2.bst.N;
                    });
                    for (var ii = 0; ii < imgs.length; ii++) {
                      var planeDst = UPNG2.quantize.planeDst;
                      var sb = new Uint8Array(imgs[ii].buffer), tb = new Uint32Array(imgs[ii].buffer), len = sb.length;
                      var stack = [], si = 0;
                      for (var i = 0; i < len; i += 4) {
                        var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);
                        var nd = root;
                        while (nd.left) nd = planeDst(nd.est, r, g, b, a) <= 0 ? nd.left : nd.right;
                        tb[i >> 2] = nd.est.rgba;
                      }
                      imgs[ii] = tb.buffer;
                    }
                    return { bufs: imgs, plte: leafs };
                  };
                  UPNG2.quantize.getNearest = function(nd, r, g, b, a) {
                    if (nd.left == null) {
                      nd.tdst = UPNG2.quantize.dist(nd.est.q, r, g, b, a);
                      return nd;
                    }
                    var planeDst = UPNG2.quantize.planeDst(nd.est, r, g, b, a);
                    var node0 = nd.left, node1 = nd.right;
                    if (planeDst > 0) {
                      node0 = nd.right;
                      node1 = nd.left;
                    }
                    var ln = UPNG2.quantize.getNearest(node0, r, g, b, a);
                    if (ln.tdst <= planeDst * planeDst) return ln;
                    var rn = UPNG2.quantize.getNearest(node1, r, g, b, a);
                    return rn.tdst < ln.tdst ? rn : ln;
                  };
                  UPNG2.quantize.planeDst = function(est, r, g, b, a) {
                    var e = est.e;
                    return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;
                  };
                  UPNG2.quantize.dist = function(q, r, g, b, a) {
                    var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];
                    return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
                  };
                  UPNG2.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
                    var vecDot = UPNG2.quantize.vecDot;
                    i1 -= 4;
                    var shfs = 0;
                    while (i0 < i1) {
                      while (vecDot(nimg, i0, e) <= eMq) i0 += 4;
                      while (vecDot(nimg, i1, e) > eMq) i1 -= 4;
                      if (i0 >= i1) break;
                      var t = nimg32[i0 >> 2];
                      nimg32[i0 >> 2] = nimg32[i1 >> 2];
                      nimg32[i1 >> 2] = t;
                      i0 += 4;
                      i1 -= 4;
                    }
                    while (vecDot(nimg, i0, e) > eMq) i0 -= 4;
                    return i0 + 4;
                  };
                  UPNG2.quantize.vecDot = function(nimg, i, e) {
                    return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];
                  };
                  UPNG2.quantize.stats = function(nimg, i0, i1) {
                    var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    var m = [0, 0, 0, 0];
                    var N = i1 - i0 >> 2;
                    for (var i = i0; i < i1; i += 4) {
                      var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);
                      m[0] += r;
                      m[1] += g;
                      m[2] += b;
                      m[3] += a;
                      R[0] += r * r;
                      R[1] += r * g;
                      R[2] += r * b;
                      R[3] += r * a;
                      R[5] += g * g;
                      R[6] += g * b;
                      R[7] += g * a;
                      R[10] += b * b;
                      R[11] += b * a;
                      R[15] += a * a;
                    }
                    R[4] = R[1];
                    R[8] = R[2];
                    R[12] = R[3];
                    R[9] = R[6];
                    R[13] = R[7];
                    R[14] = R[11];
                    return { R, m, N };
                  };
                  UPNG2.quantize.estats = function(stats) {
                    var R = stats.R, m = stats.m, N = stats.N;
                    var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;
                    var Rj = [
                      R[0] - m0 * m0 * iN,
                      R[1] - m0 * m1 * iN,
                      R[2] - m0 * m2 * iN,
                      R[3] - m0 * m3 * iN,
                      R[4] - m1 * m0 * iN,
                      R[5] - m1 * m1 * iN,
                      R[6] - m1 * m2 * iN,
                      R[7] - m1 * m3 * iN,
                      R[8] - m2 * m0 * iN,
                      R[9] - m2 * m1 * iN,
                      R[10] - m2 * m2 * iN,
                      R[11] - m2 * m3 * iN,
                      R[12] - m3 * m0 * iN,
                      R[13] - m3 * m1 * iN,
                      R[14] - m3 * m2 * iN,
                      R[15] - m3 * m3 * iN
                    ];
                    var A = Rj, M = UPNG2.M4;
                    var b = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
                    if (N != 0)
                      for (var i = 0; i < 10; i++) {
                        b = M.multVec(A, b);
                        tmi = Math.sqrt(M.dot(b, b));
                        b = M.sml(1 / tmi, b);
                        if (Math.abs(tmi - mi) < 1e-9) break;
                        mi = tmi;
                      }
                    var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];
                    var eMq255 = M.dot(M.sml(255, q), b);
                    var ia = q[3] < 1e-3 ? 0 : 1 / q[3];
                    return {
                      Cov: Rj,
                      q,
                      e: b,
                      L: mi,
                      eMq255,
                      eMq: M.dot(b, q),
                      rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2] * ia) << 16 | Math.round(255 * q[1] * ia) << 8 | Math.round(255 * q[0] * ia) << 0) >>> 0
                    };
                  };
                  UPNG2.M4 = {
                    multVec: function(m, v) {
                      return [
                        m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],
                        m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],
                        m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],
                        m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]
                      ];
                    },
                    dot: function(x, y) {
                      return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
                    },
                    sml: function(a, y) {
                      return [a * y[0], a * y[1], a * y[2], a * y[3]];
                    }
                  };
                  UPNG2.encode.alphaMul = function(img, roundA) {
                    var nimg = new Uint8Array(img.length), area = img.length >> 2;
                    for (var i = 0; i < area; i++) {
                      var qi = i << 2, ia = img[qi + 3];
                      if (roundA) ia = ia < 128 ? 0 : 255;
                      var a = ia * (1 / 255);
                      nimg[qi + 0] = img[qi + 0] * a;
                      nimg[qi + 1] = img[qi + 1] * a;
                      nimg[qi + 2] = img[qi + 2] * a;
                      nimg[qi + 3] = ia;
                    }
                    return nimg;
                  };
                })(UPNG, pako);
              })();
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/index.js"(module2, __unused_webpack_exports, __webpack_require__2) {
              var assign = __webpack_require__2(
                /*! ./lib/utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              ).assign;
              var deflate = __webpack_require__2(
                /*! ./lib/deflate */
                "./node_modules/upng-js/node_modules/pako/lib/deflate.js"
              );
              var inflate = __webpack_require__2(
                /*! ./lib/inflate */
                "./node_modules/upng-js/node_modules/pako/lib/inflate.js"
              );
              var constants = __webpack_require__2(
                /*! ./lib/zlib/constants */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
              );
              var pako = {};
              assign(pako, deflate, inflate, constants);
              module2.exports = pako;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/deflate.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var zlib_deflate = __webpack_require__2(
                /*! ./zlib/deflate */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js"
              );
              var utils = __webpack_require__2(
                /*! ./utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var strings = __webpack_require__2(
                /*! ./utils/strings */
                "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
              );
              var msg = __webpack_require__2(
                /*! ./zlib/messages */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
              );
              var ZStream = __webpack_require__2(
                /*! ./zlib/zstream */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
              );
              var toString = Object.prototype.toString;
              var Z_NO_FLUSH = 0;
              var Z_FINISH = 4;
              var Z_OK = 0;
              var Z_STREAM_END = 1;
              var Z_SYNC_FLUSH = 2;
              var Z_DEFAULT_COMPRESSION = -1;
              var Z_DEFAULT_STRATEGY = 0;
              var Z_DEFLATED = 8;
              function Deflate(options) {
                if (!(this instanceof Deflate)) return new Deflate(options);
                this.options = utils.assign({
                  level: Z_DEFAULT_COMPRESSION,
                  method: Z_DEFLATED,
                  chunkSize: 16384,
                  windowBits: 15,
                  memLevel: 8,
                  strategy: Z_DEFAULT_STRATEGY,
                  to: ""
                }, options || {});
                var opt = this.options;
                if (opt.raw && opt.windowBits > 0) {
                  opt.windowBits = -opt.windowBits;
                } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
                  opt.windowBits += 16;
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new ZStream();
                this.strm.avail_out = 0;
                var status = zlib_deflate.deflateInit2(
                  this.strm,
                  opt.level,
                  opt.method,
                  opt.windowBits,
                  opt.memLevel,
                  opt.strategy
                );
                if (status !== Z_OK) {
                  throw new Error(msg[status]);
                }
                if (opt.header) {
                  zlib_deflate.deflateSetHeader(this.strm, opt.header);
                }
                if (opt.dictionary) {
                  var dict;
                  if (typeof opt.dictionary === "string") {
                    dict = strings.string2buf(opt.dictionary);
                  } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                    dict = new Uint8Array(opt.dictionary);
                  } else {
                    dict = opt.dictionary;
                  }
                  status = zlib_deflate.deflateSetDictionary(this.strm, dict);
                  if (status !== Z_OK) {
                    throw new Error(msg[status]);
                  }
                  this._dict_set = true;
                }
              }
              Deflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var status, _mode;
                if (this.ended) {
                  return false;
                }
                _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
                if (typeof data === "string") {
                  strm.input = strings.string2buf(data);
                } else if (toString.call(data) === "[object ArrayBuffer]") {
                  strm.input = new Uint8Array(data);
                } else {
                  strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                do {
                  if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                  }
                  status = zlib_deflate.deflate(strm, _mode);
                  if (status !== Z_STREAM_END && status !== Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                  }
                  if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
                    if (this.options.to === "string") {
                      this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                    } else {
                      this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                    }
                  }
                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
                if (_mode === Z_FINISH) {
                  status = zlib_deflate.deflateEnd(this.strm);
                  this.onEnd(status);
                  this.ended = true;
                  return status === Z_OK;
                }
                if (_mode === Z_SYNC_FLUSH) {
                  this.onEnd(Z_OK);
                  strm.avail_out = 0;
                  return true;
                }
                return true;
              };
              Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
              };
              Deflate.prototype.onEnd = function(status) {
                if (status === Z_OK) {
                  if (this.options.to === "string") {
                    this.result = this.chunks.join("");
                  } else {
                    this.result = utils.flattenChunks(this.chunks);
                  }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
              };
              function deflate(input, options) {
                var deflator = new Deflate(options);
                deflator.push(input, true);
                if (deflator.err) {
                  throw deflator.msg || msg[deflator.err];
                }
                return deflator.result;
              }
              function deflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return deflate(input, options);
              }
              function gzip(input, options) {
                options = options || {};
                options.gzip = true;
                return deflate(input, options);
              }
              exports2.Deflate = Deflate;
              exports2.deflate = deflate;
              exports2.deflateRaw = deflateRaw;
              exports2.gzip = gzip;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/inflate.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var zlib_inflate = __webpack_require__2(
                /*! ./zlib/inflate */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js"
              );
              var utils = __webpack_require__2(
                /*! ./utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var strings = __webpack_require__2(
                /*! ./utils/strings */
                "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
              );
              var c = __webpack_require__2(
                /*! ./zlib/constants */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
              );
              var msg = __webpack_require__2(
                /*! ./zlib/messages */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
              );
              var ZStream = __webpack_require__2(
                /*! ./zlib/zstream */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
              );
              var GZheader = __webpack_require__2(
                /*! ./zlib/gzheader */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js"
              );
              var toString = Object.prototype.toString;
              function Inflate(options) {
                if (!(this instanceof Inflate)) return new Inflate(options);
                this.options = utils.assign({
                  chunkSize: 16384,
                  windowBits: 0,
                  to: ""
                }, options || {});
                var opt = this.options;
                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
                  opt.windowBits = -opt.windowBits;
                  if (opt.windowBits === 0) {
                    opt.windowBits = -15;
                  }
                }
                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
                  opt.windowBits += 32;
                }
                if (opt.windowBits > 15 && opt.windowBits < 48) {
                  if ((opt.windowBits & 15) === 0) {
                    opt.windowBits |= 15;
                  }
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new ZStream();
                this.strm.avail_out = 0;
                var status = zlib_inflate.inflateInit2(
                  this.strm,
                  opt.windowBits
                );
                if (status !== c.Z_OK) {
                  throw new Error(msg[status]);
                }
                this.header = new GZheader();
                zlib_inflate.inflateGetHeader(this.strm, this.header);
                if (opt.dictionary) {
                  if (typeof opt.dictionary === "string") {
                    opt.dictionary = strings.string2buf(opt.dictionary);
                  } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                    opt.dictionary = new Uint8Array(opt.dictionary);
                  }
                  if (opt.raw) {
                    status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
                    if (status !== c.Z_OK) {
                      throw new Error(msg[status]);
                    }
                  }
                }
              }
              Inflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var dictionary = this.options.dictionary;
                var status, _mode;
                var next_out_utf8, tail, utf8str;
                var allowBufError = false;
                if (this.ended) {
                  return false;
                }
                _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
                if (typeof data === "string") {
                  strm.input = strings.binstring2buf(data);
                } else if (toString.call(data) === "[object ArrayBuffer]") {
                  strm.input = new Uint8Array(data);
                } else {
                  strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                do {
                  if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                  }
                  status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
                  if (status === c.Z_NEED_DICT && dictionary) {
                    status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
                  }
                  if (status === c.Z_BUF_ERROR && allowBufError === true) {
                    status = c.Z_OK;
                    allowBufError = false;
                  }
                  if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                  }
                  if (strm.next_out) {
                    if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                      if (this.options.to === "string") {
                        next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        tail = strm.next_out - next_out_utf8;
                        utf8str = strings.buf2string(strm.output, next_out_utf8);
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) {
                          utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                        }
                        this.onData(utf8str);
                      } else {
                        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                      }
                    }
                  }
                  if (strm.avail_in === 0 && strm.avail_out === 0) {
                    allowBufError = true;
                  }
                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
                if (status === c.Z_STREAM_END) {
                  _mode = c.Z_FINISH;
                }
                if (_mode === c.Z_FINISH) {
                  status = zlib_inflate.inflateEnd(this.strm);
                  this.onEnd(status);
                  this.ended = true;
                  return status === c.Z_OK;
                }
                if (_mode === c.Z_SYNC_FLUSH) {
                  this.onEnd(c.Z_OK);
                  strm.avail_out = 0;
                  return true;
                }
                return true;
              };
              Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
              };
              Inflate.prototype.onEnd = function(status) {
                if (status === c.Z_OK) {
                  if (this.options.to === "string") {
                    this.result = this.chunks.join("");
                  } else {
                    this.result = utils.flattenChunks(this.chunks);
                  }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
              };
              function inflate(input, options) {
                var inflator = new Inflate(options);
                inflator.push(input, true);
                if (inflator.err) {
                  throw inflator.msg || msg[inflator.err];
                }
                return inflator.result;
              }
              function inflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return inflate(input, options);
              }
              exports2.Inflate = Inflate;
              exports2.inflate = inflate;
              exports2.inflateRaw = inflateRaw;
              exports2.ungzip = inflate;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"(__unused_webpack_module2, exports2) {
              var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
              function _has(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
              }
              exports2.assign = function(obj) {
                var sources = Array.prototype.slice.call(arguments, 1);
                while (sources.length) {
                  var source = sources.shift();
                  if (!source) {
                    continue;
                  }
                  if (typeof source !== "object") {
                    throw new TypeError(source + "must be non-object");
                  }
                  for (var p in source) {
                    if (_has(source, p)) {
                      obj[p] = source[p];
                    }
                  }
                }
                return obj;
              };
              exports2.shrinkBuf = function(buf, size) {
                if (buf.length === size) {
                  return buf;
                }
                if (buf.subarray) {
                  return buf.subarray(0, size);
                }
                buf.length = size;
                return buf;
              };
              var fnTyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                  if (src.subarray && dest.subarray) {
                    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                    return;
                  }
                  for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                  }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                  var i, l, len, pos, chunk, result;
                  len = 0;
                  for (i = 0, l = chunks.length; i < l; i++) {
                    len += chunks[i].length;
                  }
                  result = new Uint8Array(len);
                  pos = 0;
                  for (i = 0, l = chunks.length; i < l; i++) {
                    chunk = chunks[i];
                    result.set(chunk, pos);
                    pos += chunk.length;
                  }
                  return result;
                }
              };
              var fnUntyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                  for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                  }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                  return [].concat.apply([], chunks);
                }
              };
              exports2.setTyped = function(on) {
                if (on) {
                  exports2.Buf8 = Uint8Array;
                  exports2.Buf16 = Uint16Array;
                  exports2.Buf32 = Int32Array;
                  exports2.assign(exports2, fnTyped);
                } else {
                  exports2.Buf8 = Array;
                  exports2.Buf16 = Array;
                  exports2.Buf32 = Array;
                  exports2.assign(exports2, fnUntyped);
                }
              };
              exports2.setTyped(TYPED_OK);
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var utils = __webpack_require__2(
                /*! ./common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var STR_APPLY_OK = true;
              var STR_APPLY_UIA_OK = true;
              try {
                String.fromCharCode.apply(null, [0]);
              } catch (__) {
                STR_APPLY_OK = false;
              }
              try {
                String.fromCharCode.apply(null, new Uint8Array(1));
              } catch (__) {
                STR_APPLY_UIA_OK = false;
              }
              var _utf8len = new utils.Buf8(256);
              for (var q = 0; q < 256; q++) {
                _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
              }
              _utf8len[254] = _utf8len[254] = 1;
              exports2.string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                  c = str.charCodeAt(m_pos);
                  if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                      c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                      m_pos++;
                    }
                  }
                  buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                }
                buf = new utils.Buf8(buf_len);
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                  c = str.charCodeAt(m_pos);
                  if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                      c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                      m_pos++;
                    }
                  }
                  if (c < 128) {
                    buf[i++] = c;
                  } else if (c < 2048) {
                    buf[i++] = 192 | c >>> 6;
                    buf[i++] = 128 | c & 63;
                  } else if (c < 65536) {
                    buf[i++] = 224 | c >>> 12;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                  } else {
                    buf[i++] = 240 | c >>> 18;
                    buf[i++] = 128 | c >>> 12 & 63;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                  }
                }
                return buf;
              };
              function buf2binstring(buf, len) {
                if (len < 65534) {
                  if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                    return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                  }
                }
                var result = "";
                for (var i = 0; i < len; i++) {
                  result += String.fromCharCode(buf[i]);
                }
                return result;
              }
              exports2.buf2binstring = function(buf) {
                return buf2binstring(buf, buf.length);
              };
              exports2.binstring2buf = function(str) {
                var buf = new utils.Buf8(str.length);
                for (var i = 0, len = buf.length; i < len; i++) {
                  buf[i] = str.charCodeAt(i);
                }
                return buf;
              };
              exports2.buf2string = function(buf, max) {
                var i, out, c, c_len;
                var len = max || buf.length;
                var utf16buf = new Array(len * 2);
                for (out = 0, i = 0; i < len; ) {
                  c = buf[i++];
                  if (c < 128) {
                    utf16buf[out++] = c;
                    continue;
                  }
                  c_len = _utf8len[c];
                  if (c_len > 4) {
                    utf16buf[out++] = 65533;
                    i += c_len - 1;
                    continue;
                  }
                  c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
                  while (c_len > 1 && i < len) {
                    c = c << 6 | buf[i++] & 63;
                    c_len--;
                  }
                  if (c_len > 1) {
                    utf16buf[out++] = 65533;
                    continue;
                  }
                  if (c < 65536) {
                    utf16buf[out++] = c;
                  } else {
                    c -= 65536;
                    utf16buf[out++] = 55296 | c >> 10 & 1023;
                    utf16buf[out++] = 56320 | c & 1023;
                  }
                }
                return buf2binstring(utf16buf, out);
              };
              exports2.utf8border = function(buf, max) {
                var pos;
                max = max || buf.length;
                if (max > buf.length) {
                  max = buf.length;
                }
                pos = max - 1;
                while (pos >= 0 && (buf[pos] & 192) === 128) {
                  pos--;
                }
                if (pos < 0) {
                  return max;
                }
                if (pos === 0) {
                  return max;
                }
                return pos + _utf8len[buf[pos]] > max ? pos : max;
              };
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"(module2) {
              function adler32(adler, buf, len, pos) {
                var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
                while (len !== 0) {
                  n = len > 2e3 ? 2e3 : len;
                  len -= n;
                  do {
                    s1 = s1 + buf[pos++] | 0;
                    s2 = s2 + s1 | 0;
                  } while (--n);
                  s1 %= 65521;
                  s2 %= 65521;
                }
                return s1 | s2 << 16 | 0;
              }
              module2.exports = adler32;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"(module2) {
              module2.exports = {
                /* Allowed flush values; see deflate() and inflate() below for details */
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                /* Return codes for the compression/decompression functions. Negative values
                * are errors, positive values are used for special but normal events.
                */
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                //Z_MEM_ERROR:     -4,
                Z_BUF_ERROR: -5,
                //Z_VERSION_ERROR: -6,
                /* compression levels */
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                /* Possible values of the data_type field (though see inflate()) */
                Z_BINARY: 0,
                Z_TEXT: 1,
                //Z_ASCII:                1, // = Z_TEXT (deprecated)
                Z_UNKNOWN: 2,
                /* The deflate compression method */
                Z_DEFLATED: 8
                //Z_NULL:                 null // Use -1 or null inline, depending on var type
              };
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"(module2) {
              function makeTable() {
                var c, table = [];
                for (var n = 0; n < 256; n++) {
                  c = n;
                  for (var k = 0; k < 8; k++) {
                    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                  }
                  table[n] = c;
                }
                return table;
              }
              var crcTable = makeTable();
              function crc32(crc, buf, len, pos) {
                var t = crcTable, end = pos + len;
                crc ^= -1;
                for (var i = pos; i < end; i++) {
                  crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
                }
                return crc ^ -1;
              }
              module2.exports = crc32;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var utils = __webpack_require__2(
                /*! ../utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var trees = __webpack_require__2(
                /*! ./trees */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js"
              );
              var adler32 = __webpack_require__2(
                /*! ./adler32 */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
              );
              var crc32 = __webpack_require__2(
                /*! ./crc32 */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
              );
              var msg = __webpack_require__2(
                /*! ./messages */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
              );
              var Z_NO_FLUSH = 0;
              var Z_PARTIAL_FLUSH = 1;
              var Z_FULL_FLUSH = 3;
              var Z_FINISH = 4;
              var Z_BLOCK = 5;
              var Z_OK = 0;
              var Z_STREAM_END = 1;
              var Z_STREAM_ERROR = -2;
              var Z_DATA_ERROR = -3;
              var Z_BUF_ERROR = -5;
              var Z_DEFAULT_COMPRESSION = -1;
              var Z_FILTERED = 1;
              var Z_HUFFMAN_ONLY = 2;
              var Z_RLE = 3;
              var Z_FIXED = 4;
              var Z_DEFAULT_STRATEGY = 0;
              var Z_UNKNOWN = 2;
              var Z_DEFLATED = 8;
              var MAX_MEM_LEVEL = 9;
              var MAX_WBITS = 15;
              var DEF_MEM_LEVEL = 8;
              var LENGTH_CODES = 29;
              var LITERALS = 256;
              var L_CODES = LITERALS + 1 + LENGTH_CODES;
              var D_CODES = 30;
              var BL_CODES = 19;
              var HEAP_SIZE = 2 * L_CODES + 1;
              var MAX_BITS = 15;
              var MIN_MATCH = 3;
              var MAX_MATCH = 258;
              var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
              var PRESET_DICT = 32;
              var INIT_STATE = 42;
              var EXTRA_STATE = 69;
              var NAME_STATE = 73;
              var COMMENT_STATE = 91;
              var HCRC_STATE = 103;
              var BUSY_STATE = 113;
              var FINISH_STATE = 666;
              var BS_NEED_MORE = 1;
              var BS_BLOCK_DONE = 2;
              var BS_FINISH_STARTED = 3;
              var BS_FINISH_DONE = 4;
              var OS_CODE = 3;
              function err(strm, errorCode) {
                strm.msg = msg[errorCode];
                return errorCode;
              }
              function rank(f) {
                return (f << 1) - (f > 4 ? 9 : 0);
              }
              function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              }
              function flush_pending(strm) {
                var s = strm.state;
                var len = s.pending;
                if (len > strm.avail_out) {
                  len = strm.avail_out;
                }
                if (len === 0) {
                  return;
                }
                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                strm.next_out += len;
                s.pending_out += len;
                strm.total_out += len;
                strm.avail_out -= len;
                s.pending -= len;
                if (s.pending === 0) {
                  s.pending_out = 0;
                }
              }
              function flush_block_only(s, last) {
                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
                s.block_start = s.strstart;
                flush_pending(s.strm);
              }
              function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
              }
              function putShortMSB(s, b) {
                s.pending_buf[s.pending++] = b >>> 8 & 255;
                s.pending_buf[s.pending++] = b & 255;
              }
              function read_buf(strm, buf, start, size) {
                var len = strm.avail_in;
                if (len > size) {
                  len = size;
                }
                if (len === 0) {
                  return 0;
                }
                strm.avail_in -= len;
                utils.arraySet(buf, strm.input, strm.next_in, len, start);
                if (strm.state.wrap === 1) {
                  strm.adler = adler32(strm.adler, buf, len, start);
                } else if (strm.state.wrap === 2) {
                  strm.adler = crc32(strm.adler, buf, len, start);
                }
                strm.next_in += len;
                strm.total_in += len;
                return len;
              }
              function longest_match(s, cur_match) {
                var chain_length = s.max_chain_length;
                var scan = s.strstart;
                var match;
                var len;
                var best_len = s.prev_length;
                var nice_match = s.nice_match;
                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                var _win = s.window;
                var wmask = s.w_mask;
                var prev = s.prev;
                var strend = s.strstart + MAX_MATCH;
                var scan_end1 = _win[scan + best_len - 1];
                var scan_end = _win[scan + best_len];
                if (s.prev_length >= s.good_match) {
                  chain_length >>= 2;
                }
                if (nice_match > s.lookahead) {
                  nice_match = s.lookahead;
                }
                do {
                  match = cur_match;
                  if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                    continue;
                  }
                  scan += 2;
                  match++;
                  do {
                  } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                  len = MAX_MATCH - (strend - scan);
                  scan = strend - MAX_MATCH;
                  if (len > best_len) {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match) {
                      break;
                    }
                    scan_end1 = _win[scan + best_len - 1];
                    scan_end = _win[scan + best_len];
                  }
                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                if (best_len <= s.lookahead) {
                  return best_len;
                }
                return s.lookahead;
              }
              function fill_window(s) {
                var _w_size = s.w_size;
                var p, n, m, more, str;
                do {
                  more = s.window_size - s.lookahead - s.strstart;
                  if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                    utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                    s.match_start -= _w_size;
                    s.strstart -= _w_size;
                    s.block_start -= _w_size;
                    n = s.hash_size;
                    p = n;
                    do {
                      m = s.head[--p];
                      s.head[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    n = _w_size;
                    p = n;
                    do {
                      m = s.prev[--p];
                      s.prev[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    more += _w_size;
                  }
                  if (s.strm.avail_in === 0) {
                    break;
                  }
                  n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                  s.lookahead += n;
                  if (s.lookahead + s.insert >= MIN_MATCH) {
                    str = s.strstart - s.insert;
                    s.ins_h = s.window[str];
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                    while (s.insert) {
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                      s.prev[str & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = str;
                      str++;
                      s.insert--;
                      if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                      }
                    }
                  }
                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
              }
              function deflate_stored(s, flush) {
                var max_block_size = 65535;
                if (max_block_size > s.pending_buf_size - 5) {
                  max_block_size = s.pending_buf_size - 5;
                }
                for (; ; ) {
                  if (s.lookahead <= 1) {
                    fill_window(s);
                    if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  s.strstart += s.lookahead;
                  s.lookahead = 0;
                  var max_start = s.block_start + max_block_size;
                  if (s.strstart === 0 || s.strstart >= max_start) {
                    s.lookahead = s.strstart - max_start;
                    s.strstart = max_start;
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.strstart > s.block_start) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_NEED_MORE;
              }
              function deflate_fast(s, flush) {
                var hash_head;
                var bflush;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                      s.match_length--;
                      do {
                        s.strstart++;
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      } while (--s.match_length !== 0);
                      s.strstart++;
                    } else {
                      s.strstart += s.match_length;
                      s.match_length = 0;
                      s.ins_h = s.window[s.strstart];
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                    }
                  } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_slow(s, flush) {
                var hash_head;
                var bflush;
                var max_insert;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  s.prev_length = s.match_length;
                  s.prev_match = s.match_start;
                  s.match_length = MIN_MATCH - 1;
                  if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                    if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                      s.match_length = MIN_MATCH - 1;
                    }
                  }
                  if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    max_insert = s.strstart + s.lookahead - MIN_MATCH;
                    bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do {
                      if (++s.strstart <= max_insert) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      }
                    } while (--s.prev_length !== 0);
                    s.match_available = 0;
                    s.match_length = MIN_MATCH - 1;
                    s.strstart++;
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  } else if (s.match_available) {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                    if (bflush) {
                      flush_block_only(s, false);
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  } else {
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                  }
                }
                if (s.match_available) {
                  bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                  s.match_available = 0;
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_rle(s, flush) {
                var bflush;
                var prev;
                var scan, strend;
                var _win = s.window;
                for (; ; ) {
                  if (s.lookahead <= MAX_MATCH) {
                    fill_window(s);
                    if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  s.match_length = 0;
                  if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                    scan = s.strstart - 1;
                    prev = _win[scan];
                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                      strend = s.strstart + MAX_MATCH;
                      do {
                      } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                      s.match_length = MAX_MATCH - (strend - scan);
                      if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                      }
                    }
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                  } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_huff(s, flush) {
                var bflush;
                for (; ; ) {
                  if (s.lookahead === 0) {
                    fill_window(s);
                    if (s.lookahead === 0) {
                      if (flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      break;
                    }
                  }
                  s.match_length = 0;
                  bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                  s.lookahead--;
                  s.strstart++;
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func;
              }
              var configuration_table;
              configuration_table = [
                /*      good lazy nice chain */
                new Config(0, 0, 0, 0, deflate_stored),
                /* 0 store only */
                new Config(4, 4, 8, 4, deflate_fast),
                /* 1 max speed, no lazy matches */
                new Config(4, 5, 16, 8, deflate_fast),
                /* 2 */
                new Config(4, 6, 32, 32, deflate_fast),
                /* 3 */
                new Config(4, 4, 16, 16, deflate_slow),
                /* 4 lazy matches */
                new Config(8, 16, 32, 32, deflate_slow),
                /* 5 */
                new Config(8, 16, 128, 128, deflate_slow),
                /* 6 */
                new Config(8, 32, 128, 256, deflate_slow),
                /* 7 */
                new Config(32, 128, 258, 1024, deflate_slow),
                /* 8 */
                new Config(32, 258, 258, 4096, deflate_slow)
                /* 9 max compression */
              ];
              function lm_init(s) {
                s.window_size = 2 * s.w_size;
                zero(s.head);
                s.max_lazy_match = configuration_table[s.level].max_lazy;
                s.good_match = configuration_table[s.level].good_length;
                s.nice_match = configuration_table[s.level].nice_length;
                s.max_chain_length = configuration_table[s.level].max_chain;
                s.strstart = 0;
                s.block_start = 0;
                s.lookahead = 0;
                s.insert = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                s.ins_h = 0;
              }
              function DeflateState() {
                this.strm = null;
                this.status = 0;
                this.pending_buf = null;
                this.pending_buf_size = 0;
                this.pending_out = 0;
                this.pending = 0;
                this.wrap = 0;
                this.gzhead = null;
                this.gzindex = 0;
                this.method = Z_DEFLATED;
                this.last_flush = -1;
                this.w_size = 0;
                this.w_bits = 0;
                this.w_mask = 0;
                this.window = null;
                this.window_size = 0;
                this.prev = null;
                this.head = null;
                this.ins_h = 0;
                this.hash_size = 0;
                this.hash_bits = 0;
                this.hash_mask = 0;
                this.hash_shift = 0;
                this.block_start = 0;
                this.match_length = 0;
                this.prev_match = 0;
                this.match_available = 0;
                this.strstart = 0;
                this.match_start = 0;
                this.lookahead = 0;
                this.prev_length = 0;
                this.max_chain_length = 0;
                this.max_lazy_match = 0;
                this.level = 0;
                this.strategy = 0;
                this.good_match = 0;
                this.nice_match = 0;
                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                zero(this.dyn_ltree);
                zero(this.dyn_dtree);
                zero(this.bl_tree);
                this.l_desc = null;
                this.d_desc = null;
                this.bl_desc = null;
                this.bl_count = new utils.Buf16(MAX_BITS + 1);
                this.heap = new utils.Buf16(2 * L_CODES + 1);
                zero(this.heap);
                this.heap_len = 0;
                this.heap_max = 0;
                this.depth = new utils.Buf16(2 * L_CODES + 1);
                zero(this.depth);
                this.l_buf = 0;
                this.lit_bufsize = 0;
                this.last_lit = 0;
                this.d_buf = 0;
                this.opt_len = 0;
                this.static_len = 0;
                this.matches = 0;
                this.insert = 0;
                this.bi_buf = 0;
                this.bi_valid = 0;
              }
              function deflateResetKeep(strm) {
                var s;
                if (!strm || !strm.state) {
                  return err(strm, Z_STREAM_ERROR);
                }
                strm.total_in = strm.total_out = 0;
                strm.data_type = Z_UNKNOWN;
                s = strm.state;
                s.pending = 0;
                s.pending_out = 0;
                if (s.wrap < 0) {
                  s.wrap = -s.wrap;
                }
                s.status = s.wrap ? INIT_STATE : BUSY_STATE;
                strm.adler = s.wrap === 2 ? 0 : 1;
                s.last_flush = Z_NO_FLUSH;
                trees._tr_init(s);
                return Z_OK;
              }
              function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                if (ret === Z_OK) {
                  lm_init(strm.state);
                }
                return ret;
              }
              function deflateSetHeader(strm, head) {
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                if (strm.state.wrap !== 2) {
                  return Z_STREAM_ERROR;
                }
                strm.state.gzhead = head;
                return Z_OK;
              }
              function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) {
                  return Z_STREAM_ERROR;
                }
                var wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION) {
                  level = 6;
                }
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else if (windowBits > 15) {
                  wrap = 2;
                  windowBits -= 16;
                }
                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                  return err(strm, Z_STREAM_ERROR);
                }
                if (windowBits === 8) {
                  windowBits = 9;
                }
                var s = new DeflateState();
                strm.state = s;
                s.strm = strm;
                s.wrap = wrap;
                s.gzhead = null;
                s.w_bits = windowBits;
                s.w_size = 1 << s.w_bits;
                s.w_mask = s.w_size - 1;
                s.hash_bits = memLevel + 7;
                s.hash_size = 1 << s.hash_bits;
                s.hash_mask = s.hash_size - 1;
                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                s.window = new utils.Buf8(s.w_size * 2);
                s.head = new utils.Buf16(s.hash_size);
                s.prev = new utils.Buf16(s.w_size);
                s.lit_bufsize = 1 << memLevel + 6;
                s.pending_buf_size = s.lit_bufsize * 4;
                s.pending_buf = new utils.Buf8(s.pending_buf_size);
                s.d_buf = 1 * s.lit_bufsize;
                s.l_buf = (1 + 2) * s.lit_bufsize;
                s.level = level;
                s.strategy = strategy;
                s.method = method;
                return deflateReset(strm);
              }
              function deflateInit(strm, level) {
                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
              }
              function deflate(strm, flush) {
                var old_flush, s;
                var beg, val;
                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
                  return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                }
                s = strm.state;
                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
                  return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
                }
                s.strm = strm;
                old_flush = s.last_flush;
                s.last_flush = flush;
                if (s.status === INIT_STATE) {
                  if (s.wrap === 2) {
                    strm.adler = 0;
                    put_byte(s, 31);
                    put_byte(s, 139);
                    put_byte(s, 8);
                    if (!s.gzhead) {
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                      put_byte(s, OS_CODE);
                      s.status = BUSY_STATE;
                    } else {
                      put_byte(
                        s,
                        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                      );
                      put_byte(s, s.gzhead.time & 255);
                      put_byte(s, s.gzhead.time >> 8 & 255);
                      put_byte(s, s.gzhead.time >> 16 & 255);
                      put_byte(s, s.gzhead.time >> 24 & 255);
                      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                      put_byte(s, s.gzhead.os & 255);
                      if (s.gzhead.extra && s.gzhead.extra.length) {
                        put_byte(s, s.gzhead.extra.length & 255);
                        put_byte(s, s.gzhead.extra.length >> 8 & 255);
                      }
                      if (s.gzhead.hcrc) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                      }
                      s.gzindex = 0;
                      s.status = EXTRA_STATE;
                    }
                  } else {
                    var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                    var level_flags = -1;
                    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                      level_flags = 0;
                    } else if (s.level < 6) {
                      level_flags = 1;
                    } else if (s.level === 6) {
                      level_flags = 2;
                    } else {
                      level_flags = 3;
                    }
                    header |= level_flags << 6;
                    if (s.strstart !== 0) {
                      header |= PRESET_DICT;
                    }
                    header += 31 - header % 31;
                    s.status = BUSY_STATE;
                    putShortMSB(s, header);
                    if (s.strstart !== 0) {
                      putShortMSB(s, strm.adler >>> 16);
                      putShortMSB(s, strm.adler & 65535);
                    }
                    strm.adler = 1;
                  }
                }
                if (s.status === EXTRA_STATE) {
                  if (s.gzhead.extra) {
                    beg = s.pending;
                    while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          break;
                        }
                      }
                      put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                      s.gzindex++;
                    }
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (s.gzindex === s.gzhead.extra.length) {
                      s.gzindex = 0;
                      s.status = NAME_STATE;
                    }
                  } else {
                    s.status = NAME_STATE;
                  }
                }
                if (s.status === NAME_STATE) {
                  if (s.gzhead.name) {
                    beg = s.pending;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          val = 1;
                          break;
                        }
                      }
                      if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                      s.gzindex = 0;
                      s.status = COMMENT_STATE;
                    }
                  } else {
                    s.status = COMMENT_STATE;
                  }
                }
                if (s.status === COMMENT_STATE) {
                  if (s.gzhead.comment) {
                    beg = s.pending;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          val = 1;
                          break;
                        }
                      }
                      if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                      s.status = HCRC_STATE;
                    }
                  } else {
                    s.status = HCRC_STATE;
                  }
                }
                if (s.status === HCRC_STATE) {
                  if (s.gzhead.hcrc) {
                    if (s.pending + 2 > s.pending_buf_size) {
                      flush_pending(strm);
                    }
                    if (s.pending + 2 <= s.pending_buf_size) {
                      put_byte(s, strm.adler & 255);
                      put_byte(s, strm.adler >> 8 & 255);
                      strm.adler = 0;
                      s.status = BUSY_STATE;
                    }
                  } else {
                    s.status = BUSY_STATE;
                  }
                }
                if (s.pending !== 0) {
                  flush_pending(strm);
                  if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK;
                  }
                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
                  return err(strm, Z_BUF_ERROR);
                }
                if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                  return err(strm, Z_BUF_ERROR);
                }
                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                  var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                  if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                    s.status = FINISH_STATE;
                  }
                  if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                    }
                    return Z_OK;
                  }
                  if (bstate === BS_BLOCK_DONE) {
                    if (flush === Z_PARTIAL_FLUSH) {
                      trees._tr_align(s);
                    } else if (flush !== Z_BLOCK) {
                      trees._tr_stored_block(s, 0, 0, false);
                      if (flush === Z_FULL_FLUSH) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                          s.strstart = 0;
                          s.block_start = 0;
                          s.insert = 0;
                        }
                      }
                    }
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                      return Z_OK;
                    }
                  }
                }
                if (flush !== Z_FINISH) {
                  return Z_OK;
                }
                if (s.wrap <= 0) {
                  return Z_STREAM_END;
                }
                if (s.wrap === 2) {
                  put_byte(s, strm.adler & 255);
                  put_byte(s, strm.adler >> 8 & 255);
                  put_byte(s, strm.adler >> 16 & 255);
                  put_byte(s, strm.adler >> 24 & 255);
                  put_byte(s, strm.total_in & 255);
                  put_byte(s, strm.total_in >> 8 & 255);
                  put_byte(s, strm.total_in >> 16 & 255);
                  put_byte(s, strm.total_in >> 24 & 255);
                } else {
                  putShortMSB(s, strm.adler >>> 16);
                  putShortMSB(s, strm.adler & 65535);
                }
                flush_pending(strm);
                if (s.wrap > 0) {
                  s.wrap = -s.wrap;
                }
                return s.pending !== 0 ? Z_OK : Z_STREAM_END;
              }
              function deflateEnd(strm) {
                var status;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                status = strm.state.status;
                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
                  return err(strm, Z_STREAM_ERROR);
                }
                strm.state = null;
                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
              }
              function deflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;
                var s;
                var str, n;
                var wrap;
                var avail;
                var next;
                var input;
                var tmpDict;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                s = strm.state;
                wrap = s.wrap;
                if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
                  return Z_STREAM_ERROR;
                }
                if (wrap === 1) {
                  strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
                }
                s.wrap = 0;
                if (dictLength >= s.w_size) {
                  if (wrap === 0) {
                    zero(s.head);
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                  tmpDict = new utils.Buf8(s.w_size);
                  utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                  dictionary = tmpDict;
                  dictLength = s.w_size;
                }
                avail = strm.avail_in;
                next = strm.next_in;
                input = strm.input;
                strm.avail_in = dictLength;
                strm.next_in = 0;
                strm.input = dictionary;
                fill_window(s);
                while (s.lookahead >= MIN_MATCH) {
                  str = s.strstart;
                  n = s.lookahead - (MIN_MATCH - 1);
                  do {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                  } while (--n);
                  s.strstart = str;
                  s.lookahead = MIN_MATCH - 1;
                  fill_window(s);
                }
                s.strstart += s.lookahead;
                s.block_start = s.strstart;
                s.insert = s.lookahead;
                s.lookahead = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                strm.next_in = next;
                strm.input = input;
                strm.avail_in = avail;
                s.wrap = wrap;
                return Z_OK;
              }
              exports2.deflateInit = deflateInit;
              exports2.deflateInit2 = deflateInit2;
              exports2.deflateReset = deflateReset;
              exports2.deflateResetKeep = deflateResetKeep;
              exports2.deflateSetHeader = deflateSetHeader;
              exports2.deflate = deflate;
              exports2.deflateEnd = deflateEnd;
              exports2.deflateSetDictionary = deflateSetDictionary;
              exports2.deflateInfo = "pako deflate (from Nodeca project)";
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js"(module2) {
              function GZheader() {
                this.text = 0;
                this.time = 0;
                this.xflags = 0;
                this.os = 0;
                this.extra = null;
                this.extra_len = 0;
                this.name = "";
                this.comment = "";
                this.hcrc = 0;
                this.done = false;
              }
              module2.exports = GZheader;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js"(module2) {
              var BAD = 30;
              var TYPE = 12;
              module2.exports = function inflate_fast(strm, start) {
                var state;
                var _in;
                var last;
                var _out;
                var beg;
                var end;
                var dmax;
                var wsize;
                var whave;
                var wnext;
                var s_window;
                var hold;
                var bits;
                var lcode;
                var dcode;
                var lmask;
                var dmask;
                var here;
                var op;
                var len;
                var dist;
                var from;
                var from_source;
                var input, output;
                state = strm.state;
                _in = strm.next_in;
                input = strm.input;
                last = _in + (strm.avail_in - 5);
                _out = strm.next_out;
                output = strm.output;
                beg = _out - (start - strm.avail_out);
                end = _out + (strm.avail_out - 257);
                dmax = state.dmax;
                wsize = state.wsize;
                whave = state.whave;
                wnext = state.wnext;
                s_window = state.window;
                hold = state.hold;
                bits = state.bits;
                lcode = state.lencode;
                dcode = state.distcode;
                lmask = (1 << state.lenbits) - 1;
                dmask = (1 << state.distbits) - 1;
                top:
                  do {
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = lcode[hold & lmask];
                    dolen:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op === 0) {
                          output[_out++] = here & 65535;
                        } else if (op & 16) {
                          len = here & 65535;
                          op &= 15;
                          if (op) {
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                            len += hold & (1 << op) - 1;
                            hold >>>= op;
                            bits -= op;
                          }
                          if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                          here = dcode[hold & dmask];
                          dodist:
                            for (; ; ) {
                              op = here >>> 24;
                              hold >>>= op;
                              bits -= op;
                              op = here >>> 16 & 255;
                              if (op & 16) {
                                dist = here & 65535;
                                op &= 15;
                                if (bits < op) {
                                  hold += input[_in++] << bits;
                                  bits += 8;
                                  if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                  }
                                }
                                dist += hold & (1 << op) - 1;
                                if (dist > dmax) {
                                  strm.msg = "invalid distance too far back";
                                  state.mode = BAD;
                                  break top;
                                }
                                hold >>>= op;
                                bits -= op;
                                op = _out - beg;
                                if (dist > op) {
                                  op = dist - op;
                                  if (op > whave) {
                                    if (state.sane) {
                                      strm.msg = "invalid distance too far back";
                                      state.mode = BAD;
                                      break top;
                                    }
                                  }
                                  from = 0;
                                  from_source = s_window;
                                  if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = 0;
                                      if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                      }
                                    }
                                  } else {
                                    from += wnext - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  }
                                  while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                  }
                                  if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                      output[_out++] = from_source[from++];
                                    }
                                  }
                                } else {
                                  from = _out - dist;
                                  do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                  } while (len > 2);
                                  if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                      output[_out++] = output[from++];
                                    }
                                  }
                                }
                              } else if ((op & 64) === 0) {
                                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                continue dodist;
                              } else {
                                strm.msg = "invalid distance code";
                                state.mode = BAD;
                                break top;
                              }
                              break;
                            }
                        } else if ((op & 64) === 0) {
                          here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dolen;
                        } else if (op & 32) {
                          state.mode = TYPE;
                          break top;
                        } else {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } while (_in < last && _out < end);
                len = bits >> 3;
                _in -= len;
                bits -= len << 3;
                hold &= (1 << bits) - 1;
                strm.next_in = _in;
                strm.next_out = _out;
                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
                state.hold = hold;
                state.bits = bits;
                return;
              };
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var utils = __webpack_require__2(
                /*! ../utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var adler32 = __webpack_require__2(
                /*! ./adler32 */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
              );
              var crc32 = __webpack_require__2(
                /*! ./crc32 */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
              );
              var inflate_fast = __webpack_require__2(
                /*! ./inffast */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js"
              );
              var inflate_table = __webpack_require__2(
                /*! ./inftrees */
                "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js"
              );
              var CODES = 0;
              var LENS = 1;
              var DISTS = 2;
              var Z_FINISH = 4;
              var Z_BLOCK = 5;
              var Z_TREES = 6;
              var Z_OK = 0;
              var Z_STREAM_END = 1;
              var Z_NEED_DICT = 2;
              var Z_STREAM_ERROR = -2;
              var Z_DATA_ERROR = -3;
              var Z_MEM_ERROR = -4;
              var Z_BUF_ERROR = -5;
              var Z_DEFLATED = 8;
              var HEAD = 1;
              var FLAGS = 2;
              var TIME = 3;
              var OS = 4;
              var EXLEN = 5;
              var EXTRA = 6;
              var NAME = 7;
              var COMMENT = 8;
              var HCRC = 9;
              var DICTID = 10;
              var DICT = 11;
              var TYPE = 12;
              var TYPEDO = 13;
              var STORED = 14;
              var COPY_ = 15;
              var COPY = 16;
              var TABLE = 17;
              var LENLENS = 18;
              var CODELENS = 19;
              var LEN_ = 20;
              var LEN = 21;
              var LENEXT = 22;
              var DIST = 23;
              var DISTEXT = 24;
              var MATCH = 25;
              var LIT = 26;
              var CHECK = 27;
              var LENGTH = 28;
              var DONE = 29;
              var BAD = 30;
              var MEM = 31;
              var SYNC = 32;
              var ENOUGH_LENS = 852;
              var ENOUGH_DISTS = 592;
              var MAX_WBITS = 15;
              var DEF_WBITS = MAX_WBITS;
              function zswap32(q) {
                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
              }
              function InflateState() {
                this.mode = 0;
                this.last = false;
                this.wrap = 0;
                this.havedict = false;
                this.flags = 0;
                this.dmax = 0;
                this.check = 0;
                this.total = 0;
                this.head = null;
                this.wbits = 0;
                this.wsize = 0;
                this.whave = 0;
                this.wnext = 0;
                this.window = null;
                this.hold = 0;
                this.bits = 0;
                this.length = 0;
                this.offset = 0;
                this.extra = 0;
                this.lencode = null;
                this.distcode = null;
                this.lenbits = 0;
                this.distbits = 0;
                this.ncode = 0;
                this.nlen = 0;
                this.ndist = 0;
                this.have = 0;
                this.next = null;
                this.lens = new utils.Buf16(320);
                this.work = new utils.Buf16(288);
                this.lendyn = null;
                this.distdyn = null;
                this.sane = 0;
                this.back = 0;
                this.was = 0;
              }
              function inflateResetKeep(strm) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                strm.total_in = strm.total_out = state.total = 0;
                strm.msg = "";
                if (state.wrap) {
                  strm.adler = state.wrap & 1;
                }
                state.mode = HEAD;
                state.last = 0;
                state.havedict = 0;
                state.dmax = 32768;
                state.head = null;
                state.hold = 0;
                state.bits = 0;
                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
                state.sane = 1;
                state.back = -1;
                return Z_OK;
              }
              function inflateReset(strm) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                state.wsize = 0;
                state.whave = 0;
                state.wnext = 0;
                return inflateResetKeep(strm);
              }
              function inflateReset2(strm, windowBits) {
                var wrap;
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else {
                  wrap = (windowBits >> 4) + 1;
                  if (windowBits < 48) {
                    windowBits &= 15;
                  }
                }
                if (windowBits && (windowBits < 8 || windowBits > 15)) {
                  return Z_STREAM_ERROR;
                }
                if (state.window !== null && state.wbits !== windowBits) {
                  state.window = null;
                }
                state.wrap = wrap;
                state.wbits = windowBits;
                return inflateReset(strm);
              }
              function inflateInit2(strm, windowBits) {
                var ret;
                var state;
                if (!strm) {
                  return Z_STREAM_ERROR;
                }
                state = new InflateState();
                strm.state = state;
                state.window = null;
                ret = inflateReset2(strm, windowBits);
                if (ret !== Z_OK) {
                  strm.state = null;
                }
                return ret;
              }
              function inflateInit(strm) {
                return inflateInit2(strm, DEF_WBITS);
              }
              var virgin = true;
              var lenfix, distfix;
              function fixedtables(state) {
                if (virgin) {
                  var sym;
                  lenfix = new utils.Buf32(512);
                  distfix = new utils.Buf32(32);
                  sym = 0;
                  while (sym < 144) {
                    state.lens[sym++] = 8;
                  }
                  while (sym < 256) {
                    state.lens[sym++] = 9;
                  }
                  while (sym < 280) {
                    state.lens[sym++] = 7;
                  }
                  while (sym < 288) {
                    state.lens[sym++] = 8;
                  }
                  inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
                  sym = 0;
                  while (sym < 32) {
                    state.lens[sym++] = 5;
                  }
                  inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
                  virgin = false;
                }
                state.lencode = lenfix;
                state.lenbits = 9;
                state.distcode = distfix;
                state.distbits = 5;
              }
              function updatewindow(strm, src, end, copy) {
                var dist;
                var state = strm.state;
                if (state.window === null) {
                  state.wsize = 1 << state.wbits;
                  state.wnext = 0;
                  state.whave = 0;
                  state.window = new utils.Buf8(state.wsize);
                }
                if (copy >= state.wsize) {
                  utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                  state.wnext = 0;
                  state.whave = state.wsize;
                } else {
                  dist = state.wsize - state.wnext;
                  if (dist > copy) {
                    dist = copy;
                  }
                  utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                  copy -= dist;
                  if (copy) {
                    utils.arraySet(state.window, src, end - copy, copy, 0);
                    state.wnext = copy;
                    state.whave = state.wsize;
                  } else {
                    state.wnext += dist;
                    if (state.wnext === state.wsize) {
                      state.wnext = 0;
                    }
                    if (state.whave < state.wsize) {
                      state.whave += dist;
                    }
                  }
                }
                return 0;
              }
              function inflate(strm, flush) {
                var state;
                var input, output;
                var next;
                var put;
                var have, left;
                var hold;
                var bits;
                var _in, _out;
                var copy;
                var from;
                var from_source;
                var here = 0;
                var here_bits, here_op, here_val;
                var last_bits, last_op, last_val;
                var len;
                var ret;
                var hbuf = new utils.Buf8(4);
                var opts;
                var n;
                var order = (
                  /* permutation of code lengths */
                  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                );
                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (state.mode === TYPE) {
                  state.mode = TYPEDO;
                }
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                _in = have;
                _out = left;
                ret = Z_OK;
                inf_leave:
                  for (; ; ) {
                    switch (state.mode) {
                      case HEAD:
                        if (state.wrap === 0) {
                          state.mode = TYPEDO;
                          break;
                        }
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.wrap & 2 && hold === 35615) {
                          state.check = 0;
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                          hold = 0;
                          bits = 0;
                          state.mode = FLAGS;
                          break;
                        }
                        state.flags = 0;
                        if (state.head) {
                          state.head.done = false;
                        }
                        if (!(state.wrap & 1) || /* check if zlib header allowed */
                        (((hold & 255) << 8) + (hold >> 8)) % 31) {
                          strm.msg = "incorrect header check";
                          state.mode = BAD;
                          break;
                        }
                        if ((hold & 15) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        hold >>>= 4;
                        bits -= 4;
                        len = (hold & 15) + 8;
                        if (state.wbits === 0) {
                          state.wbits = len;
                        } else if (len > state.wbits) {
                          strm.msg = "invalid window size";
                          state.mode = BAD;
                          break;
                        }
                        state.dmax = 1 << len;
                        strm.adler = state.check = 1;
                        state.mode = hold & 512 ? DICTID : TYPE;
                        hold = 0;
                        bits = 0;
                        break;
                      case FLAGS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.flags = hold;
                        if ((state.flags & 255) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        if (state.flags & 57344) {
                          strm.msg = "unknown header flags set";
                          state.mode = BAD;
                          break;
                        }
                        if (state.head) {
                          state.head.text = hold >> 8 & 1;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = TIME;
                      /* falls through */
                      case TIME:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.time = hold;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          hbuf[2] = hold >>> 16 & 255;
                          hbuf[3] = hold >>> 24 & 255;
                          state.check = crc32(state.check, hbuf, 4, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = OS;
                      /* falls through */
                      case OS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.xflags = hold & 255;
                          state.head.os = hold >> 8;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = EXLEN;
                      /* falls through */
                      case EXLEN:
                        if (state.flags & 1024) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length = hold;
                          if (state.head) {
                            state.head.extra_len = hold;
                          }
                          if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                          }
                          hold = 0;
                          bits = 0;
                        } else if (state.head) {
                          state.head.extra = null;
                        }
                        state.mode = EXTRA;
                      /* falls through */
                      case EXTRA:
                        if (state.flags & 1024) {
                          copy = state.length;
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy) {
                            if (state.head) {
                              len = state.head.extra_len - state.length;
                              if (!state.head.extra) {
                                state.head.extra = new Array(state.head.extra_len);
                              }
                              utils.arraySet(
                                state.head.extra,
                                input,
                                next,
                                // extra field is limited to 65536 bytes
                                // - no need for additional size check
                                copy,
                                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                len
                              );
                            }
                            if (state.flags & 512) {
                              state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                          }
                          if (state.length) {
                            break inf_leave;
                          }
                        }
                        state.length = 0;
                        state.mode = NAME;
                      /* falls through */
                      case NAME:
                        if (state.flags & 2048) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.name += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;
                      /* falls through */
                      case COMMENT:
                        if (state.flags & 4096) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.comment += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.comment = null;
                        }
                        state.mode = HCRC;
                      /* falls through */
                      case HCRC:
                        if (state.flags & 512) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (hold !== (state.check & 65535)) {
                            strm.msg = "header crc mismatch";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        if (state.head) {
                          state.head.hcrc = state.flags >> 9 & 1;
                          state.head.done = true;
                        }
                        strm.adler = state.check = 0;
                        state.mode = TYPE;
                        break;
                      case DICTID:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        strm.adler = state.check = zswap32(hold);
                        hold = 0;
                        bits = 0;
                        state.mode = DICT;
                      /* falls through */
                      case DICT:
                        if (state.havedict === 0) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          return Z_NEED_DICT;
                        }
                        strm.adler = state.check = 1;
                        state.mode = TYPE;
                      /* falls through */
                      case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case TYPEDO:
                        if (state.last) {
                          hold >>>= bits & 7;
                          bits -= bits & 7;
                          state.mode = CHECK;
                          break;
                        }
                        while (bits < 3) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.last = hold & 1;
                        hold >>>= 1;
                        bits -= 1;
                        switch (hold & 3) {
                          case 0:
                            state.mode = STORED;
                            break;
                          case 1:
                            fixedtables(state);
                            state.mode = LEN_;
                            if (flush === Z_TREES) {
                              hold >>>= 2;
                              bits -= 2;
                              break inf_leave;
                            }
                            break;
                          case 2:
                            state.mode = TABLE;
                            break;
                          case 3:
                            strm.msg = "invalid block type";
                            state.mode = BAD;
                        }
                        hold >>>= 2;
                        bits -= 2;
                        break;
                      case STORED:
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                          strm.msg = "invalid stored block lengths";
                          state.mode = BAD;
                          break;
                        }
                        state.length = hold & 65535;
                        hold = 0;
                        bits = 0;
                        state.mode = COPY_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case COPY_:
                        state.mode = COPY;
                      /* falls through */
                      case COPY:
                        copy = state.length;
                        if (copy) {
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy > left) {
                            copy = left;
                          }
                          if (copy === 0) {
                            break inf_leave;
                          }
                          utils.arraySet(output, input, next, copy, put);
                          have -= copy;
                          next += copy;
                          left -= copy;
                          put += copy;
                          state.length -= copy;
                          break;
                        }
                        state.mode = TYPE;
                        break;
                      case TABLE:
                        while (bits < 14) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.nlen = (hold & 31) + 257;
                        hold >>>= 5;
                        bits -= 5;
                        state.ndist = (hold & 31) + 1;
                        hold >>>= 5;
                        bits -= 5;
                        state.ncode = (hold & 15) + 4;
                        hold >>>= 4;
                        bits -= 4;
                        if (state.nlen > 286 || state.ndist > 30) {
                          strm.msg = "too many length or distance symbols";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = LENLENS;
                      /* falls through */
                      case LENLENS:
                        while (state.have < state.ncode) {
                          while (bits < 3) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.lens[order[state.have++]] = hold & 7;
                          hold >>>= 3;
                          bits -= 3;
                        }
                        while (state.have < 19) {
                          state.lens[order[state.have++]] = 0;
                        }
                        state.lencode = state.lendyn;
                        state.lenbits = 7;
                        opts = { bits: state.lenbits };
                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid code lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = CODELENS;
                      /* falls through */
                      case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                          for (; ; ) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (here_val < 16) {
                            hold >>>= here_bits;
                            bits -= here_bits;
                            state.lens[state.have++] = here_val;
                          } else {
                            if (here_val === 16) {
                              n = here_bits + 2;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                              }
                              len = state.lens[state.have - 1];
                              copy = 3 + (hold & 3);
                              hold >>>= 2;
                              bits -= 2;
                            } else if (here_val === 17) {
                              n = here_bits + 3;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 3 + (hold & 7);
                              hold >>>= 3;
                              bits -= 3;
                            } else {
                              n = here_bits + 7;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 11 + (hold & 127);
                              hold >>>= 7;
                              bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                              strm.msg = "invalid bit length repeat";
                              state.mode = BAD;
                              break;
                            }
                            while (copy--) {
                              state.lens[state.have++] = len;
                            }
                          }
                        }
                        if (state.mode === BAD) {
                          break;
                        }
                        if (state.lens[256] === 0) {
                          strm.msg = "invalid code -- missing end-of-block";
                          state.mode = BAD;
                          break;
                        }
                        state.lenbits = 9;
                        opts = { bits: state.lenbits };
                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid literal/lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.distbits = 6;
                        state.distcode = state.distdyn;
                        opts = { bits: state.distbits };
                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        state.distbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid distances set";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      /* falls through */
                      case LEN_:
                        state.mode = LEN;
                      /* falls through */
                      case LEN:
                        if (have >= 6 && left >= 258) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          inflate_fast(strm, _out);
                          put = strm.next_out;
                          output = strm.output;
                          left = strm.avail_out;
                          next = strm.next_in;
                          input = strm.input;
                          have = strm.avail_in;
                          hold = state.hold;
                          bits = state.bits;
                          if (state.mode === TYPE) {
                            state.back = -1;
                          }
                          break;
                        }
                        state.back = 0;
                        for (; ; ) {
                          here = state.lencode[hold & (1 << state.lenbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (here_op && (here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                          state.mode = LIT;
                          break;
                        }
                        if (here_op & 32) {
                          state.back = -1;
                          state.mode = TYPE;
                          break;
                        }
                        if (here_op & 64) {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD;
                          break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;
                      /* falls through */
                      case LENEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        state.was = state.length;
                        state.mode = DIST;
                      /* falls through */
                      case DIST:
                        for (; ; ) {
                          here = state.distcode[hold & (1 << state.distbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        if (here_op & 64) {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break;
                        }
                        state.offset = here_val;
                        state.extra = here_op & 15;
                        state.mode = DISTEXT;
                      /* falls through */
                      case DISTEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.offset += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        if (state.offset > state.dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = MATCH;
                      /* falls through */
                      case MATCH:
                        if (left === 0) {
                          break inf_leave;
                        }
                        copy = _out - left;
                        if (state.offset > copy) {
                          copy = state.offset - copy;
                          if (copy > state.whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break;
                            }
                          }
                          if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                          } else {
                            from = state.wnext - copy;
                          }
                          if (copy > state.length) {
                            copy = state.length;
                          }
                          from_source = state.window;
                        } else {
                          from_source = output;
                          from = put - state.offset;
                          copy = state.length;
                        }
                        if (copy > left) {
                          copy = left;
                        }
                        left -= copy;
                        state.length -= copy;
                        do {
                          output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) {
                          state.mode = LEN;
                        }
                        break;
                      case LIT:
                        if (left === 0) {
                          break inf_leave;
                        }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;
                      case CHECK:
                        if (state.wrap) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold |= input[next++] << bits;
                            bits += 8;
                          }
                          _out -= left;
                          strm.total_out += _out;
                          state.total += _out;
                          if (_out) {
                            strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                          }
                          _out = left;
                          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = LENGTH;
                      /* falls through */
                      case LENGTH:
                        if (state.wrap && state.flags) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (hold !== (state.total & 4294967295)) {
                            strm.msg = "incorrect length check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = DONE;
                      /* falls through */
                      case DONE:
                        ret = Z_STREAM_END;
                        break inf_leave;
                      case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                      case MEM:
                        return Z_MEM_ERROR;
                      case SYNC:
                      /* falls through */
                      default:
                        return Z_STREAM_ERROR;
                    }
                  }
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
                  if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                    state.mode = MEM;
                    return Z_MEM_ERROR;
                  }
                }
                _in -= strm.avail_in;
                _out -= strm.avail_out;
                strm.total_in += _in;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap && _out) {
                  strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
                }
                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
                  ret = Z_BUF_ERROR;
                }
                return ret;
              }
              function inflateEnd(strm) {
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                var state = strm.state;
                if (state.window) {
                  state.window = null;
                }
                strm.state = null;
                return Z_OK;
              }
              function inflateGetHeader(strm, head) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if ((state.wrap & 2) === 0) {
                  return Z_STREAM_ERROR;
                }
                state.head = head;
                head.done = false;
                return Z_OK;
              }
              function inflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;
                var state;
                var dictid;
                var ret;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (state.wrap !== 0 && state.mode !== DICT) {
                  return Z_STREAM_ERROR;
                }
                if (state.mode === DICT) {
                  dictid = 1;
                  dictid = adler32(dictid, dictionary, dictLength, 0);
                  if (dictid !== state.check) {
                    return Z_DATA_ERROR;
                  }
                }
                ret = updatewindow(strm, dictionary, dictLength, dictLength);
                if (ret) {
                  state.mode = MEM;
                  return Z_MEM_ERROR;
                }
                state.havedict = 1;
                return Z_OK;
              }
              exports2.inflateReset = inflateReset;
              exports2.inflateReset2 = inflateReset2;
              exports2.inflateResetKeep = inflateResetKeep;
              exports2.inflateInit = inflateInit;
              exports2.inflateInit2 = inflateInit2;
              exports2.inflate = inflate;
              exports2.inflateEnd = inflateEnd;
              exports2.inflateGetHeader = inflateGetHeader;
              exports2.inflateSetDictionary = inflateSetDictionary;
              exports2.inflateInfo = "pako inflate (from Nodeca project)";
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js"(module2, __unused_webpack_exports, __webpack_require__2) {
              var utils = __webpack_require__2(
                /*! ../utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var MAXBITS = 15;
              var ENOUGH_LENS = 852;
              var ENOUGH_DISTS = 592;
              var CODES = 0;
              var LENS = 1;
              var DISTS = 2;
              var lbase = [
                /* Length codes 257..285 base */
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                19,
                23,
                27,
                31,
                35,
                43,
                51,
                59,
                67,
                83,
                99,
                115,
                131,
                163,
                195,
                227,
                258,
                0,
                0
              ];
              var lext = [
                /* Length codes 257..285 extra */
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                16,
                72,
                78
              ];
              var dbase = [
                /* Distance codes 0..29 base */
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577,
                0,
                0
              ];
              var dext = [
                /* Distance codes 0..29 extra */
                16,
                16,
                16,
                16,
                17,
                17,
                18,
                18,
                19,
                19,
                20,
                20,
                21,
                21,
                22,
                22,
                23,
                23,
                24,
                24,
                25,
                25,
                26,
                26,
                27,
                27,
                28,
                28,
                29,
                29,
                64,
                64
              ];
              module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                var bits = opts.bits;
                var len = 0;
                var sym = 0;
                var min = 0, max = 0;
                var root = 0;
                var curr = 0;
                var drop = 0;
                var left = 0;
                var used = 0;
                var huff = 0;
                var incr;
                var fill;
                var low;
                var mask;
                var next;
                var base = null;
                var base_index = 0;
                var end;
                var count = new utils.Buf16(MAXBITS + 1);
                var offs = new utils.Buf16(MAXBITS + 1);
                var extra = null;
                var extra_index = 0;
                var here_bits, here_op, here_val;
                for (len = 0; len <= MAXBITS; len++) {
                  count[len] = 0;
                }
                for (sym = 0; sym < codes; sym++) {
                  count[lens[lens_index + sym]]++;
                }
                root = bits;
                for (max = MAXBITS; max >= 1; max--) {
                  if (count[max] !== 0) {
                    break;
                  }
                }
                if (root > max) {
                  root = max;
                }
                if (max === 0) {
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  opts.bits = 1;
                  return 0;
                }
                for (min = 1; min < max; min++) {
                  if (count[min] !== 0) {
                    break;
                  }
                }
                if (root < min) {
                  root = min;
                }
                left = 1;
                for (len = 1; len <= MAXBITS; len++) {
                  left <<= 1;
                  left -= count[len];
                  if (left < 0) {
                    return -1;
                  }
                }
                if (left > 0 && (type === CODES || max !== 1)) {
                  return -1;
                }
                offs[1] = 0;
                for (len = 1; len < MAXBITS; len++) {
                  offs[len + 1] = offs[len] + count[len];
                }
                for (sym = 0; sym < codes; sym++) {
                  if (lens[lens_index + sym] !== 0) {
                    work[offs[lens[lens_index + sym]]++] = sym;
                  }
                }
                if (type === CODES) {
                  base = extra = work;
                  end = 19;
                } else if (type === LENS) {
                  base = lbase;
                  base_index -= 257;
                  extra = lext;
                  extra_index -= 257;
                  end = 256;
                } else {
                  base = dbase;
                  extra = dext;
                  end = -1;
                }
                huff = 0;
                sym = 0;
                len = min;
                next = table_index;
                curr = root;
                drop = 0;
                low = -1;
                used = 1 << root;
                mask = used - 1;
                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                  return 1;
                }
                for (; ; ) {
                  here_bits = len - drop;
                  if (work[sym] < end) {
                    here_op = 0;
                    here_val = work[sym];
                  } else if (work[sym] > end) {
                    here_op = extra[extra_index + work[sym]];
                    here_val = base[base_index + work[sym]];
                  } else {
                    here_op = 32 + 64;
                    here_val = 0;
                  }
                  incr = 1 << len - drop;
                  fill = 1 << curr;
                  min = fill;
                  do {
                    fill -= incr;
                    table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                  } while (fill !== 0);
                  incr = 1 << len - 1;
                  while (huff & incr) {
                    incr >>= 1;
                  }
                  if (incr !== 0) {
                    huff &= incr - 1;
                    huff += incr;
                  } else {
                    huff = 0;
                  }
                  sym++;
                  if (--count[len] === 0) {
                    if (len === max) {
                      break;
                    }
                    len = lens[lens_index + work[sym]];
                  }
                  if (len > root && (huff & mask) !== low) {
                    if (drop === 0) {
                      drop = root;
                    }
                    next += min;
                    curr = len - drop;
                    left = 1 << curr;
                    while (curr + drop < max) {
                      left -= count[curr + drop];
                      if (left <= 0) {
                        break;
                      }
                      curr++;
                      left <<= 1;
                    }
                    used += 1 << curr;
                    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                      return 1;
                    }
                    low = huff & mask;
                    table[low] = root << 24 | curr << 16 | next - table_index | 0;
                  }
                }
                if (huff !== 0) {
                  table[next + huff] = len - drop << 24 | 64 << 16 | 0;
                }
                opts.bits = root;
                return 0;
              };
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"(module2) {
              module2.exports = {
                2: "need dictionary",
                /* Z_NEED_DICT       2  */
                1: "stream end",
                /* Z_STREAM_END      1  */
                0: "",
                /* Z_OK              0  */
                "-1": "file error",
                /* Z_ERRNO         (-1) */
                "-2": "stream error",
                /* Z_STREAM_ERROR  (-2) */
                "-3": "data error",
                /* Z_DATA_ERROR    (-3) */
                "-4": "insufficient memory",
                /* Z_MEM_ERROR     (-4) */
                "-5": "buffer error",
                /* Z_BUF_ERROR     (-5) */
                "-6": "incompatible version"
                /* Z_VERSION_ERROR (-6) */
              };
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js"(__unused_webpack_module2, exports2, __webpack_require__2) {
              var utils = __webpack_require__2(
                /*! ../utils/common */
                "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
              );
              var Z_FIXED = 4;
              var Z_BINARY = 0;
              var Z_TEXT = 1;
              var Z_UNKNOWN = 2;
              function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              }
              var STORED_BLOCK = 0;
              var STATIC_TREES = 1;
              var DYN_TREES = 2;
              var MIN_MATCH = 3;
              var MAX_MATCH = 258;
              var LENGTH_CODES = 29;
              var LITERALS = 256;
              var L_CODES = LITERALS + 1 + LENGTH_CODES;
              var D_CODES = 30;
              var BL_CODES = 19;
              var HEAP_SIZE = 2 * L_CODES + 1;
              var MAX_BITS = 15;
              var Buf_size = 16;
              var MAX_BL_BITS = 7;
              var END_BLOCK = 256;
              var REP_3_6 = 16;
              var REPZ_3_10 = 17;
              var REPZ_11_138 = 18;
              var extra_lbits = (
                /* extra bits for each length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
              );
              var extra_dbits = (
                /* extra bits for each distance code */
                [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
              );
              var extra_blbits = (
                /* extra bits for each bit length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
              );
              var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              var DIST_CODE_LEN = 512;
              var static_ltree = new Array((L_CODES + 2) * 2);
              zero(static_ltree);
              var static_dtree = new Array(D_CODES * 2);
              zero(static_dtree);
              var _dist_code = new Array(DIST_CODE_LEN);
              zero(_dist_code);
              var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
              zero(_length_code);
              var base_length = new Array(LENGTH_CODES);
              zero(base_length);
              var base_dist = new Array(D_CODES);
              zero(base_dist);
              function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree;
                this.extra_bits = extra_bits;
                this.extra_base = extra_base;
                this.elems = elems;
                this.max_length = max_length;
                this.has_stree = static_tree && static_tree.length;
              }
              var static_l_desc;
              var static_d_desc;
              var static_bl_desc;
              function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree;
                this.max_code = 0;
                this.stat_desc = stat_desc;
              }
              function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
              }
              function put_short(s, w) {
                s.pending_buf[s.pending++] = w & 255;
                s.pending_buf[s.pending++] = w >>> 8 & 255;
              }
              function send_bits(s, value, length) {
                if (s.bi_valid > Buf_size - length) {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  put_short(s, s.bi_buf);
                  s.bi_buf = value >> Buf_size - s.bi_valid;
                  s.bi_valid += length - Buf_size;
                } else {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  s.bi_valid += length;
                }
              }
              function send_code(s, c, tree) {
                send_bits(
                  s,
                  tree[c * 2],
                  tree[c * 2 + 1]
                  /*.Len*/
                );
              }
              function bi_reverse(code, len) {
                var res = 0;
                do {
                  res |= code & 1;
                  code >>>= 1;
                  res <<= 1;
                } while (--len > 0);
                return res >>> 1;
              }
              function bi_flush(s) {
                if (s.bi_valid === 16) {
                  put_short(s, s.bi_buf);
                  s.bi_buf = 0;
                  s.bi_valid = 0;
                } else if (s.bi_valid >= 8) {
                  s.pending_buf[s.pending++] = s.bi_buf & 255;
                  s.bi_buf >>= 8;
                  s.bi_valid -= 8;
                }
              }
              function gen_bitlen(s, desc) {
                var tree = desc.dyn_tree;
                var max_code = desc.max_code;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var extra = desc.stat_desc.extra_bits;
                var base = desc.stat_desc.extra_base;
                var max_length = desc.stat_desc.max_length;
                var h;
                var n, m;
                var bits;
                var xbits;
                var f;
                var overflow = 0;
                for (bits = 0; bits <= MAX_BITS; bits++) {
                  s.bl_count[bits] = 0;
                }
                tree[s.heap[s.heap_max] * 2 + 1] = 0;
                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                  n = s.heap[h];
                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                  if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                  }
                  tree[n * 2 + 1] = bits;
                  if (n > max_code) {
                    continue;
                  }
                  s.bl_count[bits]++;
                  xbits = 0;
                  if (n >= base) {
                    xbits = extra[n - base];
                  }
                  f = tree[n * 2];
                  s.opt_len += f * (bits + xbits);
                  if (has_stree) {
                    s.static_len += f * (stree[n * 2 + 1] + xbits);
                  }
                }
                if (overflow === 0) {
                  return;
                }
                do {
                  bits = max_length - 1;
                  while (s.bl_count[bits] === 0) {
                    bits--;
                  }
                  s.bl_count[bits]--;
                  s.bl_count[bits + 1] += 2;
                  s.bl_count[max_length]--;
                  overflow -= 2;
                } while (overflow > 0);
                for (bits = max_length; bits !== 0; bits--) {
                  n = s.bl_count[bits];
                  while (n !== 0) {
                    m = s.heap[--h];
                    if (m > max_code) {
                      continue;
                    }
                    if (tree[m * 2 + 1] !== bits) {
                      s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                      tree[m * 2 + 1] = bits;
                    }
                    n--;
                  }
                }
              }
              function gen_codes(tree, max_code, bl_count) {
                var next_code = new Array(MAX_BITS + 1);
                var code = 0;
                var bits;
                var n;
                for (bits = 1; bits <= MAX_BITS; bits++) {
                  next_code[bits] = code = code + bl_count[bits - 1] << 1;
                }
                for (n = 0; n <= max_code; n++) {
                  var len = tree[n * 2 + 1];
                  if (len === 0) {
                    continue;
                  }
                  tree[n * 2] = bi_reverse(next_code[len]++, len);
                }
              }
              function tr_static_init() {
                var n;
                var bits;
                var length;
                var code;
                var dist;
                var bl_count = new Array(MAX_BITS + 1);
                length = 0;
                for (code = 0; code < LENGTH_CODES - 1; code++) {
                  base_length[code] = length;
                  for (n = 0; n < 1 << extra_lbits[code]; n++) {
                    _length_code[length++] = code;
                  }
                }
                _length_code[length - 1] = code;
                dist = 0;
                for (code = 0; code < 16; code++) {
                  base_dist[code] = dist;
                  for (n = 0; n < 1 << extra_dbits[code]; n++) {
                    _dist_code[dist++] = code;
                  }
                }
                dist >>= 7;
                for (; code < D_CODES; code++) {
                  base_dist[code] = dist << 7;
                  for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                    _dist_code[256 + dist++] = code;
                  }
                }
                for (bits = 0; bits <= MAX_BITS; bits++) {
                  bl_count[bits] = 0;
                }
                n = 0;
                while (n <= 143) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                while (n <= 255) {
                  static_ltree[n * 2 + 1] = 9;
                  n++;
                  bl_count[9]++;
                }
                while (n <= 279) {
                  static_ltree[n * 2 + 1] = 7;
                  n++;
                  bl_count[7]++;
                }
                while (n <= 287) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                gen_codes(static_ltree, L_CODES + 1, bl_count);
                for (n = 0; n < D_CODES; n++) {
                  static_dtree[n * 2 + 1] = 5;
                  static_dtree[n * 2] = bi_reverse(n, 5);
                }
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
              }
              function init_block(s) {
                var n;
                for (n = 0; n < L_CODES; n++) {
                  s.dyn_ltree[n * 2] = 0;
                }
                for (n = 0; n < D_CODES; n++) {
                  s.dyn_dtree[n * 2] = 0;
                }
                for (n = 0; n < BL_CODES; n++) {
                  s.bl_tree[n * 2] = 0;
                }
                s.dyn_ltree[END_BLOCK * 2] = 1;
                s.opt_len = s.static_len = 0;
                s.last_lit = s.matches = 0;
              }
              function bi_windup(s) {
                if (s.bi_valid > 8) {
                  put_short(s, s.bi_buf);
                } else if (s.bi_valid > 0) {
                  s.pending_buf[s.pending++] = s.bi_buf;
                }
                s.bi_buf = 0;
                s.bi_valid = 0;
              }
              function copy_block(s, buf, len, header) {
                bi_windup(s);
                if (header) {
                  put_short(s, len);
                  put_short(s, ~len);
                }
                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                s.pending += len;
              }
              function smaller(tree, n, m, depth) {
                var _n2 = n * 2;
                var _m2 = m * 2;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
              }
              function pqdownheap(s, tree, k) {
                var v = s.heap[k];
                var j = k << 1;
                while (j <= s.heap_len) {
                  if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                    j++;
                  }
                  if (smaller(tree, v, s.heap[j], s.depth)) {
                    break;
                  }
                  s.heap[k] = s.heap[j];
                  k = j;
                  j <<= 1;
                }
                s.heap[k] = v;
              }
              function compress_block(s, ltree, dtree) {
                var dist;
                var lc;
                var lx = 0;
                var code;
                var extra;
                if (s.last_lit !== 0) {
                  do {
                    dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                    lc = s.pending_buf[s.l_buf + lx];
                    lx++;
                    if (dist === 0) {
                      send_code(s, lc, ltree);
                    } else {
                      code = _length_code[lc];
                      send_code(s, code + LITERALS + 1, ltree);
                      extra = extra_lbits[code];
                      if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                      }
                      dist--;
                      code = d_code(dist);
                      send_code(s, code, dtree);
                      extra = extra_dbits[code];
                      if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                      }
                    }
                  } while (lx < s.last_lit);
                }
                send_code(s, END_BLOCK, ltree);
              }
              function build_tree(s, desc) {
                var tree = desc.dyn_tree;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var elems = desc.stat_desc.elems;
                var n, m;
                var max_code = -1;
                var node;
                s.heap_len = 0;
                s.heap_max = HEAP_SIZE;
                for (n = 0; n < elems; n++) {
                  if (tree[n * 2] !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;
                  } else {
                    tree[n * 2 + 1] = 0;
                  }
                }
                while (s.heap_len < 2) {
                  node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                  tree[node * 2] = 1;
                  s.depth[node] = 0;
                  s.opt_len--;
                  if (has_stree) {
                    s.static_len -= stree[node * 2 + 1];
                  }
                }
                desc.max_code = max_code;
                for (n = s.heap_len >> 1; n >= 1; n--) {
                  pqdownheap(s, tree, n);
                }
                node = elems;
                do {
                  n = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = s.heap[s.heap_len--];
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                  m = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[--s.heap_max] = n;
                  s.heap[--s.heap_max] = m;
                  tree[node * 2] = tree[n * 2] + tree[m * 2];
                  s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                  tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = node++;
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[
                  1
                  /*SMALLEST*/
                ];
                gen_bitlen(s, desc);
                gen_codes(tree, max_code, s.bl_count);
              }
              function scan_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                tree[(max_code + 1) * 2 + 1] = 65535;
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    s.bl_tree[curlen * 2] += count;
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      s.bl_tree[curlen * 2]++;
                    }
                    s.bl_tree[REP_3_6 * 2]++;
                  } else if (count <= 10) {
                    s.bl_tree[REPZ_3_10 * 2]++;
                  } else {
                    s.bl_tree[REPZ_11_138 * 2]++;
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              }
              function send_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    do {
                      send_code(s, curlen, s.bl_tree);
                    } while (--count !== 0);
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      send_code(s, curlen, s.bl_tree);
                      count--;
                    }
                    send_code(s, REP_3_6, s.bl_tree);
                    send_bits(s, count - 3, 2);
                  } else if (count <= 10) {
                    send_code(s, REPZ_3_10, s.bl_tree);
                    send_bits(s, count - 3, 3);
                  } else {
                    send_code(s, REPZ_11_138, s.bl_tree);
                    send_bits(s, count - 11, 7);
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              }
              function build_bl_tree(s) {
                var max_blindex;
                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                build_tree(s, s.bl_desc);
                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                  if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                    break;
                  }
                }
                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                return max_blindex;
              }
              function send_all_trees(s, lcodes, dcodes, blcodes) {
                var rank;
                send_bits(s, lcodes - 257, 5);
                send_bits(s, dcodes - 1, 5);
                send_bits(s, blcodes - 4, 4);
                for (rank = 0; rank < blcodes; rank++) {
                  send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
                }
                send_tree(s, s.dyn_ltree, lcodes - 1);
                send_tree(s, s.dyn_dtree, dcodes - 1);
              }
              function detect_data_type(s) {
                var black_mask = 4093624447;
                var n;
                for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                  if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                    return Z_BINARY;
                  }
                }
                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                  return Z_TEXT;
                }
                for (n = 32; n < LITERALS; n++) {
                  if (s.dyn_ltree[n * 2] !== 0) {
                    return Z_TEXT;
                  }
                }
                return Z_BINARY;
              }
              var static_init_done = false;
              function _tr_init(s) {
                if (!static_init_done) {
                  tr_static_init();
                  static_init_done = true;
                }
                s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                s.bi_buf = 0;
                s.bi_valid = 0;
                init_block(s);
              }
              function _tr_stored_block(s, buf, stored_len, last) {
                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                copy_block(s, buf, stored_len, true);
              }
              function _tr_align(s) {
                send_bits(s, STATIC_TREES << 1, 3);
                send_code(s, END_BLOCK, static_ltree);
                bi_flush(s);
              }
              function _tr_flush_block(s, buf, stored_len, last) {
                var opt_lenb, static_lenb;
                var max_blindex = 0;
                if (s.level > 0) {
                  if (s.strm.data_type === Z_UNKNOWN) {
                    s.strm.data_type = detect_data_type(s);
                  }
                  build_tree(s, s.l_desc);
                  build_tree(s, s.d_desc);
                  max_blindex = build_bl_tree(s);
                  opt_lenb = s.opt_len + 3 + 7 >>> 3;
                  static_lenb = s.static_len + 3 + 7 >>> 3;
                  if (static_lenb <= opt_lenb) {
                    opt_lenb = static_lenb;
                  }
                } else {
                  opt_lenb = static_lenb = stored_len + 5;
                }
                if (stored_len + 4 <= opt_lenb && buf !== -1) {
                  _tr_stored_block(s, buf, stored_len, last);
                } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                  send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                  compress_block(s, static_ltree, static_dtree);
                } else {
                  send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                  send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                  compress_block(s, s.dyn_ltree, s.dyn_dtree);
                }
                init_block(s);
                if (last) {
                  bi_windup(s);
                }
              }
              function _tr_tally(s, dist, lc) {
                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
                s.last_lit++;
                if (dist === 0) {
                  s.dyn_ltree[lc * 2]++;
                } else {
                  s.matches++;
                  dist--;
                  s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                  s.dyn_dtree[d_code(dist) * 2]++;
                }
                return s.last_lit === s.lit_bufsize - 1;
              }
              exports2._tr_init = _tr_init;
              exports2._tr_stored_block = _tr_stored_block;
              exports2._tr_flush_block = _tr_flush_block;
              exports2._tr_tally = _tr_tally;
              exports2._tr_align = _tr_align;
            },
            /***/
            "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"(module2) {
              function ZStream() {
                this.input = null;
                this.next_in = 0;
                this.avail_in = 0;
                this.total_in = 0;
                this.output = null;
                this.next_out = 0;
                this.avail_out = 0;
                this.total_out = 0;
                this.msg = "";
                this.state = null;
                this.data_type = 2;
                this.adler = 0;
              }
              module2.exports = ZStream;
            },
            /***/
            "./src/3Dmol.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CAP: () => (
                  /* reexport safe */
                  _GLDraw__WEBPACK_IMPORTED_MODULE_3__.CAP
                ),
                /* harmony export */
                CC: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.CC
                ),
                /* harmony export */
                CONTEXTS_PER_VIEWPORT: () => (
                  /* reexport safe */
                  _GLViewer__WEBPACK_IMPORTED_MODULE_6__.CONTEXTS_PER_VIEWPORT
                ),
                /* harmony export */
                Color: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.Color
                ),
                /* harmony export */
                CustomLinear: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.CustomLinear
                ),
                /* harmony export */
                Cylinder: () => (
                  /* reexport safe */
                  _WebGL_shapes__WEBPACK_IMPORTED_MODULE_17__.Cylinder
                ),
                /* harmony export */
                GLDraw: () => (
                  /* reexport safe */
                  _GLDraw__WEBPACK_IMPORTED_MODULE_3__.GLDraw
                ),
                /* harmony export */
                GLModel: () => (
                  /* reexport safe */
                  _GLModel__WEBPACK_IMPORTED_MODULE_4__.GLModel
                ),
                /* harmony export */
                GLShape: () => (
                  /* reexport safe */
                  _GLShape__WEBPACK_IMPORTED_MODULE_5__.GLShape
                ),
                /* harmony export */
                GLViewer: () => (
                  /* reexport safe */
                  _GLViewer__WEBPACK_IMPORTED_MODULE_6__.GLViewer
                ),
                /* harmony export */
                GLVolumetricRender: () => (
                  /* reexport safe */
                  _VolumetricRender__WEBPACK_IMPORTED_MODULE_15__.GLVolumetricRender
                ),
                /* harmony export */
                Gradient: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.Gradient
                ),
                /* harmony export */
                GradientType: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.GradientType
                ),
                /* harmony export */
                Label: () => (
                  /* reexport safe */
                  _Label__WEBPACK_IMPORTED_MODULE_8__.Label
                ),
                /* harmony export */
                LabelCount: () => (
                  /* reexport safe */
                  _Label__WEBPACK_IMPORTED_MODULE_8__.LabelCount
                ),
                /* harmony export */
                MarchingCube: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.MarchingCube
                ),
                /* harmony export */
                MarchingCubeInitializer: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.MarchingCubeInitializer
                ),
                /* harmony export */
                Matrix3: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Matrix3
                ),
                /* harmony export */
                Matrix4: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Matrix4
                ),
                /* harmony export */
                Parsers: () => (
                  /* reexport safe */
                  _parsers__WEBPACK_IMPORTED_MODULE_9__.Parsers
                ),
                /* harmony export */
                PausableTimer: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.PausableTimer
                ),
                /* harmony export */
                PointGrid: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.PointGrid
                ),
                /* harmony export */
                ProteinSurface: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.ProteinSurface
                ),
                /* harmony export */
                Quaternion: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Quaternion
                ),
                /* harmony export */
                ROYGB: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.ROYGB
                ),
                /* harmony export */
                RWB: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.RWB
                ),
                /* harmony export */
                Ray: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Ray
                ),
                /* harmony export */
                Sinebow: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.Sinebow
                ),
                /* harmony export */
                Sphere: () => (
                  /* reexport safe */
                  _WebGL_shapes__WEBPACK_IMPORTED_MODULE_17__.Sphere
                ),
                /* harmony export */
                SurfaceType: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.SurfaceType
                ),
                /* harmony export */
                Triangle: () => (
                  /* reexport safe */
                  _WebGL_shapes__WEBPACK_IMPORTED_MODULE_17__.Triangle
                ),
                /* harmony export */
                Vector2: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Vector2
                ),
                /* harmony export */
                Vector3: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.Vector3
                ),
                /* harmony export */
                VolumeData: () => (
                  /* reexport safe */
                  _VolumeData__WEBPACK_IMPORTED_MODULE_14__.VolumeData
                ),
                /* harmony export */
                adjustVolumeStyle: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.adjustVolumeStyle
                ),
                /* harmony export */
                applyPartialCharges: () => (
                  /* reexport safe */
                  _partialCharges__WEBPACK_IMPORTED_MODULE_10__.applyPartialCharges
                ),
                /* harmony export */
                autoinit: () => (
                  /* reexport safe */
                  _autoload__WEBPACK_IMPORTED_MODULE_0__.autoinit
                ),
                /* harmony export */
                autoload: () => (
                  /* reexport safe */
                  _autoload__WEBPACK_IMPORTED_MODULE_0__.autoload
                ),
                /* harmony export */
                base64ToArray: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.base64ToArray
                ),
                /* harmony export */
                bondLength: () => (
                  /* reexport safe */
                  _parsers__WEBPACK_IMPORTED_MODULE_9__.bondLength
                ),
                /* harmony export */
                builtinColorSchemes: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.builtinColorSchemes
                ),
                /* harmony export */
                builtinGradients: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.builtinGradients
                ),
                /* harmony export */
                chains: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.chains
                ),
                /* harmony export */
                clamp: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.clamp
                ),
                /* harmony export */
                conversionMatrix3: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.conversionMatrix3
                ),
                /* harmony export */
                createStereoViewer: () => (
                  /* reexport safe */
                  _GLViewer__WEBPACK_IMPORTED_MODULE_6__.createStereoViewer
                ),
                /* harmony export */
                createViewer: () => (
                  /* reexport safe */
                  _GLViewer__WEBPACK_IMPORTED_MODULE_6__.createViewer
                ),
                /* harmony export */
                createViewerGrid: () => (
                  /* reexport safe */
                  _GLViewer__WEBPACK_IMPORTED_MODULE_6__.createViewerGrid
                ),
                /* harmony export */
                deepCopy: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.deepCopy
                ),
                /* harmony export */
                degToRad: () => (
                  /* reexport safe */
                  _WebGL_math__WEBPACK_IMPORTED_MODULE_16__.degToRad
                ),
                /* harmony export */
                download: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.download
                ),
                /* harmony export */
                drawCartoon: () => (
                  /* reexport safe */
                  _glcartoon__WEBPACK_IMPORTED_MODULE_2__.drawCartoon
                ),
                /* harmony export */
                elementColors: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.elementColors
                ),
                /* harmony export */
                extend: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.extend
                ),
                /* harmony export */
                get: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.get
                ),
                /* harmony export */
                getAtomProperty: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getAtomProperty
                ),
                /* harmony export */
                getColorFromStyle: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getColorFromStyle
                ),
                /* harmony export */
                getElement: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getElement
                ),
                /* harmony export */
                getExtent: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getExtent
                ),
                /* harmony export */
                getGradient: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.getGradient
                ),
                /* harmony export */
                getPropertyRange: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getPropertyRange
                ),
                /* harmony export */
                getbin: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.getbin
                ),
                /* harmony export */
                htmlColors: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.htmlColors
                ),
                /* harmony export */
                inflateString: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.inflateString
                ),
                /* harmony export */
                isEmptyObject: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.isEmptyObject
                ),
                /* harmony export */
                isNumeric: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.isNumeric
                ),
                /* harmony export */
                makeFunction: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.makeFunction
                ),
                /* harmony export */
                mergeGeos: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.mergeGeos
                ),
                /* harmony export */
                normalizeValue: () => (
                  /* reexport safe */
                  _Gradient__WEBPACK_IMPORTED_MODULE_7__.normalizeValue
                ),
                /* harmony export */
                partialCharges: () => (
                  /* reexport safe */
                  _partialCharges__WEBPACK_IMPORTED_MODULE_10__.partialCharges
                ),
                /* harmony export */
                processing_autoinit: () => (
                  /* reexport safe */
                  _autoload__WEBPACK_IMPORTED_MODULE_0__.processing_autoinit
                ),
                /* harmony export */
                residues: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.residues
                ),
                /* harmony export */
                setBondLength: () => (
                  /* reexport safe */
                  _parsers__WEBPACK_IMPORTED_MODULE_9__.setBondLength
                ),
                /* harmony export */
                setSyncSurface: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.setSyncSurface
                ),
                /* harmony export */
                specStringToObject: () => (
                  /* reexport safe */
                  _utilities__WEBPACK_IMPORTED_MODULE_13__.specStringToObject
                ),
                /* harmony export */
                splitMesh: () => (
                  /* reexport safe */
                  _GLShape__WEBPACK_IMPORTED_MODULE_5__.splitMesh
                ),
                /* harmony export */
                ssColors: () => (
                  /* reexport safe */
                  _colors__WEBPACK_IMPORTED_MODULE_1__.ssColors
                ),
                /* harmony export */
                subdivide_spline: () => (
                  /* reexport safe */
                  _glcartoon__WEBPACK_IMPORTED_MODULE_2__.subdivide_spline
                ),
                /* harmony export */
                syncSurface: () => (
                  /* reexport safe */
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__.syncSurface
                ),
                /* harmony export */
                viewers: () => (
                  /* reexport safe */
                  _autoload__WEBPACK_IMPORTED_MODULE_0__.viewers
                )
                /* harmony export */
              });
              var _autoload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./autoload */
                "./src/autoload.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _glcartoon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./glcartoon */
                "./src/glcartoon.ts"
              );
              var _GLDraw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./GLDraw */
                "./src/GLDraw.ts"
              );
              var _GLModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./GLModel */
                "./src/GLModel.ts"
              );
              var _GLShape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./GLShape */
                "./src/GLShape.ts"
              );
              var _GLViewer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./GLViewer */
                "./src/GLViewer.ts"
              );
              var _Gradient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _Label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./Label */
                "./src/Label.ts"
              );
              var _parsers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./parsers */
                "./src/parsers/index.ts"
              );
              var _partialCharges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./partialCharges */
                "./src/partialCharges.ts"
              );
              var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                /*! ./ProteinSurface4 */
                "./src/ProteinSurface4.ts"
              );
              var _specs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                /*! ./specs */
                "./src/specs.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              var _VolumeData__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                /*! ./VolumeData */
                "./src/VolumeData.ts"
              );
              var _VolumetricRender__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__2(
                /*! ./VolumetricRender */
                "./src/VolumetricRender.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__2(
                /*! ./WebGL/shapes */
                "./src/WebGL/shapes/index.ts"
              );
            },
            /***/
            "./src/GLDraw.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CAP: () => (
                  /* binding */
                  CAP
                ),
                /* harmony export */
                GLDraw: () => (
                  /* binding */
                  GLDraw
                )
                /* harmony export */
              });
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var CAP;
              (function(CAP2) {
                CAP2[CAP2["NONE"] = 0] = "NONE";
                CAP2[CAP2["FLAT"] = 1] = "FLAT";
                CAP2[CAP2["ROUND"] = 2] = "ROUND";
              })(CAP || (CAP = {}));
              ;
              var GLDraw;
              (function(GLDraw2) {
                function getRotationMatrix(dx, dy, dz) {
                  var dxy = Math.hypot(dx, dy);
                  var dyz;
                  var sinA, cosA, sinB, cosB;
                  if (dxy < 1e-4) {
                    sinA = 0;
                    cosA = 1;
                  } else {
                    sinA = -dx / dxy;
                    cosA = dy / dxy;
                  }
                  dy = -sinA * dx + cosA * dy;
                  dyz = Math.hypot(dy, dz);
                  if (dyz < 1e-4) {
                    sinB = 0;
                    cosB = 1;
                  } else {
                    sinB = dz / dyz;
                    cosB = dy / dyz;
                  }
                  var rot = new Float32Array(9);
                  rot[0] = cosA;
                  rot[1] = sinA;
                  rot[2] = 0;
                  rot[3] = -sinA * cosB;
                  rot[4] = cosA * cosB;
                  rot[5] = sinB;
                  rot[6] = sinA * sinB;
                  rot[7] = -cosA * sinB;
                  rot[8] = cosB;
                  return rot;
                }
                ;
                class CylVertexCache {
                  constructor() {
                    this.cache = {};
                    let nvecs = [];
                    let subdivisions = 4;
                    let N = Math.pow(2, subdivisions);
                    let i = 2;
                    let M = Math.pow(2, i);
                    let spacing = N / M;
                    let j;
                    nvecs[0] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0);
                    nvecs[spacing] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
                    nvecs[spacing * 2] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);
                    nvecs[spacing * 3] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);
                    for (i = 3; i <= subdivisions; i++) {
                      M = Math.pow(2, i - 1);
                      spacing = N / M;
                      for (j = 0; j < M - 1; j++) {
                        nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[(j + 1) * spacing]).normalize();
                      }
                      j = M - 1;
                      nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[0]).normalize();
                    }
                    this.basisVectors = nvecs;
                  }
                  getVerticesForRadius(radius, cap, capType) {
                    if (typeof this.cache !== "undefined" && this.cache[radius] !== void 0) {
                      if (this.cache[radius][cap + capType] !== void 0)
                        return this.cache[radius][cap + capType];
                    }
                    var w = this.basisVectors.length;
                    var nvecs = [], norms = [];
                    var n;
                    for (var i = 0; i < w; i++) {
                      nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));
                      nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));
                      n = this.basisVectors[i].clone().normalize();
                      norms.push(n);
                      norms.push(n);
                    }
                    var verticesRows = [];
                    var heightSegments = 10, widthSegments = w;
                    if (heightSegments % 2 !== 0 || !heightSegments) {
                      console.error("heightSegments must be even");
                      return null;
                    }
                    var phiStart = 0;
                    var phiLength = Math.PI * 2;
                    var thetaStart = 0;
                    var thetaLength = Math.PI;
                    var x, y;
                    var polar = false, equator = false;
                    for (y = 0; y <= heightSegments; y++) {
                      polar = y === 0 || y === heightSegments ? true : false;
                      equator = y === heightSegments / 2 ? true : false;
                      var verticesRow = [], toRow = [];
                      for (x = 0; x <= widthSegments; x++) {
                        if (equator) {
                          var xi = x < widthSegments ? 2 * x : 0;
                          toRow.push(xi + 1);
                          verticesRow.push(xi);
                          continue;
                        }
                        var u = x / widthSegments;
                        var v = y / heightSegments;
                        if (!polar || x === 0) {
                          if (x < widthSegments) {
                            var vertex = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                            if (cap == 1)
                              vertex.y = 0;
                            else
                              vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                            if (Math.abs(vertex.x) < 1e-5)
                              vertex.x = 0;
                            if (Math.abs(vertex.y) < 1e-5)
                              vertex.y = 0;
                            if (Math.abs(vertex.z) < 1e-5)
                              vertex.z = 0;
                            if (cap == CAP.FLAT) {
                              n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, Math.cos(thetaStart + v * thetaLength), 0);
                              n.normalize();
                            } else {
                              n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(vertex.x, vertex.y, vertex.z);
                              n.normalize();
                            }
                            nvecs.push(vertex);
                            norms.push(n);
                            verticesRow.push(nvecs.length - 1);
                          } else {
                            verticesRow.push(nvecs.length - widthSegments);
                          }
                        } else if (polar)
                          verticesRow.push(nvecs.length - 1);
                      }
                      if (equator)
                        verticesRows.push(toRow);
                      verticesRows.push(verticesRow);
                    }
                    var obj = {
                      vertices: nvecs,
                      normals: norms,
                      verticesRows,
                      w: widthSegments,
                      h: heightSegments
                    };
                    if (!(radius in this.cache))
                      this.cache[radius] = {};
                    this.cache[radius][cap + capType] = obj;
                    return obj;
                  }
                }
                ;
                var cylVertexCache = new CylVertexCache();
                function drawCylinder(geo, from, to, radius, color, fromCap = 0, toCap = 0) {
                  if (!from || !to)
                    return;
                  let getcap = function(c) {
                    if (typeof c === "string") {
                      let s = c;
                      if (s.toLowerCase() == "flat") {
                        return CAP.FLAT;
                      } else if (s.toLowerCase() == "round") {
                        return CAP.ROUND;
                      } else {
                        return CAP.NONE;
                      }
                    } else {
                      return c;
                    }
                  };
                  fromCap = getcap(fromCap);
                  toCap = getcap(toCap);
                  var drawcaps = toCap || fromCap;
                  color = color || { r: 0, g: 0, b: 0 };
                  var e = getRotationMatrix(to.x - from.x, to.y - from.y, to.z - from.z);
                  var vobj = cylVertexCache.getVerticesForRadius(radius, toCap, "to");
                  var n = vobj.w, h = vobj.h;
                  var n_verts = drawcaps ? h * n + 2 : 2 * n;
                  var geoGroup = geo.updateGeoGroup(n_verts);
                  var vertices = vobj.vertices, normals = vobj.normals, verticesRows = vobj.verticesRows;
                  var toRow = verticesRows[h / 2], fromRow = verticesRows[h / 2 + 1];
                  var start = geoGroup.vertices;
                  var offset, faceoffset;
                  var i, x, y, z;
                  var vertexArray = geoGroup.vertexArray;
                  var normalArray = geoGroup.normalArray;
                  var colorArray = geoGroup.colorArray;
                  var faceArray = geoGroup.faceArray;
                  for (i = 0; i < n; ++i) {
                    var vi = 2 * i;
                    x = e[0] * vertices[vi].x + e[3] * vertices[vi].y + e[6] * vertices[vi].z;
                    y = e[1] * vertices[vi].x + e[4] * vertices[vi].y + e[7] * vertices[vi].z;
                    z = e[5] * vertices[vi].y + e[8] * vertices[vi].z;
                    offset = 3 * (start + vi);
                    faceoffset = geoGroup.faceidx;
                    vertexArray[offset] = x + from.x;
                    vertexArray[offset + 1] = y + from.y;
                    vertexArray[offset + 2] = z + from.z;
                    vertexArray[offset + 3] = x + to.x;
                    vertexArray[offset + 4] = y + to.y;
                    vertexArray[offset + 5] = z + to.z;
                    normalArray[offset] = x;
                    normalArray[offset + 3] = x;
                    normalArray[offset + 1] = y;
                    normalArray[offset + 4] = y;
                    normalArray[offset + 2] = z;
                    normalArray[offset + 5] = z;
                    colorArray[offset] = color.r;
                    colorArray[offset + 3] = color.r;
                    colorArray[offset + 1] = color.g;
                    colorArray[offset + 4] = color.g;
                    colorArray[offset + 2] = color.b;
                    colorArray[offset + 5] = color.b;
                    faceArray[faceoffset] = fromRow[i] + start;
                    faceArray[faceoffset + 1] = fromRow[i + 1] + start;
                    faceArray[faceoffset + 2] = toRow[i] + start;
                    faceArray[faceoffset + 3] = toRow[i] + start;
                    faceArray[faceoffset + 4] = fromRow[i + 1] + start;
                    faceArray[faceoffset + 5] = toRow[i + 1] + start;
                    geoGroup.faceidx += 6;
                  }
                  if (drawcaps) {
                    var ystart = toCap ? 0 : h / 2;
                    var yend = fromCap ? h + 1 : h / 2 + 1;
                    var v1, v2, v3, v4, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, nx1, nx2, nx3, nx4, ny1, ny2, ny3, ny4, nz1, nz2, nz3, nz4, v1offset, v2offset, v3offset, v4offset;
                    for (y = ystart; y < yend; y++) {
                      if (y === h / 2)
                        continue;
                      var cap = y <= h / 2 ? to : from;
                      var toObj = cylVertexCache.getVerticesForRadius(radius, toCap, "to");
                      var fromObj = cylVertexCache.getVerticesForRadius(radius, fromCap, "from");
                      if (cap === to) {
                        vertices = toObj.vertices;
                        normals = toObj.normals;
                        verticesRows = toObj.verticesRows;
                      } else if (cap == from) {
                        vertices = fromObj.vertices;
                        normals = fromObj.normals;
                        verticesRows = fromObj.verticesRows;
                      }
                      for (x = 0; x < n; x++) {
                        faceoffset = geoGroup.faceidx;
                        v1 = verticesRows[y][x + 1];
                        v1offset = (v1 + start) * 3;
                        v2 = verticesRows[y][x];
                        v2offset = (v2 + start) * 3;
                        v3 = verticesRows[y + 1][x];
                        v3offset = (v3 + start) * 3;
                        v4 = verticesRows[y + 1][x + 1];
                        v4offset = (v4 + start) * 3;
                        x1 = e[0] * vertices[v1].x + e[3] * vertices[v1].y + e[6] * vertices[v1].z;
                        x2 = e[0] * vertices[v2].x + e[3] * vertices[v2].y + e[6] * vertices[v2].z;
                        x3 = e[0] * vertices[v3].x + e[3] * vertices[v3].y + e[6] * vertices[v3].z;
                        x4 = e[0] * vertices[v4].x + e[3] * vertices[v4].y + e[6] * vertices[v4].z;
                        y1 = e[1] * vertices[v1].x + e[4] * vertices[v1].y + e[7] * vertices[v1].z;
                        y2 = e[1] * vertices[v2].x + e[4] * vertices[v2].y + e[7] * vertices[v2].z;
                        y3 = e[1] * vertices[v3].x + e[4] * vertices[v3].y + e[7] * vertices[v3].z;
                        y4 = e[1] * vertices[v4].x + e[4] * vertices[v4].y + e[7] * vertices[v4].z;
                        z1 = e[5] * vertices[v1].y + e[8] * vertices[v1].z;
                        z2 = e[5] * vertices[v2].y + e[8] * vertices[v2].z;
                        z3 = e[5] * vertices[v3].y + e[8] * vertices[v3].z;
                        z4 = e[5] * vertices[v4].y + e[8] * vertices[v4].z;
                        vertexArray[v1offset] = x1 + cap.x;
                        vertexArray[v2offset] = x2 + cap.x;
                        vertexArray[v3offset] = x3 + cap.x;
                        vertexArray[v4offset] = x4 + cap.x;
                        vertexArray[v1offset + 1] = y1 + cap.y;
                        vertexArray[v2offset + 1] = y2 + cap.y;
                        vertexArray[v3offset + 1] = y3 + cap.y;
                        vertexArray[v4offset + 1] = y4 + cap.y;
                        vertexArray[v1offset + 2] = z1 + cap.z;
                        vertexArray[v2offset + 2] = z2 + cap.z;
                        vertexArray[v3offset + 2] = z3 + cap.z;
                        vertexArray[v4offset + 2] = z4 + cap.z;
                        colorArray[v1offset] = color.r;
                        colorArray[v2offset] = color.r;
                        colorArray[v3offset] = color.r;
                        colorArray[v4offset] = color.r;
                        colorArray[v1offset + 1] = color.g;
                        colorArray[v2offset + 1] = color.g;
                        colorArray[v3offset + 1] = color.g;
                        colorArray[v4offset + 1] = color.g;
                        colorArray[v1offset + 2] = color.b;
                        colorArray[v2offset + 2] = color.b;
                        colorArray[v3offset + 2] = color.b;
                        colorArray[v4offset + 2] = color.b;
                        nx1 = e[0] * normals[v1].x + e[3] * normals[v1].y + e[6] * normals[v1].z;
                        nx2 = e[0] * normals[v2].x + e[3] * normals[v2].y + e[6] * normals[v2].z;
                        nx3 = e[0] * normals[v3].x + e[3] * normals[v3].y + e[6] * normals[v3].z;
                        nx4 = e[0] * normals[v4].x + e[3] * normals[v4].y + e[6] * normals[v4].z;
                        ny1 = e[1] * normals[v1].x + e[4] * normals[v1].y + e[7] * normals[v1].z;
                        ny2 = e[1] * normals[v2].x + e[4] * normals[v2].y + e[7] * normals[v2].z;
                        ny3 = e[1] * normals[v3].x + e[4] * normals[v3].y + e[7] * normals[v3].z;
                        ny4 = e[1] * normals[v4].x + e[4] * normals[v4].y + e[7] * normals[v4].z;
                        nz1 = e[5] * normals[v1].y + e[8] * normals[v1].z;
                        nz2 = e[5] * normals[v2].y + e[8] * normals[v2].z;
                        nz3 = e[5] * normals[v3].y + e[8] * normals[v3].z;
                        nz4 = e[5] * normals[v4].y + e[8] * normals[v4].z;
                        if (y === 0) {
                          normalArray[v1offset] = nx1;
                          normalArray[v3offset] = nx3;
                          normalArray[v4offset] = nx4;
                          normalArray[v1offset + 1] = ny1;
                          normalArray[v3offset + 1] = ny3;
                          normalArray[v4offset + 1] = ny4;
                          normalArray[v1offset + 2] = nz1;
                          normalArray[v3offset + 2] = nz3;
                          normalArray[v4offset + 2] = nz4;
                          faceArray[faceoffset] = v1 + start;
                          faceArray[faceoffset + 1] = v3 + start;
                          faceArray[faceoffset + 2] = v4 + start;
                          geoGroup.faceidx += 3;
                        } else if (y === yend - 1) {
                          normalArray[v1offset] = nx1;
                          normalArray[v2offset] = nx2;
                          normalArray[v3offset] = nx3;
                          normalArray[v1offset + 1] = ny1;
                          normalArray[v2offset + 1] = ny2;
                          normalArray[v3offset + 1] = ny3;
                          normalArray[v1offset + 2] = nz1;
                          normalArray[v2offset + 2] = nz2;
                          normalArray[v3offset + 2] = nz3;
                          faceArray[faceoffset] = v1 + start;
                          faceArray[faceoffset + 1] = v2 + start;
                          faceArray[faceoffset + 2] = v3 + start;
                          geoGroup.faceidx += 3;
                        } else {
                          normalArray[v1offset] = nx1;
                          normalArray[v2offset] = nx2;
                          normalArray[v4offset] = nx4;
                          normalArray[v1offset + 1] = ny1;
                          normalArray[v2offset + 1] = ny2;
                          normalArray[v4offset + 1] = ny4;
                          normalArray[v1offset + 2] = nz1;
                          normalArray[v2offset + 2] = nz2;
                          normalArray[v4offset + 2] = nz4;
                          normalArray[v2offset] = nx2;
                          normalArray[v3offset] = nx3;
                          normalArray[v4offset] = nx4;
                          normalArray[v2offset + 1] = ny2;
                          normalArray[v3offset + 1] = ny3;
                          normalArray[v4offset + 1] = ny4;
                          normalArray[v2offset + 2] = nz2;
                          normalArray[v3offset + 2] = nz3;
                          normalArray[v4offset + 2] = nz4;
                          faceArray[faceoffset] = v1 + start;
                          faceArray[faceoffset + 1] = v2 + start;
                          faceArray[faceoffset + 2] = v4 + start;
                          faceArray[faceoffset + 3] = v2 + start;
                          faceArray[faceoffset + 4] = v3 + start;
                          faceArray[faceoffset + 5] = v4 + start;
                          geoGroup.faceidx += 6;
                        }
                      }
                    }
                  }
                  geoGroup.vertices += n_verts;
                }
                GLDraw2.drawCylinder = drawCylinder;
                ;
                function drawCone(geo, from, to, radius, color) {
                  if (!from || !to)
                    return;
                  color = color || { r: 0, g: 0, b: 0 };
                  let ndir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(to.x - from.x, to.y - from.y, to.z - from.z);
                  var e = getRotationMatrix(ndir.x, ndir.y, ndir.z);
                  ndir = ndir.normalize();
                  var n = cylVertexCache.basisVectors.length;
                  var basis = cylVertexCache.basisVectors;
                  var n_verts = n + 2;
                  var geoGroup = geo.updateGeoGroup(n_verts);
                  var start = geoGroup.vertices;
                  var offset, faceoffset;
                  var i, x, y, z;
                  var vertexArray = geoGroup.vertexArray;
                  var normalArray = geoGroup.normalArray;
                  var colorArray = geoGroup.colorArray;
                  var faceArray = geoGroup.faceArray;
                  offset = start * 3;
                  vertexArray[offset] = from.x;
                  vertexArray[offset + 1] = from.y;
                  vertexArray[offset + 2] = from.z;
                  normalArray[offset] = -ndir.x;
                  normalArray[offset + 1] = -ndir.y;
                  normalArray[offset + 2] = -ndir.z;
                  colorArray[offset] = color.r;
                  colorArray[offset + 1] = color.g;
                  colorArray[offset + 2] = color.b;
                  vertexArray[offset + 3] = to.x;
                  vertexArray[offset + 4] = to.y;
                  vertexArray[offset + 5] = to.z;
                  normalArray[offset + 3] = ndir.x;
                  normalArray[offset + 4] = ndir.y;
                  normalArray[offset + 5] = ndir.z;
                  colorArray[offset + 3] = color.r;
                  colorArray[offset + 4] = color.g;
                  colorArray[offset + 5] = color.b;
                  offset += 6;
                  for (i = 0; i < n; ++i) {
                    var vec = basis[i].clone();
                    vec.multiplyScalar(radius);
                    x = e[0] * vec.x + e[3] * vec.y + e[6] * vec.z;
                    y = e[1] * vec.x + e[4] * vec.y + e[7] * vec.z;
                    z = e[5] * vec.y + e[8] * vec.z;
                    vertexArray[offset] = x + from.x;
                    vertexArray[offset + 1] = y + from.y;
                    vertexArray[offset + 2] = z + from.z;
                    normalArray[offset] = x;
                    normalArray[offset + 1] = y;
                    normalArray[offset + 2] = z;
                    colorArray[offset] = color.r;
                    colorArray[offset + 1] = color.g;
                    colorArray[offset + 2] = color.b;
                    offset += 3;
                  }
                  geoGroup.vertices += n + 2;
                  faceoffset = geoGroup.faceidx;
                  for (i = 0; i < n; i++) {
                    var v1 = start + 2 + i;
                    var v2 = start + 2 + (i + 1) % n;
                    faceArray[faceoffset] = v1;
                    faceArray[faceoffset + 1] = v2;
                    faceArray[faceoffset + 2] = start;
                    faceoffset += 3;
                    faceArray[faceoffset] = v1;
                    faceArray[faceoffset + 1] = v2;
                    faceArray[faceoffset + 2] = start + 1;
                    faceoffset += 3;
                  }
                  geoGroup.faceidx += 6 * n;
                }
                GLDraw2.drawCone = drawCone;
                ;
                class SphereVertexCache {
                  constructor() {
                    this.cache = /* @__PURE__ */ new Map();
                  }
                  getVerticesForRadius(radius, sphereQuality) {
                    sphereQuality = sphereQuality || 2;
                    if (!this.cache.has(sphereQuality)) {
                      this.cache.set(sphereQuality, /* @__PURE__ */ new Map());
                    }
                    let radiusCache = this.cache.get(sphereQuality);
                    if (radiusCache.has(radius))
                      return radiusCache.get(radius);
                    var obj = {
                      vertices: [],
                      verticesRows: [],
                      normals: []
                    };
                    var widthSegments = 16 * sphereQuality;
                    var heightSegments = 10 * sphereQuality;
                    if (radius < 1) {
                      widthSegments = 10 * sphereQuality;
                      heightSegments = 8 * sphereQuality;
                    }
                    var phiStart = 0;
                    var phiLength = Math.PI * 2;
                    var thetaStart = 0;
                    var thetaLength = Math.PI;
                    var x, y;
                    for (y = 0; y <= heightSegments; y++) {
                      let verticesRow = [];
                      for (x = 0; x <= widthSegments; x++) {
                        let u = x / widthSegments;
                        let v = y / heightSegments;
                        let vx = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                        let vy = radius * Math.cos(thetaStart + v * thetaLength);
                        let vz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                        var n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(vx, vy, vz);
                        n.normalize();
                        obj.vertices.push({ x: vx, y: vy, z: vz });
                        obj.normals.push(n);
                        verticesRow.push(obj.vertices.length - 1);
                      }
                      obj.verticesRows.push(verticesRow);
                    }
                    radiusCache.set(radius, obj);
                    return obj;
                  }
                }
                ;
                var sphereVertexCache = new SphereVertexCache();
                function drawSphere(geo, pos, radius, color, sphereQuality) {
                  var vobj = sphereVertexCache.getVerticesForRadius(radius, sphereQuality);
                  var vertices = vobj.vertices;
                  var normals = vobj.normals;
                  var geoGroup = geo.updateGeoGroup(vertices.length);
                  var start = geoGroup.vertices;
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  var faceArray = geoGroup.faceArray;
                  var lineArray = geoGroup.lineArray;
                  var normalArray = geoGroup.normalArray;
                  for (let i = 0, il = vertices.length; i < il; ++i) {
                    let offset = 3 * (start + i);
                    let v = vertices[i];
                    vertexArray[offset] = v.x + pos.x;
                    vertexArray[offset + 1] = v.y + pos.y;
                    vertexArray[offset + 2] = v.z + pos.z;
                    colorArray[offset] = color.r;
                    colorArray[offset + 1] = color.g;
                    colorArray[offset + 2] = color.b;
                  }
                  geoGroup.vertices += vertices.length;
                  let verticesRows = vobj.verticesRows;
                  let h = verticesRows.length - 1;
                  for (let y = 0; y < h; y++) {
                    let w = verticesRows[y].length - 1;
                    for (let x = 0; x < w; x++) {
                      let faceoffset = geoGroup.faceidx, lineoffset = geoGroup.lineidx;
                      let v1 = verticesRows[y][x + 1] + start, v1offset = v1 * 3;
                      let v2 = verticesRows[y][x] + start, v2offset = v2 * 3;
                      let v3 = verticesRows[y + 1][x] + start, v3offset = v3 * 3;
                      let v4 = verticesRows[y + 1][x + 1] + start, v4offset = v4 * 3;
                      let n1 = normals[v1 - start];
                      let n2 = normals[v2 - start];
                      let n3 = normals[v3 - start];
                      let n4 = normals[v4 - start];
                      if (Math.abs(vertices[v1 - start].y) === radius) {
                        normalArray[v1offset] = n1.x;
                        normalArray[v3offset] = n3.x;
                        normalArray[v4offset] = n4.x;
                        normalArray[v1offset + 1] = n1.y;
                        normalArray[v3offset + 1] = n3.y;
                        normalArray[v4offset + 1] = n4.y;
                        normalArray[v1offset + 2] = n1.z;
                        normalArray[v3offset + 2] = n3.z;
                        normalArray[v4offset + 2] = n4.z;
                        faceArray[faceoffset] = v1;
                        faceArray[faceoffset + 1] = v3;
                        faceArray[faceoffset + 2] = v4;
                        lineArray[lineoffset] = v1;
                        lineArray[lineoffset + 1] = v3;
                        lineArray[lineoffset + 2] = v1;
                        lineArray[lineoffset + 3] = v4;
                        lineArray[lineoffset + 4] = v3;
                        lineArray[lineoffset + 5] = v4;
                        geoGroup.faceidx += 3;
                        geoGroup.lineidx += 6;
                      } else if (Math.abs(vertices[v3 - start].y) === radius) {
                        normalArray[v1offset] = n1.x;
                        normalArray[v2offset] = n2.x;
                        normalArray[v3offset] = n3.x;
                        normalArray[v1offset + 1] = n1.y;
                        normalArray[v2offset + 1] = n2.y;
                        normalArray[v3offset + 1] = n3.y;
                        normalArray[v1offset + 2] = n1.z;
                        normalArray[v2offset + 2] = n2.z;
                        normalArray[v3offset + 2] = n3.z;
                        faceArray[faceoffset] = v1;
                        faceArray[faceoffset + 1] = v2;
                        faceArray[faceoffset + 2] = v3;
                        lineArray[lineoffset] = v1;
                        lineArray[lineoffset + 1] = v2;
                        lineArray[lineoffset + 2] = v1;
                        lineArray[lineoffset + 3] = v3;
                        lineArray[lineoffset + 4] = v2;
                        lineArray[lineoffset + 5] = v3;
                        geoGroup.faceidx += 3;
                        geoGroup.lineidx += 6;
                      } else {
                        normalArray[v1offset] = n1.x;
                        normalArray[v2offset] = n2.x;
                        normalArray[v4offset] = n4.x;
                        normalArray[v1offset + 1] = n1.y;
                        normalArray[v2offset + 1] = n2.y;
                        normalArray[v4offset + 1] = n4.y;
                        normalArray[v1offset + 2] = n1.z;
                        normalArray[v2offset + 2] = n2.z;
                        normalArray[v4offset + 2] = n4.z;
                        normalArray[v2offset] = n2.x;
                        normalArray[v3offset] = n3.x;
                        normalArray[v4offset] = n4.x;
                        normalArray[v2offset + 1] = n2.y;
                        normalArray[v3offset + 1] = n3.y;
                        normalArray[v4offset + 1] = n4.y;
                        normalArray[v2offset + 2] = n2.z;
                        normalArray[v3offset + 2] = n3.z;
                        normalArray[v4offset + 2] = n4.z;
                        faceArray[faceoffset] = v1;
                        faceArray[faceoffset + 1] = v2;
                        faceArray[faceoffset + 2] = v4;
                        faceArray[faceoffset + 3] = v2;
                        faceArray[faceoffset + 4] = v3;
                        faceArray[faceoffset + 5] = v4;
                        lineArray[lineoffset] = v1;
                        lineArray[lineoffset + 1] = v2;
                        lineArray[lineoffset + 2] = v1;
                        lineArray[lineoffset + 3] = v4;
                        lineArray[lineoffset + 4] = v2;
                        lineArray[lineoffset + 5] = v3;
                        lineArray[lineoffset + 6] = v3;
                        lineArray[lineoffset + 7] = v4;
                        geoGroup.faceidx += 6;
                        geoGroup.lineidx += 8;
                      }
                    }
                  }
                }
                GLDraw2.drawSphere = drawSphere;
                ;
              })(GLDraw || (GLDraw = {}));
            },
            /***/
            "./src/GLModel.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                GLModel: () => (
                  /* binding */
                  GLModel
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./WebGL/shapes */
                "./src/WebGL/shapes/index.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _GLDraw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./GLDraw */
                "./src/GLDraw.ts"
              );
              var _glcartoon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./glcartoon */
                "./src/glcartoon.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              var _Gradient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _parsers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./parsers */
                "./src/parsers/index.ts"
              );
              var netcdfjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! netcdfjs */
                "./node_modules/netcdfjs/lib-esm/index.js"
              );
              var _parsers_utils_assignBonds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./parsers/utils/assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              class GLModel {
                // class functions
                // return true if a and b represent the same style
                static sameObj(a, b) {
                  if (a && b)
                    return JSON.stringify(a) == JSON.stringify(b);
                  else
                    return a == b;
                }
                constructor(mid, options, viewer) {
                  this.atoms = [];
                  this.frames = [];
                  this.box = null;
                  this.atomdfs = null;
                  this.id = 0;
                  this.hidden = false;
                  this.molObj = null;
                  this.renderedMolObj = null;
                  this.lastColors = null;
                  this.modelData = {};
                  this.modelDatas = null;
                  this.idMatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
                  this.dontDuplicateAtoms = true;
                  this.defaultColor = _colors__WEBPACK_IMPORTED_MODULE_3__.elementColors.defaultColor;
                  this.defaultStickRadius = 0.25;
                  this.options = options || {};
                  this.viewer = viewer;
                  this.ElementColors = this.options.defaultcolors ? this.options.defaultcolors : _colors__WEBPACK_IMPORTED_MODULE_3__.elementColors.defaultColors;
                  this.defaultSphereRadius = this.options.defaultSphereRadius ? this.options.defaultSphereRadius : 1.5;
                  this.defaultCartoonQuality = this.options.cartoonQuality ? this.options.cartoonQuality : 10;
                  this.id = mid;
                }
                // return proper radius for atom given style
                /**
                 *
                 * @param {AtomSpec} atom
                 * @param {atomstyle} style
                 * @return {number}
                 *
                 */
                getRadiusFromStyle(atom, style) {
                  var r = this.defaultSphereRadius;
                  if (typeof style.radius != "undefined")
                    r = style.radius;
                  else if (GLModel.vdwRadii[atom.elem])
                    r = GLModel.vdwRadii[atom.elem];
                  else if (atom.elem.length > 1) {
                    let e = atom.elem;
                    e = e[0].toUpperCase() + e[1].toLowerCase();
                    if (GLModel.vdwRadii[e])
                      r = GLModel.vdwRadii[e];
                  }
                  if (typeof style.scale != "undefined")
                    r *= style.scale;
                  return r;
                }
                // cross drawing
                /**
                 *
                 * @param {AtomSpec} atom
                 * @param {Record<number, Geometry>} geos
                 */
                drawAtomCross(atom, geos) {
                  if (!atom.style.cross)
                    return;
                  var style = atom.style.cross;
                  if (style.hidden)
                    return;
                  var linewidth = style.linewidth || GLModel.defaultlineWidth;
                  if (!geos[linewidth])
                    geos[linewidth] = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry();
                  var geoGroup = geos[linewidth].updateGeoGroup(6);
                  var delta = this.getRadiusFromStyle(atom, style);
                  var points = [
                    [delta, 0, 0],
                    [-delta, 0, 0],
                    [0, delta, 0],
                    [0, -delta, 0],
                    [0, 0, delta],
                    [0, 0, -delta]
                  ];
                  var clickable = atom.clickable || atom.hoverable;
                  if (clickable && atom.intersectionShape === void 0)
                    atom.intersectionShape = { sphere: [], cylinder: [], line: [] };
                  var c = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  for (var j = 0; j < 6; j++) {
                    var offset = geoGroup.vertices * 3;
                    geoGroup.vertices++;
                    vertexArray[offset] = atom.x + points[j][0];
                    vertexArray[offset + 1] = atom.y + points[j][1];
                    vertexArray[offset + 2] = atom.z + points[j][2];
                    colorArray[offset] = c.r;
                    colorArray[offset + 1] = c.g;
                    colorArray[offset + 2] = c.b;
                    if (clickable) {
                      var point = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(points[j][0], points[j][1], points[j][2]);
                      point.multiplyScalar(0.1);
                      point.set(point.x + atom.x, point.y + atom.y, point.z + atom.z);
                      atom.intersectionShape.line.push(point);
                    }
                  }
                }
                getGoodCross(atom, atom2, p1, dir) {
                  var bestv = null;
                  var bestlen = -1;
                  for (var j = 0, n = atom.bonds.length; j < n; j++) {
                    if (atom.bonds[j] != atom2.index) {
                      let j2 = atom.bonds[j];
                      let atom3 = this.atoms[j2];
                      let p3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom3.x, atom3.y, atom3.z);
                      let dir2 = p3.clone();
                      dir2.sub(p1);
                      let v = dir2.clone();
                      v.cross(dir);
                      var l = v.lengthSq();
                      if (l > bestlen) {
                        bestlen = l;
                        bestv = v;
                        if (bestlen > 0.1) {
                          return bestv;
                        }
                      }
                    }
                  }
                  return bestv;
                }
                //from atom, return a normalized vector v that is orthogonal and along which
                //it is appropraite to draw multiple bonds
                getSideBondV(atom, atom2, i) {
                  var i2, j2, atom3, p3, dir2;
                  var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                  var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);
                  var dir = p2.clone();
                  var v = null;
                  dir.sub(p1);
                  if (atom.bonds.length === 1) {
                    if (atom2.bonds.length === 1) {
                      v = dir.clone();
                      if (Math.abs(v.x) > 1e-4)
                        v.y += 1;
                      else
                        v.x += 1;
                    } else {
                      atom3 = null;
                      for (i2 = 0; i2 < atom2.bonds.length; i2++) {
                        j2 = atom2.bonds[i2];
                        if (j2 !== atom.index) {
                          atom3 = this.atoms[j2];
                          break;
                        }
                      }
                      if (!atom3) {
                        v = dir.clone();
                        v.x += 1;
                      } else {
                        p3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom3.x, atom3.y, atom3.z);
                        dir2 = p3.clone();
                        dir2.sub(p1);
                        v = dir2.clone();
                        v.cross(dir);
                      }
                    }
                  } else {
                    v = this.getGoodCross(atom, atom2, p1, dir);
                    if (v.lengthSq() < 0.01) {
                      var v2 = this.getGoodCross(atom2, atom, p1, dir);
                      if (v2 != null)
                        v = v2;
                    }
                  }
                  if (v.lengthSq() < 0.01) {
                    v = dir.clone();
                    if (Math.abs(v.x) > 1e-4)
                      v.y += 1;
                    else
                      v.x += 1;
                  }
                  v.cross(dir);
                  v.normalize();
                  return v;
                }
                addLine(vertexArray, colorArray, offset, p1, p2, c1) {
                  vertexArray[offset] = p1.x;
                  vertexArray[offset + 1] = p1.y;
                  vertexArray[offset + 2] = p1.z;
                  colorArray[offset] = c1.r;
                  colorArray[offset + 1] = c1.g;
                  colorArray[offset + 2] = c1.b;
                  vertexArray[offset + 3] = p2.x;
                  vertexArray[offset + 4] = p2.y;
                  vertexArray[offset + 5] = p2.z;
                  colorArray[offset + 3] = c1.r;
                  colorArray[offset + 4] = c1.g;
                  colorArray[offset + 5] = c1.b;
                }
                // bonds - both atoms must match bond style
                // standardize on only drawing for lowest to highest
                /**
                 *
                 * @param {AtomSpec}
                 *            atom
                 * @param {AtomSpec[]} atoms
                 * @param {Record<number,Geometry>} geos
                 */
                drawBondLines(atom, atoms, geos) {
                  if (!atom.style.line)
                    return;
                  var style = atom.style.line;
                  if (style.hidden)
                    return;
                  var p1a, p1b, p2a, p2b;
                  var linewidth = style.linewidth || GLModel.defaultlineWidth;
                  if (!geos[linewidth])
                    geos[linewidth] = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry();
                  var geoGroup = geos[linewidth].updateGeoGroup(6 * atom.bonds.length);
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  for (var i = 0; i < atom.bonds.length; i++) {
                    var j = atom.bonds[i];
                    var atom2 = atoms[j];
                    if (!atom2.style.line)
                      continue;
                    if (atom.index >= atom2.index)
                      continue;
                    var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                    var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);
                    var mp = p1.clone().add(p2).multiplyScalar(0.5);
                    var singleBond = false;
                    var atomneedsi = atom.clickable || atom.hoverable;
                    var atom2needsi = atom2.clickable || atom2.hoverable;
                    if (atomneedsi || atom2needsi) {
                      if (atomneedsi) {
                        if (atom.intersectionShape === void 0)
                          atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                        atom.intersectionShape.line.push(p1);
                        atom.intersectionShape.line.push(mp);
                      }
                      if (atom2needsi) {
                        if (atom2.intersectionShape === void 0)
                          atom2.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                        atom2.intersectionShape.line.push(mp);
                        atom2.intersectionShape.line.push(p2);
                      }
                    }
                    var c1 = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, atom.style.line);
                    var c2 = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom2, atom2.style.line);
                    if (atom.bondStyles && atom.bondStyles[i]) {
                      var bstyle = atom.bondStyles[i];
                      if (!bstyle.iswire) {
                        continue;
                      }
                      if (bstyle.singleBond)
                        singleBond = true;
                      if (typeof bstyle.color1 != "undefined") {
                        c1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color1);
                      }
                      if (typeof bstyle.color2 != "undefined") {
                        c2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color2);
                      }
                    }
                    var offset = geoGroup.vertices * 3;
                    var mpa, mpb;
                    if (atom.bondOrder[i] > 1 && atom.bondOrder[i] < 4 && !singleBond) {
                      var v = this.getSideBondV(atom, atom2, i);
                      var dir = p2.clone();
                      dir.sub(p1);
                      if (atom.bondOrder[i] == 2) {
                        v.multiplyScalar(0.1);
                        p1a = p1.clone();
                        p1a.add(v);
                        p1b = p1.clone();
                        p1b.sub(v);
                        p2a = p1a.clone();
                        p2a.add(dir);
                        p2b = p1b.clone();
                        p2b.add(dir);
                        if (c1 == c2) {
                          geoGroup.vertices += 4;
                          this.addLine(vertexArray, colorArray, offset, p1a, p2a, c1);
                          this.addLine(vertexArray, colorArray, offset + 6, p1b, p2b, c1);
                        } else {
                          geoGroup.vertices += 8;
                          dir.multiplyScalar(0.5);
                          mpa = p1a.clone();
                          mpa.add(dir);
                          mpb = p1b.clone();
                          mpb.add(dir);
                          this.addLine(vertexArray, colorArray, offset, p1a, mpa, c1);
                          this.addLine(vertexArray, colorArray, offset + 6, mpa, p2a, c2);
                          this.addLine(vertexArray, colorArray, offset + 12, p1b, mpb, c1);
                          this.addLine(vertexArray, colorArray, offset + 18, mpb, p2b, c2);
                        }
                      } else if (atom.bondOrder[i] == 3) {
                        v.multiplyScalar(0.1);
                        p1a = p1.clone();
                        p1a.add(v);
                        p1b = p1.clone();
                        p1b.sub(v);
                        p2a = p1a.clone();
                        p2a.add(dir);
                        p2b = p1b.clone();
                        p2b.add(dir);
                        if (c1 == c2) {
                          geoGroup.vertices += 6;
                          this.addLine(vertexArray, colorArray, offset, p1, p2, c1);
                          this.addLine(vertexArray, colorArray, offset + 6, p1a, p2a, c1);
                          this.addLine(vertexArray, colorArray, offset + 12, p1b, p2b, c1);
                        } else {
                          geoGroup.vertices += 12;
                          dir.multiplyScalar(0.5);
                          mpa = p1a.clone();
                          mpa.add(dir);
                          mpb = p1b.clone();
                          mpb.add(dir);
                          this.addLine(vertexArray, colorArray, offset, p1, mp, c1);
                          this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);
                          this.addLine(vertexArray, colorArray, offset + 12, p1a, mpa, c1);
                          this.addLine(vertexArray, colorArray, offset + 18, mpa, p2a, c2);
                          this.addLine(vertexArray, colorArray, offset + 24, p1b, mpb, c1);
                          this.addLine(vertexArray, colorArray, offset + 30, mpb, p2b, c2);
                        }
                      }
                    } else {
                      if (c1 == c2) {
                        geoGroup.vertices += 2;
                        this.addLine(vertexArray, colorArray, offset, p1, p2, c1);
                      } else {
                        geoGroup.vertices += 4;
                        this.addLine(vertexArray, colorArray, offset, p1, mp, c1);
                        this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);
                      }
                    }
                  }
                }
                //sphere drawing
                //See also: drawCylinder
                /**
                 *
                 * @param {AtomSpec} atom
                 * @param {Geometry} geo
                 */
                drawAtomSphere(atom, geo) {
                  if (!atom.style.sphere)
                    return;
                  var style = atom.style.sphere;
                  if (style.hidden)
                    return;
                  var C = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);
                  var radius = this.getRadiusFromStyle(atom, style);
                  if ((atom.clickable === true || atom.hoverable) && atom.intersectionShape !== void 0) {
                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                    atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));
                  }
                  _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(geo, atom, radius, C);
                }
                /** Register atom shaped click handlers */
                drawAtomClickSphere(atom) {
                  if (!atom.style.clicksphere)
                    return;
                  var style = atom.style.clicksphere;
                  if (style.hidden)
                    return;
                  var radius = this.getRadiusFromStyle(atom, style);
                  if ((atom.clickable === true || atom.hoverable) && atom.intersectionShape !== void 0) {
                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                    atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));
                  }
                }
                drawAtomInstanced(atom, geo) {
                  if (!atom.style.sphere)
                    return;
                  var style = atom.style.sphere;
                  if (style.hidden)
                    return;
                  var radius = this.getRadiusFromStyle(atom, style);
                  var C = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);
                  var geoGroup = geo.updateGeoGroup(1);
                  var startv = geoGroup.vertices;
                  var start = startv * 3;
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  var radiusArray = geoGroup.radiusArray;
                  vertexArray[start] = atom.x;
                  vertexArray[start + 1] = atom.y;
                  vertexArray[start + 2] = atom.z;
                  colorArray[start] = C.r;
                  colorArray[start + 1] = C.g;
                  colorArray[start + 2] = C.b;
                  radiusArray[startv] = radius;
                  if ((atom.clickable === true || atom.hoverable) && atom.intersectionShape !== void 0) {
                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                    atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));
                  }
                  geoGroup.vertices += 1;
                }
                drawSphereImposter(geo, center, radius, C) {
                  var geoGroup = geo.updateGeoGroup(4);
                  var i;
                  var startv = geoGroup.vertices;
                  var start = startv * 3;
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  for (i = 0; i < 4; i++) {
                    vertexArray[start + 3 * i] = center.x;
                    vertexArray[start + 3 * i + 1] = center.y;
                    vertexArray[start + 3 * i + 2] = center.z;
                  }
                  var normalArray = geoGroup.normalArray;
                  for (i = 0; i < 4; i++) {
                    colorArray[start + 3 * i] = C.r;
                    colorArray[start + 3 * i + 1] = C.g;
                    colorArray[start + 3 * i + 2] = C.b;
                  }
                  normalArray[start + 0] = -radius;
                  normalArray[start + 1] = radius;
                  normalArray[start + 2] = 0;
                  normalArray[start + 3] = -radius;
                  normalArray[start + 4] = -radius;
                  normalArray[start + 5] = 0;
                  normalArray[start + 6] = radius;
                  normalArray[start + 7] = -radius;
                  normalArray[start + 8] = 0;
                  normalArray[start + 9] = radius;
                  normalArray[start + 10] = radius;
                  normalArray[start + 11] = 0;
                  geoGroup.vertices += 4;
                  var faceArray = geoGroup.faceArray;
                  var faceoffset = geoGroup.faceidx;
                  faceArray[faceoffset + 0] = startv;
                  faceArray[faceoffset + 1] = startv + 1;
                  faceArray[faceoffset + 2] = startv + 2;
                  faceArray[faceoffset + 3] = startv + 2;
                  faceArray[faceoffset + 4] = startv + 3;
                  faceArray[faceoffset + 5] = startv;
                  geoGroup.faceidx += 6;
                }
                //dkoes -  code for sphere imposters
                drawAtomImposter(atom, geo) {
                  if (!atom.style.sphere)
                    return;
                  var style = atom.style.sphere;
                  if (style.hidden)
                    return;
                  var radius = this.getRadiusFromStyle(atom, style);
                  var C = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);
                  if ((atom.clickable === true || atom.hoverable) && atom.intersectionShape !== void 0) {
                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                    atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));
                  }
                  this.drawSphereImposter(geo, atom, radius, C);
                }
                // Calculate dashes with color support for two-color bonds
                calculateDashes(from, to, radius, dashLength, gapLength, colors) {
                  var cylinderLength = Math.sqrt(Math.pow(from.x - to.x, 2) + Math.pow(from.y - to.y, 2) + Math.pow(from.z - to.z, 2));
                  radius = Math.max(radius, 0);
                  gapLength = Math.max(gapLength, 0) + 2 * radius;
                  dashLength = Math.max(dashLength, 1e-3);
                  if (dashLength + gapLength > cylinderLength) {
                    var segmentColor = colors && colors.length > 0 ? colors[0] : null;
                    return [{
                      from: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z),
                      to: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(to.x, to.y, to.z),
                      color: segmentColor
                    }];
                  }
                  var totalSegments = Math.floor((cylinderLength - dashLength) / (dashLength + gapLength)) + 1;
                  var totalDashLength = totalSegments * dashLength;
                  gapLength = (cylinderLength - totalDashLength) / totalSegments;
                  var new_to;
                  var new_from = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z);
                  var gapVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((to.x - from.x) / (cylinderLength / gapLength), (to.y - from.y) / (cylinderLength / gapLength), (to.z - from.z) / (cylinderLength / gapLength));
                  var dashVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((to.x - from.x) / (cylinderLength / dashLength), (to.y - from.y) / (cylinderLength / dashLength), (to.z - from.z) / (cylinderLength / dashLength));
                  var segments = [];
                  for (var place = 0; place < totalSegments; place++) {
                    new_to = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_from.x + dashVector.x, new_from.y + dashVector.y, new_from.z + dashVector.z);
                    var segmentColor = colors && colors.length > 1 && place >= totalSegments / 2 ? colors[1] : colors ? colors[0] : null;
                    segments.push({ from: new_from, to: new_to, color: segmentColor });
                    new_from = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_to.x + gapVector.x, new_to.y + gapVector.y, new_to.z + gapVector.z);
                  }
                  return segments;
                }
                // Calculate segments for solid two-color bonds (split at midpoint)
                calculateTwoColorSegments(from, to, colors) {
                  var segments = [];
                  if (colors.length <= 1) {
                    segments.push({ from: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z), to: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(to.x, to.y, to.z), color: colors[0] });
                  } else {
                    var mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((from.x + to.x) / 2, (from.y + to.y) / 2, (from.z + to.z) / 2);
                    segments.push({ from: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z), to: mp, color: colors[0] });
                    segments.push({ from: mp, to: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(to.x, to.y, to.z), color: colors[1] });
                  }
                  return segments;
                }
                // Determine which side of a multi-bond should have the dashed line.
                // Returns true if dashed should be on the +v side (toward ring interior).
                chooseDashedPlusV(atom, atom2, p1, p2, v) {
                  var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  var totalWeight = 0;
                  var hasNonTerminal = false;
                  for (var idx = 0; idx < atom.bonds.length; idx++) {
                    if (atom.bonds[idx] === atom2.index)
                      continue;
                    var a3 = this.atoms[atom.bonds[idx]];
                    if (a3 && a3.bonds && a3.bonds.length > 1) {
                      hasNonTerminal = true;
                      break;
                    }
                  }
                  if (!hasNonTerminal) {
                    for (var idx = 0; idx < atom2.bonds.length; idx++) {
                      if (atom2.bonds[idx] === atom.index)
                        continue;
                      var a3 = this.atoms[atom2.bonds[idx]];
                      if (a3 && a3.bonds && a3.bonds.length > 1) {
                        hasNonTerminal = true;
                        break;
                      }
                    }
                  }
                  var addNeighbors = (sourceAtom, excludeIdx) => {
                    for (var idx2 = 0; idx2 < sourceAtom.bonds.length; idx2++) {
                      if (sourceAtom.bonds[idx2] === excludeIdx)
                        continue;
                      var a32 = this.atoms[sourceAtom.bonds[idx2]];
                      if (!a32)
                        continue;
                      var isTerminal = !a32.bonds || a32.bonds.length <= 1;
                      var weight = hasNonTerminal && isTerminal ? 0.25 : 1;
                      center.x += a32.x * weight;
                      center.y += a32.y * weight;
                      center.z += a32.z * weight;
                      totalWeight += weight;
                    }
                  };
                  addNeighbors(atom, atom2.index);
                  addNeighbors(atom2, atom.index);
                  if (totalWeight < 1e-8)
                    return false;
                  center.multiplyScalar(1 / totalWeight);
                  var mid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                  var plus = mid.clone().add(v);
                  var minus = mid.clone().sub(v);
                  return plus.distanceToSquared(center) < minus.distanceToSquared(center);
                }
                static drawStickImposter(geo, from, to, radius, color, fromCap = 0, toCap = 0) {
                  var geoGroup = geo.updateGeoGroup(4);
                  var startv = geoGroup.vertices;
                  var start = startv * 3;
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  var radiusArray = geoGroup.radiusArray;
                  var normalArray = geoGroup.normalArray;
                  var r = color.r;
                  var g = color.g;
                  var b = color.b;
                  var negateColor = function(c) {
                    var n = -c;
                    if (n == 0)
                      n = -1e-4;
                    return n;
                  };
                  var pos = start;
                  for (var i = 0; i < 4; i++) {
                    vertexArray[pos] = from.x;
                    normalArray[pos] = to.x;
                    colorArray[pos] = r;
                    pos++;
                    vertexArray[pos] = from.y;
                    normalArray[pos] = to.y;
                    colorArray[pos] = g;
                    pos++;
                    vertexArray[pos] = from.z;
                    normalArray[pos] = to.z;
                    if (i < 2)
                      colorArray[pos] = b;
                    else
                      colorArray[pos] = negateColor(b);
                    pos++;
                  }
                  geoGroup.vertices += 4;
                  radiusArray[startv] = -radius;
                  radiusArray[startv + 1] = radius;
                  radiusArray[startv + 2] = -radius;
                  radiusArray[startv + 3] = radius;
                  var faceArray = geoGroup.faceArray;
                  var faceoffset = geoGroup.faceidx;
                  faceArray[faceoffset + 0] = startv;
                  faceArray[faceoffset + 1] = startv + 1;
                  faceArray[faceoffset + 2] = startv + 2;
                  faceArray[faceoffset + 3] = startv + 2;
                  faceArray[faceoffset + 4] = startv + 3;
                  faceArray[faceoffset + 5] = startv;
                  geoGroup.faceidx += 6;
                }
                // draws cylinders and small spheres (at bond radius)
                drawBondSticks(atom, atoms, geo) {
                  var _a, _b, _c, _d;
                  if (!atom.style.stick)
                    return;
                  var style = atom.style.stick;
                  if (style.hidden)
                    return;
                  var atomBondR = style.radius || this.defaultStickRadius;
                  var doubleBondScale = style.doubleBondScaling || 0.4;
                  var tripleBondScale = style.tripleBondScaling || 0.25;
                  var bondDashLength = ((_a = style.dashedBondConfig) === null || _a === void 0 ? void 0 : _a.dashLength) || 0.1;
                  var bondGapLength = ((_b = style.dashedBondConfig) === null || _b === void 0 ? void 0 : _b.gapLength) || 0.25;
                  var bondR = atomBondR;
                  var atomSingleBond = style.singleBonds || false;
                  var atomDashedBonds = style.dashedBonds || false;
                  var fromCap = 0, toCap = 0;
                  var atomneedsi, atom2needsi, i, singleBond, bstyle;
                  var cylinder1a, cylinder1b, cylinder1c, cylinder2a, cylinder2b, cylinder2c;
                  var C1 = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);
                  var mp, mp2, mp3;
                  if (!atom.capDrawn && atom.bonds.length < 4)
                    fromCap = 2;
                  var solidColor = ((_c = style.dashedBondConfig) === null || _c === void 0 ? void 0 : _c.solidColor) ? _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(style.dashedBondConfig.solidColor) : null;
                  var dashedColor = ((_d = style.dashedBondConfig) === null || _d === void 0 ? void 0 : _d.dashedColor) ? _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(style.dashedBondConfig.dashedColor) : null;
                  var self2 = this;
                  var selectCylDrawMethod = (bondOrder) => {
                    var drawMethod2 = geo.imposter ? GLModel.drawStickImposter : _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawCylinder;
                    if (!atomDashedBonds && bondOrder % 1 === 0) {
                      return (geo2, from, to, radius, color1, color2, fromCap2 = 0, toCap2 = 0) => {
                        if (!color2 || color1 === color2) {
                          drawMethod2(geo2, from, to, radius, color1, fromCap2, toCap2);
                        } else {
                          var segments = self2.calculateTwoColorSegments(from, to, [color1, color2]);
                          for (var si = 0; si < segments.length; si++) {
                            var seg = segments[si];
                            var fc = si === 0 ? fromCap2 : 0;
                            var tc = si === segments.length - 1 ? toCap2 : 0;
                            drawMethod2(geo2, seg.from, seg.to, radius, seg.color, fc, tc);
                          }
                        }
                      };
                    }
                    return (geo2, from, to, radius, color1, color2, fromCap2 = 0, toCap2 = 0) => {
                      var colors = color2 ? [color1, color2] : [color1];
                      var segments = self2.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);
                      segments.forEach((segment) => {
                        drawMethod2(geo2, segment.from, segment.to, radius, segment.color, fromCap2, toCap2);
                      });
                    };
                  };
                  for (i = 0; i < atom.bonds.length; i++) {
                    var rawBondOrder = atom.bondOrder[i];
                    var renderBondOrder = rawBondOrder === 4 ? 1.5 : rawBondOrder;
                    var drawCyl = selectCylDrawMethod(renderBondOrder);
                    var j = atom.bonds[i];
                    var atom2 = atoms[j];
                    mp = mp2 = mp3 = null;
                    if (atom.index < atom2.index) {
                      toCap = 0;
                      var style2 = atom2.style;
                      if (!style2.stick || style2.stick.hidden)
                        continue;
                      var C2 = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom2, style2.stick);
                      bondR = atomBondR;
                      singleBond = atomSingleBond;
                      if (atom.bondStyles && atom.bondStyles[i]) {
                        bstyle = atom.bondStyles[i];
                        if (bstyle.iswire) {
                          continue;
                        }
                        if (bstyle.radius)
                          bondR = bstyle.radius;
                        if (bstyle.singleBond)
                          singleBond = true;
                        if (typeof bstyle.color1 != "undefined") {
                          C1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color1);
                        }
                        if (typeof bstyle.color2 != "undefined") {
                          C2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color2);
                        }
                      }
                      var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);
                      var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);
                      var solid1 = solidColor || C1;
                      var solid2 = solidColor || C2;
                      var dashed1 = dashedColor || C1;
                      var dashed2 = dashedColor || C2;
                      if (renderBondOrder <= 1 || singleBond || renderBondOrder > 3) {
                        if (renderBondOrder < 1)
                          bondR *= renderBondOrder;
                        if (!atom2.capDrawn && atom2.bonds.length < 4)
                          toCap = 2;
                        const isDashed = atomDashedBonds || renderBondOrder % 1 !== 0;
                        const colA = isDashed ? dashed1 : C1;
                        const colB = isDashed ? dashed2 : C2;
                        drawCyl(geo, p1, p2, bondR, colA, colB, fromCap, toCap);
                        atomneedsi = atom.clickable || atom.hoverable;
                        atom2needsi = atom2.clickable || atom2.hoverable;
                        if (atomneedsi || atom2needsi) {
                          if (!mp)
                            mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                          if (atomneedsi) {
                            var cylinder1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1, mp, bondR);
                            var sphere1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(p1, bondR);
                            atom.intersectionShape.cylinder.push(cylinder1);
                            atom.intersectionShape.sphere.push(sphere1);
                          }
                          if (atom2needsi) {
                            var cylinder2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2, mp, bondR);
                            var sphere2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(p2, bondR);
                            atom2.intersectionShape.cylinder.push(cylinder2);
                            atom2.intersectionShape.sphere.push(sphere2);
                          }
                        }
                      } else if (renderBondOrder > 1) {
                        var mfromCap = 0;
                        var mtoCap = 0;
                        if (bondR != atomBondR) {
                          mfromCap = 2;
                          mtoCap = 2;
                        }
                        var dir = p2.clone();
                        var v = null;
                        dir.sub(p1);
                        var r, r2, p1a, p1b, p2a, p2b;
                        v = this.getSideBondV(atom, atom2, i);
                        var isDashedBondFlipped = false;
                        if (renderBondOrder % 1 !== 0) {
                          isDashedBondFlipped = this.chooseDashedPlusV(atom, atom2, p1, p2, v);
                        }
                        if (renderBondOrder > 1 && renderBondOrder <= 2) {
                          r = bondR * doubleBondScale;
                          r2 = r * (renderBondOrder - 1);
                          v.multiplyScalar(r * 1.5);
                          p1a = p1.clone();
                          p1a.add(v);
                          p1b = p1.clone();
                          p1b.sub(v);
                          p2a = p1a.clone();
                          p2a.add(dir);
                          p2b = p1b.clone();
                          p2b.add(dir);
                          var solid1 = solidColor || C1;
                          var solid2 = solidColor || C2;
                          var dashed1 = dashedColor || C1;
                          var dashed2 = dashedColor || C2;
                          var drawMethod = geo.imposter ? GLModel.drawStickImposter : _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawCylinder;
                          var drawSolid = (from, to, radius, c1, c2, fc, tc) => {
                            if (c1 != c2) {
                              var m = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(from, to).multiplyScalar(0.5);
                              drawMethod(geo, from, m, radius, c1, fc, 0);
                              drawMethod(geo, m, to, radius, c2, 0, tc);
                            } else {
                              drawMethod(geo, from, to, radius, c1, fc, tc);
                            }
                          };
                          var drawDashed = (from, to, radius, c1, c2, fc, tc) => {
                            var colors = c1 != c2 ? [c1, c2] : [c1];
                            var segments = self2.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);
                            segments.forEach((segment) => {
                              drawMethod(geo, segment.from, segment.to, radius, segment.color || c1, fc, tc);
                            });
                          };
                          if (renderBondOrder == 2) {
                            drawSolid(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);
                            drawSolid(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);
                          } else {
                            if (!isDashedBondFlipped) {
                              drawSolid(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);
                              drawDashed(p1b, p2b, r2, dashed1, dashed2, mfromCap, mtoCap);
                            } else {
                              drawDashed(p1a, p2a, r2, dashed1, dashed2, mfromCap, mtoCap);
                              drawSolid(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);
                            }
                          }
                          atomneedsi = atom.clickable || atom.hoverable;
                          atom2needsi = atom2.clickable || atom2.hoverable;
                          if (atomneedsi || atom2needsi) {
                            if (!mp)
                              mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a).multiplyScalar(0.5);
                            if (!mp2)
                              mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b).multiplyScalar(0.5);
                            var raRadius = renderBondOrder == 2 ? r : isDashedBondFlipped ? r2 : r;
                            var rbRadius = renderBondOrder == 2 ? r : isDashedBondFlipped ? r : r2;
                            if (atomneedsi) {
                              cylinder1a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1a, mp, raRadius);
                              cylinder1b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1b, mp2, rbRadius);
                              atom.intersectionShape.cylinder.push(cylinder1a);
                              atom.intersectionShape.cylinder.push(cylinder1b);
                            }
                            if (atom2needsi) {
                              cylinder2a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2a, mp, raRadius);
                              cylinder2b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2b, mp2, rbRadius);
                              atom2.intersectionShape.cylinder.push(cylinder2a);
                              atom2.intersectionShape.cylinder.push(cylinder2b);
                            }
                          }
                        } else if (renderBondOrder > 2 && renderBondOrder <= 3) {
                          r = bondR * tripleBondScale;
                          var r3 = r * (renderBondOrder - 2);
                          v.cross(dir);
                          v.normalize();
                          v.multiplyScalar(r * 3);
                          p1a = p1.clone();
                          p1a.add(v);
                          p1b = p1.clone();
                          p1b.sub(v);
                          p2a = p1a.clone();
                          p2a.add(dir);
                          p2b = p1b.clone();
                          p2b.add(dir);
                          var drawMethod = geo.imposter ? GLModel.drawStickImposter : _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawCylinder;
                          var drawSolidTriple = (from, to, radius, c1, c2, fc, tc) => {
                            if (c1 != c2) {
                              var m = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(from, to).multiplyScalar(0.5);
                              drawMethod(geo, from, m, radius, c1, fc, 0);
                              drawMethod(geo, m, to, radius, c2, 0, tc);
                            } else {
                              drawMethod(geo, from, to, radius, c1, fc, tc);
                            }
                          };
                          var drawDashedTriple = (from, to, radius, c1, c2, fc, tc) => {
                            var colors = c1 != c2 ? [c1, c2] : [c1];
                            var segments = self2.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);
                            segments.forEach((segment) => {
                              drawMethod(geo, segment.from, segment.to, radius, segment.color || c1, fc, tc);
                            });
                          };
                          if (renderBondOrder == 3) {
                            drawSolidTriple(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);
                            drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);
                            drawSolidTriple(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);
                          } else {
                            if (!isDashedBondFlipped) {
                              drawSolidTriple(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);
                              drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);
                              drawDashedTriple(p1b, p2b, r3, dashed1, dashed2, mfromCap, mtoCap);
                            } else {
                              drawDashedTriple(p1a, p2a, r3, dashed1, dashed2, mfromCap, mtoCap);
                              drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);
                              drawSolidTriple(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);
                            }
                          }
                          atomneedsi = atom.clickable || atom.hoverable;
                          atom2needsi = atom2.clickable || atom2.hoverable;
                          if (atomneedsi || atom2needsi) {
                            if (!mp)
                              mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a).multiplyScalar(0.5);
                            if (!mp2)
                              mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b).multiplyScalar(0.5);
                            if (!mp3)
                              mp3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                            var raRadius = renderBondOrder == 3 ? r : isDashedBondFlipped ? r3 : r;
                            var rbRadius = renderBondOrder == 3 ? r : isDashedBondFlipped ? r : r3;
                            if (atomneedsi) {
                              cylinder1a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1a.clone(), mp.clone(), raRadius);
                              cylinder1b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1b.clone(), mp2.clone(), rbRadius);
                              cylinder1c = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1.clone(), mp3.clone(), r);
                              atom.intersectionShape.cylinder.push(cylinder1a);
                              atom.intersectionShape.cylinder.push(cylinder1b);
                              atom.intersectionShape.cylinder.push(cylinder1c);
                            }
                            if (atom2needsi) {
                              cylinder2a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2a.clone(), mp.clone(), raRadius);
                              cylinder2b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2b.clone(), mp2.clone(), rbRadius);
                              cylinder2c = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2.clone(), mp3.clone(), r);
                              atom2.intersectionShape.cylinder.push(cylinder2a);
                              atom2.intersectionShape.cylinder.push(cylinder2b);
                              atom2.intersectionShape.cylinder.push(cylinder2c);
                            }
                          }
                        }
                      }
                    }
                  }
                  var drawSphere = false;
                  var numsinglebonds = 0;
                  var differentradii = false;
                  for (i = 0; i < atom.bonds.length; i++) {
                    singleBond = atomSingleBond;
                    if (atom.bondStyles && atom.bondStyles[i]) {
                      bstyle = atom.bondStyles[i];
                      if (bstyle.singleBond)
                        singleBond = true;
                      if (bstyle.radius && bstyle.radius != atomBondR) {
                        differentradii = true;
                      }
                    }
                    if (singleBond || atom.bondOrder[i] == 1) {
                      numsinglebonds++;
                    }
                  }
                  if (differentradii) {
                    if (numsinglebonds > 0)
                      drawSphere = true;
                  } else if (numsinglebonds == 0 && (atom.bonds.length > 0 || style.showNonBonded)) {
                    drawSphere = true;
                  }
                  if (drawSphere) {
                    bondR = atomBondR;
                    if (geo.imposter) {
                      this.drawSphereImposter(geo.sphereGeometry, atom, bondR, C1);
                    } else {
                      _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(geo, atom, bondR, C1);
                    }
                  }
                }
                // go through all the atoms and regenerate their geometries
                // we try to have one geometry for each style since this is much much
                // faster
                // at some point we should optimize this to avoid unnecessary
                // recalculation
                /** param {AtomSpec[]} atoms */
                createMolObj(atoms, options) {
                  options = options || {};
                  var ret = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();
                  var cartoonAtoms = [];
                  var lineGeometries = {};
                  var crossGeometries = {};
                  var drawSphereFunc = this.drawAtomSphere;
                  var sphereGeometry = null;
                  var stickGeometry = null;
                  if (options.supportsImposters) {
                    drawSphereFunc = this.drawAtomImposter;
                    sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                    sphereGeometry.imposter = true;
                    stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true, true);
                    stickGeometry.imposter = true;
                    stickGeometry.sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                    stickGeometry.sphereGeometry.imposter = true;
                    stickGeometry.drawnCaps = {};
                  } else if (options.supportsAIA) {
                    drawSphereFunc = this.drawAtomInstanced;
                    sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(false, true, true);
                    sphereGeometry.instanced = true;
                    stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                  } else {
                    sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                    stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                  }
                  var i, j, n, testOpacities;
                  var opacities = {};
                  var range = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
                  for (i = 0, n = atoms.length; i < n; i++) {
                    var atom = atoms[i];
                    if (atom && atom.style) {
                      if ((atom.clickable || atom.hoverable) && atom.intersectionShape === void 0)
                        atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                      testOpacities = { line: void 0, cross: void 0, stick: void 0, sphere: void 0 };
                      for (j in testOpacities) {
                        if (atom.style[j]) {
                          if (atom.style[j].opacity)
                            testOpacities[j] = parseFloat(atom.style[j].opacity);
                          else
                            testOpacities[j] = 1;
                        } else
                          testOpacities[j] = void 0;
                        if (opacities[j]) {
                          if (testOpacities[j] != void 0 && opacities[j] != testOpacities[j]) {
                            console.log("Warning: " + j + " opacity is ambiguous");
                            opacities[j] = 1;
                          }
                        } else
                          opacities[j] = testOpacities[j];
                      }
                      drawSphereFunc.call(this, atom, sphereGeometry);
                      this.drawAtomClickSphere(atom);
                      this.drawAtomCross(atom, crossGeometries);
                      this.drawBondLines(atom, atoms, lineGeometries);
                      this.drawBondSticks(atom, atoms, stickGeometry);
                      if (typeof atom.style.cartoon !== "undefined" && !atom.style.cartoon.hidden) {
                        if (atom.style.cartoon.color === "spectrum" && typeof atom.resi === "number" && !atom.hetflag) {
                          if (atom.resi < range[0])
                            range[0] = atom.resi;
                          if (atom.resi > range[1])
                            range[1] = atom.resi;
                        }
                        cartoonAtoms.push(atom);
                      }
                    }
                  }
                  if (cartoonAtoms.length > 0) {
                    (0, _glcartoon__WEBPACK_IMPORTED_MODULE_5__.drawCartoon)(ret, cartoonAtoms, range, this.defaultCartoonQuality);
                  }
                  if (sphereGeometry && sphereGeometry.vertices > 0) {
                    sphereGeometry.initTypedArrays();
                    var sphereMaterial = null;
                    var sphere = null;
                    if (sphereGeometry.imposter) {
                      sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SphereImposterMaterial({
                        ambient: 0,
                        vertexColors: true,
                        reflectivity: 0
                      });
                    } else if (sphereGeometry.instanced) {
                      sphere = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                      _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(sphere, { x: 0, y: 0, z: 0 }, 1, new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0.5, 0.5, 0.5));
                      sphere.initTypedArrays();
                      sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.InstancedMaterial({
                        sphereMaterial: new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({
                          ambient: 0,
                          vertexColors: true,
                          reflectivity: 0
                        }),
                        sphere
                      });
                    } else {
                      sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({
                        ambient: 0,
                        vertexColors: true,
                        reflectivity: 0
                      });
                    }
                    if (opacities.sphere < 1 && opacities.sphere >= 0) {
                      sphereMaterial.transparent = true;
                      sphereMaterial.opacity = opacities.sphere;
                    }
                    sphere = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(sphereGeometry, sphereMaterial);
                    ret.add(sphere);
                  }
                  if (stickGeometry.vertices > 0) {
                    var stickMaterial = null;
                    var ballMaterial = null;
                    var balls = stickGeometry.sphereGeometry;
                    if (!balls || typeof balls.vertices === "undefined" || balls.vertices == 0)
                      balls = null;
                    stickGeometry.initTypedArrays();
                    if (balls)
                      balls.initTypedArrays();
                    var matvals = { ambient: 0, vertexColors: true, reflectivity: 0 };
                    if (stickGeometry.imposter) {
                      stickMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.StickImposterMaterial(matvals);
                      ballMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SphereImposterMaterial(matvals);
                    } else {
                      stickMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial(matvals);
                      ballMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial(matvals);
                      if (stickMaterial.wireframe) {
                        stickGeometry.setUpWireframe();
                        if (balls)
                          balls.setUpWireframe();
                      }
                    }
                    if (opacities.stick < 1 && opacities.stick >= 0) {
                      stickMaterial.transparent = true;
                      stickMaterial.opacity = opacities.stick;
                      ballMaterial.transparent = true;
                      ballMaterial.opacity = opacities.stick;
                    }
                    var sticks = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(stickGeometry, stickMaterial);
                    ret.add(sticks);
                    if (balls) {
                      var stickspheres = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(balls, ballMaterial);
                      ret.add(stickspheres);
                    }
                  }
                  var linewidth;
                  for (i in lineGeometries) {
                    if (lineGeometries.hasOwnProperty(i)) {
                      linewidth = i;
                      var lineMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
                        linewidth,
                        vertexColors: true
                      });
                      if (opacities.line < 1 && opacities.line >= 0) {
                        lineMaterial.transparent = true;
                        lineMaterial.opacity = opacities.line;
                      }
                      lineGeometries[i].initTypedArrays();
                      var line = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometries[i], lineMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);
                      ret.add(line);
                    }
                  }
                  for (i in crossGeometries) {
                    if (crossGeometries.hasOwnProperty(i)) {
                      linewidth = i;
                      var crossMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
                        linewidth,
                        vertexColors: true
                      });
                      if (opacities.cross < 1 && opacities.cross >= 0) {
                        crossMaterial.transparent = true;
                        crossMaterial.opacity = opacities.cross;
                      }
                      crossGeometries[i].initTypedArrays();
                      var cross = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(crossGeometries[i], crossMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);
                      ret.add(cross);
                    }
                  }
                  if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {
                    var finalRet = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();
                    var t;
                    for (t = 0; t < this.modelData.symmetries.length; t++) {
                      var transformedRet = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();
                      transformedRet = ret.clone();
                      transformedRet.matrix.copy(this.modelData.symmetries[t]);
                      transformedRet.matrixAutoUpdate = false;
                      finalRet.add(transformedRet);
                    }
                    return finalRet;
                  }
                  return ret;
                }
                /**
                 * Return viewer associated with this model.
                 * @returns GLViewer
                 */
                getViewer() {
                  return this.viewer;
                }
                /**
                 * Return object representing internal state of
                 * the model appropriate for passing to setInternalState
                 *
                */
                getInternalState() {
                  return {
                    "atoms": this.atoms,
                    "frames": this.frames
                  };
                }
                /**
                 * Overwrite the internal model state with the passed state.
                 *
                */
                setInternalState(state) {
                  this.atoms = state.atoms;
                  this.frames = state.frames;
                  this.molObj = null;
                }
                /**
                 * Returns crystallographic information if present.
                 *
                 *
                 */
                getCrystData() {
                  if (this.modelData.cryst) {
                    if (!this.modelData.cryst.matrix) {
                      const cryst = this.modelData.cryst;
                      this.modelData.cryst.matrix = (0, _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(cryst.a, cryst.b, cryst.c, cryst.alpha, cryst.beta, cryst.gamma);
                    }
                    return this.modelData.cryst;
                  } else {
                    return null;
                  }
                }
                /**
                     * Set crystallographic information using three angles and three lengths
                     *
                     * @param {number} a - length of unit cell side
                     * @param {number} b - length of unit cell side
                     * @param {number} c - length of unit cell side
                     * @param {number} alpha - unit cell angle in degrees (default 90)
                     * @param {number} beta - unit cell angle in degrees (default 90)
                     * @param {number} gamma - unit cell angle in degrees (default 90)
                
                     */
                setCrystData(a, b, c, alpha, beta, gamma) {
                  a = a || 1;
                  b = b || 1;
                  c = c || 1;
                  alpha = alpha || 90;
                  beta = beta || 90;
                  gamma = gamma || 90;
                  const matrix = (0, _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(a, b, c, alpha, beta, gamma);
                  this.modelData.cryst = {
                    "a": a,
                    "b": b,
                    "c": c,
                    "alpha": alpha,
                    "beta": beta,
                    "gamma": gamma,
                    "matrix": matrix
                  };
                }
                /**
                 * Set the crystallographic matrix to the given matrix.
                 *
                 * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from
                 * the crystal data.
                 *
                 * @param {Matrix3} matrix - unit cell matrix
                 */
                setCrystMatrix(matrix) {
                  matrix = matrix || new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
                  this.modelData.cryst = {
                    "matrix": matrix
                  };
                }
                /**
                 * Returns list of rotational/translational matrices if there is BIOMT data
                 * Otherwise returns a list of just the ID matrix
                 *
                 * @return {Array<Matrix4>}
                 *
                 */
                getSymmetries() {
                  if (typeof this.modelData.symmetries == "undefined") {
                    this.modelData.symmetries = [this.idMatrix];
                  }
                  return this.modelData.symmetries;
                }
                /**
                 * Sets symmetries based on specified matrices in list
                 *
                 * @param {Array<Matrix4>} list
                 *
                 */
                setSymmetries(list) {
                  if (typeof list == "undefined") {
                    this.modelData.symmetries = [this.idMatrix];
                  } else {
                    this.modelData.symmetries = list;
                    this.molObj = null;
                  }
                }
                /**
                 * Returns model id number
                 *
                 * @return {number} Model ID
                 */
                getID() {
                  return this.id;
                }
                /**
                 * Returns model's frames property, a list of atom lists
                 *
                 * @return {number}
                 */
                getNumFrames() {
                  return this.frames.numFrames != void 0 ? this.frames.numFrames : this.frames.length;
                }
                adjustCoord(x1, x2, margin, adjust) {
                  var dist = x2 - x1;
                  if (dist < -margin) {
                    return x2 + adjust;
                  } else if (dist > margin) {
                    return x2 - adjust;
                  }
                  return x2;
                }
                //go over current atoms in depth first order and ensure that connected
                //attoms aren't split across the box
                adjustCoordinatesToBox() {
                  if (!this.box)
                    return;
                  if (!this.atomdfs)
                    return;
                  var bx = this.box[0];
                  var by = this.box[1];
                  var bz = this.box[2];
                  var mx = bx * 0.9;
                  var my = by * 0.9;
                  var mz = bz * 0.9;
                  for (var c = 0; c < this.atomdfs.length; c++) {
                    var component = this.atomdfs[c];
                    for (var i = 1; i < component.length; i++) {
                      var atom = this.atoms[component[i][0]];
                      var prev = this.atoms[component[i][1]];
                      atom.x = this.adjustCoord(prev.x, atom.x, mx, bx);
                      atom.y = this.adjustCoord(prev.y, atom.y, my, by);
                      atom.z = this.adjustCoord(prev.z, atom.z, mz, bz);
                    }
                  }
                }
                /**
                 * Sets model's atomlist to specified frame
                 * Sets to last frame if framenum out of range
                 *
                 * @param {number} framenum - model's atoms are set to this index in frames list
                 * @return {Promise}
                 */
                setFrame(framenum) {
                  var numFrames = this.getNumFrames();
                  let model = this;
                  let viewer = this.viewer;
                  return new Promise(function(resolve, reject) {
                    if (numFrames == 0) {
                      resolve();
                    }
                    if (framenum < 0 || framenum >= numFrames) {
                      framenum = numFrames - 1;
                    }
                    if (model.frames.url != void 0) {
                      var url = model.frames.url;
                      (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getbin)(url + "/traj/frame/" + framenum + "/" + model.frames.path, void 0, "POST", void 0).then(function(buffer) {
                        var values = new Float32Array(buffer, 44);
                        var count = 0;
                        for (var i = 0; i < model.atoms.length; i++) {
                          model.atoms[i].x = values[count++];
                          model.atoms[i].y = values[count++];
                          model.atoms[i].z = values[count++];
                        }
                        if (model.box && model.atomdfs) {
                          model.adjustCoordinatesToBox();
                        }
                        resolve();
                      }).catch(reject);
                    } else {
                      model.atoms = model.frames[framenum];
                      resolve();
                    }
                    model.molObj = null;
                    if (model.modelDatas && framenum < model.modelDatas.length) {
                      model.modelData = model.modelDatas[framenum];
                      if (model.unitCellObjects && viewer) {
                        viewer.removeUnitCell(model);
                        viewer.addUnitCell(model);
                      }
                    }
                  });
                }
                /**
                 * Add atoms as frames of model
                 *
                 * @param {AtomSpec[]} atoms - atoms to be added
                 */
                addFrame(atoms) {
                  this.frames.push(atoms);
                }
                /**
                     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.
                     * Model can then be animated
                     *
                     * @param {number} numFrames - number of frames to be created, default to 10
                     * @param {number} amplitude - amplitude of distortion, default to 1 (full)
                     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
                     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
                     *@example
                
                      $3Dmol.download("pdb:4UAA",viewer,{},function(){
                        viewer.setStyle({},{stick:{}});
                        viewer.vibrate(10, 1);
                        viewer.animate({loop: "forward",reps: 1});
                
                        viewer.zoomTo();
                              viewer.render();
                          });
                     */
                vibrate(numFrames = 10, amplitude = 1, bothWays = false, arrowSpec) {
                  var start = 0;
                  var end = numFrames;
                  let viewer = this.viewer;
                  if (bothWays) {
                    start = -numFrames;
                    end = numFrames;
                  }
                  if (this.frames !== void 0 && this.frames.origIndex !== void 0) {
                    this.setFrame(this.frames.origIndex);
                  } else {
                    this.setFrame(0);
                  }
                  if (start < end)
                    this.frames = [];
                  if (bothWays)
                    this.frames.origIndex = numFrames;
                  for (var i = start; i < end; i++) {
                    var newAtoms = [];
                    var currframe = this.frames.length;
                    if (i == 0 && !arrowSpec) {
                      this.frames.push(this.atoms);
                      continue;
                    }
                    for (var j = 0; j < this.atoms.length; j++) {
                      var dx = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], "dx");
                      var dy = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], "dy");
                      var dz = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], "dz");
                      var newVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(dx, dy, dz);
                      var starting = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(this.atoms[j].x, this.atoms[j].y, this.atoms[j].z);
                      var mult = i * amplitude / numFrames;
                      newVector.multiplyScalar(mult);
                      starting.add(newVector);
                      var newAtom = {};
                      for (var k in this.atoms[j]) {
                        newAtom[k] = this.atoms[j][k];
                      }
                      newAtom.x = starting.x;
                      newAtom.y = starting.y;
                      newAtom.z = starting.z;
                      newAtoms.push(newAtom);
                      if (viewer && arrowSpec) {
                        var spec = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.extend)({}, arrowSpec);
                        var arrowend = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(dx, dy, dz);
                        arrowend.multiplyScalar(amplitude);
                        arrowend.add(starting);
                        spec.start = starting;
                        spec.end = arrowend;
                        spec.frame = currframe;
                        if (!spec.color) {
                          var s = newAtom.style.sphere;
                          if (!s)
                            s = newAtom.style.stick;
                          if (!s)
                            s = newAtom.style.line;
                          spec.color = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(newAtom, s);
                        }
                        viewer.addArrow(spec);
                      }
                    }
                    this.frames.push(newAtoms);
                  }
                }
                // set default style and colors for atoms
                setAtomDefaults(atoms) {
                  for (let i = 0; i < atoms.length; i++) {
                    let atom = atoms[i];
                    if (atom) {
                      atom.style = atom.style || (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(GLModel.defaultAtomStyle);
                      atom.color = atom.color || this.ElementColors[atom.elem] || this.defaultColor;
                      atom.model = this.id;
                      if (atom.clickable || atom.hoverable)
                        atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                    }
                  }
                }
                /** add atoms to this model from molecular data string
                 *
                 * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer
                 * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)
                 * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format
                 */
                addMolData(data, format, options = {}) {
                  var parsedAtoms = GLModel.parseMolData(data, format, options);
                  this.dontDuplicateAtoms = !options.duplicateAssemblyAtoms;
                  var mData = parsedAtoms.modelData;
                  if (mData) {
                    if (Array.isArray(mData)) {
                      this.modelData = mData[0];
                      if (options.frames) {
                        this.modelDatas = mData;
                      }
                    } else {
                      this.modelData = mData;
                    }
                  }
                  if (parsedAtoms.box) {
                    this.box = parsedAtoms.box;
                  } else {
                    this.box = null;
                  }
                  if (this.frames.length == 0) {
                    for (let i2 = 0; i2 < parsedAtoms.length; i2++) {
                      if (parsedAtoms[i2].length != 0)
                        this.frames.push(parsedAtoms[i2]);
                    }
                    if (this.frames[0])
                      this.atoms = this.frames[0];
                  } else {
                    if (options.frames) {
                      for (let i2 = 0; i2 < parsedAtoms.length; i2++) {
                        this.frames.push(parsedAtoms[i2]);
                      }
                    } else {
                      for (var i = 0; i < parsedAtoms.length; i++) {
                        this.addAtoms(parsedAtoms[i]);
                      }
                    }
                  }
                  for (let i2 = 0; i2 < this.frames.length; i2++) {
                    this.setAtomDefaults(this.frames[i2]);
                  }
                  if (options.vibrate && options.vibrate.frames && options.vibrate.amplitude) {
                    this.vibrate(options.vibrate.frames, options.vibrate.amplitude);
                  }
                  if (options.style) {
                    this.setStyle({}, options.style);
                  }
                }
                setDontDuplicateAtoms(dup) {
                  this.dontDuplicateAtoms = dup;
                }
                setModelData(mData) {
                  this.modelData = mData;
                }
                //return true if atom value matches property val
                propertyMatches(atomval, val) {
                  if (atomval == val) {
                    return true;
                  } else if (typeof val == "string" && typeof atomval == "number") {
                    var match = val.match(/(-?\d+)\s*-\s*(-?\d+)/);
                    if (match) {
                      var lo = parseInt(match[1]);
                      var hi = parseInt(match[2]);
                      if (match && atomval >= lo && atomval <= hi) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
                // make a deep copy of a selection object and create caches of expensive
                // selections.  We create a copy so caches are not attached to user
                // supplied objects where the user might change them invalidating the cache.
                // This does not support arbitrary
                // javascript objects, but support enough for eveything that is
                // used in selections: number, string, boolean, functions; as well
                // as arrays and nested objects with values of the aformentioned
                // types.
                static deepCopyAndCache(selobject, model) {
                  if (typeof selobject != "object" || selobject == null || selobject instanceof GLModel)
                    return selobject;
                  if (selobject.__cache_created)
                    return selobject;
                  const copy = {};
                  for (const key in selobject) {
                    const item = selobject[key];
                    if (Array.isArray(item)) {
                      copy[key] = [];
                      for (let i = 0; i < item.length; i++) {
                        copy[key].push(GLModel.deepCopyAndCache(item[i], model));
                      }
                    } else if (typeof item === "object" && key != "properties" && key != "model") {
                      copy[key] = GLModel.deepCopyAndCache(item, model);
                    } else {
                      copy[key] = item;
                    }
                    if (key == "and" || key == "or") {
                      const results = [];
                      for (const subSelection of copy[key]) {
                        const set = /* @__PURE__ */ new Set();
                        for (const match of model.selectedAtoms(subSelection)) {
                          set.add(match.index);
                        }
                        results.push(set);
                      }
                      if (key == "and") {
                        const intersect = function(first, other) {
                          const result = /* @__PURE__ */ new Set();
                          for (const elem of other) {
                            if (first.has(elem)) {
                              result.add(elem);
                            }
                          }
                          return result;
                        };
                        let intersection = new Set(results[0]);
                        for (const set of results.splice(1)) {
                          intersection = intersect(intersection, set);
                        }
                        copy[key].__cached_results = intersection;
                      } else if (key == "or") {
                        const union = /* @__PURE__ */ new Set();
                        for (const set of results) {
                          for (const elem of set) {
                            union.add(elem);
                          }
                        }
                        copy[key].__cached_results = union;
                      }
                    }
                  }
                  copy.__cache_created = true;
                  return copy;
                }
                /** given a selection specification, return true if atom is selected.
                 * Does not support context-aware selectors like expand/within/byres.
                 *
                 * @param {AtomSpec} atom
                 * @param {AtomSelectionSpec} sel
                 * @return {boolean}
                 */
                atomIsSelected(atom, sel) {
                  if (typeof sel === "undefined")
                    return true;
                  var invert = !!sel.invert;
                  var ret = true;
                  for (var key in sel) {
                    if (key == "and" || key == "or" || key == "not") {
                      if (key == "not") {
                        if (this.atomIsSelected(atom, sel[key])) {
                          ret = false;
                          break;
                        }
                      } else {
                        if (sel[key].__cached_results === void 0) {
                          sel = GLModel.deepCopyAndCache(sel, this);
                        }
                        ret = sel[key].__cached_results.has(atom.index);
                        if (!ret) {
                          break;
                        }
                      }
                    } else if (key === "predicate") {
                      if (!sel.predicate(atom)) {
                        ret = false;
                        break;
                      }
                    } else if (key == "properties" && atom[key]) {
                      for (var propkey in sel.properties) {
                        if (propkey.startsWith("__cache"))
                          continue;
                        if (typeof atom.properties[propkey] === "undefined") {
                          ret = false;
                          break;
                        }
                        if (atom.properties[propkey] != sel.properties[propkey]) {
                          ret = false;
                          break;
                        }
                      }
                    } else if (key == "model") {
                      let m = sel.model;
                      if (typeof m === "number" && m < 0) {
                        m = this.viewer.getNextModelId() + m;
                      }
                      if (Array.isArray(m)) {
                        let isokay = false;
                        for (let i = 0; i < m.length; i++) {
                          if (m[i] == this || m[i] == this.id) {
                            isokay = true;
                            break;
                          }
                        }
                        if (!isokay) {
                          ret = false;
                          break;
                        }
                      } else {
                        if (m != this && m != this.id) {
                          ret = false;
                          break;
                        }
                      }
                    } else if (sel.hasOwnProperty(key) && !GLModel.ignoredKeys.has(key) && !key.startsWith("__cache")) {
                      if (typeof atom[key] === "undefined") {
                        ret = false;
                        break;
                      }
                      let isokay = false;
                      if (key === "bonds") {
                        var val = sel[key];
                        if (val != atom.bonds.length) {
                          ret = false;
                          break;
                        }
                      } else if (Array.isArray(sel[key])) {
                        var valarr = sel[key];
                        var atomval = atom[key];
                        for (let i = 0; i < valarr.length; i++) {
                          if (this.propertyMatches(atomval, valarr[i])) {
                            isokay = true;
                            break;
                          }
                        }
                        if (!isokay) {
                          ret = false;
                          break;
                        }
                      } else {
                        let val2 = sel[key];
                        if (!this.propertyMatches(atom[key], val2)) {
                          ret = false;
                          break;
                        }
                      }
                    }
                  }
                  return invert ? !ret : ret;
                }
                static squaredDistance(atom1, atom2) {
                  var xd = atom2.x - atom1.x;
                  var yd = atom2.y - atom1.y;
                  var zd = atom2.z - atom1.z;
                  return xd * xd + yd * yd + zd * zd;
                }
                /** returns a list of atoms in the expanded bounding box, but not in the current one
                 *
                 *  Bounding box:
                 *
                 *    [ [ xmin, ymin, zmin ],
                 *      [ xmax, ymax, zmax ],
                 *      [ xctr, yctr, zctr ] ]
                 *
                 **/
                expandAtomList(atomList, amt) {
                  if (amt <= 0)
                    return atomList;
                  var pb = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getExtent)(atomList, void 0);
                  var nb = [[], [], []];
                  for (var i = 0; i < 3; i++) {
                    nb[0][i] = pb[0][i] - amt;
                    nb[1][i] = pb[1][i] + amt;
                    nb[2][i] = pb[2][i];
                  }
                  var expand = [];
                  for (let i2 = 0; i2 < this.atoms.length; i2++) {
                    var x = this.atoms[i2].x;
                    var y = this.atoms[i2].y;
                    var z = this.atoms[i2].z;
                    if (x >= nb[0][0] && x <= nb[1][0] && y >= nb[0][1] && y <= nb[1][1] && z >= nb[0][2] && z <= nb[1][2]) {
                      if (!(x >= pb[0][0] && x <= pb[1][0] && y >= pb[0][1] && y <= pb[1][1] && z >= pb[0][2] && z <= pb[1][2])) {
                        expand.push(this.atoms[i2]);
                      }
                    }
                  }
                  return expand;
                }
                static getFloat(val) {
                  if (typeof val === "number")
                    return val;
                  else
                    return parseFloat(val);
                }
                /** return list of atoms selected by sel, this is specific to glmodel
                 *
                 * @param {AtomSelectionSpec} sel
                 * @return {Object[]}
                 * @example
                 $3Dmol.download("pdb:4wwy",viewer,{},function(){
                          var atoms = viewer.selectedAtoms({chain:'A'});
                          for(var i = 0, n = atoms.length; i < n; i++) {
                             atoms[i].b = 0.0;
                          }
                          viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});
                          viewer.render();
                      });
                 */
                selectedAtoms(sel, from) {
                  var ret = [];
                  sel = GLModel.deepCopyAndCache(sel || {}, this);
                  if (!from)
                    from = this.atoms;
                  var aLength = from.length;
                  for (var i = 0; i < aLength; i++) {
                    var atom = from[i];
                    if (atom) {
                      if (this.atomIsSelected(atom, sel))
                        ret.push(atom);
                    }
                  }
                  if (sel.hasOwnProperty("expand")) {
                    const exdist = GLModel.getFloat(sel.expand);
                    let expand = this.expandAtomList(ret, exdist);
                    let retlen = ret.length;
                    const thresh = exdist * exdist;
                    for (let i2 = 0; i2 < expand.length; i2++) {
                      for (let j2 = 0; j2 < retlen; j2++) {
                        var dist = GLModel.squaredDistance(expand[i2], ret[j2]);
                        if (dist < thresh && dist > 0) {
                          ret.push(expand[i2]);
                        }
                      }
                    }
                  }
                  if (sel.hasOwnProperty("within") && sel.within.hasOwnProperty("sel") && sel.within.hasOwnProperty("distance")) {
                    var sel2 = this.selectedAtoms(sel.within.sel, this.atoms);
                    var within = {};
                    const dist2 = GLModel.getFloat(sel.within.distance);
                    const thresh = dist2 * dist2;
                    for (let i2 = 0; i2 < sel2.length; i2++) {
                      for (let j2 = 0; j2 < ret.length; j2++) {
                        let dist3 = GLModel.squaredDistance(sel2[i2], ret[j2]);
                        if (dist3 < thresh && dist3 > 0) {
                          within[j2] = 1;
                        }
                      }
                    }
                    var newret = [];
                    if (sel.within.invert) {
                      for (let j2 = 0; j2 < ret.length; j2++) {
                        if (!within[j2])
                          newret.push(ret[j2]);
                      }
                    } else {
                      for (let j2 in within) {
                        newret.push(ret[j2]);
                      }
                    }
                    ret = newret;
                  }
                  if (sel.hasOwnProperty("byres")) {
                    var vResis = {};
                    var vAtoms = [];
                    var stack = [];
                    for (let i2 = 0; i2 < ret.length; i2++) {
                      let atom3 = ret[i2];
                      var c = atom3.chain;
                      var r = atom3.resi;
                      if (vResis[c] === void 0)
                        vResis[c] = {};
                      if (atom3.hasOwnProperty("resi") && vResis[c][r] === void 0) {
                        vResis[c][r] = true;
                        stack.push(atom3);
                        while (stack.length > 0) {
                          atom3 = stack.pop();
                          c = atom3.chain;
                          r = atom3.resi;
                          if (vAtoms[atom3.index] === void 0) {
                            vAtoms[atom3.index] = true;
                            for (var j = 0; j < atom3.bonds.length; j++) {
                              var atom2 = this.atoms[atom3.bonds[j]];
                              if (vAtoms[atom2.index] === void 0 && atom2.hasOwnProperty("resi") && atom2.chain == c && atom2.resi == r) {
                                stack.push(atom2);
                                ret.push(atom2);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  return ret;
                }
                /** Add list of new atoms to model.  Adjusts bonds appropriately.
                     *
                     * @param {AtomSpec[]} newatoms
                     * @example
                     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];
                
                        viewer.setBackgroundColor(0xffffffff);
                        var m = viewer.addModel();
                        m.addAtoms(atoms);
                        m.setStyle({},{stick:{}});
                        viewer.zoomTo();
                        viewer.render();
                     */
                addAtoms(newatoms) {
                  this.molObj = null;
                  var start = this.atoms.length;
                  var indexmap = [];
                  var i;
                  for (i = 0; i < newatoms.length; i++) {
                    if (typeof newatoms[i].index == "undefined")
                      newatoms[i].index = i;
                    if (typeof newatoms[i].serial == "undefined")
                      newatoms[i].serial = i;
                    indexmap[newatoms[i].index] = start + i;
                  }
                  for (i = 0; i < newatoms.length; i++) {
                    var olda = newatoms[i];
                    var nindex = indexmap[olda.index];
                    var a = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.extend)({}, olda);
                    a.index = nindex;
                    a.bonds = [];
                    a.bondOrder = [];
                    a.model = this.id;
                    a.style = a.style || (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(GLModel.defaultAtomStyle);
                    if (typeof a.color == "undefined")
                      a.color = this.ElementColors[a.elem] || this.defaultColor;
                    var nbonds = olda.bonds ? olda.bonds.length : 0;
                    for (var j = 0; j < nbonds; j++) {
                      var neigh = indexmap[olda.bonds[j]];
                      if (typeof neigh != "undefined") {
                        a.bonds.push(neigh);
                        a.bondOrder.push(olda.bondOrder ? olda.bondOrder[j] : 1);
                      }
                    }
                    this.atoms.push(a);
                  }
                }
                /** Assign bonds based on atomic coordinates.
                 *  This currently uses a primitive distance-based algorithm that does not
                 * consider valence constraints and will only create single bonds.
                 */
                assignBonds() {
                  (0, _parsers_utils_assignBonds__WEBPACK_IMPORTED_MODULE_10__.assignBonds)(this.atoms, { assignBonds: true });
                }
                /** Remove specified atoms from model
                 *
                 * @param {AtomSpec[]} badatoms - list of atoms
                 */
                removeAtoms(badatoms) {
                  this.molObj = null;
                  var baddies = [];
                  var i;
                  for (i = 0; i < badatoms.length; i++) {
                    baddies[badatoms[i].index] = true;
                  }
                  var newatoms = [];
                  for (i = 0; i < this.atoms.length; i++) {
                    var a = this.atoms[i];
                    if (!baddies[a.index])
                      newatoms.push(a);
                  }
                  this.atoms = [];
                  this.addAtoms(newatoms);
                }
                /** Set atom style of selected atoms
                     *
                     * @param {AtomSelectionSpec} sel
                     * @param {AtomStyleSpec} style
                     * @param {boolean} add - if true, add to current style, don't replace
                     @example
                    $3Dmol.download("pdb:4UB9",viewer,{},function(){
                              viewer.setBackgroundColor(0xffffffff);
                
                              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
                              viewer.render();
                          });
                     */
                setStyle(sel, style, add) {
                  if (typeof style === "undefined" && typeof add == "undefined") {
                    style = sel;
                    sel = {};
                  }
                  sel = sel;
                  if (typeof style === "string") {
                    style = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.specStringToObject)(style);
                  }
                  var changedAtoms = false;
                  var that = this;
                  var setStyleHelper = function(atomArr) {
                    var selected = that.selectedAtoms(sel, atomArr);
                    for (let i2 = 0; i2 < atomArr.length; i2++) {
                      if (atomArr[i2])
                        atomArr[i2].capDrawn = false;
                    }
                    for (let i2 = 0; i2 < selected.length; i2++) {
                      changedAtoms = true;
                      if (selected[i2].clickable || selected[i2].hoverable)
                        selected[i2].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                      if (!add)
                        selected[i2].style = {};
                      for (let s in style) {
                        if (style.hasOwnProperty(s)) {
                          selected[i2].style[s] = selected[i2].style[s] || {};
                          Object.assign(selected[i2].style[s], style[s]);
                        }
                      }
                    }
                  };
                  if (sel.frame !== void 0 && sel.frame < this.frames.length) {
                    let frame = sel.frame;
                    if (frame < 0)
                      frame = this.frames.length + frame;
                    setStyleHelper(this.frames[frame]);
                  } else {
                    setStyleHelper(this.atoms);
                    for (var i = 0; i < this.frames.length; i++) {
                      if (this.frames[i] !== this.atoms)
                        setStyleHelper(this.frames[i]);
                    }
                  }
                  if (changedAtoms)
                    this.molObj = null;
                }
                /** Set clickable and callback of selected atoms
                     *
                     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
                     * @param {boolean} clickable - whether click-handling is enabled for the selection
                     * @param {function} callback - function called when an atom in the selection is clicked
                
                     */
                setClickable(sel, clickable, callback2) {
                  clickable = !!clickable;
                  callback2 = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(callback2);
                  if (callback2 === null) {
                    console.log("Callback is not a function");
                    return;
                  }
                  var selected = this.selectedAtoms(sel, this.atoms);
                  var len = selected.length;
                  for (let i = 0; i < len; i++) {
                    selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                    selected[i].clickable = clickable;
                    if (callback2)
                      selected[i].callback = callback2;
                  }
                  if (len > 0)
                    this.molObj = null;
                }
                /** Set hoverable and callback of selected atoms
                *
                * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
                * @param {boolean} hoverable - whether hover-handling is enabled for the selection
                * @param {function} hover_callback - function called when an atom in the selection is hovered over
                * @param {function} unhover_callback - function called when the mouse moves out of the hover area
                */
                setHoverable(sel, hoverable, hover_callback, unhover_callback) {
                  hoverable = !!hoverable;
                  hover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(hover_callback);
                  unhover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(unhover_callback);
                  if (hover_callback === null) {
                    console.log("Hover_callback is not a function");
                    return;
                  }
                  if (unhover_callback === null) {
                    console.log("Unhover_callback is not a function");
                    return;
                  }
                  var selected = this.selectedAtoms(sel, this.atoms);
                  var len = selected.length;
                  for (let i = 0; i < len; i++) {
                    selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                    selected[i].hoverable = hoverable;
                    if (hover_callback)
                      selected[i].hover_callback = hover_callback;
                    if (unhover_callback)
                      selected[i].unhover_callback = unhover_callback;
                  }
                  if (len > 0)
                    this.molObj = null;
                }
                /** enable context menu of selected atoms
                 *
                 * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
                 * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
                 */
                enableContextMenu(sel, contextMenuEnabled) {
                  contextMenuEnabled = !!contextMenuEnabled;
                  var i;
                  var selected = this.selectedAtoms(sel, this.atoms);
                  var len = selected.length;
                  for (i = 0; i < len; i++) {
                    selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };
                    selected[i].contextMenuEnabled = contextMenuEnabled;
                  }
                  if (len > 0)
                    this.molObj = null;
                }
                /** given a mapping from element to color, set atom colors
                 *
                 * @param {AtomSelectionSpec} sel
                 * @param {object} colors
                 */
                setColorByElement(sel, colors) {
                  if (this.molObj !== null && GLModel.sameObj(colors, this.lastColors))
                    return;
                  this.lastColors = colors;
                  var atoms = this.selectedAtoms(sel, atoms);
                  if (atoms.length > 0)
                    this.molObj = null;
                  for (var i = 0; i < atoms.length; i++) {
                    var a = atoms[i];
                    if (typeof colors[a.elem] !== "undefined") {
                      a.color = colors[a.elem];
                    }
                  }
                }
                /**
                 * @param {AtomSelectionSpec} sel
                 * @param {string} prop
                 * @param {Gradient|string} scheme
                 */
                setColorByProperty(sel, prop, scheme, range) {
                  var i, a;
                  var atoms = this.selectedAtoms(sel, atoms);
                  this.lastColors = null;
                  if (atoms.length > 0)
                    this.molObj = null;
                  if (typeof scheme === "string" && typeof _Gradient__WEBPACK_IMPORTED_MODULE_7__.Gradient.builtinGradients[scheme] != "undefined") {
                    scheme = new _Gradient__WEBPACK_IMPORTED_MODULE_7__.Gradient.builtinGradients[scheme]();
                  }
                  scheme = scheme;
                  if (!range) {
                    range = scheme.range();
                  }
                  if (!range) {
                    range = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getPropertyRange)(atoms, prop);
                  }
                  for (i = 0; i < atoms.length; i++) {
                    a = atoms[i];
                    var val = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(a, prop);
                    if (val != null) {
                      a.color = scheme.valueToHex(parseFloat(a.properties[prop]), range);
                    }
                  }
                }
                /**
                     * @deprecated use setStyle and colorfunc attribute
                     * @param {AtomSelectionSpec} sel - selection object
                     * @param {function} func - function to be used to set the color
                     @example
                      $3Dmol.download("pdb:4UAA",viewer,{},function(){
                              viewer.setBackgroundColor(0xffffffff);
                              var colorAsSnake = function(atom) {
                                return atom.resi % 2 ? 'white': 'green'
                              };
                
                              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});
                
                              viewer.render();
                          });
                
                     */
                setColorByFunction(sel, colorfun) {
                  var atoms = this.selectedAtoms(sel, atoms);
                  if (typeof colorfun !== "function")
                    return;
                  this.lastColors = null;
                  if (atoms.length > 0)
                    this.molObj = null;
                  for (let i = 0; i < atoms.length; i++) {
                    let a = atoms[i];
                    a.color = colorfun(a);
                  }
                }
                /** Convert the model into an object in the format of a ChemDoodle JSON model.
                 *
                 * @param {boolean} whether or not to include style information. Defaults to false.
                 * @return {Object}
                 */
                toCDObject(includeStyles = false) {
                  var out = { a: [], b: [] };
                  if (includeStyles) {
                    out.s = [];
                  }
                  for (let i = 0; i < this.atoms.length; i++) {
                    let atomJSON = {};
                    let atom = this.atoms[i];
                    atomJSON.x = atom.x;
                    atomJSON.y = atom.y;
                    atomJSON.z = atom.z;
                    if (atom.elem != "C") {
                      atomJSON.l = atom.elem;
                    }
                    if (includeStyles) {
                      var s = 0;
                      while (s < out.s.length && JSON.stringify(atom.style) !== JSON.stringify(out.s[s])) {
                        s++;
                      }
                      if (s === out.s.length) {
                        out.s.push(atom.style);
                      }
                      if (s !== 0) {
                        atomJSON.s = s;
                      }
                    }
                    out.a.push(atomJSON);
                    for (let b = 0; b < atom.bonds.length; b++) {
                      let firstAtom = i;
                      let secondAtom = atom.bonds[b];
                      if (firstAtom >= secondAtom)
                        continue;
                      let bond = {
                        b: firstAtom,
                        e: secondAtom
                      };
                      let bondOrder = atom.bondOrder[b];
                      if (bondOrder != 1) {
                        bond.o = bondOrder;
                      }
                      out.b.push(bond);
                    }
                  }
                  return out;
                }
                /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add
                 *
                 * @param {Object3D} group
                 * @param Object options
                 */
                globj(group, options) {
                  if (this.molObj === null || options.regen) {
                    this.molObj = this.createMolObj(this.atoms, options);
                    if (this.renderedMolObj) {
                      group.remove(this.renderedMolObj);
                      this.renderedMolObj = null;
                    }
                    this.renderedMolObj = this.molObj.clone();
                    if (this.hidden) {
                      this.renderedMolObj.setVisible(false);
                      this.molObj.setVisible(false);
                    }
                    group.add(this.renderedMolObj);
                  }
                }
                /** return a VRML string representation of the model.  Does not include VRML header information
                 * @return VRML
                 */
                exportVRML() {
                  var tmpobj = this.createMolObj(this.atoms, { supportsImposters: false, supportsAIA: false });
                  return tmpobj.vrml();
                }
                /** Remove any renderable mol object from scene
                 *
                 * @param {Object3D} group
                 */
                removegl(group) {
                  if (this.renderedMolObj) {
                    if (this.renderedMolObj.geometry !== void 0)
                      this.renderedMolObj.geometry.dispose();
                    if (this.renderedMolObj.material !== void 0)
                      this.renderedMolObj.material.dispose();
                    group.remove(this.renderedMolObj);
                    this.renderedMolObj = null;
                  }
                  this.molObj = null;
                }
                /**
                     * Don't show this model in future renderings. Keep all styles and state
                     * so it can be efficiencly shown again.
                     *
                     * * @see GLModel#show
                
                     * @example
                        $3Dmol.download("pdb:3ucr",viewer,{},function(){
                        viewer.setStyle({},{stick:{}});
                        viewer.getModel().hide();
                        viewer.render();
                        });
                     */
                hide() {
                  this.hidden = true;
                  if (this.renderedMolObj)
                    this.renderedMolObj.setVisible(false);
                  if (this.molObj)
                    this.molObj.setVisible(false);
                }
                /**
                 * Unhide a hidden model
                 * @see GLModel#hide
                 * @example
                    $3Dmol.download("pdb:3ucr",viewer,{},function(){
                    viewer.setStyle({},{stick:{}});
                    viewer.getModel().hide();
                    viewer.render(  )
                    viewer.getModel().show()
                    viewer.render();
                    });
                 */
                show() {
                  this.hidden = false;
                  if (this.renderedMolObj)
                    this.renderedMolObj.setVisible(true);
                  if (this.molObj)
                    this.molObj.setVisible(true);
                }
                /** Create labels for atoms that show the value of the passed property.
                 *
                 * @param {String} prop - property name
                 * @param {AtomSelectionSpec} sel
                 * @param {LabelSpec} options
                 */
                addPropertyLabels(prop, sel, style) {
                  let atoms = this.selectedAtoms(sel);
                  let viewer = this.viewer;
                  let mystyle = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(style);
                  for (let i = 0; i < atoms.length; i++) {
                    let a = atoms[i];
                    var label = null;
                    if (typeof a[prop] != "undefined") {
                      label = String(a[prop]);
                    } else if (typeof a.properties[prop] != "undefined") {
                      label = String(a.properties[prop]);
                    }
                    if (label != null) {
                      mystyle.position = a;
                      viewer.addLabel(label, mystyle);
                    }
                  }
                }
                /** Create labels for residues of selected atoms.
                 * Will create a single label at the center of mass of all atoms
                 * with the same chain,resn, and resi.
                 *
                 * @param {AtomSelectionSpec} sel
                 * @param {LabelSpec} options
                 * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already
                 */
                addResLabels(sel, style, byframe = false) {
                  let viewer = this.viewer;
                  var created_labels = [];
                  var helper = function(model, framenum) {
                    var atoms = model.selectedAtoms(sel, atoms);
                    var bylabel = {};
                    for (var i = 0; i < atoms.length; i++) {
                      var a = atoms[i];
                      var c = a.chain;
                      var resn = a.resn;
                      var resi = a.resi;
                      var label = resn + "" + resi;
                      if (!bylabel[c])
                        bylabel[c] = {};
                      if (!bylabel[c][label])
                        bylabel[c][label] = [];
                      bylabel[c][label].push(a);
                    }
                    var mystyle = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(style);
                    for (let c2 in bylabel) {
                      if (bylabel.hasOwnProperty(c2)) {
                        var labels = bylabel[c2];
                        for (let label2 in labels) {
                          if (labels.hasOwnProperty(label2)) {
                            let atoms2 = labels[label2];
                            let sum = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                            for (let i2 = 0; i2 < atoms2.length; i2++) {
                              let a2 = atoms2[i2];
                              sum.x += a2.x;
                              sum.y += a2.y;
                              sum.z += a2.z;
                            }
                            sum.divideScalar(atoms2.length);
                            mystyle.position = sum;
                            mystyle.frame = framenum;
                            let l = viewer.addLabel(label2, mystyle, void 0, true);
                            created_labels.push(l);
                          }
                        }
                      }
                    }
                  };
                  if (byframe) {
                    var n = this.getNumFrames();
                    let savedatoms = this.atoms;
                    for (let i = 0; i < n; i++) {
                      if (this.frames[i]) {
                        this.atoms = this.frames[i];
                        helper(this, i);
                      }
                    }
                    this.atoms = savedatoms;
                  } else {
                    helper(this);
                  }
                  return created_labels;
                }
                //recurse over the current atoms to establish a depth first order
                setupDFS() {
                  this.atomdfs = [];
                  var self2 = this;
                  var visited = new Int8Array(this.atoms.length);
                  visited.fill(0);
                  var search = function(i2, prev, component2) {
                    component2.push([i2, prev]);
                    var atom2 = self2.atoms[i2];
                    visited[i2] = 1;
                    for (var b = 0; b < atom2.bonds.length; b++) {
                      var nexti = atom2.bonds[b];
                      if (self2.atoms[nexti] && !visited[nexti]) {
                        search(nexti, i2, component2);
                      }
                    }
                  };
                  for (var i = 0; i < this.atoms.length; i++) {
                    var atom = this.atoms[i];
                    if (atom && !visited[i]) {
                      var component = [];
                      search(i, -1, component);
                      this.atomdfs.push(component);
                    }
                  }
                }
                /**
                * Set coordinates from remote trajectory file.
                * @param {string} url - contains the url where mdsrv has been hosted
                * @param {string} path - contains the path of the file (<root>/filename)
                * @return {Promise}
                */
                setCoordinatesFromURL(url, path) {
                  this.frames = [];
                  var self2 = this;
                  if (this.box)
                    this.setupDFS();
                  if (!url.startsWith("http"))
                    url = "http://" + url;
                  return (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.get)(url + "/traj/numframes/" + path, function(numFrames) {
                    if (!isNaN(parseInt(numFrames))) {
                      self2.frames.push(self2.atoms);
                      self2.frames.numFrames = numFrames;
                      self2.frames.url = url;
                      self2.frames.path = path;
                      return self2.setFrame(0);
                    }
                  });
                }
                /**
                * Set coordinates for the atoms from provided trajectory file.
                * @param {string|ArrayBuffer} str - contains the data of the file
                * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.
                  @example
                     let m = viewer.addModel()  //create an empty model
                     m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms
                     viewer.setStyle({'sphere':{}})
                     m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');
                     viewer.animate({loop: "forward",reps: 1});
                     viewer.zoomTo();
                     viewer.zoom(0.5);
                     viewer.render();
                */
                setCoordinates(str, format) {
                  format = format || "";
                  if (!str)
                    return [];
                  if (/\.gz$/.test(format)) {
                    format = format.replace(/\.gz$/, "");
                    try {
                      str = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.inflateString)(str);
                    } catch (err) {
                      console.log(err);
                    }
                  }
                  var supportedFormats = { "mdcrd": "", "inpcrd": "", "pdb": "", "netcdf": "", "array": "" };
                  if (supportedFormats.hasOwnProperty(format)) {
                    this.frames = [];
                    var atomCount = this.atoms.length;
                    var values = GLModel.parseCrd(str, format);
                    var count = 0;
                    while (count < values.length) {
                      var temp = [];
                      for (var i = 0; i < atomCount; i++) {
                        var newAtom = {};
                        for (var k in this.atoms[i]) {
                          newAtom[k] = this.atoms[i][k];
                        }
                        temp[i] = newAtom;
                        temp[i].x = values[count++];
                        temp[i].y = values[count++];
                        temp[i].z = values[count++];
                      }
                      this.frames.push(temp);
                    }
                    this.atoms = this.frames[0];
                    return this.frames;
                  }
                  return [];
                }
                /**
                 * add atomSpecs to validAtomSelectionSpecs
                 * @deprecated
                 * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs
                 * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.
                 * These messages are no longer generated as, in theory, typescript will catch problems at compile time.
                 * In practice, there may still be issues at run-time but we don't check for them...
                 *
                 * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime
                 * type checking, but it currently doesn't work with our types...
                 */
                addAtomSpecs(customAtomSpecs) {
                }
                static parseCrd(data, format) {
                  var values = [];
                  var counter = 0;
                  if (format == "pdb") {
                    var index = data.indexOf("\nATOM");
                    while (index != -1) {
                      while (data.slice(index, index + 5) == "\nATOM" || data.slice(index, index + 7) == "\nHETATM") {
                        values[counter++] = parseFloat(data.slice(index + 31, index + 39));
                        values[counter++] = parseFloat(data.slice(index + 39, index + 47));
                        values[counter++] = parseFloat(data.slice(index + 47, index + 55));
                        index = data.indexOf("\n", index + 54);
                        if (data.slice(index, index + 4) == "\nTER")
                          index = data.indexOf("\n", index + 5);
                      }
                      index = data.indexOf("\nATOM", index);
                    }
                  } else if (format == "netcdf") {
                    var reader = new netcdfjs__WEBPACK_IMPORTED_MODULE_9__.NetCDFReader(data);
                    values = [].concat.apply([], reader.getDataVariable("coordinates"));
                  } else if (format == "array" || Array.isArray(data)) {
                    return data.flat(2);
                  } else {
                    let index2 = data.indexOf("\n");
                    if (format == "inpcrd") {
                      index2 = data.indexOf("\n", index2 + 1);
                    }
                    data = data.slice(index2 + 1);
                    values = data.match(/\S+/g).map(parseFloat);
                  }
                  return values;
                }
                static parseMolData(data, format = "", options) {
                  if (!data)
                    return [];
                  if (/\.gz$/.test(format)) {
                    format = format.replace(/\.gz$/, "");
                    try {
                      if (format.match(/bcif/i)) {
                        data = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.inflateString)(data, false);
                      } else {
                        data = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.inflateString)(data);
                      }
                    } catch (err) {
                      console.log(err);
                    }
                  }
                  if (typeof _parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format] == "undefined") {
                    format = format.split(".").pop();
                    if (typeof _parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format] == "undefined") {
                      console.log("Unknown format: " + format);
                      if (data instanceof Uint8Array) {
                        format = "bcif";
                      } else if (data.match(/^@<TRIPOS>MOLECULE/gm)) {
                        format = "mol2";
                      } else if (data.match(/^data_/gm) && data.match(/^loop_/gm)) {
                        format = "cif";
                      } else if (data.match(/^HETATM/gm) || data.match(/^ATOM/gm)) {
                        format = "pdb";
                      } else if (data.match(/ITEM: TIMESTEP/gm)) {
                        format = "lammpstrj";
                      } else if (data.match(/^.*\n.*\n.\s*(\d+)\s+(\d+)/gm)) {
                        format = "sdf";
                      } else if (data.match(/^%VERSION\s+VERSION_STAMP/gm)) {
                        format = "prmtop";
                      } else {
                        format = "xyz";
                      }
                      console.log("Best guess: " + format);
                    }
                  }
                  var parse = _parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format];
                  var parsedAtoms = parse(data, options);
                  return parsedAtoms;
                }
              }
              GLModel.defaultAtomStyle = {
                line: {}
              };
              GLModel.defaultlineWidth = 1;
              GLModel.vdwRadii = {
                "H": 1.2,
                "He": 1.4,
                "Li": 1.82,
                "Be": 1.53,
                "B": 1.92,
                "C": 1.7,
                "N": 1.55,
                "O": 1.52,
                "F": 1.47,
                "Ne": 1.54,
                "Na": 2.27,
                "Mg": 1.73,
                "Al": 1.84,
                "Si": 2.1,
                "P": 1.8,
                "S": 1.8,
                "Cl": 1.75,
                "Ar": 1.88,
                "K": 2.75,
                "Ca": 2.31,
                "Ni": 1.63,
                "Cu": 1.4,
                "Zn": 1.39,
                "Ga": 1.87,
                "Ge": 2.11,
                "As": 1.85,
                "Se": 1.9,
                "Br": 1.85,
                "Kr": 2.02,
                "Rb": 3.03,
                "Sr": 2.49,
                "Pd": 1.63,
                "Ag": 1.72,
                "Cd": 1.58,
                "In": 1.93,
                "Sn": 2.17,
                "Sb": 2.06,
                "Te": 2.06,
                "I": 1.98,
                "Xe": 2.16,
                "Cs": 3.43,
                "Ba": 2.68,
                "Pt": 1.75,
                "Au": 1.66,
                "Hg": 1.55,
                "Tl": 1.96,
                "Pb": 2.02,
                "Bi": 2.07,
                "Po": 1.97,
                "At": 2.02,
                "Rn": 2.2,
                "Fr": 3.48,
                "Ra": 2.83,
                "U": 1.86
              };
              GLModel.ignoredKeys = /* @__PURE__ */ new Set(["props", "invert", "model", "frame", "byres", "expand", "within", "and", "or", "not"]);
              ;
            },
            /***/
            "./src/GLShape.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                GLShape: () => (
                  /* binding */
                  GLShape
                ),
                /* harmony export */
                splitMesh: () => (
                  /* binding */
                  splitMesh
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./WebGL/shapes */
                "./src/WebGL/shapes/index.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./ProteinSurface4 */
                "./src/ProteinSurface4.ts"
              );
              var _VolumeData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./VolumeData */
                "./src/VolumeData.ts"
              );
              var _GLDraw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./GLDraw */
                "./src/GLDraw.ts"
              );
              var _glcartoon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./glcartoon */
                "./src/glcartoon.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              class GLShape {
                static finalizeGeo(geo) {
                  var geoGroup = geo.updateGeoGroup(0);
                  if (geoGroup.vertices > 0) {
                    geoGroup.truncateArrayBuffers(true, true);
                  }
                }
                /*
                 *
                 * @param {Geometry}
                 *            geo
                 * @param {Color | colorlike} color
                 */
                static updateColor(geo, color) {
                  color = color || _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(color);
                  geo.colorsNeedUpdate = true;
                  var r, g, b;
                  if (color.constructor !== Array) {
                    r = color.r;
                    g = color.g;
                    b = color.b;
                  }
                  for (let gg in geo.geometryGroups) {
                    let geoGroup = geo.geometryGroups[gg];
                    let colorArr = geoGroup.colorArray;
                    for (let i = 0, il = geoGroup.vertices; i < il; ++i) {
                      if (color.constructor === Array) {
                        let c = color[i];
                        r = c.r;
                        g = c.g;
                        b = c.b;
                      }
                      colorArr[i * 3] = r;
                      colorArr[i * 3 + 1] = g;
                      colorArr[i * 3 + 2] = b;
                    }
                  }
                }
                /*
                 * @param {GLShape}
                 *            shape
                 * @param {geometryGroup}
                 *            geoGroup
                 * @param {ArrowSpec}
                 *            spec
                 */
                static drawArrow(shape, geo, spec) {
                  var from = spec.start, end = spec.end, radius = spec.radius, radiusRatio = spec.radiusRatio, mid = spec.mid, midoffset = spec.midpos;
                  if (!(from && end))
                    return;
                  var geoGroup = geo.updateGeoGroup(51);
                  var dir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(end.x, end.y, end.z).sub(from);
                  if (midoffset) {
                    let length = dir.length();
                    if (midoffset > 0)
                      mid = midoffset / length;
                    else
                      mid = (length + midoffset) / length;
                  }
                  dir.multiplyScalar(mid);
                  var to = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z).add(dir);
                  var negDir = dir.clone().negate();
                  let fromv = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z);
                  shape.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(fromv, to.clone(), radius));
                  shape.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(fromv, radius));
                  var nvecs = [];
                  nvecs[0] = dir.clone();
                  if (Math.abs(nvecs[0].x) > 1e-4)
                    nvecs[0].y += 1;
                  else
                    nvecs[0].x += 1;
                  nvecs[0].cross(dir);
                  nvecs[0].normalize();
                  nvecs[4] = nvecs[0].clone();
                  nvecs[4].crossVectors(nvecs[0], dir);
                  nvecs[4].normalize();
                  nvecs[8] = nvecs[0].clone().negate();
                  nvecs[12] = nvecs[4].clone().negate();
                  nvecs[2] = nvecs[0].clone().add(nvecs[4]).normalize();
                  nvecs[6] = nvecs[4].clone().add(nvecs[8]).normalize();
                  nvecs[10] = nvecs[8].clone().add(nvecs[12]).normalize();
                  nvecs[14] = nvecs[12].clone().add(nvecs[0]).normalize();
                  nvecs[1] = nvecs[0].clone().add(nvecs[2]).normalize();
                  nvecs[3] = nvecs[2].clone().add(nvecs[4]).normalize();
                  nvecs[5] = nvecs[4].clone().add(nvecs[6]).normalize();
                  nvecs[7] = nvecs[6].clone().add(nvecs[8]).normalize();
                  nvecs[9] = nvecs[8].clone().add(nvecs[10]).normalize();
                  nvecs[11] = nvecs[10].clone().add(nvecs[12]).normalize();
                  nvecs[13] = nvecs[12].clone().add(nvecs[14]).normalize();
                  nvecs[15] = nvecs[14].clone().add(nvecs[0]).normalize();
                  var start = geoGroup.vertices;
                  var vertexArray = geoGroup.vertexArray;
                  var faceArray = geoGroup.faceArray;
                  var normalArray = geoGroup.normalArray;
                  var lineArray = geoGroup.lineArray;
                  var offset, i, n;
                  for (i = 0, n = nvecs.length; i < n; ++i) {
                    offset = 3 * (start + 3 * i);
                    var bottom = nvecs[i].clone().multiplyScalar(radius).add(from);
                    var top = nvecs[i].clone().multiplyScalar(radius).add(to);
                    var conebase = nvecs[i].clone().multiplyScalar(radius * radiusRatio).add(to);
                    vertexArray[offset] = bottom.x;
                    vertexArray[offset + 1] = bottom.y;
                    vertexArray[offset + 2] = bottom.z;
                    vertexArray[offset + 3] = top.x;
                    vertexArray[offset + 4] = top.y;
                    vertexArray[offset + 5] = top.z;
                    vertexArray[offset + 6] = conebase.x;
                    vertexArray[offset + 7] = conebase.y;
                    vertexArray[offset + 8] = conebase.z;
                    if (i > 0) {
                      var prev_x = vertexArray[offset - 3];
                      var prev_y = vertexArray[offset - 2];
                      var prev_z = vertexArray[offset - 1];
                      var c = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(prev_x, prev_y, prev_z);
                      var b = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(end.x, end.y, end.z), b2 = to.clone();
                      var a = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(conebase.x, conebase.y, conebase.z);
                      shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(a, b, c));
                      shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(c.clone(), b2, a.clone()));
                    }
                  }
                  geoGroup.vertices += 48;
                  offset = geoGroup.vertices * 3;
                  vertexArray[offset] = from.x;
                  vertexArray[offset + 1] = from.y;
                  vertexArray[offset + 2] = from.z;
                  vertexArray[offset + 3] = to.x;
                  vertexArray[offset + 4] = to.y;
                  vertexArray[offset + 5] = to.z;
                  vertexArray[offset + 6] = end.x;
                  vertexArray[offset + 7] = end.y;
                  vertexArray[offset + 8] = end.z;
                  geoGroup.vertices += 3;
                  var face, faceoffset, lineoffset;
                  var t1, t2, t2b, t3, t3b, t4, t1offset, t2offset, t2boffset, t3offset, t3boffset, t4offset;
                  var n1, n2, n3, n4;
                  var fromi = geoGroup.vertices - 3, toi = geoGroup.vertices - 2, endi = geoGroup.vertices - 1;
                  var fromoffset = fromi * 3, tooffset = toi * 3, endoffset = endi * 3;
                  for (i = 0, n = nvecs.length - 1; i < n; ++i) {
                    var ti = start + 3 * i;
                    offset = ti * 3;
                    faceoffset = geoGroup.faceidx;
                    lineoffset = geoGroup.lineidx;
                    t1 = ti;
                    t1offset = t1 * 3;
                    t2 = ti + 1;
                    t2offset = t2 * 3;
                    t2b = ti + 2;
                    t2boffset = t2b * 3;
                    t3 = ti + 4;
                    t3offset = t3 * 3;
                    t3b = ti + 5;
                    t3boffset = t3b * 3;
                    t4 = ti + 3;
                    t4offset = t4 * 3;
                    n1 = n2 = nvecs[i];
                    n3 = n4 = nvecs[i + 1];
                    normalArray[t1offset] = n1.x;
                    normalArray[t2offset] = n2.x;
                    normalArray[t4offset] = n4.x;
                    normalArray[t1offset + 1] = n1.y;
                    normalArray[t2offset + 1] = n2.y;
                    normalArray[t4offset + 1] = n4.y;
                    normalArray[t1offset + 2] = n1.z;
                    normalArray[t2offset + 2] = n2.z;
                    normalArray[t4offset + 2] = n4.z;
                    normalArray[t2offset] = n2.x;
                    normalArray[t3offset] = n3.x;
                    normalArray[t4offset] = n4.x;
                    normalArray[t2offset + 1] = n2.y;
                    normalArray[t3offset + 1] = n3.y;
                    normalArray[t4offset + 1] = n4.y;
                    normalArray[t2offset + 2] = n2.z;
                    normalArray[t3offset + 2] = n3.z;
                    normalArray[t4offset + 2] = n4.z;
                    normalArray[t2boffset] = n2.x;
                    normalArray[t3boffset] = n3.x;
                    normalArray[t2boffset + 1] = n2.y;
                    normalArray[t3boffset + 1] = n3.y;
                    normalArray[t2boffset + 2] = n2.z;
                    normalArray[t3boffset + 2] = n3.z;
                    faceArray[faceoffset] = t1;
                    faceArray[faceoffset + 1] = t2;
                    faceArray[faceoffset + 2] = t4;
                    faceArray[faceoffset + 3] = t2;
                    faceArray[faceoffset + 4] = t3;
                    faceArray[faceoffset + 5] = t4;
                    faceArray[faceoffset + 6] = t1;
                    faceArray[faceoffset + 7] = t4;
                    faceArray[faceoffset + 8] = fromi;
                    faceArray[faceoffset + 9] = t2b;
                    faceArray[faceoffset + 10] = toi;
                    faceArray[faceoffset + 11] = t3b;
                    faceArray[faceoffset + 12] = t2b;
                    faceArray[faceoffset + 13] = endi;
                    faceArray[faceoffset + 14] = t3b;
                    lineArray[lineoffset] = t1;
                    lineArray[lineoffset + 1] = t2;
                    lineArray[lineoffset + 2] = t1;
                    lineArray[lineoffset + 3] = t4;
                    lineArray[lineoffset + 4] = t3;
                    lineArray[lineoffset + 5] = t4;
                    lineArray[lineoffset + 6] = t1;
                    lineArray[lineoffset + 7] = t4;
                    lineArray[lineoffset + 8] = t2b;
                    lineArray[lineoffset + 9] = t2;
                    lineArray[lineoffset + 10] = t2b;
                    lineArray[lineoffset + 11] = t3b;
                    lineArray[lineoffset + 12] = t3;
                    lineArray[lineoffset + 13] = t3b;
                    lineArray[lineoffset + 14] = t2b;
                    lineArray[lineoffset + 15] = endi;
                    lineArray[lineoffset + 16] = t2b;
                    lineArray[lineoffset + 17] = t3b;
                    lineArray[lineoffset + 18] = endi;
                    lineArray[lineoffset + 19] = t3b;
                    geoGroup.faceidx += 15;
                    geoGroup.lineidx += 20;
                  }
                  face = [
                    start + 45,
                    start + 46,
                    start + 1,
                    start,
                    start + 47,
                    start + 2
                  ];
                  faceoffset = geoGroup.faceidx;
                  lineoffset = geoGroup.lineidx;
                  t1 = face[0];
                  t1offset = t1 * 3;
                  t2 = face[1];
                  t2offset = t2 * 3;
                  t2b = face[4];
                  t2boffset = t2b * 3;
                  t3 = face[2];
                  t3offset = t3 * 3;
                  t3b = face[5];
                  t3boffset = t3b * 3;
                  t4 = face[3];
                  t4offset = t4 * 3;
                  n1 = n2 = nvecs[15];
                  n3 = n4 = nvecs[0];
                  normalArray[t1offset] = n1.x;
                  normalArray[t2offset] = n2.x;
                  normalArray[t4offset] = n4.x;
                  normalArray[t1offset + 1] = n1.y;
                  normalArray[t2offset + 1] = n2.y;
                  normalArray[t4offset + 1] = n4.y;
                  normalArray[t1offset + 2] = n1.z;
                  normalArray[t2offset + 2] = n2.z;
                  normalArray[t4offset + 2] = n4.z;
                  normalArray[t2offset] = n2.x;
                  normalArray[t3offset] = n3.x;
                  normalArray[t4offset] = n4.x;
                  normalArray[t2offset + 1] = n2.y;
                  normalArray[t3offset + 1] = n3.y;
                  normalArray[t4offset + 1] = n4.y;
                  normalArray[t2offset + 2] = n2.z;
                  normalArray[t3offset + 2] = n3.z;
                  normalArray[t4offset + 2] = n4.z;
                  normalArray[t2boffset] = n2.x;
                  normalArray[t3boffset] = n3.x;
                  normalArray[t2boffset + 1] = n2.y;
                  normalArray[t3boffset + 1] = n3.y;
                  normalArray[t2boffset + 2] = n2.z;
                  normalArray[t3boffset + 2] = n3.z;
                  dir.normalize();
                  negDir.normalize();
                  normalArray[fromoffset] = negDir.x;
                  normalArray[tooffset] = normalArray[endoffset] = dir.x;
                  normalArray[fromoffset + 1] = negDir.y;
                  normalArray[tooffset + 1] = normalArray[endoffset + 1] = dir.y;
                  normalArray[fromoffset + 2] = negDir.z;
                  normalArray[tooffset + 2] = normalArray[endoffset + 2] = dir.z;
                  faceArray[faceoffset] = t1;
                  faceArray[faceoffset + 1] = t2;
                  faceArray[faceoffset + 2] = t4;
                  faceArray[faceoffset + 3] = t2;
                  faceArray[faceoffset + 4] = t3;
                  faceArray[faceoffset + 5] = t4;
                  faceArray[faceoffset + 6] = t1;
                  faceArray[faceoffset + 7] = t4;
                  faceArray[faceoffset + 8] = fromi;
                  faceArray[faceoffset + 9] = t2b;
                  faceArray[faceoffset + 10] = toi;
                  faceArray[faceoffset + 11] = t3b;
                  faceArray[faceoffset + 12] = t2b;
                  faceArray[faceoffset + 13] = endi;
                  faceArray[faceoffset + 14] = t3b;
                  lineArray[lineoffset] = t1;
                  lineArray[lineoffset + 1] = t2;
                  lineArray[lineoffset + 2] = t1;
                  lineArray[lineoffset + 3] = t4;
                  lineArray[lineoffset + 4] = t3;
                  lineArray[lineoffset + 5] = t4;
                  lineArray[lineoffset + 6] = t1;
                  lineArray[lineoffset + 7] = t4;
                  lineArray[lineoffset + 8] = t2b;
                  lineArray[lineoffset + 9] = t2;
                  lineArray[lineoffset + 10] = t2b;
                  lineArray[lineoffset + 11] = t3b;
                  lineArray[lineoffset + 12] = t3;
                  lineArray[lineoffset + 13] = t3b;
                  lineArray[lineoffset + 14] = t2b;
                  lineArray[lineoffset + 15] = endi;
                  lineArray[lineoffset + 16] = t2b;
                  lineArray[lineoffset + 17] = t3b;
                  lineArray[lineoffset + 18] = endi;
                  lineArray[lineoffset + 19] = t3b;
                  geoGroup.faceidx += 15;
                  geoGroup.lineidx += 20;
                }
                // Update a bounding sphere's position and radius
                // from list of centroids and new points
                /*
                 * @param {Sphere}
                 *            sphere
                 * @param {Object}
                 *            components, centroid of all objects in shape
                 * @param {Array}
                 *            points, flat array of all points in shape
                 * @param {int} numPoints, number of valid poitns in points
                 */
                static updateBoundingFromPoints(sphere, components, points, numPoints) {
                  sphere.center.set(0, 0, 0);
                  let xmin = Infinity, ymin = Infinity, zmin = Infinity;
                  let xmax = -Infinity, ymax = -Infinity, zmax = -Infinity;
                  if (sphere.box) {
                    xmin = sphere.box.min.x;
                    xmax = sphere.box.max.x;
                    ymin = sphere.box.min.y;
                    ymax = sphere.box.max.y;
                    zmin = sphere.box.min.z;
                    zmax = sphere.box.max.z;
                  }
                  for (let i = 0, il = numPoints; i < il; i++) {
                    var x = points[i * 3], y = points[i * 3 + 1], z = points[i * 3 + 2];
                    if (x < xmin)
                      xmin = x;
                    if (y < ymin)
                      ymin = y;
                    if (z < zmin)
                      zmin = z;
                    if (x > xmax)
                      xmax = x;
                    if (y > ymax)
                      ymax = y;
                    if (z > zmax)
                      zmax = z;
                  }
                  sphere.center.set((xmax + xmin) / 2, (ymax + ymin) / 2, (zmax + zmin) / 2);
                  sphere.radius = sphere.center.distanceTo({ x: xmax, y: ymax, z: zmax });
                  sphere.box = { min: { x: xmin, y: ymin, z: zmin }, max: { x: xmax, y: ymax, z: zmax } };
                }
                //helper function for adding an appropriately sized mesh
                static addCustomGeo(shape, geo, mesh, color, clickable) {
                  var geoGroup = geo.addGeoGroup();
                  var vertexArr = mesh.vertexArr, normalArr = mesh.normalArr, faceArr = mesh.faceArr;
                  geoGroup.vertices = vertexArr.length;
                  geoGroup.faceidx = faceArr.length;
                  var offset, v, a, b, c, i, il, r, g;
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  if (color.constructor !== Array) {
                    r = color.r;
                    g = color.g;
                    b = color.b;
                  }
                  for (i = 0, il = geoGroup.vertices; i < il; ++i) {
                    offset = i * 3;
                    v = vertexArr[i];
                    vertexArray[offset] = v.x;
                    vertexArray[offset + 1] = v.y;
                    vertexArray[offset + 2] = v.z;
                    if (color.constructor === Array) {
                      c = color[i];
                      r = c.r;
                      g = c.g;
                      b = c.b;
                    }
                    colorArray[offset] = r;
                    colorArray[offset + 1] = g;
                    colorArray[offset + 2] = b;
                  }
                  if (clickable) {
                    for (i = 0, il = geoGroup.faceidx / 3; i < il; ++i) {
                      offset = i * 3;
                      a = faceArr[offset];
                      b = faceArr[offset + 1];
                      c = faceArr[offset + 2];
                      var vA = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(), vB = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(), vC = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                      shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(vA.copy(vertexArr[a]), vB.copy(vertexArr[b]), vC.copy(vertexArr[c])));
                    }
                  }
                  if (clickable) {
                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                    var cnt = 0;
                    for (let g2 = 0; g2 < geo.geometryGroups.length; g2++) {
                      center.add(geo.geometryGroups[g2].getCentroid());
                      cnt++;
                    }
                    center.divideScalar(cnt);
                    GLShape.updateBoundingFromPoints(shape.boundingSphere, { centroid: center }, vertexArray, geoGroup.vertices);
                  }
                  geoGroup.faceArray = new Uint16Array(faceArr);
                  geoGroup.truncateArrayBuffers(true, true);
                  if (normalArr.length < geoGroup.vertices)
                    geoGroup.setNormals();
                  else {
                    var normalArray = geoGroup.normalArray = new Float32Array(geoGroup.vertices * 3);
                    var n;
                    for (i = 0, il = geoGroup.vertices; i < il; ++i) {
                      offset = i * 3;
                      n = normalArr[i];
                      normalArray[offset] = n.x;
                      normalArray[offset + 1] = n.y;
                      normalArray[offset + 2] = n.z;
                    }
                  }
                  geoGroup.setLineIndices();
                  geoGroup.lineidx = geoGroup.lineArray.length;
                }
                /*
                 *
                 * @param {$3Dmol.GLShape}
                 *            shape
                 * @param {ShapeSpec}
                 *            stylespec
                 * @returns {undefined}
                 */
                static updateFromStyle(shape, stylespec) {
                  if (typeof stylespec.color != "undefined") {
                    shape.color = stylespec.color || new _colors__WEBPACK_IMPORTED_MODULE_3__.Color();
                    if (!(stylespec.color instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color))
                      shape.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(stylespec.color);
                  } else {
                    shape.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(0);
                  }
                  shape.wireframe = stylespec.wireframe ? true : false;
                  shape.opacity = stylespec.alpha ? (0, _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(stylespec.alpha, 0, 1) : 1;
                  if (typeof stylespec.opacity != "undefined") {
                    shape.opacity = (0, _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(stylespec.opacity, 0, 1);
                  }
                  shape.side = stylespec.side !== void 0 ? stylespec.side : _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;
                  shape.linewidth = typeof stylespec.linewidth == "undefined" ? 1 : stylespec.linewidth;
                  shape.clickable = stylespec.clickable ? true : false;
                  shape.callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.callback);
                  shape.hoverable = stylespec.hoverable ? true : false;
                  shape.hover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.hover_callback);
                  shape.unhover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.unhover_callback);
                  shape.contextMenuEnabled = !!stylespec.contextMenuEnabled;
                  shape.hidden = stylespec.hidden;
                  shape.frame = stylespec.frame;
                }
                /**
                 * Custom renderable shape
                 *
                 * @constructor
                 *
                 * @param {ShapeSpec} stylespec
                 */
                constructor(stylespec) {
                  this.color = 16777215;
                  this.hidden = false;
                  this.wireframe = false;
                  this.opacity = 1;
                  this.linewidth = 1;
                  this.clickable = false;
                  this.hoverable = false;
                  this.contextMenuEnabled = false;
                  this.side = _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;
                  this.stylespec = stylespec || {};
                  this.boundingSphere = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere();
                  this.intersectionShape = {
                    sphere: [],
                    cylinder: [],
                    line: [],
                    triangle: []
                  };
                  GLShape.updateFromStyle(this, this.stylespec);
                  this.components = [];
                  this.shapeObj = null;
                  this.renderedShapeObj = null;
                  this.geo = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                  this.linegeo = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);
                }
                /** Update shape with new style specification
                 * @param {ShapeSpec} newspec
                   @example
                    let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                    sphere.updateStyle({color:'yellow',opacity:0.5});
                    viewer.render();
                 */
                updateStyle(newspec) {
                  for (var prop in newspec) {
                    this.stylespec[prop] = newspec[prop];
                  }
                  GLShape.updateFromStyle(this, this.stylespec);
                  if (newspec.voldata && newspec.volscheme) {
                    (0, _utilities__WEBPACK_IMPORTED_MODULE_8__.adjustVolumeStyle)(newspec);
                    const scheme = newspec.volscheme;
                    const voldata = newspec.voldata;
                    const cc = _colors__WEBPACK_IMPORTED_MODULE_3__.CC;
                    const range = scheme.range() || [-1, 1];
                    this.geo.setColors(function(x, y, z) {
                      let val = voldata.getVal(x, y, z);
                      let col = cc.color(scheme.valueToHex(val, range));
                      return col;
                    });
                    delete this.color;
                  }
                }
                /**
                 * Creates a custom shape from supplied vertex and face arrays
                 * @param {CustomShapeSpec} customSpec
                 */
                addCustom(customSpec) {
                  customSpec.vertexArr = customSpec.vertexArr || [];
                  customSpec.faceArr = customSpec.faceArr || [];
                  customSpec.normalArr = customSpec.normalArr || [];
                  GLShape.drawCustom(this, this.geo, customSpec);
                }
                /**
                 * Creates a sphere shape
                 * @param {SphereSpec} sphereSpec
                 @example
                 viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                 
                 viewer.render();
                 */
                addSphere(sphereSpec) {
                  if (!sphereSpec.center) {
                    sphereSpec.center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  }
                  sphereSpec.radius = sphereSpec.radius ? (0, _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(sphereSpec.radius, 0, Infinity) : 1.5;
                  sphereSpec.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(sphereSpec.color);
                  this.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(sphereSpec.center, sphereSpec.radius));
                  _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawSphere(this.geo, sphereSpec.center, sphereSpec.radius, sphereSpec.color, sphereSpec.quality);
                  this.components.push({
                    centroid: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(sphereSpec.center.x, sphereSpec.center.y, sphereSpec.center.z)
                  });
                  var geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                /**
                 * Creates a box
                 * @param {BoxSpec} boxSpec
                 @example
                 var shape = viewer.addShape({color:'red'});
                 shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});
                 shape.addBox({corner: {x:-5,y:-3,z:0},
                               dimensions: { w: {x:1,y:1,z:0},
                                             h: {x:-1,y:1,z:0},
                                             d: {x:0,y:0,z:1} }});
                 viewer.zoomTo();
                 viewer.rotate(30);
                 viewer.render();
                 */
                addBox(boxSpec) {
                  var dim = boxSpec.dimensions || { w: 1, h: 1, d: 1 };
                  var w;
                  if (typeof dim.w == "number") {
                    w = { x: dim.w, y: 0, z: 0 };
                  } else {
                    w = dim.w;
                  }
                  var h;
                  if (typeof dim.h == "number") {
                    h = { x: 0, y: dim.h, z: 0 };
                  } else {
                    h = dim.h;
                  }
                  var d;
                  if (typeof dim.d == "number") {
                    d = { x: 0, y: 0, z: dim.d };
                  } else {
                    d = dim.d;
                  }
                  var c = boxSpec.corner;
                  if (c == void 0) {
                    if (boxSpec.center !== void 0) {
                      c = {
                        x: boxSpec.center.x - 0.5 * (w.x + h.x + d.x),
                        y: boxSpec.center.y - 0.5 * (w.y + h.y + d.y),
                        z: boxSpec.center.z - 0.5 * (w.z + h.z + d.z)
                      };
                    } else {
                      c = { x: 0, y: 0, z: 0 };
                    }
                  }
                  var uv = [
                    { x: c.x, y: c.y, z: c.z },
                    { x: c.x + w.x, y: c.y + w.y, z: c.z + w.z },
                    { x: c.x + h.x, y: c.y + h.y, z: c.z + h.z },
                    { x: c.x + w.x + h.x, y: c.y + w.y + h.y, z: c.z + w.z + h.z },
                    { x: c.x + d.x, y: c.y + d.y, z: c.z + d.z },
                    { x: c.x + w.x + d.x, y: c.y + w.y + d.y, z: c.z + w.z + d.z },
                    { x: c.x + h.x + d.x, y: c.y + h.y + d.y, z: c.z + h.z + d.z },
                    { x: c.x + w.x + h.x + d.x, y: c.y + w.y + h.y + d.y, z: c.z + w.z + h.z + d.z }
                  ];
                  var verts = [];
                  var faces = [];
                  verts.splice(verts.length, 0, uv[0], uv[1], uv[2], uv[3]);
                  faces.splice(faces.length, 0, 0, 2, 1, 1, 2, 3);
                  var foff = 4;
                  verts.splice(verts.length, 0, uv[2], uv[3], uv[6], uv[7]);
                  faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);
                  foff += 4;
                  verts.splice(verts.length, 0, uv[4], uv[5], uv[0], uv[1]);
                  faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);
                  foff += 4;
                  verts.splice(verts.length, 0, uv[6], uv[7], uv[4], uv[5]);
                  faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);
                  foff += 4;
                  verts.splice(verts.length, 0, uv[3], uv[1], uv[7], uv[5]);
                  faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);
                  foff += 4;
                  verts.splice(verts.length, 0, uv[2], uv[6], uv[0], uv[4]);
                  faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);
                  foff += 4;
                  var spec = (0, _utilities__WEBPACK_IMPORTED_MODULE_8__.extend)({}, boxSpec);
                  spec.vertexArr = verts;
                  spec.faceArr = faces;
                  spec.normalArr = [];
                  GLShape.drawCustom(this, this.geo, spec);
                  var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  this.components.push({
                    centroid: centroid.addVectors(uv[0], uv[7]).multiplyScalar(0.5)
                  });
                  var geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                /**
                 * Creates a cylinder shape
                 * @param {CylinderSpec} cylinderSpec
                 @example
                      viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
                                          end:{x:10.0,y:0.0,z:0.0},
                                          radius:1.0,
                                          fromCap:1,
                                          toCap:2,
                                          color:'red',
                                          hoverable:true,
                                          clickable:true,
                                          callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
                                          hover_callback: function(){ viewer.render( );},
                                          unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
                                         });
                      viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
                                          end:{x:0.0,y:10.0,z:0.0},
                                          radius:0.5,
                                          fromCap:false,
                                          toCap:true,
                                          color:'teal'});
                      viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
                                          end:{x:20.0,y:0.0,z:0.0},
                                          radius:1.0,
                                          color:'black',
                                          fromCap:false,
                                          toCap:false});
                      viewer.render();
                 */
                addCylinder(cylinderSpec) {
                  var start;
                  var end;
                  if (!cylinderSpec.start) {
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  } else {
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);
                  }
                  if (!cylinderSpec.end) {
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  } else {
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);
                    if (typeof end.x == "undefined")
                      end.x = 3;
                  }
                  var radius = cylinderSpec.radius || 0.1;
                  var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(cylinderSpec.color);
                  this.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(start, end, radius));
                  _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawCylinder(this.geo, start, end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);
                  var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  this.components.push({
                    centroid: centroid.addVectors(start, end).multiplyScalar(0.5)
                  });
                  var geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                /**
                 * Creates a dashed cylinder shape
                 * @param {CylinderSpec} cylinderSpec
                 */
                addDashedCylinder(cylinderSpec) {
                  cylinderSpec.dashLength = cylinderSpec.dashLength || 0.25;
                  cylinderSpec.gapLength = cylinderSpec.gapLength || 0.25;
                  var start;
                  if (!cylinderSpec.start)
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  else {
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);
                  }
                  var end;
                  if (!cylinderSpec.end)
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);
                  else {
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);
                    if (typeof end.x == "undefined")
                      end.x = 3;
                  }
                  var radius = cylinderSpec.radius || 0.1;
                  var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(cylinderSpec.color);
                  var cylinderLength = Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2) + Math.pow(start.z - end.z, 2));
                  var count = cylinderLength / (cylinderSpec.gapLength + cylinderSpec.dashLength);
                  var new_start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);
                  var new_end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);
                  var gapVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.gapLength), (end.y - start.y) / (cylinderLength / cylinderSpec.gapLength), (end.z - start.z) / (cylinderLength / cylinderSpec.gapLength));
                  var dashVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.dashLength), (end.y - start.y) / (cylinderLength / cylinderSpec.dashLength), (end.z - start.z) / (cylinderLength / cylinderSpec.dashLength));
                  for (var place = 0; place < count; place++) {
                    new_end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_start.x + dashVector.x, new_start.y + dashVector.y, new_start.z + dashVector.z);
                    this.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(new_start, new_end, radius));
                    _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawCylinder(this.geo, new_start, new_end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);
                    new_start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_end.x + gapVector.x, new_end.y + gapVector.y, new_end.z + gapVector.z);
                  }
                  var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  this.components.push({
                    centroid: centroid.addVectors(start, end).multiplyScalar(0.5)
                  });
                  var geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                /**
                 * Creates a curved shape
                 * @param {CurveSpec} curveSpec
                 */
                addCurve(curveSpec) {
                  curveSpec.points = curveSpec.points || [];
                  curveSpec.smooth = curveSpec.smooth || 10;
                  if (typeof curveSpec.fromCap == "undefined")
                    curveSpec.fromCap = 2;
                  if (typeof curveSpec.toCap == "undefined")
                    curveSpec.toCap = 2;
                  var points = (0, _glcartoon__WEBPACK_IMPORTED_MODULE_7__.subdivide_spline)(curveSpec.points, curveSpec.smooth);
                  if (points.length < 3) {
                    console.log("Too few points in addCurve");
                    return;
                  }
                  var radius = curveSpec.radius || 0.1;
                  var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(curveSpec.color);
                  var start = 0;
                  var end = points.length - 1;
                  var segmentlen = points[0].distanceTo(points[1]);
                  var npts = Math.ceil(2 * radius / segmentlen);
                  if (curveSpec.toArrow) {
                    end -= npts;
                    let arrowspec = {
                      start: points[end],
                      end: points[points.length - 1],
                      radius,
                      color,
                      mid: 1e-4
                    };
                    this.addArrow(arrowspec);
                  }
                  if (curveSpec.fromArrow) {
                    start += npts;
                    let arrowspec = {
                      start: points[start],
                      end: points[0],
                      radius,
                      color,
                      mid: 1e-4
                    };
                    this.addArrow(arrowspec);
                  }
                  var midway = Math.ceil(points.length / 2);
                  var middleSpec = { radius, color, fromCap: 2, toCap: 2 };
                  for (var i = start; i < end; i++) {
                    middleSpec.start = points[i];
                    middleSpec.end = points[i + 1];
                    middleSpec.fromCap = 2;
                    middleSpec.toCap = 2;
                    if (i < midway) {
                      middleSpec.fromCap = 2;
                      middleSpec.toCap = 0;
                    } else if (i > midway) {
                      middleSpec.fromCap = 0;
                      middleSpec.toCap = 2;
                    } else {
                      middleSpec.fromCap = 2;
                      middleSpec.toCap = 2;
                    }
                    this.addCylinder(middleSpec);
                  }
                }
                /**
                 * Creates a line shape
                 * @param {LineSpec} lineSpec
                 @example
                 $3Dmol.download("pdb:2ABJ",viewer,{},function(){
                          viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
                          viewer.render(callback);
                      });
                
                 */
                addLine(lineSpec) {
                  var start;
                  var end;
                  if (!lineSpec.start) {
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  } else {
                    start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(lineSpec.start.x || 0, lineSpec.start.y || 0, lineSpec.start.z || 0);
                  }
                  if (!lineSpec.end) {
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);
                  } else {
                    end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(lineSpec.end.x, lineSpec.end.y || 0, lineSpec.end.z || 0);
                    if (typeof end.x == "undefined")
                      end.x = 3;
                  }
                  var geoGroup = this.geo.updateGeoGroup(2);
                  var vstart = geoGroup.vertices;
                  var i = vstart * 3;
                  var vertexArray = geoGroup.vertexArray;
                  vertexArray[i] = start.x;
                  vertexArray[i + 1] = start.y;
                  vertexArray[i + 2] = start.z;
                  vertexArray[i + 3] = end.x;
                  vertexArray[i + 4] = end.y;
                  vertexArray[i + 5] = end.z;
                  geoGroup.vertices += 2;
                  var lineArray = geoGroup.lineArray;
                  var li = geoGroup.lineidx;
                  lineArray[li] = vstart;
                  lineArray[li + 1] = vstart + 1;
                  geoGroup.lineidx += 2;
                  var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  this.components.push({
                    centroid: centroid.addVectors(start, end).multiplyScalar(0.5)
                  });
                  geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                /**
                 * Creates an arrow shape
                 * @param {ArrowSpec} arrowSpec
                 @example
                  $3Dmol.download("pdb:4DM7",viewer,{},function(){
                          viewer.setBackgroundColor(0xffffffff);
                          viewer.addArrow({
                              start: {x:-10.0, y:0.0, z:0.0},
                              end: {x:0.0, y:-10.0, z:0.0},
                              radius: 1.0,
                              radiusRadio:1.0,
                              mid:1.0,
                              clickable:true,
                              callback:function(){
                                  this.color.setHex(0xFF0000FF);
                                  viewer.render( );
                              }
                          });
                          viewer.render();
                        });
                 */
                addArrow(arrowSpec) {
                  if (!arrowSpec.start) {
                    arrowSpec.start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  } else {
                    arrowSpec.start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(arrowSpec.start.x || 0, arrowSpec.start.y || 0, arrowSpec.start.z || 0);
                  }
                  if (arrowSpec.dir instanceof _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3 && typeof arrowSpec.length === "number") {
                    var end = arrowSpec.dir.clone().multiplyScalar(arrowSpec.length).add(arrowSpec.start);
                    arrowSpec.end = end;
                  } else if (!arrowSpec.end) {
                    arrowSpec.end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);
                  } else {
                    arrowSpec.end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(arrowSpec.end.x, arrowSpec.end.y || 0, arrowSpec.end.z || 0);
                    if (typeof arrowSpec.end.x == "undefined")
                      arrowSpec.end.x = 3;
                  }
                  arrowSpec.radius = arrowSpec.radius || 0.1;
                  arrowSpec.radiusRatio = arrowSpec.radiusRatio || 1.618034;
                  arrowSpec.mid = 0 < arrowSpec.mid && arrowSpec.mid < 1 ? arrowSpec.mid : 0.618034;
                  GLShape.drawArrow(this, this.geo, arrowSpec);
                  var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  this.components.push({
                    centroid: centroid.addVectors(arrowSpec.start, arrowSpec.end).multiplyScalar(0.5)
                  });
                  var geoGroup = this.geo.updateGeoGroup(0);
                  GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);
                }
                static distance_from(c1, c2) {
                  return Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2) + Math.pow(c1.z - c2.z, 2));
                }
                static inSelectedRegion(coordinate, selectedRegion, radius) {
                  for (var i = 0; i < selectedRegion.length; i++) {
                    if (GLShape.distance_from(selectedRegion[i], coordinate) <= radius)
                      return true;
                  }
                  return false;
                }
                /**
                 * Create isosurface from volumetric data.
                 * @param {VolumeData} data - volumetric input data
                 * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification
                 * @example //the user can specify a selected region for the isosurface
                 $.get('../test_structs/benzene-homo.cube', function(data){
                          var voldata = new $3Dmol.VolumeData(data, "cube");
                          viewer.addIsosurface(voldata, {isoval: 0.01,
                                                         color: "blue",
                                                         alpha: 0.5,
                                                         smoothness: 10});
                          viewer.addIsosurface(voldata, {isoval: -0.01,
                                                         color: "red",
                                                         smoothness: 5,
                                                         opacity:0.5,
                                                         wireframe:true,
                                                         clickable:true,
                                                         callback:
                                                         function() {
                                                             this.opacity = 0.0;
                                                             viewer.render( );
                                                         }});
                          viewer.setStyle({}, {stick:{}});
                          viewer.zoomTo();
                          viewer.render();
                        });
                 */
                addIsosurface(data, volSpec, callback2, viewer) {
                  var isoval = volSpec.isoval !== void 0 && typeof volSpec.isoval === "number" ? volSpec.isoval : 0;
                  var voxel = volSpec.voxel ? true : false;
                  var smoothness = volSpec.smoothness === void 0 ? 1 : volSpec.smoothness;
                  var nX = data.size.x;
                  var nY = data.size.y;
                  var nZ = data.size.z;
                  var vertnums = new Int16Array(nX * nY * nZ);
                  var vals = data.data;
                  var i, il;
                  for (i = 0, il = vertnums.length; i < il; ++i)
                    vertnums[i] = -1;
                  var bitdata = new Uint8Array(nX * nY * nZ);
                  for (i = 0, il = vals.length; i < il; ++i) {
                    var val = isoval >= 0 ? vals[i] - isoval : isoval - vals[i];
                    if (val > 0)
                      bitdata[i] |= GLShape.ISDONE;
                  }
                  var verts = [], faces = [];
                  _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__.MarchingCube.march(bitdata, verts, faces, {
                    fulltable: true,
                    voxel,
                    unitCube: data.unit,
                    origin: data.origin,
                    matrix: data.matrix,
                    nX,
                    nY,
                    nZ
                  });
                  if (!voxel && smoothness > 0)
                    _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__.MarchingCube.laplacianSmooth(smoothness, verts, faces);
                  var vertexmapping = [];
                  var newvertices = [];
                  var newfaces = [];
                  if (volSpec.selectedRegion && volSpec.coords === void 0) {
                    volSpec.coords = volSpec.selectedRegion;
                  }
                  if (volSpec.coords === void 0 && volSpec.selection !== void 0) {
                    if (!viewer) {
                      console.log("addIsosurface needs viewer is selection provided.");
                    } else {
                      volSpec.coords = viewer.selectedAtoms(volSpec.selection);
                    }
                  }
                  if (volSpec.coords !== void 0) {
                    var xmax = volSpec.coords[0].x, ymax = volSpec.coords[0].y, zmax = volSpec.coords[0].z, xmin = volSpec.coords[0].x, ymin = volSpec.coords[0].y, zmin = volSpec.coords[0].z;
                    for (let i2 = 0; i2 < volSpec.coords.length; i2++) {
                      if (volSpec.coords[i2].x > xmax)
                        xmax = volSpec.coords[i2].x;
                      else if (volSpec.coords[i2].x < xmin)
                        xmin = volSpec.coords[i2].x;
                      if (volSpec.coords[i2].y > ymax)
                        ymax = volSpec.coords[i2].y;
                      else if (volSpec.coords[i2].y < ymin)
                        ymin = volSpec.coords[i2].y;
                      if (volSpec.coords[i2].z > zmax)
                        zmax = volSpec.coords[i2].z;
                      else if (volSpec.coords[i2].z < zmin)
                        zmin = volSpec.coords[i2].z;
                    }
                    var rad = 2;
                    if (volSpec.radius !== void 0) {
                      rad = volSpec.radius;
                    }
                    if (volSpec.selectedOffset !== void 0) {
                      rad = volSpec.selectedOffset;
                    }
                    if (volSpec.seldist !== void 0) {
                      rad = volSpec.seldist;
                    }
                    xmin -= rad;
                    xmax += rad;
                    ymin -= rad;
                    ymax += rad;
                    zmin -= rad;
                    zmax += rad;
                    for (let i2 = 0; i2 < verts.length; i2++) {
                      if (verts[i2].x > xmin && verts[i2].x < xmax && verts[i2].y > ymin && verts[i2].y < ymax && verts[i2].z > zmin && verts[i2].z < zmax && GLShape.inSelectedRegion(verts[i2], volSpec.coords, rad)) {
                        vertexmapping.push(newvertices.length);
                        newvertices.push(verts[i2]);
                      } else {
                        vertexmapping.push(-1);
                      }
                    }
                    for (let i2 = 0; i2 + 2 < faces.length; i2 += 3) {
                      if (vertexmapping[faces[i2]] !== -1 && vertexmapping[faces[i2 + 1]] !== -1 && vertexmapping[faces[i2 + 2]] !== -1) {
                        newfaces.push(faces[i2] - (faces[i2] - vertexmapping[faces[i2]]));
                        newfaces.push(faces[i2 + 1] - (faces[i2 + 1] - vertexmapping[faces[i2 + 1]]));
                        newfaces.push(faces[i2 + 2] - (faces[i2 + 2] - vertexmapping[faces[i2 + 2]]));
                      }
                    }
                    verts = newvertices;
                    faces = newfaces;
                  }
                  GLShape.drawCustom(this, this.geo, {
                    vertexArr: verts,
                    faceArr: faces,
                    normalArr: [],
                    clickable: volSpec.clickable,
                    hoverable: volSpec.hoverable
                  });
                  this.updateStyle(volSpec);
                  var origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(data.origin.x, data.origin.y, data.origin.z);
                  var size = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(data.size.x * data.unit.x, data.size.y * data.unit.y, data.size.z * data.unit.z);
                  var total = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
                  var maxv = origin.clone();
                  var minv = origin.clone().add(size);
                  for (let i2 = 0; i2 < verts.length; i2++) {
                    total.add(verts[i2]);
                    maxv.max(verts[i2]);
                    minv.min(verts[i2]);
                  }
                  total.divideScalar(verts.length);
                  var len1 = total.distanceTo(minv);
                  var len2 = total.distanceTo(maxv);
                  this.boundingSphere.center = total;
                  this.boundingSphere.radius = Math.max(len1, len2);
                  if (typeof callback2 == "function")
                    callback2();
                }
                /**
                 * @deprecated Use addIsosurface instead
                 * Creates custom shape from volumetric data
                 * @param {string} data - Volumetric input data
                 * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)
                 * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification
                 */
                addVolumetricData(data, fmt, volSpec) {
                  data = new _VolumeData__WEBPACK_IMPORTED_MODULE_5__.VolumeData(data, fmt);
                  this.addIsosurface(data, volSpec);
                }
                //for internal use, truncate buffers to save memory
                finalize() {
                  GLShape.finalizeGeo(this.geo);
                  this.geo.initTypedArrays();
                  return this.geo;
                }
                /*
                 * Initialize webgl objects for rendering
                 * @param {$3Dmol.Object3D} group
                 *
                 */
                globj(group) {
                  if (this.renderedShapeObj) {
                    group.remove(this.renderedShapeObj);
                    this.renderedShapeObj = null;
                  }
                  if (this.hidden)
                    return;
                  GLShape.finalizeGeo(this.geo);
                  this.geo.initTypedArrays();
                  if (this.wireframe) {
                    this.geo.setUpWireframe();
                  }
                  if (typeof this.color != "undefined")
                    GLShape.updateColor(this.geo, this.color);
                  this.shapeObj = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();
                  var material = null;
                  if (this.side == _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide) {
                    material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshDoubleLambertMaterial({
                      wireframe: this.wireframe,
                      side: this.side,
                      transparent: this.opacity < 1 ? true : false,
                      opacity: this.opacity,
                      wireframeLinewidth: this.linewidth,
                      vertexColors: _WebGL__WEBPACK_IMPORTED_MODULE_0__.Coloring.VertexColors
                    });
                  } else {
                    material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({
                      wireframe: this.wireframe,
                      side: this.side,
                      transparent: this.opacity < 1 ? true : false,
                      opacity: this.opacity,
                      wireframeLinewidth: this.linewidth,
                      vertexColors: _WebGL__WEBPACK_IMPORTED_MODULE_0__.Coloring.VertexColors
                    });
                  }
                  var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geo, material);
                  this.shapeObj.add(mesh);
                  if (this.linegeo && this.linegeo.vertices > 0) {
                    var lineMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
                      linewidth: this.linewidth,
                      color: this.color
                    });
                    var line = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(this.linegeo, lineMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);
                    this.shapeObj.add(line);
                  }
                  this.renderedShapeObj = this.shapeObj.clone();
                  group.add(this.renderedShapeObj);
                }
                removegl(group) {
                  if (this.renderedShapeObj) {
                    if (this.renderedShapeObj.geometry !== void 0)
                      this.renderedShapeObj.geometry.dispose();
                    if (this.renderedShapeObj.material !== void 0)
                      this.renderedShapeObj.material.dispose();
                    group.remove(this.renderedShapeObj);
                    this.renderedShapeObj = null;
                  }
                  this.shapeObj = null;
                }
                get position() {
                  return this.boundingSphere.center;
                }
                get x() {
                  return this.boundingSphere.center.x;
                }
                get y() {
                  return this.boundingSphere.center.y;
                }
                get z() {
                  return this.boundingSphere.center.z;
                }
              }
              GLShape.ISDONE = 2;
              GLShape.drawCustom = function(shape, geo, customSpec) {
                var mesh = customSpec;
                var vertexArr = mesh.vertexArr;
                var faceArr = mesh.faceArr;
                if (vertexArr.length === 0 || faceArr.length === 0) {
                  console.warn("Error adding custom shape component: No vertices and/or face indices supplied!");
                }
                var color = customSpec.color;
                if (typeof color == "undefined") {
                  color = shape.color;
                }
                color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(color);
                var splits = splitMesh(mesh);
                for (var i = 0, n = splits.length; i < n; i++) {
                  GLShape.addCustomGeo(shape, geo, splits[i], splits[i].colorArr ? splits[i].colorArr : color, customSpec.clickable);
                }
              };
              ;
              function splitMesh(mesh) {
                var MAXVERT = 64e3;
                if (mesh.vertexArr.length < MAXVERT)
                  return [mesh];
                var slices = [{ vertexArr: [], normalArr: [], faceArr: [] }];
                if (mesh.colorArr)
                  slices.colorArr = [];
                var vertSlice = [];
                var vertIndex = [];
                var currentSlice = 0;
                var faces = mesh.faceArr;
                for (let i = 0, nf = faces.length; i < nf; i += 3) {
                  let slice = slices[currentSlice];
                  for (let j = 0; j < 3; j++) {
                    var v = faces[i + j];
                    if (vertSlice[v] !== currentSlice) {
                      vertSlice[v] = currentSlice;
                      vertIndex[v] = slice.vertexArr.length;
                      slice.vertexArr.push(mesh.vertexArr[v]);
                      if (mesh.normalArr && mesh.normalArr[v])
                        slice.normalArr.push(mesh.normalArr[v]);
                      if (mesh.colorArr && mesh.colorArr[v])
                        slice.colorArr.push(mesh.colorArr[v]);
                    }
                    slice.faceArr.push(vertIndex[v]);
                  }
                  if (slice.vertexArr.length >= MAXVERT) {
                    slices.push({ vertexArr: [], normalArr: [], faceArr: [] });
                    if (mesh.colorArr)
                      slices.colorArr = [];
                    currentSlice++;
                  }
                }
                return slices;
              }
              ;
              ;
              ;
              ;
              ;
              ;
              ;
              ;
              ;
              ;
            },
            /***/
            "./src/GLViewer.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CONTEXTS_PER_VIEWPORT: () => (
                  /* binding */
                  CONTEXTS_PER_VIEWPORT
                ),
                /* harmony export */
                GLViewer: () => (
                  /* binding */
                  GLViewer
                ),
                /* harmony export */
                createStereoViewer: () => (
                  /* binding */
                  createStereoViewer
                ),
                /* harmony export */
                createViewer: () => (
                  /* binding */
                  createViewer
                ),
                /* harmony export */
                createViewerGrid: () => (
                  /* binding */
                  createViewerGrid
                )
                /* harmony export */
              });
              var upng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! upng-js */
                "./node_modules/upng-js/UPNG.js"
              );
              var upng_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(upng_js__WEBPACK_IMPORTED_MODULE_0__);
              var _GLModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./GLModel */
                "./src/GLModel.ts"
              );
              var _GLShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./GLShape */
                "./src/GLShape.ts"
              );
              var _Gradient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _Label__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./Label */
                "./src/Label.ts"
              );
              var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./ProteinSurface4 */
                "./src/ProteinSurface4.ts"
              );
              var _VolumeData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./VolumeData */
                "./src/VolumeData.ts"
              );
              var _VolumetricRender__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./VolumetricRender */
                "./src/VolumetricRender.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              const CONTEXTS_PER_VIEWPORT = 16;
              class Surface extends Array {
                constructor(items) {
                  super(...items);
                }
                /**
                 * Returns list of rotational/translational matrices if there is BIOMT data
                 * Otherwise returns a list of just the ID matrix
                 *
                 * @return {Array<Matrix4>}
                 *
                 */
                getSymmetries() {
                  if (this.length == 0)
                    return [];
                  let obj = this[0];
                  if (typeof obj.symmetries == "undefined") {
                    this.setSymmetries([new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Matrix4()]);
                  }
                  return obj.symmetries;
                }
                /**
                 * Sets symmetries based on specified matrices in list
                 *
                 * @param {Array<Matrix4>} list
                 *
                 */
                setSymmetries(syms) {
                  if (typeof syms == "undefined") {
                    syms = [new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Matrix4()];
                  }
                  for (let obj of this) {
                    obj.symmetries = syms;
                    obj.finished = false;
                  }
                }
              }
              class GLViewer {
                getWidth() {
                  let div = this.container;
                  let w = div.offsetWidth;
                  if (w == 0 && div.style.display === "none") {
                    let oldpos = div.style.position;
                    let oldvis = div.style.visibility;
                    div.style.display = "block";
                    div.style.visibility = "hidden";
                    div.style.position = "absolute";
                    w = div.offsetWidth;
                    div.style.display = "none";
                    div.style.visibility = oldvis;
                    div.style.position = oldpos;
                  }
                  return w;
                }
                getHeight() {
                  let div = this.container;
                  let h = div.offsetHeight;
                  if (h == 0 && div.style.display === "none") {
                    let oldpos = div.style.position;
                    let oldvis = div.style.visibility;
                    div.style.display = "block";
                    div.style.visibility = "hidden";
                    div.style.position = "absolute";
                    h = div.offsetHeight;
                    div.style.display = "none";
                    div.style.visibility = oldvis;
                    div.style.position = oldpos;
                  }
                  return h;
                }
                setupRenderer() {
                  let rendopt = Object.assign(Object.assign({}, this.config), {
                    preserveDrawingBuffer: true,
                    premultipliedAlpha: false,
                    //cannot initialize with zero size - render will start out lost
                    containerWidth: this.WIDTH,
                    containerHeight: this.HEIGHT
                  });
                  this.renderer = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Renderer(rendopt);
                  this.renderer.domElement.style.width = "100%";
                  this.renderer.domElement.style.height = "100%";
                  this.renderer.domElement.style.padding = "0";
                  this.renderer.domElement.style.position = "absolute";
                  this.renderer.domElement.style.top = "0px";
                  this.renderer.domElement.style.left = "0px";
                  this.renderer.domElement.style.zIndex = "0";
                }
                initializeScene() {
                  this.scene = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Scene();
                  this.scene.fog = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Fog(this.bgColor, 100, 200);
                  this.modelGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Object3D();
                  this.rotationGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Object3D();
                  this.rotationGroup.useQuaternion = true;
                  this.rotationGroup.quaternion = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(0, 0, 0, 1);
                  this.rotationGroup.add(this.modelGroup);
                  this.scene.add(this.rotationGroup);
                  var directionalLight = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Light(16777215);
                  directionalLight.position = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0.2, 0.2, 1).normalize();
                  directionalLight.intensity = 1;
                  this.scene.add(directionalLight);
                }
                _handleLostContext(event) {
                  const isVisible = function(cont) {
                    const rect = cont.getBoundingClientRect();
                    return !(rect.right < 0 || rect.bottom < 0 || rect.top > (window.innerHeight || document.documentElement.clientHeight) || rect.left > (window.innerWidth || document.documentElement.clientWidth));
                  };
                  if (isVisible(this.container)) {
                    let restored = 0;
                    for (let c of document.getElementsByTagName("canvas")) {
                      if (isVisible(c) && c._3dmol_viewer != void 0) {
                        c._3dmol_viewer.resize();
                        restored += 1;
                        if (restored >= CONTEXTS_PER_VIEWPORT)
                          break;
                      }
                    }
                  }
                }
                initContainer(element) {
                  this.container = element;
                  this.WIDTH = this.getWidth();
                  this.HEIGHT = this.getHeight();
                  this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);
                  this.renderer.setSize(this.WIDTH, this.HEIGHT);
                  this.container.append(this.renderer.domElement);
                  this.glDOM = this.renderer.domElement;
                  this.glDOM._3dmol_viewer = this;
                  this.glDOM.addEventListener("webglcontextlost", this._handleLostContext.bind(this));
                  if (!this.nomouse) {
                    this.glDOM.addEventListener("mousedown", this._handleMouseDown.bind(this), { passive: false });
                    this.glDOM.addEventListener("touchstart", this._handleMouseDown.bind(this), { passive: false });
                    this.glDOM.addEventListener("wheel", this._handleMouseScroll.bind(this), { passive: false });
                    this.glDOM.addEventListener("mousemove", this._handleMouseMove.bind(this), { passive: false });
                    this.glDOM.addEventListener("touchmove", this._handleMouseMove.bind(this), { passive: false });
                    this.glDOM.addEventListener("contextmenu", this._handleContextMenu.bind(this), { passive: false });
                  }
                }
                decAnim() {
                  this.animated--;
                  if (this.animated < 0)
                    this.animated = 0;
                }
                incAnim() {
                  this.animated++;
                }
                nextSurfID() {
                  var max = 0;
                  for (let i in this.surfaces) {
                    if (!this.surfaces.hasOwnProperty(i))
                      continue;
                    var val = parseInt(i);
                    if (!isNaN(val)) {
                      if (val > max)
                        max = val;
                    }
                  }
                  return max + 1;
                }
                setSlabAndFog() {
                  let center = this.camera.position.z - this.rotationGroup.position.z;
                  if (center < 1)
                    center = 1;
                  this.camera.near = center + this.slabNear;
                  if (!this.camera.ortho && this.camera.near < 1)
                    this.camera.near = 1;
                  this.camera.far = center + this.slabFar;
                  if (this.camera.near + 1 > this.camera.far)
                    this.camera.far = this.camera.near + 1;
                  this.camera.fov = this.fov;
                  this.camera.right = center * Math.tan(Math.PI / 180 * this.fov);
                  this.camera.left = -this.camera.right;
                  this.camera.top = this.camera.right / this.ASPECT;
                  this.camera.bottom = -this.camera.top;
                  this.camera.updateProjectionMatrix();
                  this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near);
                  this.scene.fog.far = this.camera.near + this.fogEnd * (this.camera.far - this.camera.near);
                  if (this.config.disableFog) {
                    this.scene.fog.near = this.scene.fog.far;
                  }
                }
                // display scene
                //if nolink is set/true, don't propagate changes to linked viewers
                show(nolink) {
                  this.renderer.setViewport();
                  if (!this.scene)
                    return;
                  this.setSlabAndFog();
                  this.renderer.render(this.scene, this.camera);
                  if (this.viewChangeCallback)
                    this.viewChangeCallback(this._viewer.getView());
                  if (!nolink && this.linkedViewers.length > 0) {
                    var view = this._viewer.getView();
                    for (var i = 0; i < this.linkedViewers.length; i++) {
                      var other = this.linkedViewers[i];
                      other.setView(view, true);
                    }
                  }
                }
                //regenerate the list of clickables
                //also updates hoverables
                updateClickables() {
                  this.clickables.splice(0, this.clickables.length);
                  this.hoverables.splice(0, this.hoverables.length);
                  this.contextMenuEnabledObjects.splice(0, this.contextMenuEnabledObjects.length);
                  for (let i = 0, il = this.models.length; i < il; i++) {
                    let model = this.models[i];
                    if (model) {
                      let atoms = model.selectedAtoms({
                        clickable: true
                      });
                      let hoverable_atoms = model.selectedAtoms({
                        hoverable: true
                      });
                      let contextMenuEnabled_atom = model.selectedAtoms({ contextMenuEnabled: true });
                      for (let n = 0; n < hoverable_atoms.length; n++) {
                        this.hoverables.push(hoverable_atoms[n]);
                      }
                      for (let m = 0; m < atoms.length; m++) {
                        this.clickables.push(atoms[m]);
                      }
                      for (let m = 0; m < contextMenuEnabled_atom.length; m++) {
                        this.contextMenuEnabledObjects.push(contextMenuEnabled_atom[m]);
                      }
                    }
                  }
                  for (let i = 0, il = this.shapes.length; i < il; i++) {
                    let shape = this.shapes[i];
                    if (shape && shape.clickable) {
                      this.clickables.push(shape);
                    }
                    if (shape && shape.hoverable) {
                      this.hoverables.push(shape);
                    }
                    if (shape && shape.contextMenuEnabled) {
                      this.contextMenuEnabledObjects.push(shape);
                    }
                  }
                }
                // Checks for selection intersects on mousedown
                handleClickSelection(mouseX, mouseY, event) {
                  let intersects = this.targetedObjects(mouseX, mouseY, this.clickables);
                  if (intersects.length) {
                    var selected = intersects[0].clickable;
                    if (selected.callback !== void 0) {
                      if (typeof selected.callback != "function") {
                        selected.callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.makeFunction)(selected.callback);
                      }
                      if (typeof selected.callback === "function") {
                        const isContextMenu = this.mouseButton === 3 && this.contextMenuEnabledObjects.includes(selected) && this.userContextMenuHandler;
                        if (!isContextMenu) {
                          selected.callback(selected, this._viewer, event, this.container, intersects);
                        }
                      }
                    }
                  }
                }
                //return offset of container
                canvasOffset() {
                  let canvas = this.glDOM;
                  let rect = canvas.getBoundingClientRect();
                  let doc = canvas.ownerDocument;
                  let docElem = doc.documentElement;
                  let win = doc.defaultView;
                  return {
                    top: rect.top + win.pageYOffset - docElem.clientTop,
                    left: rect.left + win.pageXOffset - docElem.clientLeft
                  };
                }
                //set current_hover to sel (which can be null), calling appropraite callbacks
                setHover(selected, event, intersects) {
                  if (this.current_hover == selected)
                    return;
                  if (this.current_hover) {
                    if (typeof this.current_hover.unhover_callback != "function") {
                      this.current_hover.unhover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.makeFunction)(this.current_hover.unhover_callback);
                    }
                    this.current_hover.unhover_callback(this.current_hover, this._viewer, event, this.container, intersects);
                  }
                  this.current_hover = selected;
                  if (selected && selected.hover_callback !== void 0) {
                    if (typeof selected.hover_callback != "function") {
                      selected.hover_callback = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.makeFunction)(selected.hover_callback);
                    }
                    if (typeof selected.hover_callback === "function") {
                      selected.hover_callback(selected, this._viewer, event, this.container, intersects);
                    }
                  }
                }
                //checks for selection intersects on hover
                handleHoverSelection(mouseX, mouseY, event) {
                  if (this.hoverables.length == 0)
                    return;
                  let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);
                  if (intersects.length) {
                    var selected = intersects[0].clickable;
                    this.setHover(selected, event, intersects);
                    this.current_hover = selected;
                  } else {
                    this.setHover(null);
                  }
                }
                //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called
                handleHoverContinue(mouseX, mouseY) {
                  let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);
                  if (intersects.length == 0 || intersects[0] === void 0) {
                    this.setHover(null);
                  }
                  if (intersects[0] !== void 0 && intersects[0].clickable !== this.current_hover) {
                    this.setHover(null);
                  }
                }
                /**
                 * Determine if a positioned event is "close enough" to mouseStart to be considered a click.
                 * With a mouse, the position should be exact, but allow a slight delta for a touch interface.
                 * @param {Event} event
                 * @param {{ allowTolerance, tolerance: number }} options
                 */
                closeEnoughForClick(event, { allowTolerance = event.targetTouches, tolerance = 5 } = {}) {
                  const x = this.getX(event);
                  const y = this.getY(event);
                  if (allowTolerance) {
                    const deltaX = Math.abs(x - this.mouseStartX);
                    const deltaY = Math.abs(y - this.mouseStartY);
                    return deltaX <= tolerance && deltaY <= tolerance;
                  } else {
                    return x === this.mouseStartX && y === this.mouseStartY;
                  }
                }
                calcTouchDistance(ev) {
                  var xdiff = ev.targetTouches[0].pageX - ev.targetTouches[1].pageX;
                  var ydiff = ev.targetTouches[0].pageY - ev.targetTouches[1].pageY;
                  return Math.hypot(xdiff, ydiff);
                }
                //check targetTouches as well
                getX(ev) {
                  var x = ev.pageX;
                  if (x == void 0)
                    x = ev.pageX;
                  if (ev.targetTouches && ev.targetTouches[0]) {
                    x = ev.targetTouches[0].pageX;
                  } else if (ev.changedTouches && ev.changedTouches[0]) {
                    x = ev.changedTouches[0].pageX;
                  }
                  return x;
                }
                getY(ev) {
                  var y = ev.pageY;
                  if (y == void 0)
                    y = ev.pageY;
                  if (ev.targetTouches && ev.targetTouches[0]) {
                    y = ev.targetTouches[0].pageY;
                  } else if (ev.changedTouches && ev.changedTouches[0]) {
                    y = ev.changedTouches[0].pageY;
                  }
                  return y;
                }
                //for grid viewers, return true if point is in this viewer
                isInViewer(x, y) {
                  if (this.viewers != void 0) {
                    var width = this.WIDTH / this.cols;
                    var height = this.HEIGHT / this.rows;
                    var offset = this.canvasOffset();
                    var relx = x - offset.left;
                    var rely = y - offset.top;
                    var r = this.rows - Math.floor(rely / height) - 1;
                    var c = Math.floor(relx / width);
                    if (r != this.row || c != this.col)
                      return false;
                  }
                  return true;
                }
                //if the user has specify zoom limits, readjust to fit within them
                //also, make sure we don't go past CAMERA_Z
                adjustZoomToLimits(z) {
                  if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {
                    let lower = this.CAMERA_Z - this.config.lowerZoomLimit;
                    if (z > lower)
                      z = lower;
                  }
                  if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {
                    let upper = this.CAMERA_Z - this.config.upperZoomLimit;
                    if (z < upper)
                      z = upper;
                  }
                  if (z > this.CAMERA_Z - 1) {
                    z = this.CAMERA_Z - 1;
                  }
                  return z;
                }
                //interpolate between two normalized quaternions (t between 0 and 1)
                //https://en.wikipedia.org/wiki/Slerp
                static slerp(v0, v1, t) {
                  if (t == 1)
                    return v1.clone();
                  else if (t == 0)
                    return v0.clone();
                  let dot = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w;
                  if (dot > 0.9995) {
                    let result = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(v0.x + t * (v1.x - v0.x), v0.y + t * (v1.y - v0.y), v0.z + t * (v1.z - v0.z), v0.w + t * (v1.w - v0.w));
                    result.normalize();
                    return result;
                  }
                  if (dot < 0) {
                    v1 = v1.clone().multiplyScalar(-1);
                    dot = -dot;
                  }
                  if (dot > 1)
                    dot = 1;
                  else if (dot < -1)
                    dot = -1;
                  var theta_0 = Math.acos(dot);
                  var theta = theta_0 * t;
                  var v2 = v1.clone();
                  v2.sub(v0.clone().multiplyScalar(dot));
                  v2.normalize();
                  var c = Math.cos(theta);
                  var s = Math.sin(theta);
                  var ret = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(v0.x * c + v2.x * s, v0.y * c + v2.y * s, v0.z * c + v2.z * s, v0.w * c + v2.w * s);
                  ret.normalize();
                  return ret;
                }
                /* @param {Object} element HTML element within which to create viewer
                 * @param {ViewerSpec} config Object containing optional configuration for the viewer
                 */
                constructor(element, c = {}) {
                  this.nomouse = false;
                  this.glDOM = null;
                  this.models = [];
                  this.surfaces = {};
                  this.shapes = [];
                  this.labels = [];
                  this.clickables = [];
                  this.hoverables = [];
                  this.contextMenuEnabledObjects = [];
                  this.current_hover = null;
                  this.hoverDuration = 500;
                  this.longTouchDuration = 1e3;
                  this.viewer_frame = 0;
                  this.viewChangeCallback = null;
                  this.stateChangeCallback = null;
                  this.NEAR = 1;
                  this.FAR = 800;
                  this.CAMERA_Z = 150;
                  this.fov = 20;
                  this.linkedViewers = [];
                  this.renderer = null;
                  this.control_all = false;
                  this.scene = null;
                  this.rotationGroup = null;
                  this.modelGroup = null;
                  this.fogStart = 0.4;
                  this.fogEnd = 1;
                  this.slabNear = -50;
                  this.slabFar = 50;
                  this.cq = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(0, 0, 0, 1);
                  this.dq = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(0, 0, 0, 1);
                  this.animated = 0;
                  this.animationTimers = /* @__PURE__ */ new Set();
                  this.isDragging = false;
                  this.mouseStartX = 0;
                  this.mouseStartY = 0;
                  this.touchDistanceStart = 0;
                  this.touchHold = false;
                  this.currentModelPos = 0;
                  this.cz = 0;
                  this.cslabNear = 0;
                  this.cslabFar = 0;
                  this.userContextMenuHandler = null;
                  this.config = c;
                  this.callback = this.config.callback;
                  this.defaultcolors = this.config.defaultcolors;
                  if (!this.defaultcolors)
                    this.defaultcolors = _colors__WEBPACK_IMPORTED_MODULE_10__.elementColors.defaultColors;
                  this.nomouse = Boolean(this.config.nomouse);
                  this.bgColor = 0;
                  this.config.backgroundColor = this.config.backgroundColor || "#ffffff";
                  if (typeof this.config.backgroundColor != "undefined") {
                    this.bgColor = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(this.config.backgroundColor).getHex();
                  }
                  this.config.backgroundAlpha = this.config.backgroundAlpha == void 0 ? 1 : this.config.backgroundAlpha;
                  this.camerax = 0;
                  if (typeof this.config.camerax != "undefined") {
                    this.camerax = typeof this.config.camerax === "string" ? parseFloat(this.config.camerax) : this.config.camerax;
                  }
                  this._viewer = this;
                  this.container = element;
                  if (this.config.hoverDuration != void 0) {
                    this.hoverDuration = this.config.hoverDuration;
                  }
                  if (this.config.antialias === void 0)
                    this.config.antialias = true;
                  if (this.config.cartoonQuality === void 0)
                    this.config.cartoonQuality = 10;
                  this.WIDTH = this.getWidth();
                  this.HEIGHT = this.getHeight();
                  this.setupRenderer();
                  this.row = this.config.row == void 0 ? 0 : this.config.row;
                  this.col = this.config.col == void 0 ? 0 : this.config.col;
                  this.cols = this.config.cols;
                  this.rows = this.config.rows;
                  this.viewers = this.config.viewers;
                  this.control_all = this.config.control_all;
                  this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);
                  this.camera = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic);
                  this.camera.position = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(this.camerax, 0, this.CAMERA_Z);
                  this.lookingAt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3();
                  this.camera.lookAt(this.lookingAt);
                  this.raycaster = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Raycaster(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 0), new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 0));
                  this.projector = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Projector();
                  this.initializeScene();
                  this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);
                  this.scene.fog.color = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(this.bgColor);
                  document.body.addEventListener("mouseup", this._handleMouseUp.bind(this));
                  document.body.addEventListener("touchend", this._handleMouseUp.bind(this));
                  this.initContainer(this.container);
                  if (this.config.style) {
                    this.setViewStyle(this.config);
                  }
                  window.addEventListener("resize", this.resize.bind(this));
                  if (typeof window.ResizeObserver !== "undefined") {
                    this.divwatcher = new window.ResizeObserver(this.resize.bind(this));
                    this.divwatcher.observe(this.container);
                  }
                  if (typeof window.IntersectionObserver !== "undefined") {
                    let intcallback = (entries, observer) => {
                      entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                          this.resize();
                        }
                      });
                    };
                    this.intwatcher = new window.IntersectionObserver(intcallback);
                    this.intwatcher.observe(this.container);
                  }
                  try {
                    if (typeof this.callback === "function")
                      this.callback(this);
                  } catch (e) {
                    console.log("error with glviewer callback: " + e);
                  }
                }
                /**
                * Return a list of objects that intersect that at the specified viewer position.
                *
                * @param x - x position in screen coordinates
                * @param y - y position in screen coordinates
                * @param {Object[]} - list of objects or selection object specifying what object to check for targeting
                */
                targetedObjects(x, y, objects) {
                  var mouse = {
                    x,
                    y,
                    z: -1
                  };
                  if (!Array.isArray(objects)) {
                    objects = this.selectedAtoms(objects);
                  }
                  if (objects.length == 0)
                    return [];
                  this.raycaster.setFromCamera(mouse, this.camera);
                  return this.raycaster.intersectObjects(this.modelGroup, objects);
                }
                /** Convert model coordinates to screen coordinates.
                 * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)
                 * @return {object | list} - and object or list of {x: screenX, y: screenY}
                 */
                modelToScreen(coords) {
                  let returnsingle = false;
                  if (!Array.isArray(coords)) {
                    coords = [coords];
                    returnsingle = true;
                  }
                  let ratioX = this.renderer.getXRatio();
                  let ratioY = this.renderer.getYRatio();
                  let col = this.col;
                  let row = this.row;
                  let viewxoff = col * (this.WIDTH / ratioX);
                  let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);
                  let results = [];
                  let offset = this.canvasOffset();
                  coords.forEach((coord) => {
                    let t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(coord.x, coord.y, coord.z);
                    t.applyMatrix4(this.modelGroup.matrixWorld);
                    this.projector.projectVector(t, this.camera);
                    let screenX = this.WIDTH / ratioX * (t.x + 1) / 2 + offset.left + viewxoff;
                    let screenY = -(this.HEIGHT / ratioY) * (t.y - 1) / 2 + offset.top + viewyoff;
                    results.push({ x: screenX, y: screenY });
                  });
                  if (returnsingle)
                    results = results[0];
                  return results;
                }
                /**
                 * For a given screen (x,y) displacement return model displacement
                 * @param{x} x displacement in screen coordinates
                 * @param{y} y displacement in screen corodinates
                 * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis
                */
                screenOffsetToModel(x, y, modelz) {
                  var dx = x / this.WIDTH;
                  var dy = y / this.HEIGHT;
                  var zpos = modelz === void 0 ? this.rotationGroup.position.z : modelz;
                  var q = this.rotationGroup.quaternion;
                  var t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, zpos);
                  this.projector.projectVector(t, this.camera);
                  t.x += dx * 2;
                  t.y -= dy * 2;
                  this.projector.unprojectVector(t, this.camera);
                  t.z = 0;
                  t.applyQuaternion(q);
                  return t;
                }
                /**
                 * Distance from screen coordinate to model coordinate assuming screen point
                 * is projected to the same depth as model coordinate
                 * @param{screen} xy screen coordinate
                 * @param{model} xyz model coordinate
                */
                screenToModelDistance(screen, model) {
                  let offset = this.canvasOffset();
                  let mvec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(model.x, model.y, model.z);
                  mvec.applyMatrix4(this.modelGroup.matrixWorld);
                  let m = mvec.clone();
                  this.projector.projectVector(mvec, this.camera);
                  let t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3((screen.x - offset.left) * 2 / this.WIDTH - 1, (screen.y - offset.top) * 2 / -this.HEIGHT + 1, mvec.z);
                  this.projector.unprojectVector(t, this.camera);
                  return t.distanceTo(m);
                }
                /**
                 * Set a callback to call when the view has potentially changed.
                 *
                */
                setViewChangeCallback(callback2) {
                  if (typeof callback2 === "function" || callback2 == null)
                    this.viewChangeCallback = callback2;
                }
                /**
                 * Set a callback to call when the view has potentially changed.
                 *
                */
                setStateChangeCallback(callback2) {
                  if (typeof callback2 === "function" || callback2 == null)
                    this.stateChangeCallback = callback2;
                }
                /**
                 * Return configuration of viewer
                 */
                getConfig() {
                  return this.config;
                }
                /**
                 * Set the configuration object.  Note that some settings may only
                 * have an effect at viewer creation time.
                 */
                setConfig(c) {
                  this.config = c;
                  if (c.ambientOcclusion) {
                    this.renderer.enableAmbientOcclusion(c.ambientOcclusion);
                  }
                }
                /**
                 * Return object representing internal state of
                 * the viewer appropriate for passing to setInternalState
                 *
                */
                getInternalState() {
                  var ret = { "models": [], "surfaces": [], "shapes": [], "labels": [] };
                  for (let i = 0; i < this.models.length; i++) {
                    if (this.models[i]) {
                      ret.models[i] = this.models[i].getInternalState();
                    }
                  }
                  return ret;
                }
                /**
                 * Overwrite internal state of the viewer with passed  object
                 * which should come from getInternalState.
                 *
                */
                setInternalState(state) {
                  this.clear();
                  var newm = state.models;
                  for (let i = 0; i < newm.length; i++) {
                    if (newm[i]) {
                      this.models[i] = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(i, void 0, this);
                      this.models[i].setInternalState(newm[i]);
                    }
                  }
                  this.render();
                }
                /**
                 * Set lower and upper limit stops for zoom.
                 *
                 * @param {lower} - limit on zoom in (positive number).  Default 0.
                 * @param {upper} - limit on zoom out (positive number).  Default infinite.
                 * @example
                  $3Dmol.get("data/set1_122_complex.mol2", function(moldata) {
                        var m = viewer.addModel(moldata);
                        viewer.setStyle({stick:{colorscheme:"Jmol"}});
                        viewer.setZoomLimits(100,200);
                        viewer.zoomTo();
                        viewer.zoom(10); //will not zoom all the way
                        viewer.render();
                    });
                */
                setZoomLimits(lower, upper) {
                  if (typeof lower !== "undefined")
                    this.config.lowerZoomLimit = lower;
                  if (upper)
                    this.config.upperZoomLimit = upper;
                  this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  this.show();
                }
                /**
                 * Set camera parameters (distance to the origin and field of view)
                 *
                 * @param {parameters} - new camera parameters, with possible fields
                 *                       being fov for the field of view, z for the
                 *                       distance to the origin, and orthographic (boolean)
                 *                       for kind of projection (default false).
                 * @example
                  $3Dmol.get("data/set1_122_complex.mol2", function(data) {
                        var m = viewer.addModel(data);
                        viewer.setStyle({stick:{}});
                        viewer.zoomTo();
                        viewer.setCameraParameters({ fov: 10 , z: 300 });
                        viewer.render();
                    });
                */
                setCameraParameters(parameters) {
                  if (parameters.fov !== void 0) {
                    this.fov = parameters.fov;
                    this.camera.fov = this.fov;
                  }
                  if (parameters.z !== void 0) {
                    this.CAMERA_Z = parameters.z;
                    this.camera.z = this.CAMERA_Z;
                  }
                  if (parameters.orthographic !== void 0) {
                    this.camera.ortho = parameters.orthographic;
                  }
                  this.setSlabAndFog();
                }
                _handleMouseDown(ev) {
                  ev.preventDefault();
                  if (!this.scene)
                    return;
                  var x = this.getX(ev);
                  var y = this.getY(ev);
                  if (x === void 0)
                    return;
                  this.isDragging = true;
                  this.mouseButton = ev.which;
                  this.mouseStartX = x;
                  this.mouseStartY = y;
                  this.touchHold = true;
                  this.touchDistanceStart = 0;
                  if (ev.targetTouches && ev.targetTouches.length == 2) {
                    this.touchDistanceStart = this.calcTouchDistance(ev);
                  }
                  this.cq = this.rotationGroup.quaternion.clone();
                  this.cz = this.rotationGroup.position.z;
                  this.currentModelPos = this.modelGroup.position.clone();
                  this.cslabNear = this.slabNear;
                  this.cslabFar = this.slabFar;
                  let self2 = this;
                  if (ev.targetTouches && ev.targetTouches.length === 1) {
                    this.longTouchTimeout = setTimeout(function() {
                      if (self2.touchHold == true) {
                        self2.glDOM = self2.renderer.domElement;
                        const touch = ev.targetTouches[0];
                        const newEvent = new PointerEvent("contextmenu", Object.assign(Object.assign({}, ev), { pageX: touch.pageX, pageY: touch.pageY, screenX: touch.screenX, screenY: touch.screenY, clientX: touch.clientX, clientY: touch.clientY }));
                        self2.glDOM.dispatchEvent(newEvent);
                      } else {
                      }
                    }, this.longTouchDuration);
                  }
                }
                _handleMouseUp(ev) {
                  this.touchHold = false;
                  if (this.isDragging && this.scene) {
                    var x = this.getX(ev);
                    var y = this.getY(ev);
                    if (this.closeEnoughForClick(ev) && this.isInViewer(x, y)) {
                      let mouse = this.mouseXY(x, y);
                      this.handleClickSelection(mouse.x, mouse.y, ev);
                    }
                  }
                  this.isDragging = false;
                }
                _handleMouseScroll(ev) {
                  ev.preventDefault();
                  if (!this.scene)
                    return;
                  var x = this.getX(ev);
                  var y = this.getY(ev);
                  if (x === void 0)
                    return;
                  if (!this.control_all && !this.isInViewer(x, y)) {
                    return;
                  }
                  var scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;
                  var mult = 1;
                  if (ev.ctrlKey) {
                    mult = -1;
                  }
                  if (ev.detail) {
                    this.rotationGroup.position.z += mult * scaleFactor * ev.detail / 10;
                  } else if (ev.wheelDelta) {
                    let wd = ev.wheelDelta * 600 / (ev.wheelDelta + 600);
                    this.rotationGroup.position.z -= mult * scaleFactor * wd / 400;
                  }
                  this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  this.show();
                }
                /**
                 * Return image URI of viewer contents (base64 encoded).     *
                 */
                pngURI() {
                  return this.getCanvas().toDataURL("image/png");
                }
                /**
                 * Return a promise that resolves to an animated PNG image URI of
                 viewer contents (base64 encoded) for nframes of viewer changes.
                 * @return {Promise}
                 */
                apngURI(nframes) {
                  let viewer = this;
                  nframes = nframes ? nframes : 1;
                  return new Promise(function(resolve) {
                    let framecnt = 0;
                    let oldcb = viewer.viewChangeCallback;
                    let bufpromise = [];
                    let delays = [];
                    let lasttime = Date.now();
                    viewer.viewChangeCallback = function() {
                      delays.push(Date.now() - lasttime);
                      lasttime = Date.now();
                      bufpromise.push(new Promise((resolve2) => {
                        viewer.getCanvas().toBlob(function(blob) {
                          blob.arrayBuffer().then(resolve2);
                        }, "image/png");
                      }));
                      framecnt += 1;
                      if (framecnt == nframes) {
                        viewer.viewChangeCallback = oldcb;
                        Promise.all(bufpromise).then((buffers) => {
                          let rgbas = [];
                          for (let i = 0; i < buffers.length; i++) {
                            let img = (0, upng_js__WEBPACK_IMPORTED_MODULE_0__.decode)(buffers[i]);
                            rgbas.push((0, upng_js__WEBPACK_IMPORTED_MODULE_0__.toRGBA8)(img)[0]);
                          }
                          let width = viewer.getCanvas().width;
                          let height = viewer.getCanvas().height;
                          let apng = (0, upng_js__WEBPACK_IMPORTED_MODULE_0__.encode)(rgbas, width, height, 0, delays);
                          let blob = new Blob([apng], { type: "image/png" });
                          let fr = new FileReader();
                          fr.onload = function(e) {
                            resolve(e.target.result);
                          };
                          fr.readAsDataURL(blob);
                        });
                      }
                    };
                  });
                }
                /**
                 * Return underlying canvas element.
                 */
                getCanvas() {
                  return this.glDOM;
                }
                /**
                 * Return renderer element.
                 */
                getRenderer() {
                  return this.renderer;
                }
                /**
                     * Set the duration of the hover delay
                     *
                     * @param {number}
                     *            [hoverDuration] - an optional parameter that denotes
                     *            the duration of the hover delay (in milliseconds) before the hover action is called
                     *
                 */
                setHoverDuration(duration) {
                  this.hoverDuration = duration;
                }
                mouseXY(x, y) {
                  let offset = this.canvasOffset();
                  let ratioX = this.renderer.getXRatio();
                  let ratioY = this.renderer.getYRatio();
                  let col = this.col;
                  let row = this.row;
                  let viewxoff = col * (this.WIDTH / ratioX);
                  let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);
                  let mouseX = (x - offset.left - viewxoff) / (this.WIDTH / ratioX) * 2 - 1;
                  let mouseY = -((y - offset.top - viewyoff) / (this.HEIGHT / ratioY)) * 2 + 1;
                  return { x: mouseX, y: mouseY };
                }
                _handleMouseMove(ev) {
                  clearTimeout(this.hoverTimeout);
                  ev.preventDefault();
                  let x = this.getX(ev);
                  let y = this.getY(ev);
                  if (x === void 0)
                    return;
                  let ratioX = this.renderer.getXRatio();
                  let ratioY = this.renderer.getYRatio();
                  let mouse = this.mouseXY(x, y);
                  let self2 = this;
                  if (this.current_hover !== null) {
                    this.handleHoverContinue(mouse.x, mouse.y);
                  }
                  var mode = 0;
                  if (!this.control_all && !this.isInViewer(x, y)) {
                    return;
                  }
                  if (!this.scene)
                    return;
                  if (this.hoverables.length > 0) {
                    this.hoverTimeout = setTimeout(function() {
                      self2.handleHoverSelection(mouse.x, mouse.y, ev);
                    }, this.hoverDuration);
                  }
                  if (!this.isDragging)
                    return;
                  if (ev.targetTouches && (ev.targetTouches.length > 1 || ev.targetTouches.length === 1 && !this.closeEnoughForClick(ev))) {
                    clearTimeout(this.longTouchTimeout);
                  }
                  var dx = (x - this.mouseStartX) / this.WIDTH;
                  var dy = (y - this.mouseStartY) / this.HEIGHT;
                  if (this.touchDistanceStart != 0 && ev.targetTouches && ev.targetTouches.length == 2) {
                    var newdist = this.calcTouchDistance(ev);
                    mode = 2;
                    dy = (newdist - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);
                  } else if (ev.targetTouches && ev.targetTouches.length == 3) {
                    mode = 1;
                  }
                  dx *= ratioX;
                  dy *= ratioY;
                  var r = Math.hypot(dx, dy);
                  var scaleFactor;
                  if (mode == 3 || this.mouseButton == 3 && ev.ctrlKey) {
                    this.slabNear = this.cslabNear + dx * 100;
                    this.slabFar = this.cslabFar - dy * 100;
                  } else if (mode == 2 || this.mouseButton == 3 || ev.shiftKey) {
                    scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;
                    if (scaleFactor < 80)
                      scaleFactor = 80;
                    this.rotationGroup.position.z = this.cz + dy * scaleFactor;
                    this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  } else if (mode == 1 || this.mouseButton == 2 || ev.ctrlKey) {
                    var t = this.screenOffsetToModel(ratioX * (x - this.mouseStartX), ratioY * (y - this.mouseStartY));
                    this.modelGroup.position.addVectors(this.currentModelPos, t);
                  } else if ((mode === 0 || this.mouseButton == 1) && r !== 0) {
                    var rs = Math.sin(r * Math.PI) / r;
                    this.dq.x = Math.cos(r * Math.PI);
                    this.dq.y = 0;
                    this.dq.z = rs * dx;
                    this.dq.w = -rs * dy;
                    this.rotationGroup.quaternion.set(1, 0, 0, 0);
                    this.rotationGroup.quaternion.multiply(this.dq);
                    this.rotationGroup.quaternion.multiply(this.cq);
                  }
                  this.show();
                }
                _handleContextMenu(ev) {
                  ev.preventDefault();
                  if (this.closeEnoughForClick(ev)) {
                    var x = this.mouseStartX;
                    var y = this.mouseStartY;
                    var offset = this.canvasOffset();
                    let mouse = this.mouseXY(x, y);
                    let mouseX = mouse.x;
                    let mouseY = mouse.y;
                    let intersects = this.targetedObjects(mouseX, mouseY, this.contextMenuEnabledObjects);
                    var selected = null;
                    if (intersects.length) {
                      selected = intersects[0].clickable;
                    }
                    var offset = this.canvasOffset();
                    var x = this.mouseStartX - offset.left;
                    var y = this.mouseStartY - offset.top;
                    if (this.userContextMenuHandler) {
                      this.userContextMenuHandler(selected, x, y, intersects, ev);
                      this.isDragging = false;
                    }
                  }
                }
                /**
                     * Change the viewer's container element
                     * Also useful if the original container element was removed from the DOM.
                     *
                     * @param {Object | string} element
                     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.
                
                     */
                setContainer(element) {
                  let elem = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getElement)(element) || this.container;
                  this.initContainer(elem);
                  return this;
                }
                /**
                     * Set the background color (default white)
                     *
                     * @param {number}
                     *            hex Hexcode specified background color, or standard color spec
                     * @param {number}
                     *            a Alpha level (default 1.0)
                     *
                     * @example
                     *
                     * viewer.setBackgroundColor("green",0.5);
                
                
                     *
                     */
                setBackgroundColor(hex, a) {
                  if (typeof a == "undefined") {
                    a = 1;
                  } else if (a < 0 || a > 1) {
                    a = 1;
                  }
                  var c = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(hex);
                  this.scene.fog.color = c;
                  this.bgColor = c.getHex();
                  this.renderer.setClearColorHex(c.getHex(), a);
                  this.show();
                  return this;
                }
                /**
                     * Set view projection scheme.  Either orthographic or perspective.
                     * Default is perspective.  Orthographic can also be enabled on viewer creation
                     * by setting orthographic to true in the config object.
                     *
                     *
                     * @example
                     viewer.setViewStyle({style:"outline"});
                          $3Dmol.get('data/1fas.pqr', function(data){
                              viewer.addModel(data, "pqr");
                              $3Dmol.get("data/1fas.cube",function(volumedata){
                                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                              });
                              viewer.zoomTo();
                
                              viewer.setProjection("orthographic");
                              viewer.render(callback);
                          });
                     *
                     */
                setProjection(proj) {
                  this.camera.ortho = proj === "orthographic";
                  this.setSlabAndFog();
                }
                /**
                 * Set global view styles.
                 *
                 * @example
                 *   viewer.setViewStyle({style:"outline"});
                      $3Dmol.get('data/1fas.pqr', function(data){
                          viewer.addModel(data, "pqr");
                          $3Dmol.get("data/1fas.cube",function(volumedata){
                              viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                          });
                          viewer.zoomTo();
                          viewer.render(callback);
                      });
                 *
                 */
                setViewStyle(parameters) {
                  parameters = parameters || {};
                  parameters.style = parameters.style || "";
                  if (parameters.style.includes("outline")) {
                    this.renderer.enableOutline(parameters);
                  } else {
                    this.renderer.disableOutline();
                  }
                  if (parameters.style.includes("ambientOcclusion")) {
                    var params = {};
                    if (parameters.strength)
                      params.strength = parameters.strength;
                    if (parameters.radius)
                      params.radius = parameters.radius;
                    this.renderer.enableAmbientOcclusion(params);
                  } else {
                    this.renderer.disableAmbientOcclusion();
                  }
                  return this;
                }
                updateSize() {
                  this.renderer.setSize(this.WIDTH, this.HEIGHT);
                  this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);
                  this.renderer.setSize(this.WIDTH, this.HEIGHT);
                  this.camera.aspect = this.ASPECT;
                  this.camera.updateProjectionMatrix();
                }
                /**
                 * Set viewer width independently of the HTML container.  This is probably not what you want.
                 *
                 * @param {number} w Width in pixels
                 */
                setWidth(w) {
                  this.WIDTH = w || this.WIDTH;
                  this.updateSize();
                  return this;
                }
                /**
                 * Set viewer height independently of the HTML container.  This is probably not what you want.
                 *
                 * @param {number} h Height in pixels
                 */
                setHeight(h) {
                  this.HEIGHT = h || this.HEIGHT;
                  this.updateSize();
                  return this;
                }
                /**
                 * Resize viewer according to containing HTML element's dimensions
                 *
                 */
                resize() {
                  this.WIDTH = this.getWidth();
                  this.HEIGHT = this.getHeight();
                  let regen = false;
                  if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0) {
                    let resetcanvas = false;
                    let currentcanvas = this.container.querySelector("canvas");
                    if (currentcanvas && currentcanvas != this.renderer.getCanvas()) {
                      this.config.canvas = currentcanvas;
                    } else {
                      currentcanvas.remove();
                      if (this.config && this.config.canvas != void 0) {
                        delete this.config.canvas;
                        resetcanvas = true;
                      }
                    }
                    this.setupRenderer();
                    this.initContainer(this.container);
                    this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);
                    regen = true;
                    if (resetcanvas) {
                      this.config.canvas = this.renderer.getCanvas();
                    }
                  }
                  if (this.WIDTH == 0 || this.HEIGHT == 0) {
                    if (this.animated)
                      this._viewer.pauseAnimate();
                  } else if (this.animated) {
                    this._viewer.resumeAnimate();
                  }
                  this.updateSize();
                  if (regen) {
                    let options = this.renderer.supportedExtensions();
                    options.regen = true;
                    if (this.viewers) {
                      for (let i = 0, n = this.viewers.length; i < n; i++) {
                        for (let j = 0, m = this.viewers[i].length; j < m; j++) {
                          this.viewers[i][j].render(null, options);
                        }
                      }
                    }
                    this._viewer.render(null, options);
                  } else if (this.WIDTH > 0 && this.HEIGHT > 0) {
                    this.show();
                  }
                  return this;
                }
                /**
                 * Return specified model
                 *
                 * @param {number}
                 *            [id=last model id] - Retrieve model with specified id
                 * @default Returns last model added to viewer or null if there are no models
                 * @return {GLModel}
                 *
                 * @example // Retrieve reference to first GLModel added var m =
                 *    $3Dmol.download("pdb:1UBQ",viewer,{},function(m1){
                          $3Dmol.download("pdb:1UBI", viewer,{}, function(m2) {
                            viewer.zoomTo();
                            m1.setStyle({cartoon: {color:'green'}});
                            //could use m2 here as well
                            viewer.getModel().setStyle({cartoon: {color:'blue'}});
                            viewer.render();
                        })
                      });
                 */
                getModel(id) {
                  if (id === void 0) {
                    return this.models.length == 0 ? null : this.models[this.models.length - 1];
                  }
                  if (id instanceof _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel) {
                    return id;
                  }
                  if (!(id in this.models)) {
                    if (this.models.length == 0)
                      return null;
                    else
                      return this.models[this.models.length - 1];
                  }
                  return this.models[id];
                }
                /**
                 * Continuously rotate a scene around the specified axis.
                 *
                 * Call `spin(false)` to stop spinning.
                 *
                 * @param  {string|boolean|Array} axis
                 *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
                 *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
                 * @param  {number} speed
                 *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative
                 *             value reverses the direction of the spin.
                 * @param {boolean} only_when_visable
                 *            [only_when_visable] - if true, will only update spin when canvas is visible
                 *
                 */
                spin(axis, speed = 1, only_when_visable = false) {
                  clearInterval(this.spinInterval);
                  if (typeof axis == "undefined")
                    axis = "y";
                  if (typeof axis == "boolean") {
                    if (!axis)
                      return;
                    else
                      axis = "y";
                  }
                  if (Array.isArray(axis)) {
                    axis = { x: axis[0], y: axis[1], z: axis[2] };
                  }
                  var viewer = this;
                  this.spinInterval = setInterval(function() {
                    if (!viewer.getCanvas().isConnected && viewer.renderer.isLost()) {
                      clearInterval(viewer.spinInterval);
                    }
                    if (!only_when_visable || viewer.container.checkVisibility && viewer.container.checkVisibility()) {
                      viewer.rotate(1 * speed, axis);
                    }
                  }, 25);
                }
                //animate motion between current position and passed position
                // can set some parameters to null
                //if fixed is true will enforce the request animation, otherwise
                //does relative updates
                //positions objects have modelggroup position, rotation group position.z,
                //and rotationgroup quaternion
                //return array includes final position, but not current
                //the returned array includes an animate method
                animateMotion(duration, fixed, mpos, rz, rot, cam) {
                  var interval = 20;
                  var nsteps = Math.ceil(duration / interval);
                  if (nsteps < 1)
                    nsteps = 1;
                  this.incAnim();
                  var curr = {
                    mpos: this.modelGroup.position.clone(),
                    rz: this.rotationGroup.position.z,
                    rot: this.rotationGroup.quaternion.clone(),
                    cam: this.lookingAt.clone()
                  };
                  if (fixed) {
                    let steps = new Array(nsteps);
                    for (let i = 0; i < nsteps; i++) {
                      let frac = (i + 1) / nsteps;
                      let next2 = { mpos: curr.mpos, rz: curr.rz, rot: curr.rot };
                      next2.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac).add(curr.mpos);
                      next2.rz = curr.rz + frac * (rz - curr.rz);
                      next2.rot = GLViewer.slerp(curr.rot, rot, frac);
                      next2.cam = cam.clone().sub(curr.cam).multiplyScalar(frac).add(curr.cam);
                      steps[i] = next2;
                    }
                    let step = 0;
                    let self2 = this;
                    let callback2 = function() {
                      var p = steps[step];
                      step += 1;
                      self2.modelGroup.position = p.mpos;
                      self2.rotationGroup.position.z = p.rz;
                      self2.rotationGroup.quaternion = p.rot;
                      self2.camera.lookAt(p.cam);
                      if (step < steps.length) {
                        setTimeout(callback2, interval);
                      } else {
                        self2.decAnim();
                      }
                      self2.show();
                    };
                    setTimeout(callback2, interval);
                  } else {
                    var delta = {};
                    let frac = 1 / nsteps;
                    if (mpos) {
                      delta.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac);
                    }
                    if (typeof rz != "undefined" && rz != null) {
                      delta.rz = frac * (rz - curr.rz);
                    }
                    if (rot) {
                      var next = GLViewer.slerp(curr.rot, rot, frac);
                      delta.rot = curr.rot.clone().inverse().multiply(next);
                    }
                    if (cam) {
                      delta.cam = cam.clone().sub(curr.cam).multiplyScalar(frac);
                    }
                    let step = 0;
                    let self2 = this;
                    let callback2 = function() {
                      step += 1;
                      if (delta.mpos) {
                        self2.modelGroup.position.add(delta.mpos);
                      }
                      if (delta.rz) {
                        self2.rotationGroup.position.z += delta.rz;
                      }
                      if (delta.rot) {
                        self2.rotationGroup.quaternion.multiply(delta.rot);
                      }
                      if (delta.cam) {
                        self2.lookingAt.add(delta.cam);
                        self2.camera.lookAt(self2.lookingAt);
                      }
                      if (step < nsteps) {
                        setTimeout(callback2, interval);
                      } else {
                        self2.decAnim();
                      }
                      self2.show();
                    };
                    setTimeout(callback2, interval);
                  }
                }
                /**
                     * Rotate scene by angle degrees around axis
                     *
                     * @param {number}
                     *            [angle] - Angle, in degrees, to rotate by.
                     * @param {string}
                     *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
                     *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
                     *            Axis can also be specified as a vector.
                     * @param {number}
                     *            [animationDuration] - an optional parameter that denotes
                     *            the duration of the rotation animation. Default 0 (no animation)
                     * @param {boolean} [fixedPath] - if true animation is constrained to
                     *      requested motion, overriding updates that happen during the animation         *
                     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {
                    viewer.setStyle({stick:{}});
                    viewer.zoomTo();
                    viewer.rotate(90,'y',1);
                    viewer.render(callback);
                    });
                
                     *
                     */
                rotate(angle, axis = "y", animationDuration = 0, fixedPath = false) {
                  if (axis == "x") {
                    axis = { x: 1, y: 0, z: 0 };
                  } else if (axis == "y") {
                    axis = { x: 0, y: 1, z: 0 };
                  } else if (axis == "z") {
                    axis = { x: 0, y: 0, z: 1 };
                  }
                  if (axis == "vx") {
                    axis = { vx: 1, vy: 0, vz: 0 };
                  } else if (axis == "vy") {
                    axis = { vx: 0, vy: 1, vz: 0 };
                  } else if (axis == "vz") {
                    axis = { vx: 0, vy: 0, vz: 1 };
                  }
                  if (typeof axis.vx !== "undefined") {
                    var vaxis = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(axis.vx, axis.vy, axis.vz);
                    vaxis.applyQuaternion(this.rotationGroup.quaternion);
                    axis = { x: vaxis.x, y: vaxis.y, z: vaxis.z };
                  }
                  var qFromAngle = function(rangle2) {
                    var s = Math.sin(rangle2 / 2);
                    var c = Math.cos(rangle2 / 2);
                    var i = 0, j = 0, k = 0;
                    i = axis.x * s;
                    j = axis.y * s;
                    k = axis.z * s;
                    return new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion(i, j, k, c).normalize();
                  };
                  var rangle = Math.PI * angle / 180;
                  var q = qFromAngle(rangle);
                  if (animationDuration) {
                    var final = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Quaternion().copy(this.rotationGroup.quaternion).multiply(q);
                    this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, final, this.lookingAt);
                  } else {
                    this.rotationGroup.quaternion.multiply(q);
                    this.show();
                  }
                  return this;
                }
                surfacesFinished() {
                  for (var key in this.surfaces) {
                    if (!this.surfaces[key][0].done) {
                      return false;
                    }
                  }
                  return true;
                }
                /** Returns an array representing the current viewpoint.
                 * Translation, zoom, and rotation quaternion.
                 * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]
                 *  */
                getView() {
                  if (!this.modelGroup)
                    return [0, 0, 0, 0, 0, 0, 0, 1];
                  var pos = this.modelGroup.position;
                  var q = this.rotationGroup.quaternion;
                  return [
                    pos.x,
                    pos.y,
                    pos.z,
                    this.rotationGroup.position.z,
                    q.x,
                    q.y,
                    q.z,
                    q.w
                  ];
                }
                /** Sets the view to the specified translation, zoom, and rotation.
                 *
                 * @param {Array.<number>} arg Array formatted identically to the return value of getView */
                setView(arg, nolink) {
                  if (arg === void 0 || !(arg instanceof Array || arg.length !== 8))
                    return this;
                  if (!this.modelGroup || !this.rotationGroup)
                    return this;
                  this.modelGroup.position.x = arg[0];
                  this.modelGroup.position.y = arg[1];
                  this.modelGroup.position.z = arg[2];
                  this.rotationGroup.position.z = arg[3];
                  this.rotationGroup.quaternion.x = arg[4];
                  this.rotationGroup.quaternion.y = arg[5];
                  this.rotationGroup.quaternion.z = arg[6];
                  this.rotationGroup.quaternion.w = arg[7];
                  if (typeof arg[8] != "undefined") {
                    this.rotationGroup.position.x = arg[8];
                    this.rotationGroup.position.y = arg[9];
                  }
                  this.show(nolink);
                  return this;
                }
                // apply styles, models, etc in viewer
                /**
                 * Render current state of viewer, after
                 * adding/removing models, applying styles, etc.
                 *
                 */
                render(callback2, exts) {
                  this.renderer.setViewport();
                  this.updateClickables();
                  var view = this.getView();
                  if (this.stateChangeCallback) {
                    this.stateChangeCallback(this.getInternalState());
                  }
                  var i, n;
                  if (!exts)
                    exts = this.renderer.supportedExtensions();
                  for (i = 0; i < this.models.length; i++) {
                    if (this.models[i]) {
                      this.models[i].globj(this.modelGroup, exts);
                    }
                  }
                  for (i = 0; i < this.shapes.length; i++) {
                    if (this.shapes[i]) {
                      if (typeof this.shapes[i].frame === "undefined" || this.viewer_frame < 0 || this.shapes[i].frame < 0 || this.shapes[i].frame == this.viewer_frame) {
                        this.shapes[i].globj(this.modelGroup, exts);
                      } else {
                        this.shapes[i].removegl(this.modelGroup);
                      }
                    }
                  }
                  for (i = 0; i < this.labels.length; i++) {
                    if (exts.regen) {
                      this.labels[i].dispose();
                      this.modelGroup.remove(this.labels[i].sprite);
                      this.labels[i].setContext();
                      this.modelGroup.add(this.labels[i].sprite);
                    }
                    if (this.labels[i] && typeof this.labels[i].frame != "undefined" && this.labels[i].frame >= 0) {
                      this.modelGroup.remove(this.labels[i].sprite);
                      if (this.viewer_frame < 0 || this.labels[i].frame == this.viewer_frame) {
                        this.modelGroup.add(this.labels[i].sprite);
                      }
                    }
                  }
                  for (i in this.surfaces) {
                    if (!this.surfaces.hasOwnProperty(i))
                      continue;
                    var surfArr = this.surfaces[i];
                    for (n = 0; n < surfArr.length; n++) {
                      if (surfArr.hasOwnProperty(n)) {
                        var geo = surfArr[n].geo;
                        if (!surfArr[n].finished || exts.regen) {
                          geo.verticesNeedUpdate = true;
                          geo.elementsNeedUpdate = true;
                          geo.normalsNeedUpdate = true;
                          geo.colorsNeedUpdate = true;
                          geo.buffersNeedUpdate = true;
                          surfArr[n].mat.needsUpdate = true;
                          if (surfArr[n].done) {
                            surfArr[n].finished = true;
                          }
                          if (surfArr[n].lastGL)
                            this.modelGroup.remove(surfArr[n].lastGL);
                          var smesh = null;
                          if (surfArr[n].mat instanceof _WebGL__WEBPACK_IMPORTED_MODULE_8__.LineBasicMaterial) {
                            smesh = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Line(geo, surfArr[n].mat);
                          } else {
                            if ("wireframe" in surfArr.style && surfArr.style.wireframe) {
                              geo.setUpWireframe();
                            }
                            smesh = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Mesh(geo, surfArr[n].mat);
                          }
                          if (surfArr[n].mat.transparent && surfArr[n].mat.opacity == 0) {
                            smesh.visible = false;
                          } else {
                            smesh.visible = true;
                          }
                          if (surfArr[n].symmetries.length > 1 || surfArr[n].symmetries.length == 1 && !surfArr[n].symmetries[0].isIdentity()) {
                            var j;
                            var tmeshes = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Object3D();
                            for (j = 0; j < surfArr[n].symmetries.length; j++) {
                              var tmesh = smesh.clone();
                              tmesh.matrix = surfArr[n].symmetries[j];
                              tmesh.matrixAutoUpdate = false;
                              tmeshes.add(tmesh);
                            }
                            surfArr[n].lastGL = tmeshes;
                            this.modelGroup.add(tmeshes);
                          } else {
                            surfArr[n].lastGL = smesh;
                            this.modelGroup.add(smesh);
                          }
                        }
                      }
                    }
                  }
                  this.setView(view);
                  if (typeof callback2 === "function") {
                    callback2(this);
                  }
                  return this;
                }
                /* @param {AtomSelectionSpec|any} sel
                 * @return list of models specified by sel
                 */
                getModelList(sel) {
                  let ms = [];
                  if (typeof sel === "undefined" || typeof sel.model === "undefined") {
                    for (let i = 0; i < this.models.length; i++) {
                      if (this.models[i])
                        ms.push(this.models[i]);
                    }
                  } else {
                    let selm = sel.model;
                    if (!Array.isArray(selm))
                      selm = [selm];
                    for (let i = 0; i < selm.length; i++) {
                      if (typeof selm[i] === "number") {
                        var index = selm[i];
                        if (index < 0)
                          index += this.models.length;
                        ms.push(this.models[index]);
                      } else {
                        ms.push(selm[i]);
                      }
                    }
                  }
                  return ms;
                }
                /**
                 *
                 * @param {AtomSelectionSpec}
                 *            sel
                 * @return {AtomSpec[]}
                 */
                getAtomsFromSel(sel) {
                  var atoms = [];
                  if (typeof sel === "undefined")
                    sel = {};
                  var ms = this.getModelList(sel);
                  for (let i = 0; i < ms.length; i++) {
                    atoms = atoms.concat(ms[i].selectedAtoms(sel));
                  }
                  return atoms;
                }
                /**
                 *
                 * @param {AtomSpec}
                 *            atom
                 * @param {AtomSelectionSpec}
                 *            sel
                 * @return {boolean}
                 */
                atomIsSelected(atom, sel) {
                  if (typeof sel === "undefined")
                    sel = {};
                  var ms = this.getModelList(sel);
                  for (var i = 0; i < ms.length; i++) {
                    if (ms[i].atomIsSelected(atom, sel))
                      return true;
                  }
                  return false;
                }
                /** return list of atoms selected by sel
                 *
                 * @param {AtomSelectionSpec} sel
                 * @return {AtomSpec[]}
                 */
                selectedAtoms(sel) {
                  return this.getAtomsFromSel(sel);
                }
                /**
                * Returns valid values for the specified attribute in the given selection
                * @param {string} attribute
                * @param {AtomSelectionSpec} sel
                * @return {Array.<Object>}
                *
                */
                getUniqueValues(attribute, sel) {
                  if (typeof sel === "undefined")
                    sel = {};
                  var atoms = this.getAtomsFromSel(sel);
                  var values = {};
                  for (var atom in atoms) {
                    if (atoms[atom].hasOwnProperty(attribute)) {
                      var value = atoms[atom][attribute];
                      values[value] = true;
                    }
                  }
                  return Object.keys(values);
                }
                /**
                 * Return pdb output of selected atoms (if atoms from pdb input)
                 *
                 * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer
                 * @return {string} PDB string of selected atoms
                 */
                pdbData(sel) {
                  var atoms = this.getAtomsFromSel(sel);
                  var ret = "";
                  for (var i = 0, n = atoms.length; i < n; ++i) {
                    ret += atoms[i].pdbline + "\n";
                  }
                  return ret;
                }
                /**
                     * Zoom current view by a constant factor
                     *
                     * @param {number}
                     *            [factor] - Magnification factor. Values greater than 1
                     *            will zoom in, less than one will zoom out. Default 2.
                     * @param {number}
                     *            [animationDuration] - an optional parameter that denotes
                     *            the duration of a zoom animation
                     * @param {Boolean} [fixedPath] - if true animation is constrained to
                     *      requested motion, overriding updates that happen during the animation
                     * @example
                    $3Dmol.get('data/4csv.pdb', function(data) {
                    viewer.addModel(data,'pdb');
                    viewer.setStyle({cartoon:{},stick:{}});
                    viewer.zoomTo()
                    viewer.zoom(2,1000);
                    viewer.render();
                    });
                
                         */
                zoom(factor = 2, animationDuration = 0, fixedPath = false) {
                  var scale = (this.CAMERA_Z - this.rotationGroup.position.z) / factor;
                  var final_z = this.CAMERA_Z - scale;
                  if (animationDuration > 0) {
                    this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.adjustZoomToLimits(final_z), this.rotationGroup.quaternion, this.lookingAt);
                  } else {
                    this.rotationGroup.position.z = this.adjustZoomToLimits(final_z);
                    this.show();
                  }
                  return this;
                }
                /**
                 * Translate current view by x,y screen coordinates
                 * This pans the camera rather than translating the model.
                 *
                 * @param {number} x Relative change in view coordinates of camera
                 * @param {number} y Relative change in view coordinates of camera
                 * @param {number}
                 *            [animationDuration] - an optional parameter that denotes
                 *            the duration of a zoom animation
                 * @param {Boolean} [fixedPath] - if true animation is constrained to
                 *      requested motion, overriding updates that happen during the animation         *
                 * @example     $3Dmol.get('data/4csv.pdb', function(data) {
                viewer.addModel(data,'pdb');
                viewer.setStyle({cartoon:{},stick:{}});
                viewer.zoomTo();
                viewer.translate(200,50);
                viewer.rotate(90,'z');
                viewer.render(callback);
                });
                 */
                translate(x, y, animationDuration = 0, fixedPath = false) {
                  var dx = x / this.WIDTH;
                  var dy = y / this.HEIGHT;
                  var v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, -this.CAMERA_Z);
                  this.projector.projectVector(v, this.camera);
                  v.x -= dx;
                  v.y -= dy;
                  this.projector.unprojectVector(v, this.camera);
                  v.z = 0;
                  var final_position = this.lookingAt.clone().add(v);
                  if (animationDuration > 0) {
                    this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, final_position);
                  } else {
                    this.lookingAt = final_position;
                    this.camera.lookAt(this.lookingAt);
                    this.show();
                  }
                  return this;
                }
                /**
                 * Translate current models by x,y screen coordinates
                 * This translates the models relative to the current view. It does
                 * not change the center of rotation.
                 *
                 * @param {number} x Relative change in x screen coordinate
                 * @param {number} y Relative change in y screen coordinate
                 * @param {number}
                 *            [animationDuration] - an optional parameter that denotes
                 *            the duration of a zoom animation
                 * @param {Boolean} [fixedPath] - if true animation is constrained to
                 *      requested motion, overriding updates that happen during the animation         *
                 * @example     $3Dmol.get('data/4csv.pdb', function(data) {
                viewer.addModel(data,'pdb');
                viewer.setStyle({cartoon:{},stick:{}});
                viewer.zoomTo();
                viewer.translateScene(200,50);
                viewer.rotate(90,'z'); // will no longer be around model center
                viewer.render(callback);
                });
                 */
                translateScene(x, y, animationDuration = 0, fixedPath = false) {
                  var t = this.screenOffsetToModel(x, y);
                  var final_position = this.modelGroup.position.clone().add(t);
                  if (animationDuration > 0) {
                    this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt);
                  } else {
                    this.modelGroup.position = final_position;
                    this.show();
                  }
                  return this;
                }
                /**
                 * Adjust slab to fully enclose selection (default everything).
                 *
                 * @param {AtomSelectionSpec} sel
                 *            Selection specification specifying model and atom
                 *            properties to select. Default: all atoms in viewer
                 * @example
                        $3Dmol.get('data/1jpy.cif', function(data) {
                          let m = viewer.addModel(data);
                          viewer.setStyle('stick');
                          viewer.zoomTo({resn:'NAG',chain:'B'});
                          viewer.fitSlab({resn:'NAG',chain:'B'});
                          viewer.render();
                });
                 */
                fitSlab(sel) {
                  sel = sel || {};
                  var atoms = this.getAtomsFromSel(sel);
                  var tmp = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                  var x = tmp[1][0] - tmp[0][0], y = tmp[1][1] - tmp[0][1], z = tmp[1][2] - tmp[0][2];
                  var maxD = Math.hypot(x, y, z);
                  if (maxD < 5)
                    maxD = 5;
                  this.slabNear = -maxD / 1.9;
                  this.slabFar = maxD / 2;
                  return this;
                }
                /**
                 * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).
                 *
                 * @param {AtomSelectionSpec}
                 *            [sel] - Selection specification specifying model and atom
                 *            properties to select. Default: all atoms in viewer
                 * @param {number}
                 *            [animationDuration] - an optional parameter that denotes
                 *            the duration of a zoom animation
                 * @param {Boolean} [fixedPath] - if true animation is constrained to
                 *      requested motion, overriding updates that happen during the animation         *
                 * @example // if the user were to pass the animationDuration value to
                 *           // the function like so viewer.zoomTo({resn:'STI'},1000);
                 *         //   the program would center on resn 'STI' over the course
                 *         //   of 1 second(1000 milleseconds).
                 *  // Reposition to centroid of all atoms of all models in this
                 * //viewer glviewer.center();
                $3Dmol.get('data/4csv.pdb', function(data) {
                viewer.addModel(data,'pdb');
                viewer.setStyle({cartoon:{},stick:{}});
                viewer.center();
                viewer.render(callback);
                });
                 */
                center(sel = {}, animationDuration = 0, fixedPath = false) {
                  var allatoms, alltmp;
                  var atoms = this.getAtomsFromSel(sel);
                  var tmp = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                  if ((0, _utilities__WEBPACK_IMPORTED_MODULE_11__.isEmptyObject)(sel)) {
                    this.shapes.forEach((shape) => {
                      if (shape && shape.boundingSphere && shape.boundingSphere.center) {
                        var c = shape.boundingSphere.center;
                        var r = shape.boundingSphere.radius;
                        if (r > 0) {
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x + r, c.y, c.z));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x - r, c.y, c.z));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y + r, c.z));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y - r, c.z));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y, c.z + r));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y, c.z - r));
                        } else {
                          atoms.push(c);
                        }
                      }
                    });
                    tmp = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                    allatoms = atoms;
                    alltmp = tmp;
                  } else {
                    allatoms = this.getAtomsFromSel({});
                    alltmp = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(allatoms);
                  }
                  var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(tmp[2][0], tmp[2][1], tmp[2][2]);
                  var x = alltmp[1][0] - alltmp[0][0], y = alltmp[1][1] - alltmp[0][1], z = alltmp[1][2] - alltmp[0][2];
                  var maxD = Math.hypot(x, y, z);
                  if (maxD < 5)
                    maxD = 5;
                  this.slabNear = -maxD / 1.9;
                  this.slabFar = maxD / 2;
                  x = tmp[1][0] - tmp[0][0];
                  y = tmp[1][1] - tmp[0][1];
                  z = tmp[1][2] - tmp[0][2];
                  maxD = Math.hypot(x, y, z);
                  if (maxD < 5)
                    maxD = 5;
                  var maxDsq = 25;
                  for (var i = 0; i < atoms.length; i++) {
                    if (atoms[i]) {
                      var dsq = center.distanceToSquared(atoms[i]);
                      if (dsq > maxDsq)
                        maxDsq = dsq;
                    }
                  }
                  maxD = Math.sqrt(maxDsq) * 2;
                  var finalpos = center.clone().multiplyScalar(-1);
                  if (animationDuration > 0) {
                    this.animateMotion(animationDuration, fixedPath, finalpos, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt);
                  } else {
                    this.modelGroup.position = finalpos;
                    this.show();
                  }
                  return this;
                }
                /**
                     * Zoom to center of atom selection.  The slab will be set appropriately for
                     * the selection, unless an empty selection is provided, in which case there will be no slab.
                     *
                     * @param {Object}
                     *            [sel] - Selection specification specifying model and atom
                     *            properties to select. Default: all atoms in viewer
                     * @param {number}
                     *            [animationDuration] - an optional parameter that denotes
                     *            the duration of a zoom animation
                     * @param {Boolean} [fixedPath] - if true animation is constrained to
                     *      requested motion, overriding updates that happen during the animation         *
                      * @example
                
                
                          $3Dmol.get('data/1fas.pqr', function(data){
                              viewer.addModel(data, "pqr");
                          viewer.zoomTo();
                              $3Dmol.get("data/1fas.cube",function(volumedata){
                                  viewer.addSurface($3Dmol.SurfaceType.VDW, {
                                      opacity:0.85,
                                      voldata: new $3Dmol.VolumeData(volumedata, "cube"),
                                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))
                                  },{});
                
                              viewer.render();
                              });
                            });
                     */
                zoomTo(sel = {}, animationDuration = 0, fixedPath = false) {
                  let atoms = this.getAtomsFromSel(sel);
                  let atombox = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                  let allbox = atombox;
                  if ((0, _utilities__WEBPACK_IMPORTED_MODULE_11__.isEmptyObject)(sel)) {
                    let natoms = atoms && atoms.length;
                    this.shapes.forEach((shape) => {
                      if (shape && shape.boundingSphere) {
                        if (shape.boundingSphere.box) {
                          let box = shape.boundingSphere.box;
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(box.min.x, box.min.y, box.min.z));
                          atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(box.max.x, box.max.y, box.max.z));
                        } else if (shape.boundingSphere.center) {
                          var c = shape.boundingSphere.center;
                          var r = shape.boundingSphere.radius;
                          if (r > 0) {
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x + r, c.y, c.z));
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x - r, c.y, c.z));
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y + r, c.z));
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y - r, c.z));
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y, c.z + r));
                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(c.x, c.y, c.z - r));
                          } else {
                            atoms.push(c);
                          }
                        }
                      }
                    });
                    allbox = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                    if (!natoms) {
                      for (let i2 = 0; i2 < 3; i2++) {
                        atombox[2][i2] = (allbox[0][i2] + allbox[1][i2]) / 2;
                      }
                    }
                  } else {
                    let allatoms = this.getAtomsFromSel({});
                    allbox = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(allatoms);
                  }
                  var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(atombox[2][0], atombox[2][1], atombox[2][2]);
                  var x = allbox[1][0] - allbox[0][0], y = allbox[1][1] - allbox[0][1], z = allbox[1][2] - allbox[0][2];
                  var maxD = Math.hypot(x, y, z);
                  if (maxD < 5)
                    maxD = 5;
                  this.slabNear = -maxD / 1.9;
                  this.slabFar = maxD / 2;
                  if (Object.keys(sel).length === 0) {
                    this.slabNear = Math.min(-maxD * 2, -50);
                    this.slabFar = Math.max(maxD * 2, 50);
                  }
                  var MAXD = this.config.minimumZoomToDistance || 5;
                  x = atombox[1][0] - atombox[0][0];
                  y = atombox[1][1] - atombox[0][1];
                  z = atombox[1][2] - atombox[0][2];
                  maxD = Math.hypot(x, y, z);
                  if (maxD < MAXD)
                    maxD = MAXD;
                  var maxDsq = MAXD * MAXD;
                  for (var i = 0; i < atoms.length; i++) {
                    if (atoms[i]) {
                      var dsq = center.distanceToSquared(atoms[i]);
                      if (dsq > maxDsq)
                        maxDsq = dsq;
                    }
                  }
                  maxD = Math.sqrt(maxDsq) * 2;
                  var finalpos = center.clone().multiplyScalar(-1);
                  var finalz = -(maxD * 0.5 / Math.tan(Math.PI / 180 * this.camera.fov / 2) - this.CAMERA_Z);
                  finalz = this.adjustZoomToLimits(finalz);
                  if (animationDuration > 0) {
                    this.animateMotion(animationDuration, fixedPath, finalpos, finalz, this.rotationGroup.quaternion, this.lookingAt);
                  } else {
                    this.modelGroup.position = finalpos;
                    this.rotationGroup.position.z = finalz;
                    this.show();
                  }
                  return this;
                }
                /**
                 * Set slab of view (contents outside of slab are clipped).
                 * Must call render to update.
                 *
                 * @param {number} near near clipping plane distance
                 * @param {number} far far clipping plane distance
                 */
                setSlab(near, far) {
                  this.slabNear = near;
                  this.slabFar = far;
                }
                /**
                 * Get slab of view (contents outside of slab are clipped).
                 *
                 * @return {Object}
                 *      @property {number} near - near clipping plane distance
                 *      @property {number} far - far clipping plane distance
                 */
                getSlab() {
                  return { near: this.slabNear, far: this.slabFar };
                }
                /**
                     * Add label to viewer
                     *
                     * @param {string}
                     *            text - Label text
                     * @param {LabelSpec}
                     *            options - Label style specification
                      @param {AtomSelection}
                     *            sel - Set position of label to center of this selection
                     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient
                     * @return {Label}
                     *
                     * @example
                     *  $3Dmol.download("pdb:2EJ0",viewer,{},function(){
                
                              viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
                              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
                                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
                                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
                              viewer.setStyle({chain:'A'},{cross:{hidden:true}});
                              viewer.setStyle({chain:'B'},{cross:{hidden:false,
                                                                  linewidth:1.0,
                                                                  colorscheme:'greenCarbon'}});
                              viewer.setStyle({chain:'C'},{cross:{hidden:false,
                                                                  linewidth:1.0,
                                                                  radius:0.5}});
                              viewer.setStyle({chain:'D'},{cross:{hidden:false,
                                                                  linewidth:10.0}});
                              viewer.setStyle({chain:'E'},{cross:{hidden:false,
                                                                  linewidth:1.0,
                                                                  color:'black'}});
                
                              viewer.render();
                
                
                            });
                
                     */
                addLabel(text, options = {}, sel, noshow = false) {
                  if (sel) {
                    var extent = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(this.getAtomsFromSel(sel));
                    options.position = { x: extent[2][0], y: extent[2][1], z: extent[2][2] };
                  }
                  var label = new _Label__WEBPACK_IMPORTED_MODULE_4__.Label(text, options);
                  label.setContext();
                  this.modelGroup.add(label.sprite);
                  this.labels.push(label);
                  if (!noshow)
                    this.show();
                  return label;
                }
                /** Add residue labels.  This will generate one label per a
                 * residue within the selected atoms.  The label will be at the
                 * centroid of the atoms and styled according to the passed style.
                 * The label text will be [resn][resi]
                 *
                 * @param {AtomSelectionSpec} sel
                 * @param {AtomStyleSpec} style
                 * @param {boolean} byframe - if true, create labels for every individual frame, not just current
                 *
                 * @example
                     $3Dmol.download("mmtf:2ll5",viewer,{},function(){
                          viewer.setStyle({stick:{radius:0.15},cartoon:{}});
                          viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});
                          viewer.zoomTo();
                          viewer.render();
                        });
                 */
                addResLabels(sel, style, byframe = false) {
                  let start = this.labels.length;
                  this.applyToModels("addResLabels", sel, style, byframe);
                  this.show();
                  return this.labels.slice(start);
                }
                /** Add property labels.  This will generate one label per a selected
                 * atom at the atom's coordinates with the property value as the label text.
                 *
                 * @param {string} prop - property name
                 * @param {AtomSelectionSpec} sel
                 * @param {AtomStyleSpec} style
                 *
                 * * @example
                     $3Dmol.download("cid:5291",viewer,{},function(){
                          viewer.setStyle({stick: {radius:.2}});
                          viewer.addPropertyLabels("index",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});
                          viewer.zoomTo();
                          viewer.render();
                        });
                 */
                addPropertyLabels(prop, sel, style) {
                  this.applyToModels("addPropertyLabels", prop, sel, style);
                  this.show();
                  return this;
                }
                /**
                     * Remove label from viewer
                     *
                     * @param {Label} label - $3Dmol label
                     *
                     * @example // Remove labels created in
                     $3Dmol.download("pdb:2EJ0",viewer,{},function(){
                              var toremove = viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
                              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
                                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
                                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
                              viewer.removeLabel(toremove);
                              viewer.render();
                
                
                            });
                
                     */
                removeLabel(label) {
                  for (var i = 0; i < this.labels.length; i++) {
                    if (this.labels[i] == label) {
                      this.labels.splice(i, 1);
                      label.dispose();
                      this.modelGroup.remove(label.sprite);
                      break;
                    }
                  }
                  this.show();
                  return this;
                }
                /**
                     * Remove all labels from viewer
                     *
                     *         @example
                    $3Dmol.download("pdb:1ubq",viewer,{},function(){
                
                           viewer.addResLabels();
                           viewer.setStyle({},{stick:{}});
                           viewer.render( ); //show labels
                
                           viewer.removeAllLabels();
                           viewer.render(); //hide labels
                    });
                     */
                removeAllLabels() {
                  for (var i = 0; i < this.labels.length; i++) {
                    if (this.labels[i] && this.labels[i].sprite) {
                      this.modelGroup.remove(this.labels[i].sprite);
                    }
                  }
                  this.labels.splice(0, this.labels.length);
                  this.show();
                  return this;
                }
                /**
                     * Hide all labels in viewer
                     *
                     *         @example
                    $3Dmol.download("pdb:1ubq",viewer,{},function(){
                
                           viewer.addResLabels();
                           viewer.setStyle({},{stick:{}});
                           viewer.render( ); //show labels
                
                           viewer.hideAllLabels();
                           viewer.render(); //hide labels
                    });
                     */
                hideAllLabels() {
                  for (var i = 0; i < this.labels.length; i++) {
                    if (this.labels[i]) {
                      this.labels[i].hide();
                    }
                  }
                  this.show();
                  return this;
                }
                /**
                     * Show all labels in viewer
                     *
                     *         @example
                    $3Dmol.download("pdb:1ubq",viewer,{},function(){
                
                           viewer.addLabel("Hello World",{position:{x:10,y:0,z:0},backgroundColor: "blue",useScreen: true, fontSize: 64})
                           viewer.setStyle({},{stick:{}});
                           viewer.render( ); //show labels
                
                           viewer.hideAllLabels();
                           viewer.showAllLabels();
                           viewer.render(); //hide labels
                    });
                     */
                showAllLabels() {
                  for (var i = 0; i < this.labels.length; i++) {
                    if (this.labels[i]) {
                      this.labels[i].show();
                    }
                  }
                  this.show();
                  return this;
                }
                // Modify label style
                /**
                 * Modify existing label's style
                 *
                 * @param {Label} label - $3Dmol label
                 * @param {LabelSpec}
                 *            stylespec - Label style specification
                 * @return {Label}
                 */
                setLabelStyle(label, stylespec) {
                  this.modelGroup.remove(label.sprite);
                  label.dispose();
                  label.stylespec = stylespec;
                  label.setContext();
                  this.modelGroup.add(label.sprite);
                  this.show();
                  return label;
                }
                // Change label text
                /**
                 * Modify existing label's text
                 *
                 * @param {Label}  label - $3Dmol label
                 * @param {String}
                 *            text - Label text
                 * @return {Label}
                 */
                setLabelText(label, text) {
                  this.modelGroup.remove(label.sprite);
                  label.dispose();
                  label.text = text;
                  label.setContext();
                  this.modelGroup.add(label.sprite);
                  this.show();
                  return label;
                }
                /**
                 * Add shape object to viewer
                 * @see {GLShape}
                 *
                 * @param {ShapeSpec} shapeSpec - style specification for label
                 * @return {GLShape}
                 */
                addShape(shapeSpec) {
                  shapeSpec = shapeSpec || {};
                  var shape = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(shapeSpec);
                  shape.shapePosition = this.shapes.length;
                  this.shapes.push(shape);
                  return shape;
                }
                /**
                 * Remove shape object from viewer
                 *
                 * @param {GLShape} shape - Reference to shape object to remove
                 */
                removeShape(shape) {
                  if (!shape)
                    return this;
                  shape.removegl(this.modelGroup);
                  delete this.shapes[shape.shapePosition];
                  while (this.shapes.length > 0 && typeof this.shapes[this.shapes.length - 1] === "undefined")
                    this.shapes.pop();
                  return this;
                }
                /**
                 * Remove all shape objects from viewer
                 */
                removeAllShapes() {
                  for (var i = 0; i < this.shapes.length; i++) {
                    var shape = this.shapes[i];
                    if (shape)
                      shape.removegl(this.modelGroup);
                  }
                  this.shapes.splice(0, this.shapes.length);
                  return this;
                }
                //gets the center of the selection
                getSelectionCenter(spec) {
                  if (spec.hasOwnProperty("x") && spec.hasOwnProperty("y") && spec.hasOwnProperty("z"))
                    return spec;
                  var atoms = this.getAtomsFromSel(spec);
                  if (atoms.length == 0)
                    return { x: 0, y: 0, z: 0 };
                  var extent = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atoms);
                  return { x: extent[0][0] + (extent[1][0] - extent[0][0]) / 2, y: extent[0][1] + (extent[1][1] - extent[0][1]) / 2, z: extent[0][2] + (extent[1][2] - extent[0][2]) / 2 };
                }
                /**
                     * Create and add sphere shape. This method provides a shorthand
                     * way to create a spherical shape object
                     *
                     * @param {SphereShapeSpec} spec - Sphere shape style specification
                     * @return {GLShape}
                     @example
                
                     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                
                     viewer.render();
                     */
                addSphere(spec) {
                  spec = spec || {};
                  spec.center = this.getSelectionCenter(spec.center);
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addSphere(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add box shape. This method provides a shorthand
                     * way to create a box shape object
                     *
                     * @param {BoxSpec} spec - Box shape style specification
                     * @return {GLShape}
                     @example
                
                     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});
                     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});
                     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});
                
                     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});
                     viewer.zoomTo();
                     viewer.rotate(45, {x:1,y:1,z:1});
                     viewer.render();
                     */
                addBox(spec = {}) {
                  if (spec.corner != void 0) {
                    spec.corner = this.getSelectionCenter(spec.corner);
                  }
                  if (spec.center != void 0) {
                    spec.center = this.getSelectionCenter(spec.center);
                  }
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addBox(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add arrow shape
                     *
                     * @param {ArrowSpec} spec - Style specification
                     * @return {GLShape}
                     @example
                    $3Dmol.download("pdb:4DM7",viewer,{},function(){
                
                              viewer.setBackgroundColor(0xffffffff);
                              viewer.addArrow({
                                  start: {x:-10.0, y:0.0, z:0.0},
                                  end: {x:0.0, y:-10.0, z:0.0},
                                  radius: 1.0,
                                  radiusRadio:1.0,
                                  mid:1.0,
                                  clickable:true,
                                  callback:function(){
                                      this.color.setHex(0xFF0000FF);
                                      viewer.render( );
                                  }
                              });
                              viewer.render();
                            });
                     */
                addArrow(spec = {}) {
                  spec.start = this.getSelectionCenter(spec.start);
                  spec.end = this.getSelectionCenter(spec.end);
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addArrow(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add cylinder shape
                     *
                     * @param {CylinderSpec} spec - Style specification
                     * @return {GLShape}
                
                      @example
                     viewer.setBackgroundColor(0xffffffff);
                          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
                                              end:{x:10.0,y:0.0,z:0.0},
                                              radius:1.0,
                                              fromCap:1,
                                              toCap:2,
                                              color:'red',
                                              hoverable:true,
                                              clickable:true,
                                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
                                              hover_callback: function(){ viewer.render( );},
                                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
                                             });
                          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
                                              end:{x:0.0,y:10.0,z:0.0},
                                              radius:0.5,
                                              fromCap:false,
                                              toCap:true,
                                              color:'teal'});
                          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
                                              end:{x:20.0,y:0.0,z:0.0},
                                              radius:1.0,
                                              color:'black',
                                              fromCap:false,
                                              toCap:false});
                          viewer.render();
                     */
                addCylinder(spec = {}) {
                  spec.start = this.getSelectionCenter(spec.start);
                  spec.end = this.getSelectionCenter(spec.end);
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  if (spec.dashed)
                    s.addDashedCylinder(spec);
                  else
                    s.addCylinder(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add Curve shape
                     *
                     * @param {CurveSpec} spec - Style specification
                     * @return {GLShape}
                
                     @example
                          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],
                                              radius:0.5,
                                              smooth: 10,
                                              fromArrow:false,
                                              toArrow: true,
                                              color:'orange',
                                              });
                          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],
                                              radius:1,
                                              fromArrow:true,
                                              toArrow: false,
                                              color:'purple',
                                              });
                          viewer.zoomTo();
                          viewer.render();
                     */
                addCurve(spec = {}) {
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addCurve(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add line shape
                     *
                     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength
                     * @return {GLShape}
                     @example
                     $3Dmol.download("pdb:2ABJ",viewer,{},function(){
                
                              viewer.setViewStyle({style:"outline"});
                              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});
                              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});
                              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});
                              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});
                              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
                              viewer.render();
                          });
                
                     */
                addLine(spec = {}) {
                  spec.start = this.getSelectionCenter(spec.start);
                  spec.end = this.getSelectionCenter(spec.end);
                  spec.wireframe = true;
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  if (spec.dashed)
                    s = this.addLineDashed(spec, s);
                  else
                    s.addLine(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Create and add unit cell visualization.
                     *
                     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                     * @param {UnitCellStyleSpec} spec - visualization style
                       @example
                
                            $3Dmol.get('data/1jpy.cif', function(data) {
                              let m = viewer.addModel(data);
                              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});
                              viewer.zoomTo();
                              viewer.render();
                    });
                     */
                addUnitCell(model, spec) {
                  model = this.getModel(model);
                  spec = spec || { alabel: "a", blabel: "b", clabel: "c" };
                  spec.box = spec.box || {};
                  spec.astyle = spec.astyle || { color: "red", radius: 0.1, midpos: -1 };
                  spec.bstyle = spec.bstyle || { color: "green", radius: 0.1, midpos: -1 };
                  spec.cstyle = spec.cstyle || { color: "blue", radius: 0.1, midpos: -1 };
                  spec.alabelstyle = spec.alabelstyle || { fontColor: "red", showBackground: false, alignment: "center", inFront: false };
                  spec.blabelstyle = spec.blabelstyle || { fontColor: "green", showBackground: false, alignment: "center", inFront: false };
                  spec.clabelstyle = spec.clabelstyle || { fontColor: "blue", showBackground: false, alignment: "center", inFront: false };
                  if (model.unitCellObjects) {
                    this.removeUnitCell(model);
                  }
                  model.unitCellObjects = { shapes: [], labels: [] };
                  var data = model.getCrystData();
                  var matrix = null;
                  if (data) {
                    if (data.matrix) {
                      matrix = data.matrix;
                    } else {
                      var a = data.a, b = data.b, c = data.c, alpha = data.alpha, beta = data.beta, gamma = data.gamma;
                      alpha = alpha * Math.PI / 180;
                      beta = beta * Math.PI / 180;
                      gamma = gamma * Math.PI / 180;
                      var u, v, w;
                      u = Math.cos(beta);
                      v = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
                      w = Math.sqrt(Math.max(0, 1 - u * u - v * v));
                      matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Matrix3(a, b * Math.cos(gamma), c * u, 0, b * Math.sin(gamma), c * v, 0, 0, c * w);
                    }
                    var points = [
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 0),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(1, 0, 0),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 1, 0),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 1),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(1, 1, 0),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 1, 1),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(1, 0, 1),
                      new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(1, 1, 1)
                    ];
                    if (data.matrix4) {
                      for (let i = 0; i < points.length; i++) {
                        if (data.size)
                          points[i].multiplyVectors(points[i], data.size);
                        points[i] = points[i].applyMatrix4(data.matrix4);
                      }
                    } else {
                      for (let i = 0; i < points.length; i++) {
                        points[i] = points[i].applyMatrix3(matrix);
                      }
                    }
                    if (spec.box && !spec.box.hidden) {
                      spec.box.wireframe = true;
                      var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec.box);
                      s.shapePosition = this.shapes.length;
                      s.addLine({ start: points[0], end: points[1] });
                      s.addLine({ start: points[0], end: points[2] });
                      s.addLine({ start: points[1], end: points[4] });
                      s.addLine({ start: points[2], end: points[4] });
                      s.addLine({ start: points[0], end: points[3] });
                      s.addLine({ start: points[3], end: points[5] });
                      s.addLine({ start: points[2], end: points[5] });
                      s.addLine({ start: points[1], end: points[6] });
                      s.addLine({ start: points[4], end: points[7] });
                      s.addLine({ start: points[6], end: points[7] });
                      s.addLine({ start: points[3], end: points[6] });
                      s.addLine({ start: points[5], end: points[7] });
                      this.shapes.push(s);
                      model.unitCellObjects.shapes.push(s);
                      s.finalize();
                    }
                    if (!spec.astyle.hidden) {
                      spec.astyle.start = points[0];
                      spec.astyle.end = points[1];
                      let arrow = this.addArrow(spec.astyle);
                      model.unitCellObjects.shapes.push(arrow);
                    }
                    if (!spec.bstyle.hidden) {
                      spec.bstyle.start = points[0];
                      spec.bstyle.end = points[2];
                      let arrow = this.addArrow(spec.bstyle);
                      model.unitCellObjects.shapes.push(arrow);
                    }
                    if (!spec.cstyle.hidden) {
                      spec.cstyle.start = points[0];
                      spec.cstyle.end = points[3];
                      let arrow = this.addArrow(spec.cstyle);
                      model.unitCellObjects.shapes.push(arrow);
                    }
                    if (spec.alabel) {
                      spec.alabelstyle.position = points[1];
                      let label = this.addLabel(spec.alabel, spec.alabelstyle);
                      model.unitCellObjects.labels.push(label);
                    }
                    if (spec.blabel) {
                      spec.blabelstyle.position = points[2];
                      let label = this.addLabel(spec.blabel, spec.blabelstyle);
                      model.unitCellObjects.labels.push(label);
                    }
                    if (spec.clabel) {
                      spec.clabelstyle.position = points[3];
                      let label = this.addLabel(spec.clabel, spec.clabelstyle);
                      model.unitCellObjects.labels.push(label);
                    }
                  }
                }
                /**
                * Remove unit cell visualization from model.
                *
                * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                  @example
                       $3Dmol.get('data/icsd_200866.cif', function(data) {
                         let m = viewer.addModel(data);
                         viewer.setStyle({sphere:{}})
                         viewer.addUnitCell();
                         viewer.zoomTo();
                         viewer.removeUnitCell();
                         viewer.render();
                   });
                */
                removeUnitCell(model) {
                  model = this.getModel(model);
                  if (model.unitCellObjects) {
                    let viewer = this;
                    model.unitCellObjects.shapes.forEach(function(s) {
                      viewer.removeShape(s);
                    });
                    model.unitCellObjects.labels.forEach(function(l) {
                      viewer.removeLabel(l);
                    });
                  }
                  delete model.unitCellObjects;
                }
                /**
                * Replicate atoms in model to form a super cell of the specified dimensions.
                * Original cell will be centered as much as possible.
                *
                * @param {integer} A - number of times to replicate cell in X dimension.
                * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.
                * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.
                * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                * @param {boolean} addBonds - Create bonds between unit cells based on distances.
                * @param {boolean} prune - Keep only atoms that are within the original unit cell (i.e., on edges).  Alternatively, call replicateUnitCell(1).
                  @example
                       $3Dmol.get('data/icsd_200866.cif', function(data) {
                         let m = viewer.addModel(data);
                         viewer.setStyle({sphere:{scale:.25}})
                         viewer.addUnitCell();
                         viewer.zoomTo();
                         viewer.replicateUnitCell(3,2,1,m);
                         viewer.render();
                   });
                */
                replicateUnitCell(A = 3, B = A, C = B, model, addBonds, prune) {
                  model = this.getModel(model);
                  let cryst = model.getCrystData();
                  if (cryst) {
                    const atoms = model.selectedAtoms({});
                    const matrix = cryst.matrix;
                    let makeoff = function(I) {
                      if (I % 2 == 0)
                        return -I / 2;
                      else
                        return Math.ceil(I / 2);
                    };
                    if (A <= 1 && B <= 1 && C <= 1) {
                      prune = true;
                      A = B = C = 3;
                    }
                    let omitPosition = function(x, y, z) {
                      return false;
                    };
                    if (prune) {
                      const invmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Matrix3().getInverse3(matrix);
                      omitPosition = function(x, y, z) {
                        let pos = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(x, y, z).applyMatrix3(invmatrix);
                        if (pos.x > -1e-4 && pos.x < 1.0001 && pos.y > -1e-4 && pos.y < 1.0001 && pos.z > -1e-4 && pos.z < 1.0001) {
                          return false;
                        } else {
                          return true;
                        }
                      };
                    }
                    for (let i = 0; i < A; i++) {
                      for (let j = 0; j < B; j++) {
                        for (let k = 0; k < C; k++) {
                          if (i == 0 && j == 0 && k == 0)
                            continue;
                          let offset = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(makeoff(i), makeoff(j), makeoff(k));
                          offset.applyMatrix3(matrix);
                          let newatoms = [];
                          for (let a = 0; a < atoms.length; a++) {
                            let newx = atoms[a].x + offset.x, newy = atoms[a].y + offset.y, newz = atoms[a].z + offset.z;
                            if (omitPosition(newx, newy, newz)) {
                              continue;
                            }
                            let newAtom = {};
                            for (let p in atoms[a]) {
                              newAtom[p] = atoms[a][p];
                            }
                            newAtom.x = newx;
                            newAtom.y = newy;
                            newAtom.z = newz;
                            newatoms.push(newAtom);
                          }
                          model.addAtoms(newatoms);
                        }
                      }
                    }
                    if (addBonds) {
                      model.assignBonds();
                    }
                  }
                }
                /** Add dashed line to shape */
                addLineDashed(spec, s) {
                  spec.dashLength = spec.dashLength || 0.5;
                  spec.gapLength = spec.gapLength || 0.5;
                  var p1;
                  if (!spec.start) {
                    p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 0);
                  } else {
                    p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(spec.start.x || 0, spec.start.y || 0, spec.start.z || 0);
                  }
                  var p2;
                  if (!spec.end)
                    p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, 0);
                  else
                    p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(spec.end.x, spec.end.y || 0, spec.end.z || 0);
                  var dir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3();
                  var dash = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3();
                  var gap = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3();
                  var length, dashAmt, gapAmt;
                  var temp = p1.clone();
                  var drawn = 0;
                  dir.subVectors(p2, p1);
                  length = dir.length();
                  dir.normalize();
                  dash = dir.clone();
                  gap = dir.clone();
                  dash.multiplyScalar(spec.dashLength);
                  gap.multiplyScalar(spec.gapLength);
                  dashAmt = dash.length();
                  gapAmt = gap.length();
                  while (drawn < length) {
                    if (drawn + dashAmt > length) {
                      spec.start = p1;
                      spec.end = p2;
                      s.addLine(spec);
                      break;
                    }
                    temp.addVectors(p1, dash);
                    spec.start = p1;
                    spec.end = temp;
                    s.addLine(spec);
                    p1 = temp.clone();
                    drawn += dashAmt;
                    temp.addVectors(p1, gap);
                    p1 = temp.clone();
                    drawn += gapAmt;
                  }
                  s.finalize();
                  return s;
                }
                /**
                     * Add custom shape component from user supplied function
                     *
                     * @param {CustomSpec} spec - Style specification
                     * @return {GLShape}
                     @example
                     function triangle(viewer) {
                        var vertices = [];
                        var normals = [];
                        var colors = [];
                        var r = 20;
                        //triangle
                        vertices.push(new $3Dmol.Vector3(0,0,0));
                        vertices.push(new $3Dmol.Vector3(r,0,0));
                        vertices.push(new $3Dmol.Vector3(0,r,0));
                
                        normals.push(new $3Dmol.Vector3(0,0,1));
                        normals.push(new $3Dmol.Vector3(0,0,1));
                        normals.push(new $3Dmol.Vector3(0,0,1));
                
                        colors.push({r:1,g:0,b:0});
                        colors.push({r:0,g:1,b:0});
                        colors.push({r:0,g:0,b:1});
                
                        var faces = [ 0,1,2 ];
                
                        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};
                        viewer.addCustom(spec);
                    }
                    triangle(viewer);
                    viewer.render();
                     */
                addCustom(spec) {
                  spec = spec || {};
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addCustom(spec);
                  this.shapes.push(s);
                  s.finalize();
                  return s;
                }
                /**
                     * Construct isosurface from volumetric data in gaussian cube format
                     * @param {String} data - Input file contents
                     * @param {String} format - Input file format
                     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification
                     * @return {GLShape}
                     *
                     * @example
                
                
                    $3Dmol.get('data/bohr.cube', function(data) {
                
                    viewer.addVolumetricData(data, "cube", {isoval: -0.01, color: "red", opacity: 0.95});
                    viewer.setStyle({cartoon:{},stick:{}});
                    viewer.zoomTo();
                    viewer.render();
                    });
                
                
                     */
                addVolumetricData(data, format, spec = {}) {
                  var voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_6__.VolumeData(data, format);
                  if (spec.hasOwnProperty("transferfn")) {
                    return this.addVolumetricRender(voldata, spec);
                  } else {
                    return this.addIsosurface(voldata, spec);
                  }
                }
                /**
                 * Construct isosurface from volumetric data.  This is more flexible
                * than addVolumetricData, but can not be used with py3Dmol.
                 * @param {VolumeData} data - volumetric data
                 * @param {IsoSurfaceSpec} spec - Shape style specification
                 * @return {GLShape}
                 *
                 @example
                 $3Dmol.get('../test_structs/benzene-homo.cube', function(data){
                          var voldata = new $3Dmol.VolumeData(data, "cube");
                          viewer.addIsosurface(voldata, {isoval: 0.01,
                                                         color: "blue"});
                          viewer.addIsosurface(voldata, {isoval: -0.01,
                                                         color: "red"});
                          viewer.zoomTo();
                          viewer.render();
                        });
                 */
                addIsosurface(data, spec = {}, callback2) {
                  var s = new _GLShape__WEBPACK_IMPORTED_MODULE_2__.GLShape(spec);
                  s.shapePosition = this.shapes.length;
                  s.addIsosurface(data, spec, callback2, this);
                  this.shapes.push(s);
                  return s;
                }
                /**
                 * Create volumetric renderer for volumetricData
                 * @param {VolumeData} data - volumetric data
                 * @param {VolumetricRenderSpec} spec - specification of volumetric render
                 *
                 * @return {GLShape}
                 *
                 */
                addVolumetricRender(data, spec) {
                  spec = spec || {};
                  var s = new _VolumetricRender__WEBPACK_IMPORTED_MODULE_7__.GLVolumetricRender(data, spec, this);
                  s.shapePosition = this.shapes.length;
                  this.shapes.push(s);
                  return s;
                }
                /**
                 * Return true if volumetric rendering is supported (WebGL 2.0 required)
                 *
                 * @return {boolean}
                 */
                hasVolumetricRender() {
                  return this.renderer.supportsVolumetric();
                }
                /**
                 * Enable/disable fog for content far from the camera
                 *
                 * @param {boolean} fog whether to enable or disable the fog
                 *
                 * @example
                        $3Dmol.get('data/1jpy.cif', function(data) {
                          let m = viewer.addModel(data);
                          viewer.setStyle('stick');
                          viewer.zoomTo({resn:'NAG',chain:'B'});
                          viewer.enableFog({fogStart:.2,fogEnd:.6});
                          viewer.render();
                });
                 */
                enableFog(fog) {
                  if (fog) {
                    this.scene.fog = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Fog(this.bgColor, 100, 200);
                    this.config.disableFog = false;
                    const f = fog;
                    if (f.fogStart == void 0)
                      this.fogStart = 0.4;
                    else
                      this.fogStart = f.fogStart;
                    if (f.fogEnd == void 0)
                      this.fogEnd = 1;
                    else
                      this.fogEnd = f.fogEnd;
                  } else {
                    this.config.disableFog = true;
                    this.show();
                  }
                }
                /**
                 * Sets the atomlists of all models in the viewer to specified frame.
                 * Shapes and labels can also be displayed by frame.
                 * Sets to last frame if framenum out of range
                 *
                 * @param {number} framenum - fame index to use, starts at zero
                 * @return {Promise}
                 */
                setFrame(framenum) {
                  this.viewer_frame = framenum;
                  let viewer = this;
                  return new Promise(function(resolve) {
                    var modelMap = viewer.models.map(function(model) {
                      return model.setFrame(framenum);
                    });
                    Promise.all(modelMap).then(function() {
                      resolve();
                    });
                  });
                }
                /**
                 * Gets the current viewer frame.
                 *
                 */
                getFrame() {
                  return this.viewer_frame;
                }
                /**
                 * Returns the number of frames that the model with the most frames in the viewer has
                 *
                 * @return {number}
                 */
                getNumFrames() {
                  var mostFrames = 0;
                  for (let i = 0; i < this.models.length; i++) {
                    if (this.models[i].getNumFrames() > mostFrames) {
                      mostFrames = this.models[i].getNumFrames();
                    }
                  }
                  for (let i = 0; i < this.shapes.length; i++) {
                    if (this.shapes[i].frame && this.shapes[i].frame >= mostFrames) {
                      mostFrames = this.shapes[i].frame + 1;
                    }
                  }
                  for (let i = 0; i < this.labels.length; i++) {
                    if (this.labels[i].frame && this.labels[i].frame >= mostFrames) {
                      mostFrames = this.labels[i].frame + 1;
                    }
                  }
                  return mostFrames;
                }
                getNextModelId() {
                  return this.models.length;
                }
                /**
                 * Animate all models in viewer from their respective frames
                 * @param {Object} options - can specify interval (speed of animation), loop (direction
                 * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)
                 *
                 */
                animate(options) {
                  this.incAnim();
                  var interval = 100;
                  var loop = "forward";
                  var reps = Infinity;
                  options = options || {};
                  if (options.interval) {
                    interval = options.interval;
                  }
                  if (options.loop) {
                    loop = options.loop;
                  }
                  if (options.reps) {
                    reps = options.reps;
                  }
                  var mostFrames = this.getNumFrames();
                  var self2 = this;
                  var currFrame = 0;
                  if (options.startFrame) {
                    currFrame = options.startFrame % mostFrames;
                  }
                  var inc = 1;
                  if (options.step) {
                    inc = options.step;
                    reps /= inc;
                  }
                  var displayCount = 0;
                  var displayMax = mostFrames * reps;
                  var time = /* @__PURE__ */ new Date();
                  var resolve, timer;
                  var display = function(direction) {
                    time = /* @__PURE__ */ new Date();
                    if (direction == "forward") {
                      self2.setFrame(currFrame).then(function() {
                        currFrame = (currFrame + inc) % mostFrames;
                        resolve();
                      });
                    } else if (direction == "backward") {
                      self2.setFrame(mostFrames - 1 - currFrame).then(function() {
                        currFrame = (currFrame + inc) % mostFrames;
                        resolve();
                      });
                    } else {
                      self2.setFrame(currFrame).then(function() {
                        currFrame += inc;
                        inc *= currFrame % (mostFrames - 1) == 0 ? -1 : 1;
                        resolve();
                      });
                    }
                  };
                  resolve = function() {
                    self2.render();
                    if (!self2.getCanvas().isConnected) {
                      self2.stopAnimate();
                    } else if (++displayCount >= displayMax || !self2.isAnimated()) {
                      timer.cancel();
                      self2.animationTimers.delete(timer);
                      self2.decAnim();
                    } else {
                      var newInterval = interval - ((/* @__PURE__ */ new Date()).getTime() - time.getTime());
                      newInterval = newInterval > 0 ? newInterval : 0;
                      timer.cancel();
                      self2.animationTimers.delete(timer);
                      timer = new _utilities__WEBPACK_IMPORTED_MODULE_11__.PausableTimer(display, newInterval, loop);
                      self2.animationTimers.add(timer);
                    }
                  };
                  timer = new _utilities__WEBPACK_IMPORTED_MODULE_11__.PausableTimer(display, 0, loop);
                  this.animationTimers.add(timer);
                  return this;
                }
                /**
                 * Stop animation of all models in viewer
                 */
                stopAnimate() {
                  this.animated = 0;
                  this.animationTimers.forEach(function(timer) {
                    timer.cancel();
                  });
                  this.animationTimers = /* @__PURE__ */ new Set();
                  return this;
                }
                /**
                 * Pause animation of all models in viewer
                 */
                pauseAnimate() {
                  this.animationTimers.forEach(function(timer) {
                    timer.pause();
                  });
                  return this;
                }
                /**
                 * Resume animation of all models in viewer
                 */
                resumeAnimate() {
                  this.animationTimers.forEach(function(timer) {
                    timer.resume();
                  });
                  return this;
                }
                /**
                 * Return true if viewer is currently being animated, false otherwise
                 * @return {boolean}
                 */
                isAnimated() {
                  return this.animated > 0;
                }
                //setup options dict
                getModelOpt(options) {
                  if (options && !options.defaultcolors) {
                    options.defaultcolors = this.defaultcolors;
                    options.cartoonQuality = options.cartoonQuality || this.config.cartoonQuality;
                  } else if (typeof options === "undefined") {
                    options = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality };
                  }
                  return options;
                }
                /**
                     * Create and add model to viewer, given molecular data and its format
                     *
                     * @param {string} data - Input data
                     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')
                     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.
                     * @example
                
                
                          viewer.setViewStyle({style:"outline"});
                          $3Dmol.get('data/1fas.pqr', function(data){
                              viewer.addModel(data, "pqr");
                              $3Dmol.get("data/1fas.cube",function(volumedata){
                                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                
                              viewer.render();
                              });
                              viewer.zoomTo();
                          });
                     *
                     * @return {GLModel}
                     */
                addModel(data, format = "", options) {
                  options = this.getModelOpt(options);
                  var m = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(this.models.length, options, this);
                  m.addMolData(data, format, options);
                  this.models.push(m);
                  return m;
                }
                /**
                 * Given multimodel file and its format, add atom data to the viewer as separate models
                 * and return list of these models
                 *
                 * @param {string} data - Input data
                 * @param {string} format - Input format (see {@link FileFormats})
                 * @return {Array<GLModel>}
                 */
                addModels(data, format, options) {
                  options = this.getModelOpt(options);
                  options.multimodel = true;
                  options.frames = true;
                  var modelatoms = _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel.parseMolData(data, format, options);
                  for (var i = 0; i < modelatoms.length; i++) {
                    var newModel = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(this.models.length, options, this);
                    newModel.setAtomDefaults(modelatoms[i]);
                    newModel.addFrame(modelatoms[i]);
                    newModel.setFrame(0);
                    if (modelatoms.modelData)
                      newModel.setModelData(modelatoms.modelData[i]);
                    newModel.setDontDuplicateAtoms(!options.duplicateAssemblyAtoms);
                    this.models.push(newModel);
                  }
                  return this.models;
                }
                /**
                 * Create and add model to viewer. Given multimodel file and its format,
                 * different atomlists are stored in model's frame
                 * property and model's atoms are set to the 0th frame
                 *
                 * @param {string} data - Input data
                 * @param {string} format - Input format (see {@link FileFormats})
                 * @return {GLModel}
                 *
                 * @example
                        $3Dmol.get('../test_structs/multiple2.xyz', function(data){
                          viewer.addModelsAsFrames(data, "xyz");
                          viewer.animate({loop: "forward",reps: 1});
                          viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});
                          viewer.zoomTo();
                          viewer.render();
                      });
                 */
                addModelsAsFrames(data, format, options) {
                  options = this.getModelOpt(options);
                  options.multimodel = true;
                  options.frames = true;
                  var m = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(this.models.length, options, this);
                  m.addMolData(data, format, options);
                  this.models.push(m);
                  return m;
                }
                /**
                     * Create and add model to viewer. Given multimodel file and its format,
                     * all atoms are added to one model
                     *
                     * @param {string} data - Input data
                     * @param {string} format - Input format (see {@link FileFormats})
                     * @return {GLModel}
                     @example
                
                
                          $3Dmol.get('../test_structs/multiple.sdf', function(data){
                              viewer.addAsOneMolecule(data, "sdf");
                              viewer.zoomTo();
                              viewer.render();
                          });
                     */
                addAsOneMolecule(data, format, options) {
                  options = this.getModelOpt(options);
                  options.multimodel = true;
                  options.onemol = true;
                  var m = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(this.models.length, options, this);
                  m.addMolData(data, format, options);
                  this.models.push(m);
                  return m;
                }
                /**
                 * Delete specified model from viewer
                 *
                 * @param {GLModel|number} model
                 */
                removeModel(model) {
                  model = this.getModel(model);
                  if (!model)
                    return;
                  model.removegl(this.modelGroup);
                  delete this.models[model.getID()];
                  while (this.models.length > 0 && typeof this.models[this.models.length - 1] === "undefined")
                    this.models.pop();
                  return this;
                }
                /**
                 * Delete all existing models
                 */
                removeAllModels() {
                  for (var i = 0; i < this.models.length; i++) {
                    var model = this.models[i];
                    if (model)
                      model.removegl(this.modelGroup);
                  }
                  this.models.splice(0, this.models.length);
                  return this;
                }
                /**
                 * Export one or all of the loaded models into ChemDoodle compatible JSON.
                 * @param {boolean} includeStyles - Whether or not to include style information.
                 * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.
                 * @return {string}
                 */
                exportJSON(includeStyles, modelID) {
                  var object = {};
                  if (modelID === void 0) {
                    object.m = this.models.map(function(model) {
                      return model.toCDObject(includeStyles);
                    });
                  } else {
                    object.m = [this.models[modelID].toCDObject()];
                  }
                  return JSON.stringify(object);
                }
                /** return a VRML string representation of the scene.  Include VRML header information
                 * @return VRML
                 */
                exportVRML() {
                  var savedmodelGroup = this.modelGroup;
                  this.applyToModels("removegl", this.modelGroup);
                  this.modelGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Object3D();
                  this.render(null, { supportsImposters: false, supportsAIA: false, regen: true });
                  var ret = "#VRML V2.0 utf8\n" + this.modelGroup.vrml() + "\n";
                  this.applyToModels("removegl", this.modelGroup);
                  this.modelGroup = savedmodelGroup;
                  return ret;
                }
                /**
                 * Create a new model from atoms specified by sel.
                 * If extract, removes selected atoms from existing models
                 *
                 * @param {AtomSelectionSpec} sel - Atom selection specification
                 * @param {boolean=} extract - If true, remove selected atoms from existing models
                 * @return {GLModel}
                 */
                createModelFrom(sel, extract = false) {
                  var m = new _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel(this.models.length, this.defaultcolors, this);
                  for (var i = 0; i < this.models.length; i++) {
                    if (this.models[i]) {
                      var atoms = this.models[i].selectedAtoms(sel);
                      m.addAtoms(atoms);
                      if (extract)
                        this.models[i].removeAtoms(atoms);
                    }
                  }
                  this.models.push(m);
                  return m;
                }
                applyToModels(func, sel, value1, value2, value3, value4, value5) {
                  var ms = this.getModelList(sel);
                  for (var i = 0; i < ms.length; i++) {
                    ms[i][func](sel, value1, value2, value3, value4, value5);
                  }
                }
                setStyle(sel, style) {
                  if (typeof style === "undefined") {
                    style = sel;
                    sel = {};
                  }
                  this.applyToModels("setStyle", sel, style, false);
                  return this;
                }
                addStyle(sel, style) {
                  if (typeof style === "undefined") {
                    style = sel;
                    sel = {};
                  }
                  this.applyToModels("setStyle", sel, style, true);
                  return this;
                }
                /**
                     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.
                     *
                     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
                     * @param {boolean} clickable - whether click-handling is enabled for the selection
                     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed
                     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list
                     * of all intersecting objects with their distances from the viewer.
                     *
                     * @example
                        $3Dmol.download("cid:307900",viewer,{},function(){
                
                               viewer.setStyle({},{sphere:{}});
                               viewer.setClickable({},true,function(atom,viewer,event,container) {
                                   viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});
                               });
                               viewer.render();
                    });
                     */
                setClickable(sel, clickable, callback2) {
                  this.applyToModels("setClickable", sel, clickable, callback2);
                  return this;
                }
                /** Set hoverable and callback of selected atoms
                     *
                     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
                     * @param {boolean} hoverable - whether hover-handling is enabled for the selection
                     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.
                     * @param {function} unhover_callback - function called when the mouse moves out of the hover area
                    @example
                    $3Dmol.download("pdb:1ubq",viewer,{},function(){
                
                           viewer.setHoverable({},true,function(atom,viewer,event,container) {
                               if(!atom.label) {
                                atom.label = viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});
                               }
                           },
                           function(atom,viewer) {
                               if(atom.label) {
                                viewer.removeLabel(atom.label);
                                delete atom.label;
                               }
                            }
                           );
                           viewer.setStyle({},{stick:{}});
                           viewer.render();
                    });
                
                     */
                setHoverable(sel, hoverable, hover_callback, unhover_callback) {
                  this.applyToModels("setHoverable", sel, hoverable, hover_callback, unhover_callback);
                  return this;
                }
                /** enable context menu and callback of selected atoms
                     *
                     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
                     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
                
                     */
                enableContextMenu(sel, contextMenuEnabled) {
                  this.applyToModels("enableContextMenu", sel, contextMenuEnabled);
                  return this;
                }
                /**
                 * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.
                 * Models can then be animated
                 *
                 * @param {number} numFrames - number of frames to be created, default to 10
                 * @param {number} amplitude - amplitude of distortion, default to 1 (full)
                 * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
                 * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
                 */
                vibrate(numFrames, amplitude, bothways, arrowSpec) {
                  this.applyToModels("vibrate", numFrames, amplitude, bothways, arrowSpec);
                  return this;
                }
                /**
                 * @param {AtomSelectionSpec} sel
                 * @param {string} prop
                 * @param {Gradient|string} scheme
                 * @param {object} range
                 */
                setColorByProperty(sel, prop, scheme, range) {
                  this.applyToModels("setColorByProperty", sel, prop, scheme, range);
                  return this;
                }
                /**
                 * @param {AtomSelectionSpec} sel
                 * @param {object} colors
                 */
                setColorByElement(sel, colors) {
                  this.applyToModels("setColorByElement", sel, colors);
                  return this;
                }
                /**
                 *
                 * @param {AtomSpec[]} atomlist
                 * @param {Array}
                 *            extent
                 * @return {Array}
                 */
                static getAtomsWithin(atomlist, extent) {
                  var ret = [];
                  for (let i = 0; i < atomlist.length; i++) {
                    var atom = atomlist[i];
                    if (typeof atom == "undefined")
                      continue;
                    if (atom.x < extent[0][0] || atom.x > extent[1][0])
                      continue;
                    if (atom.y < extent[0][1] || atom.y > extent[1][1])
                      continue;
                    if (atom.z < extent[0][2] || atom.z > extent[1][2])
                      continue;
                    ret.push(atom);
                  }
                  return ret;
                }
                // return volume of extent
                static volume(extent) {
                  var w = extent[1][0] - extent[0][0];
                  var h = extent[1][1] - extent[0][1];
                  var d = extent[1][2] - extent[0][2];
                  return w * h * d;
                }
                // volume
                /*
                 * Break up bounding box/atoms into smaller pieces so we can parallelize
                 * with webworkers and also limit the size of the working memory Returns
                 * a list of bounding boxes with the corresponding atoms. These extents
                 * are expanded by 4 angstroms on each side.
                 */
                /**
                 *
                 * @param {Array}
                 *            extent
                 * @param {AtomSpec[]} atomlist
                 * @param {AtomSpec[]} atomstoshow
                 * @return {Array}
                 */
                carveUpExtent(extent, atomlist, atomstoshow) {
                  let ret = [];
                  let index2atomlist = {};
                  for (let i = 0, n = atomlist.length; i < n; i++) {
                    index2atomlist[atomlist[i].index] = i;
                  }
                  let atomsToListIndex = function(atoms) {
                    let ret2 = [];
                    for (let i = 0, n = atoms.length; i < n; i++) {
                      if (atoms[i].index in index2atomlist)
                        ret2.push(index2atomlist[atoms[i].index]);
                    }
                    return ret2;
                  };
                  let copyExtent = function(extent2) {
                    let ret2 = [];
                    ret2[0] = [extent2[0][0], extent2[0][1], extent2[0][2]];
                    ret2[1] = [extent2[1][0], extent2[1][1], extent2[1][2]];
                    return ret2;
                  };
                  let splitExtentR = function(extent2) {
                    if (GLViewer.volume(extent2) < GLViewer.maxVolume) {
                      return [extent2];
                    } else {
                      var w = extent2[1][0] - extent2[0][0];
                      var h = extent2[1][1] - extent2[0][1];
                      var d = extent2[1][2] - extent2[0][2];
                      var index;
                      if (w > h && w > d) {
                        index = 0;
                      } else if (h > w && h > d) {
                        index = 1;
                      } else {
                        index = 2;
                      }
                      var a = copyExtent(extent2);
                      var b = copyExtent(extent2);
                      var mid = (extent2[1][index] - extent2[0][index]) / 2 + extent2[0][index];
                      a[1][index] = mid;
                      b[0][index] = mid;
                      var alist = splitExtentR(a);
                      var blist = splitExtentR(b);
                      return alist.concat(blist);
                    }
                  };
                  let splits = splitExtentR(extent);
                  let off = 6;
                  for (let i = 0, n = splits.length; i < n; i++) {
                    let e = copyExtent(splits[i]);
                    e[0][0] -= off;
                    e[0][1] -= off;
                    e[0][2] -= off;
                    e[1][0] += off;
                    e[1][1] += off;
                    e[1][2] += off;
                    let atoms = GLViewer.getAtomsWithin(atomlist, e);
                    let toshow = GLViewer.getAtomsWithin(atomstoshow, splits[i]);
                    ret.push({
                      extent: splits[i],
                      atoms: atomsToListIndex(atoms),
                      toshow: atomsToListIndex(toshow)
                    });
                  }
                  return ret;
                }
                // create a mesh defined from the passed vertices and faces and material
                // Just create a single geometry chunk - broken up whether sync or not
                /**
                 *
                 * @param {AtomSpec[]} atoms
                 * @param {{vertices:number,faces:number}}
                 *            VandF
                 * @param {MeshLambertMaterial}
                 *            mat
                 * @return {Mesh}
                 */
                static generateSurfaceMesh(atoms, VandF, mat) {
                  var geo = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Geometry(true);
                  var geoGroup = geo.updateGeoGroup(0);
                  var colors = [];
                  for (let i = 0, il = atoms.length; i < il; i++) {
                    var atom = atoms[i];
                    if (atom) {
                      if (typeof atom.surfaceColor != "undefined") {
                        colors[i] = atom.surfaceColor;
                      } else if (atom.color)
                        colors[i] = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(atom.color);
                    }
                  }
                  var vertexArray = geoGroup.vertexArray;
                  var v = VandF.vertices;
                  for (let i = 0, il = v.length; i < il; i++) {
                    let offset = geoGroup.vertices * 3;
                    vertexArray[offset] = v[i].x;
                    vertexArray[offset + 1] = v[i].y;
                    vertexArray[offset + 2] = v[i].z;
                    geoGroup.vertices++;
                  }
                  var colorArray = geoGroup.colorArray;
                  let atomArray = geoGroup.atomArray;
                  if (mat.voldata && mat.volscheme) {
                    var scheme = mat.volscheme;
                    var voldata = mat.voldata;
                    var range = scheme.range() || [-1, 1];
                    for (let i = 0, il = v.length; i < il; i++) {
                      let A = v[i].atomid;
                      let val = voldata.getVal(v[i].x, v[i].y, v[i].z);
                      let col = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(scheme.valueToHex(val, range));
                      let offset = i * 3;
                      colorArray[offset] = col.r;
                      colorArray[offset + 1] = col.g;
                      colorArray[offset + 2] = col.b;
                      atomArray[i] = atoms[A];
                    }
                  } else if (colors.length > 0) {
                    for (let i = 0, il = v.length; i < il; i++) {
                      let A = v[i].atomid;
                      let offsetA2 = i * 3;
                      colorArray[offsetA2] = colors[A].r;
                      colorArray[offsetA2 + 1] = colors[A].g;
                      colorArray[offsetA2 + 2] = colors[A].b;
                      atomArray[i] = atoms[A];
                    }
                  }
                  var faces = VandF.faces;
                  geoGroup.faceidx = faces.length;
                  geo.initTypedArrays();
                  var verts = geoGroup.vertexArray;
                  var normalArray = geoGroup.normalArray;
                  var vA, vB, vC, norm;
                  for (let i = 0, il = faces.length; i < il; i += 3) {
                    var a = faces[i], b = faces[i + 1], c = faces[i + 2];
                    var offsetA = a * 3, offsetB = b * 3, offsetC = c * 3;
                    vA = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(verts[offsetA], verts[offsetA + 1], verts[offsetA + 2]);
                    vB = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(verts[offsetB], verts[offsetB + 1], verts[offsetB + 2]);
                    vC = new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(verts[offsetC], verts[offsetC + 1], verts[offsetC + 2]);
                    vC.subVectors(vC, vB);
                    vA.subVectors(vA, vB);
                    vC.cross(vA);
                    norm = vC;
                    norm.normalize();
                    normalArray[offsetA] += norm.x;
                    normalArray[offsetB] += norm.x;
                    normalArray[offsetC] += norm.x;
                    normalArray[offsetA + 1] += norm.y;
                    normalArray[offsetB + 1] += norm.y;
                    normalArray[offsetC + 1] += norm.y;
                    normalArray[offsetA + 2] += norm.z;
                    normalArray[offsetB + 2] += norm.z;
                    normalArray[offsetC + 2] += norm.z;
                  }
                  geoGroup.faceArray = new Uint16Array(faces);
                  var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Mesh(geo, mat);
                  return mesh;
                }
                // do same thing as worker in main thread
                /**
                 *
                 * @param {SurfaceType}
                 *            type
                 * @param {Array}
                 *            expandedExtent
                 * @param {AtomSpec[]}
                 *            extendedAtoms
                 * @param {AtomSpec[]}
                 *            atomsToShow
                 * @param {AtomSpec[]} atoms
                 * @param {number}
                 *            vol
                 * @return {Object}
                 */
                static generateMeshSyncHelper(type, expandedExtent, extendedAtoms, atomsToShow, atoms, vol) {
                  var ps = new _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.ProteinSurface();
                  ps.initparm(expandedExtent, type === 1 ? false : true, vol);
                  ps.fillvoxels(atoms, extendedAtoms);
                  ps.buildboundary();
                  if (type == _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.SES || type == _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.MS) {
                    ps.fastdistancemap();
                    ps.boundingatom(false);
                    ps.fillvoxelswaals(atoms, extendedAtoms);
                  }
                  ps.marchingcube(type);
                  return ps.getFacesAndVertices(atomsToShow);
                }
                /*
                 *
                 * @param {SurfaceStyleSpec}
                 *            style
                 * @return {MeshLambertMaterial}
                 */
                static getMatWithStyle(style) {
                  let mat = null;
                  if (style.onesided) {
                    mat = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.MeshLambertMaterial();
                  } else {
                    mat = new _WebGL__WEBPACK_IMPORTED_MODULE_8__.MeshDoubleLambertMaterial();
                  }
                  mat.vertexColors = _WebGL__WEBPACK_IMPORTED_MODULE_8__.Coloring.VertexColors;
                  for (var prop in style) {
                    if (prop === "color" || prop === "map") {
                    } else if (style.hasOwnProperty(prop))
                      mat[prop] = style[prop];
                  }
                  if (style.opacity !== void 0) {
                    if (style.opacity === 1)
                      mat.transparent = false;
                    else
                      mat.transparent = true;
                  }
                  if (style.wireframe !== void 0) {
                    mat.wireframe = style.wireframe;
                  }
                  return mat;
                }
                /**
                 * Adds an explicit mesh as a surface object.
                 * @param {Mesh}
                 *            mesh
                 * @param {Object}
                 *            style
                 * @returns {number} surfid
                 */
                addMesh(mesh) {
                  let surfobj = {
                    geo: mesh.geometry,
                    mat: mesh.material,
                    done: true,
                    finished: false
                    //the rendered finishes surfaces when they are done
                  };
                  var surfid = this.nextSurfID();
                  this.surfaces[surfid] = new Surface([surfobj]);
                  return surfid;
                }
                //return a shallow copy of list l, e.g., for atoms so we can
                //ignore superficial changes (ie surfacecolor, position) that happen
                //while we're surface building
                static shallowCopy(l) {
                  var ret = [];
                  let length = l.length;
                  for (let i = 0; i < length; i++) {
                    ret[i] = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.extend)({}, l[i]);
                  }
                  return ret;
                }
                /**
                 * Add surface representation to atoms
                 * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)
                 * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)
                 * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection
                 * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'
                 * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms
                 * @param {function} surfacecallback - function to be called after setting the surface
                 * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.
                 */
                addSurface(stype, style = {}, atomsel = {}, allsel, focus, surfacecallback) {
                  let surfid = this.nextSurfID();
                  let mat = null;
                  let self2 = this;
                  let type = _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.VDW;
                  if (typeof stype == "string") {
                    if (GLViewer.surfaceTypeMap[stype.toUpperCase()] !== void 0)
                      type = GLViewer.surfaceTypeMap[stype];
                    else {
                      console.log("Surface type : " + stype + " is not recognized");
                    }
                  } else if (typeof stype == "number") {
                    type = stype;
                  }
                  var atomlist = null, focusSele = null;
                  var atomsToShow = GLViewer.shallowCopy(this.getAtomsFromSel(atomsel));
                  if (!allsel) {
                    atomlist = atomsToShow;
                  } else {
                    atomlist = GLViewer.shallowCopy(this.getAtomsFromSel(allsel));
                  }
                  (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.adjustVolumeStyle)(style);
                  var symmetries = false;
                  var n;
                  for (n = 0; n < this.models.length; n++) {
                    if (this.models[n]) {
                      var symMatrices = this.models[n].getSymmetries();
                      if (symMatrices.length > 1 || symMatrices.length == 1 && !symMatrices[0].isIdentity()) {
                        symmetries = true;
                        break;
                      }
                    }
                  }
                  var addSurfaceHelper = function addSurfaceHelper2(surfobj, atomlist2, atomsToShow2) {
                    if (!focus) {
                      focusSele = atomsToShow2;
                    } else {
                      focusSele = GLViewer.shallowCopy(self2.getAtomsFromSel(focus));
                    }
                    var atom;
                    var extent = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(atomsToShow2, true);
                    if (style.map && style.map.prop) {
                      var prop = style.map.prop;
                      let scheme = (0, _Gradient__WEBPACK_IMPORTED_MODULE_3__.getGradient)(style.map.scheme || style.map.gradient || new _Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.RWB());
                      let range = scheme.range();
                      if (!range) {
                        range = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getPropertyRange)(atomsToShow2, prop);
                      }
                      style.colorscheme = { prop, gradient: scheme };
                    }
                    for (let i = 0, il = atomlist2.length; i < il; i++) {
                      atom = atomlist2[i];
                      atom.surfaceColor = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getColorFromStyle)(atom, style);
                    }
                    var totalVol = GLViewer.volume(extent);
                    var extents = self2.carveUpExtent(extent, atomlist2, atomsToShow2);
                    if (focusSele && focusSele.length && focusSele.length > 0) {
                      var seleExtent = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getExtent)(focusSele, true);
                      var sortFunc = function(a, b) {
                        var distSq = function(ex, sele) {
                          var e = ex.extent;
                          var x = e[1][0] - e[0][0];
                          var y = e[1][1] - e[0][1];
                          var z = e[1][2] - e[0][2];
                          var dx = x - sele[2][0];
                          dx *= dx;
                          var dy = y - sele[2][1];
                          dy *= dy;
                          var dz = z - sele[2][2];
                          dz *= dz;
                          return dx + dy + dz;
                        };
                        var d1 = distSq(a, seleExtent);
                        var d2 = distSq(b, seleExtent);
                        return d1 - d2;
                      };
                      extents.sort(sortFunc);
                    }
                    var reducedAtoms = [];
                    for (let i = 0, il = atomlist2.length; i < il; i++) {
                      atom = atomlist2[i];
                      reducedAtoms[i] = {
                        x: atom.x,
                        y: atom.y,
                        z: atom.z,
                        serial: i,
                        elem: atom.elem
                      };
                    }
                    var sync = !!_ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.syncSurface;
                    if (typeof $3Dmol == "undefined" || typeof $3Dmol.SurfaceWorker == "undefined") {
                      console.log("$3Dmol.SurfaceWorker is not defined, using synchronous surface generation.");
                      sync = true;
                    }
                    if (sync) {
                      var callSyncHelper = function callSyncHelper2(i) {
                        return new Promise(function(resolve) {
                          var VandF = GLViewer.generateMeshSyncHelper(type, extents[i].extent, extents[i].atoms, extents[i].toshow, reducedAtoms, totalVol);
                          var VandFs = (0, _GLShape__WEBPACK_IMPORTED_MODULE_2__.splitMesh)({ vertexArr: VandF.vertices, faceArr: VandF.faces });
                          for (var vi = 0, vl = VandFs.length; vi < vl; vi++) {
                            VandF = {
                              vertices: VandFs[vi].vertexArr,
                              faces: VandFs[vi].faceArr
                            };
                            var mesh = GLViewer.generateSurfaceMesh(atomlist2, VandF, mat);
                            (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.mergeGeos)(surfobj.geo, mesh);
                          }
                          self2.render();
                          resolve();
                        });
                      };
                      var promises2 = [];
                      for (let i = 0; i < extents.length; i++) {
                        promises2.push(callSyncHelper(i));
                      }
                      return Promise.all(promises2).then(function() {
                        surfobj.done = true;
                        self2.render();
                        return Promise.resolve(surfid);
                      });
                    } else {
                      var workers = [];
                      if (type < 0)
                        type = 0;
                      for (let i = 0, il = GLViewer.numWorkers; i < il; i++) {
                        var w = new Worker($3Dmol.SurfaceWorker);
                        workers.push(w);
                        w.postMessage({
                          "type": -1,
                          "atoms": reducedAtoms,
                          "volume": totalVol
                        });
                      }
                      return new Promise(function(resolve, reject) {
                        var cnt = 0;
                        var releaseMemory = function() {
                          if (!workers || !workers.length)
                            return;
                          workers.forEach(function(worker2) {
                            if (worker2 && worker2.terminate) {
                              worker2.terminate();
                            }
                          });
                        };
                        var rfunction = function(event) {
                          var VandFs = (0, _GLShape__WEBPACK_IMPORTED_MODULE_2__.splitMesh)({
                            vertexArr: event.data.vertices,
                            faceArr: event.data.faces
                          });
                          for (var i = 0, vl = VandFs.length; i < vl; i++) {
                            var VandF = {
                              vertices: VandFs[i].vertexArr,
                              faces: VandFs[i].faceArr
                            };
                            var mesh = GLViewer.generateSurfaceMesh(atomlist2, VandF, mat);
                            (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.mergeGeos)(surfobj.geo, mesh);
                          }
                          self2.render();
                          cnt++;
                          if (cnt == extents.length) {
                            surfobj.done = true;
                            releaseMemory();
                            resolve(surfid);
                          }
                        };
                        var efunction = function(event) {
                          releaseMemory();
                          console.log(event.message + " (" + event.filename + ":" + event.lineno + ")");
                          reject(event);
                        };
                        for (let i = 0; i < extents.length; i++) {
                          var worker = workers[i % workers.length];
                          worker.onmessage = rfunction;
                          worker.onerror = efunction;
                          worker.postMessage({
                            "type": type,
                            "expandedExtent": extents[i].extent,
                            "extendedAtoms": extents[i].atoms,
                            "atomsToShow": extents[i].toshow
                          });
                        }
                      });
                    }
                  };
                  style = style || {};
                  mat = GLViewer.getMatWithStyle(style);
                  let surf = new Surface([]);
                  surf.style = style;
                  surf.atomsel = atomsel;
                  surf.allsel = allsel;
                  surf.focus = focus;
                  var promise = null;
                  if (symmetries) {
                    var modelsAtomList = {};
                    var modelsAtomsToShow = {};
                    for (n = 0; n < this.models.length; n++) {
                      modelsAtomList[n] = [];
                      modelsAtomsToShow[n] = [];
                    }
                    for (n = 0; n < atomlist.length; n++) {
                      modelsAtomList[atomlist[n].model].push(atomlist[n]);
                    }
                    for (n = 0; n < atomsToShow.length; n++) {
                      modelsAtomsToShow[atomsToShow[n].model].push(atomsToShow[n]);
                    }
                    var promises = [];
                    for (n = 0; n < this.models.length; n++) {
                      if (modelsAtomsToShow[n].length > 0) {
                        surf.push({
                          geo: new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Geometry(true),
                          mat,
                          done: false,
                          finished: false,
                          symmetries: this.models[n].getSymmetries()
                          // also webgl initialized
                        });
                        promises.push(addSurfaceHelper(surf[surf.length - 1], modelsAtomList[n], modelsAtomsToShow[n]));
                      }
                    }
                    promise = Promise.all(promises);
                  } else {
                    surf.push({
                      geo: new _WebGL__WEBPACK_IMPORTED_MODULE_8__.Geometry(true),
                      mat,
                      done: false,
                      finished: false,
                      symmetries: [new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Matrix4()]
                    });
                    promise = addSurfaceHelper(surf[surf.length - 1], atomlist, atomsToShow);
                  }
                  this.surfaces[surfid] = surf;
                  promise.surfid = surfid;
                  if (surfacecallback && typeof surfacecallback == "function") {
                    promise.then(function(surfid2) {
                      surfacecallback(surfid2);
                    });
                    return surfid;
                  } else {
                    return promise;
                  }
                }
                /**
                 * Set the surface material to something else, must render change
                 * @param {number} surf - Surface ID to apply changes to
                 * @param {SurfaceStyleSpec} style - new material style specification
                 @example
                 $3Dmol.get("data/9002806.cif",function(data){
                    viewer.addModel(data);
                    viewer.setStyle({stick:{}});
                    let surf = viewer.addSurface("SAS");
                    surf.then(function() {
                        viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});
                        viewer.render();
                        });
                   });
                 */
                setSurfaceMaterialStyle(surf, style) {
                  (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.adjustVolumeStyle)(style);
                  if (this.surfaces[surf]) {
                    var surfArr = this.surfaces[surf];
                    for (let i = 0; i < surfArr.length; i++) {
                      var mat = surfArr[i].mat = GLViewer.getMatWithStyle(style);
                      surfArr[i].mat.side = _WebGL__WEBPACK_IMPORTED_MODULE_8__.FrontSide;
                      if (style.wireframe) {
                        surfArr[i].geo.setUpWireframe();
                      }
                      if (style.color) {
                        surfArr[i].mat.color = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(style.color);
                        surfArr[i].geo.colorsNeedUpdate = true;
                        const c = _colors__WEBPACK_IMPORTED_MODULE_10__.CC.color(style.color);
                        surfArr[i].geo.setColor(c);
                      } else if (mat.voldata && mat.volscheme) {
                        const scheme = mat.volscheme;
                        const voldata = mat.voldata;
                        const cc = _colors__WEBPACK_IMPORTED_MODULE_10__.CC;
                        const range = scheme.range() || [-1, 1];
                        surfArr[i].geo.setColors(function(x, y, z) {
                          let val = voldata.getVal(x, y, z);
                          let col = cc.color(scheme.valueToHex(val, range));
                          return col;
                        });
                      } else {
                        surfArr[i].geo.colorsNeedUpdate = true;
                        for (let geo of surfArr[i].geo.geometryGroups) {
                          for (let j = 0; j < geo.vertices; j++) {
                            let c = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getColorFromStyle)(geo.atomArray[j], style);
                            let off = 3 * j;
                            geo.colorArray[off] = c.r;
                            geo.colorArray[off + 1] = c.g;
                            geo.colorArray[off + 2] = c.b;
                          }
                        }
                      }
                      surfArr[i].finished = false;
                    }
                  }
                  return this;
                }
                /**
                 * Return surface object
                 * @param {number} surf - surface id
                 */
                getSurface(surf) {
                  return this.surfaces[surf];
                }
                /**
                 * Remove surface with given ID
                 * @param {number} surf - surface id
                 */
                removeSurface(surf) {
                  var surfArr = this.surfaces[surf];
                  for (var i = 0; i < surfArr.length; i++) {
                    if (surfArr[i] && surfArr[i].lastGL) {
                      if (surfArr[i].geo !== void 0)
                        surfArr[i].geo.dispose();
                      if (surfArr[i].mat !== void 0)
                        surfArr[i].mat.dispose();
                      this.modelGroup.remove(surfArr[i].lastGL);
                    }
                  }
                  delete this.surfaces[surf];
                  this.show();
                  return this;
                }
                /** Remove all surfaces.
                 **/
                removeAllSurfaces() {
                  for (var n in this.surfaces) {
                    if (!this.surfaces.hasOwnProperty(n))
                      continue;
                    var surfArr = this.surfaces[n];
                    for (var i = 0; i < surfArr.length; i++) {
                      if (surfArr[i] && surfArr[i].lastGL) {
                        if (surfArr[i].geo !== void 0)
                          surfArr[i].geo.dispose();
                        if (surfArr[i].mat !== void 0)
                          surfArr[i].mat.dispose();
                        this.modelGroup.remove(surfArr[i].lastGL);
                      }
                    }
                    delete this.surfaces[n];
                  }
                  this.show();
                  return this;
                }
                /** return Jmol moveto command to position this scene */
                jmolMoveTo() {
                  var pos = this.modelGroup.position;
                  var ret = "center { " + -pos.x + " " + -pos.y + " " + -pos.z + " }; ";
                  var q = this.rotationGroup.quaternion;
                  ret += "moveto .5 quaternion { " + q.x + " " + q.y + " " + q.z + " " + q.w + " };";
                  return ret;
                }
                /** Clear scene of all objects
                 * */
                clear() {
                  this.removeAllSurfaces();
                  this.removeAllModels();
                  this.removeAllLabels();
                  this.removeAllShapes();
                  this.show();
                  return this;
                }
                // props is a list of objects that select certain atoms and enumerate
                // properties for those atoms
                /**
                 * Add specified properties to all atoms matching input argument
                 * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties
                 * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here
                     @example
                     $3Dmol.get('../test_structs/b.sdf', function(data){
                              viewer.addModel(data,'sdf');
                              let props = [];
                              //make the atom index a property x
                              for(let i = 0; i < 8; i++) {
                                props.push({index:i,props:{'x':i}});
                              }
                              viewer.mapAtomProperties(props);
                              viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});
                              viewer.zoomTo();
                              viewer.render();
                            });
                 */
                mapAtomProperties(props, sel) {
                  sel = sel || {};
                  var atoms = this.getAtomsFromSel(sel);
                  if (typeof props == "function") {
                    for (let a = 0, numa = atoms.length; a < numa; a++) {
                      let atom2 = atoms[a];
                      props(atom2);
                    }
                  } else {
                    for (let a = 0, numa = atoms.length; a < numa; a++) {
                      var atom = atoms[a];
                      for (let i = 0, n = props.length; i < n; i++) {
                        let prop = props[i];
                        if (prop.props) {
                          for (var p in prop.props) {
                            if (prop.props.hasOwnProperty(p)) {
                              if (this.atomIsSelected(atom, prop)) {
                                if (!atom.properties)
                                  atom.properties = {};
                                atom.properties[p] = prop.props[p];
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  return this;
                }
                /**
                 * Synchronize this view matrix of this viewer to the passed viewer.
                 * When the viewpoint of this viewer changes, the other viewer will
                 * be set to this viewer's view.
                 * @param {GLViewer} otherview
                 */
                linkViewer(otherviewer) {
                  this.linkedViewers.push(otherviewer);
                  return this;
                }
                /**
                 * Return the z distance between the model and the camera
                 * @return {number} distance
                 */
                getPerceivedDistance() {
                  return this.CAMERA_Z - this.rotationGroup.position.z;
                }
                /**
                 * Set the distance between the model and the camera
                 * Essentially zooming. Useful while stereo rendering.
                 */
                setPerceivedDistance(dist) {
                  this.rotationGroup.position.z = this.CAMERA_Z - dist;
                }
                /**
                 * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object
                 * @return {number} camera x position
                 */
                setAutoEyeSeparation(isright, x) {
                  var dist = this.getPerceivedDistance();
                  if (!x)
                    x = 5;
                  if (isright || this.camera.position.x > 0)
                    this.camera.position.x = dist * Math.tan(Math.PI / 180 * x);
                  else
                    this.camera.position.x = -dist * Math.tan(Math.PI / 180 * x);
                  this.camera.lookAt(new _WebGL_math__WEBPACK_IMPORTED_MODULE_9__.Vector3(0, 0, this.rotationGroup.position.z));
                  return this.camera.position.x;
                }
                /**
                 * Set the default cartoon quality for newly created models.  Default is 5.
                 * Current models are not affected.
                 * @number quality, higher results in higher resolution renders
                 */
                setDefaultCartoonQuality(val) {
                  this.config.cartoonQuality = val;
                }
              }
              GLViewer.numWorkers = 4;
              GLViewer.maxVolume = 64e3;
              GLViewer.surfaceTypeMap = {
                "VDW": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.VDW,
                "MS": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.MS,
                "SAS": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.SAS,
                "SES": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_5__.SurfaceType.SES
              };
              function createViewer(element, config) {
                element = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getElement)(element);
                if (!element)
                  return;
                config = config || {};
                try {
                  var viewer = new GLViewer(element, config);
                  return viewer;
                } catch (e) {
                  throw "error creating viewer: " + e;
                }
              }
              ;
              function createViewerGrid(element, config = {}, viewer_config = {}) {
                element = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getElement)(element);
                if (!element)
                  return;
                var viewers = [];
                var canvas = document.createElement("canvas");
                viewer_config.rows = config.rows;
                viewer_config.cols = config.cols;
                viewer_config.control_all = config.control_all != void 0 ? config.control_all : false;
                element.appendChild(canvas);
                try {
                  for (var r = 0; r < config.rows; r++) {
                    var row = [];
                    for (var c = 0; c < config.cols; c++) {
                      viewer_config.row = r;
                      viewer_config.col = c;
                      viewer_config.canvas = canvas;
                      viewer_config.viewers = viewers;
                      viewer_config.control_all = config.control_all;
                      var viewer = createViewer(element, (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.extend)({}, viewer_config));
                      row.push(viewer);
                    }
                    viewers.unshift(row);
                  }
                } catch (e) {
                  throw "error creating viewer grid: " + e;
                }
                return viewers;
              }
              ;
              function createStereoViewer(element) {
                var that = this;
                element = (0, _utilities__WEBPACK_IMPORTED_MODULE_11__.getElement)(element);
                if (!element)
                  return;
                var viewers = createViewerGrid(element, { rows: 1, cols: 2, control_all: true });
                this.glviewer1 = viewers[0][0];
                this.glviewer2 = viewers[0][1];
                this.glviewer1.setAutoEyeSeparation(false);
                this.glviewer2.setAutoEyeSeparation(true);
                this.glviewer1.linkViewer(this.glviewer2);
                this.glviewer2.linkViewer(this.glviewer1);
                var methods = Object.getOwnPropertyNames(this.glviewer1.__proto__).filter(function(property) {
                  return typeof that.glviewer1[property] == "function";
                });
                for (var i = 0; i < methods.length; i++) {
                  this[methods[i]] = /* @__PURE__ */ (function(method) {
                    return function() {
                      var m1 = this.glviewer1[method].apply(this.glviewer1, arguments);
                      var m2 = this.glviewer2[method].apply(this.glviewer2, arguments);
                      return [m1, m2];
                    };
                  })(methods[i]);
                }
                this.setCoordinates = function(models, data, format) {
                  for (var i2 = 0; i2 < models.length; i2++) {
                    models[i2].setCoordinates(data, format);
                  }
                };
                this.surfacesFinished = function() {
                  return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();
                };
                this.isAnimated = function() {
                  return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();
                };
                this.render = function(callback2) {
                  this.glviewer1.render();
                  this.glviewer2.render();
                  if (callback2) {
                    callback2(this);
                  }
                };
                this.getCanvas = function() {
                  return this.glviewer1.getCanvas();
                };
              }
              ;
              ;
              ;
              ;
            },
            /***/
            "./src/Gradient.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CustomLinear: () => (
                  /* binding */
                  CustomLinear
                ),
                /* harmony export */
                Gradient: () => (
                  /* binding */
                  Gradient
                ),
                /* harmony export */
                GradientType: () => (
                  /* binding */
                  GradientType
                ),
                /* harmony export */
                ROYGB: () => (
                  /* binding */
                  ROYGB
                ),
                /* harmony export */
                RWB: () => (
                  /* binding */
                  RWB
                ),
                /* harmony export */
                Sinebow: () => (
                  /* binding */
                  Sinebow
                ),
                /* harmony export */
                builtinGradients: () => (
                  /* binding */
                  builtinGradients
                ),
                /* harmony export */
                getGradient: () => (
                  /* binding */
                  getGradient
                ),
                /* harmony export */
                normalizeValue: () => (
                  /* binding */
                  normalizeValue
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              class GradientType {
              }
              function normalizeValue(lo, hi, val) {
                if (hi >= lo) {
                  if (val < lo)
                    val = lo;
                  if (val > hi)
                    val = hi;
                  return { lo, hi, val };
                } else {
                  if (val > lo)
                    val = lo;
                  if (val < hi)
                    val = hi;
                  val = lo - val + hi;
                  return { lo: hi, hi: lo, val };
                }
              }
              function getGradient(grad) {
                if (grad instanceof GradientType) {
                  return grad;
                } else if (grad.gradient !== void 0 && builtinGradients[grad.gradient]) {
                  let min = grad.min === void 0 ? -1 : grad.min;
                  let max = grad.max === void 0 ? 1 : grad.max;
                  if (grad.mid === void 0) {
                    if (grad.colors === void 0) {
                      return new builtinGradients[grad.gradient](min, max);
                    } else {
                      return new builtinGradients[grad.gradient](min, max, grad.colors);
                    }
                  } else {
                    return new builtinGradients[grad.gradient](min, max, grad.mid);
                  }
                } else if (typeof grad.gradient == "string" && grad.gradient.startsWith("linear_")) {
                  let colors = grad.gradient.split("_");
                  colors.shift();
                  let min = grad.min === void 0 ? -1 : grad.min;
                  let max = grad.max === void 0 ? 1 : grad.max;
                  return new CustomLinear(min, max, colors);
                }
                return grad;
              }
              class RWB extends GradientType {
                constructor(min, max, mid) {
                  super();
                  this.gradient = "RWB";
                  this.mult = 1;
                  this.mid = mid;
                  this.min = min;
                  this.max = max;
                  if (typeof max == "undefined" && Array.isArray(min) && min.length >= 2) {
                    this.max = min[1];
                    this.min = min[0];
                  } else if (!!min && !!max && !Array.isArray(min)) {
                    this.min = min;
                    this.max = max;
                  }
                }
                //return range used for color mapping, null if none set
                range() {
                  if (typeof this.min != "undefined" && typeof this.max != "undefined") {
                    return [this.min, this.max];
                  }
                  return null;
                }
                //map value to hex color, range is provided
                valueToHex(val, range) {
                  var lo, hi;
                  val = this.mult * val;
                  if (range) {
                    lo = range[0];
                    hi = range[1];
                  } else {
                    lo = this.min;
                    hi = this.max;
                  }
                  if (val === void 0)
                    return 16777215;
                  var norm = normalizeValue(lo, hi, val);
                  lo = norm.lo;
                  hi = norm.hi;
                  val = norm.val;
                  var middle = (hi + lo) / 2;
                  if (range && typeof range[2] != "undefined")
                    middle = range[2];
                  else if (typeof this.mid != "undefined")
                    middle = this.mid;
                  else
                    middle = (lo + hi) / 2;
                  var scale, color;
                  if (val < middle) {
                    scale = Math.floor(255 * Math.sqrt((val - lo) / (middle - lo)));
                    color = 16711680 + 256 * scale + scale;
                    return color;
                  } else if (val > middle) {
                    scale = Math.floor(255 * Math.sqrt(1 - (val - middle) / (hi - middle)));
                    color = 65536 * scale + 256 * scale + 255;
                    return color;
                  } else {
                    return 16777215;
                  }
                }
              }
              class ROYGB extends GradientType {
                constructor(min, max) {
                  super();
                  this.gradient = "ROYGB";
                  this.mult = 1;
                  this.min = min;
                  this.max = max;
                  if (typeof max == "undefined" && Array.isArray(min) && min.length >= 2) {
                    this.max = min[1];
                    this.min = min[0];
                  } else if (!!min && !!max && !Array.isArray(min)) {
                    this.min = min;
                    this.max = max;
                  }
                }
                //map value to hex color, range is provided
                valueToHex(val, range) {
                  var lo, hi;
                  val = this.mult * val;
                  if (range) {
                    lo = range[0];
                    hi = range[1];
                  } else {
                    lo = this.min;
                    hi = this.max;
                  }
                  if (typeof val == "undefined")
                    return 16777215;
                  var norm = normalizeValue(lo, hi, val);
                  lo = norm.lo;
                  hi = norm.hi;
                  val = norm.val;
                  var mid = (lo + hi) / 2;
                  var q1 = (lo + mid) / 2;
                  var q3 = (mid + hi) / 2;
                  var scale, color;
                  if (val < q1) {
                    scale = Math.floor(255 * Math.sqrt((val - lo) / (q1 - lo)));
                    color = 16711680 + 256 * scale + 0;
                    return color;
                  } else if (val < mid) {
                    scale = Math.floor(255 * Math.sqrt(1 - (val - q1) / (mid - q1)));
                    color = 65536 * scale + 65280 + 0;
                    return color;
                  } else if (val < q3) {
                    scale = Math.floor(255 * Math.sqrt((val - mid) / (q3 - mid)));
                    color = 0 + 65280 + 1 * scale;
                    return color;
                  } else {
                    scale = Math.floor(255 * Math.sqrt(1 - (val - q3) / (hi - q3)));
                    color = 0 + 256 * scale + 255;
                    return color;
                  }
                }
                //return range used for color mapping, null if none set
                range() {
                  if (typeof this.min != "undefined" && typeof this.max != "undefined") {
                    return [this.min, this.max];
                  }
                  return null;
                }
              }
              class Sinebow extends GradientType {
                constructor(min, max) {
                  super();
                  this.gradient = "Sinebow";
                  this.mult = 1;
                  this.min = min;
                  this.max = max;
                  if (typeof max == "undefined" && Array.isArray(min) && min.length >= 2) {
                    this.max = min[1];
                    this.min = min[0];
                  }
                  if (max < min) {
                    this.mult = -1;
                    this.min *= -1;
                    this.max *= -1;
                  }
                }
                //map value to hex color, range is provided
                valueToHex(val, range) {
                  var lo, hi;
                  val = this.mult * val;
                  if (range) {
                    lo = range[0];
                    hi = range[1];
                  } else {
                    lo = this.min;
                    hi = this.max;
                  }
                  if (typeof val == "undefined")
                    return 16777215;
                  var norm = Gradient.normalizeValue(lo, hi, val);
                  lo = norm.lo;
                  hi = norm.hi;
                  val = norm.val;
                  var scale = (val - lo) / (hi - lo);
                  var h = 5 * scale / 6 + 0.5;
                  var r = Math.sin(Math.PI * h);
                  r *= r * 255;
                  var g = Math.sin(Math.PI * (h + 1 / 3));
                  g *= g * 255;
                  var b = Math.sin(Math.PI * (h + 2 / 3));
                  b *= b * 255;
                  return 65536 * Math.floor(r) + 256 * Math.floor(b) + 1 * Math.floor(g);
                }
                //return range used for color mapping, null if none set
                range() {
                  if (typeof this.min != "undefined" && typeof this.max != "undefined") {
                    return [this.min, this.max];
                  }
                  return null;
                }
              }
              class CustomLinear extends GradientType {
                constructor(min, max, colors) {
                  super();
                  this.gradient = "linear";
                  this.colors = new Array();
                  var carr;
                  if (Array.isArray(min) && min.length >= 2) {
                    this.max = min[1];
                    this.min = min[0];
                    carr = max;
                  } else {
                    this.min = min;
                    this.max = max;
                    carr = colors;
                  }
                  if (carr) {
                    for (let c of carr) {
                      this.colors.push(_colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(c));
                    }
                  } else {
                    this.colors.push(_colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(0));
                  }
                }
                //return range used for color mapping, null if none set
                range() {
                  if (typeof this.min != "undefined" && typeof this.max != "undefined") {
                    return [this.min, this.max];
                  }
                  return null;
                }
                //map value to hex color, range is provided
                valueToHex(val, range) {
                  var lo, hi;
                  if (range) {
                    lo = range[0];
                    hi = range[1];
                  } else {
                    lo = this.min;
                    hi = this.max;
                  }
                  if (val === void 0)
                    return 16777215;
                  var norm = normalizeValue(lo, hi, val);
                  lo = norm.lo;
                  hi = norm.hi;
                  val = norm.val;
                  let nsteps = this.colors.length;
                  let stepsize = (hi - lo) / nsteps;
                  let startpos = Math.min(Math.floor((val - lo) / stepsize), nsteps - 1);
                  let endpos = Math.min(startpos + 1, nsteps - 1);
                  let frac = (val - lo - startpos * stepsize) / stepsize;
                  let startcol = this.colors[startpos];
                  let endcol = this.colors[endpos];
                  let col = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(startcol.r + frac * (endcol.r - startcol.r), startcol.g + frac * (endcol.g - startcol.g), startcol.b + frac * (endcol.b - startcol.b));
                  return col.getHex();
                }
              }
              const builtinGradients = {
                "rwb": RWB,
                "RWB": RWB,
                "roygb": ROYGB,
                "ROYGB": ROYGB,
                "sinebow": Sinebow,
                "linear": CustomLinear
              };
              class Gradient extends GradientType {
                valueToHex(_value, _range) {
                  return 0;
                }
                range() {
                  return null;
                }
              }
              Gradient.RWB = RWB;
              Gradient.ROYGB = ROYGB;
              Gradient.Sinebow = Sinebow;
              Gradient.CustomLinear = CustomLinear;
              Gradient.builtinGradients = builtinGradients;
              Gradient.normalizeValue = normalizeValue;
              Gradient.getGradient = getGradient;
            },
            /***/
            "./src/Label.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Label: () => (
                  /* binding */
                  Label
                ),
                /* harmony export */
                LabelCount: () => (
                  /* binding */
                  LabelCount
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _Gradient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              let LabelCount = 0;
              function roundRect(ctx, x, y, w, h, r, drawBorder) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();
                if (drawBorder)
                  ctx.stroke();
              }
              function getColor(style, stylealpha, init) {
                var ret = init;
                if (typeof style != "undefined") {
                  if (style instanceof _colors__WEBPACK_IMPORTED_MODULE_2__2.Color)
                    ret = style.scaled();
                  else {
                    ret = _colors__WEBPACK_IMPORTED_MODULE_2__2.CC.color(style);
                    if (typeof ret.scaled != "undefined") {
                      ret = ret.scaled();
                    }
                  }
                }
                if (typeof stylealpha != "undefined") {
                  ret.a = parseFloat(stylealpha);
                }
                return ret;
              }
              class Label {
                constructor(text, parameters) {
                  this.id = LabelCount++;
                  this.stylespec = parameters || {};
                  this.canvas = document.createElement("canvas");
                  this.canvas.width = 134;
                  this.canvas.height = 35;
                  this.context = this.canvas.getContext("2d");
                  this.sprite = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Sprite();
                  this.text = text;
                  this.frame = this.stylespec.frame;
                }
                getStyle() {
                  return this.stylespec;
                }
                /** Hide this label. */
                hide() {
                  if (this.sprite) {
                    this.sprite.visible = false;
                  }
                }
                /** Show a hidden label. */
                show() {
                  if (this.sprite) {
                    this.sprite.visible = true;
                  }
                }
                setContext() {
                  var style = this.stylespec;
                  var useScreen = typeof style.useScreen == "undefined" ? false : style.useScreen;
                  var showBackground = style.showBackground;
                  if (showBackground === "0" || showBackground === "false")
                    showBackground = false;
                  if (typeof showBackground == "undefined")
                    showBackground = true;
                  var font = style.font ? style.font : "sans-serif";
                  var fontSize = parseInt(style.fontSize) ? parseInt(style.fontSize) : 18;
                  var fontColor = getColor(style.fontColor, style.fontOpacity, {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1
                  });
                  var padding = style.padding ? style.padding : 4;
                  var borderThickness = style.borderThickness ? style.borderThickness : 0;
                  var backgroundColor = getColor(style.backgroundColor, style.backgroundOpacity, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                  });
                  var borderColor = getColor(style.borderColor, style.borderOpacity, backgroundColor);
                  var position = style.position ? style.position : {
                    x: -10,
                    y: 1,
                    z: 1
                  };
                  var inFront = style.inFront !== void 0 ? style.inFront : true;
                  if (inFront === "false" || inFront === "0")
                    inFront = false;
                  var spriteAlignment = style.alignment || _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment.topLeft;
                  if (typeof spriteAlignment == "string" && spriteAlignment in _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment) {
                    spriteAlignment = _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment[spriteAlignment];
                  }
                  var bold = "";
                  if (style.bold)
                    bold = "bold ";
                  this.context.font = bold + fontSize + "px  " + font;
                  var metrics = this.context.measureText(this.text);
                  var textWidth = metrics.width;
                  if (!showBackground)
                    borderThickness = 0;
                  var width = textWidth + 2.5 * borderThickness + 2 * padding;
                  var height = fontSize * 1.25 + 2 * borderThickness + 2 * padding;
                  if (style.backgroundImage) {
                    var img = style.backgroundImage;
                    var w = style.backgroundWidth ? style.backgroundWidth : img.width;
                    var h = style.backgroundHeight ? style.backgroundHeight : img.height;
                    if (w > width)
                      width = w;
                    if (h > height)
                      height = h;
                  }
                  this.canvas.width = width;
                  this.canvas.height = height;
                  this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                  bold = "";
                  if (style.bold)
                    bold = "bold ";
                  this.context.font = bold + fontSize + "px  " + font;
                  this.context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                  this.context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
                  if (style.backgroundGradient) {
                    let gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
                    let g = _Gradient__WEBPACK_IMPORTED_MODULE_1__.Gradient.getGradient(style.backgroundGradient);
                    let minmax = g.range();
                    let min = -1;
                    let max = 1;
                    if (minmax) {
                      min = minmax[0];
                      max = minmax[1];
                    }
                    let d = max - min;
                    for (let i = 0; i < 1.01; i += 0.1) {
                      let c = getColor(g.valueToHex(min + d * i));
                      let cname = "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a + ")";
                      gradient.addColorStop(i, cname);
                    }
                    this.context.fillStyle = gradient;
                  }
                  this.context.lineWidth = borderThickness;
                  if (showBackground) {
                    roundRect(this.context, borderThickness, borderThickness, width - 2 * borderThickness, height - 2 * borderThickness, 6, borderThickness > 0);
                  }
                  if (style.backgroundImage) {
                    this.context.drawImage(img, 0, 0, width, height);
                  }
                  this.context.fillStyle = "rgba(" + fontColor.r + "," + fontColor.g + "," + fontColor.b + "," + fontColor.a + ")";
                  this.context.fillText(this.text, borderThickness + padding, fontSize + borderThickness + padding, textWidth);
                  var texture = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Texture(this.canvas);
                  texture.needsUpdate = true;
                  this.sprite.material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial({
                    map: texture,
                    useScreenCoordinates: useScreen,
                    alignment: spriteAlignment,
                    depthTest: !inFront,
                    screenOffset: style.screenOffset || null
                  });
                  this.sprite.scale.set(1, 1, 1);
                  this.sprite.position.set(position.x, position.y, position.z);
                }
                // clean up material and texture
                dispose() {
                  if (this.sprite.material.map !== void 0)
                    this.sprite.material.map.dispose();
                  if (this.sprite.material !== void 0)
                    this.sprite.material.dispose();
                }
              }
            },
            /***/
            "./src/ProteinSurface4.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MarchingCube: () => (
                  /* binding */
                  MarchingCube
                ),
                /* harmony export */
                MarchingCubeInitializer: () => (
                  /* binding */
                  MarchingCubeInitializer
                ),
                /* harmony export */
                PointGrid: () => (
                  /* binding */
                  PointGrid
                ),
                /* harmony export */
                ProteinSurface: () => (
                  /* binding */
                  ProteinSurface2
                ),
                /* harmony export */
                SurfaceType: () => (
                  /* binding */
                  SurfaceType
                ),
                /* harmony export */
                setSyncSurface: () => (
                  /* binding */
                  setSyncSurface
                ),
                /* harmony export */
                syncSurface: () => (
                  /* binding */
                  syncSurface
                )
                /* harmony export */
              });
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var SurfaceType;
              (function(SurfaceType2) {
                SurfaceType2[SurfaceType2["VDW"] = 1] = "VDW";
                SurfaceType2[SurfaceType2["MS"] = 2] = "MS";
                SurfaceType2[SurfaceType2["SAS"] = 3] = "SAS";
                SurfaceType2[SurfaceType2["SES"] = 4] = "SES";
              })(SurfaceType || (SurfaceType = {}));
              ;
              var syncSurface = false;
              function setSyncSurface(val) {
                syncSurface = val;
              }
              if (window.navigator.userAgent.indexOf("MSIE ") >= 0 || window.navigator.userAgent.indexOf("Trident/") >= 0) {
                syncSurface = true;
              }
              class MarchingCubeInitializer {
                constructor() {
                  this.ISDONE = 2;
                  this.edgeTable = new Uint32Array([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2816,
                    0,
                    0,
                    0,
                    1792,
                    0,
                    3328,
                    3584,
                    3840,
                    0,
                    0,
                    0,
                    138,
                    0,
                    21,
                    0,
                    134,
                    0,
                    0,
                    0,
                    652,
                    0,
                    2067,
                    3865,
                    3600,
                    0,
                    0,
                    0,
                    42,
                    0,
                    0,
                    0,
                    294,
                    0,
                    0,
                    21,
                    28,
                    0,
                    3875,
                    1049,
                    3360,
                    0,
                    168,
                    162,
                    170,
                    0,
                    645,
                    2475,
                    2210,
                    0,
                    687,
                    293,
                    172,
                    4010,
                    3747,
                    3497,
                    3232,
                    0,
                    0,
                    0,
                    0,
                    0,
                    69,
                    0,
                    900,
                    0,
                    0,
                    0,
                    1792,
                    138,
                    131,
                    1608,
                    1920,
                    0,
                    81,
                    0,
                    2074,
                    84,
                    85,
                    84,
                    86,
                    0,
                    81,
                    0,
                    3676,
                    330,
                    1105,
                    1881,
                    1616,
                    0,
                    0,
                    0,
                    42,
                    0,
                    69,
                    0,
                    502,
                    0,
                    0,
                    21,
                    3580,
                    138,
                    2035,
                    1273,
                    1520,
                    2816,
                    104,
                    2337,
                    106,
                    840,
                    581,
                    367,
                    102,
                    2816,
                    3695,
                    3429,
                    3180,
                    1898,
                    1635,
                    1385,
                    1120,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    3910,
                    0,
                    0,
                    69,
                    588,
                    42,
                    2083,
                    41,
                    2880,
                    0,
                    0,
                    0,
                    1722,
                    0,
                    2293,
                    4095,
                    3830,
                    0,
                    255,
                    757,
                    764,
                    2538,
                    2291,
                    3065,
                    2800,
                    0,
                    0,
                    81,
                    338,
                    0,
                    3925,
                    1119,
                    3414,
                    84,
                    855,
                    85,
                    340,
                    2130,
                    2899,
                    89,
                    2384,
                    1792,
                    712,
                    194,
                    1162,
                    4036,
                    3781,
                    3535,
                    3270,
                    708,
                    719,
                    197,
                    204,
                    3018,
                    2755,
                    2505,
                    2240,
                    0,
                    0,
                    0,
                    0,
                    168,
                    420,
                    168,
                    1958,
                    162,
                    162,
                    676,
                    2988,
                    170,
                    163,
                    680,
                    928,
                    3328,
                    3096,
                    3328,
                    3642,
                    52,
                    53,
                    1855,
                    1590,
                    2340,
                    2111,
                    2869,
                    2620,
                    298,
                    51,
                    825,
                    560,
                    3584,
                    3584,
                    3090,
                    3482,
                    1668,
                    1941,
                    1183,
                    1430,
                    146,
                    2975,
                    2069,
                    2460,
                    154,
                    915,
                    153,
                    400,
                    3840,
                    3592,
                    3329,
                    3082,
                    1796,
                    1541,
                    1295,
                    1030,
                    2818,
                    2575,
                    2309,
                    2060,
                    778,
                    515,
                    265,
                    0
                  ]);
                  this.triTable = [
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [11, 9, 8],
                    [],
                    [],
                    [],
                    [8, 10, 9],
                    [],
                    [10, 8, 11],
                    [9, 11, 10],
                    [8, 10, 9, 8, 11, 10],
                    [],
                    [],
                    [],
                    [1, 7, 3],
                    [],
                    [4, 2, 0],
                    [],
                    [2, 1, 7],
                    [],
                    [],
                    [],
                    [2, 7, 3, 2, 9, 7],
                    [],
                    [1, 4, 11, 1, 0, 4],
                    [3, 8, 0, 11, 9, 4, 11, 10, 9],
                    [4, 11, 9, 11, 10, 9],
                    [],
                    [],
                    [],
                    [5, 3, 1],
                    [],
                    [],
                    [],
                    [2, 5, 8, 2, 1, 5],
                    [],
                    [],
                    [2, 4, 0],
                    [3, 2, 4],
                    [],
                    [0, 9, 1, 8, 10, 5, 8, 11, 10],
                    [3, 4, 0, 3, 10, 4],
                    [5, 8, 10, 8, 11, 10],
                    [],
                    [3, 5, 7],
                    [7, 1, 5],
                    [1, 7, 3, 1, 5, 7],
                    [],
                    [9, 2, 0, 9, 7, 2],
                    [0, 3, 8, 1, 7, 11, 1, 5, 7],
                    [11, 1, 7, 1, 5, 7],
                    [],
                    [9, 1, 0, 5, 3, 2, 5, 7, 3],
                    [8, 2, 5, 8, 0, 2],
                    [2, 5, 3, 5, 7, 3],
                    [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                    [9, 1, 0, 10, 7, 11, 10, 5, 7],
                    [3, 8, 0, 7, 10, 5, 7, 11, 10],
                    [11, 5, 7, 11, 10, 5],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [0, 6, 2],
                    [],
                    [7, 2, 9, 7, 9, 8],
                    [],
                    [],
                    [],
                    [8, 10, 9],
                    [7, 1, 3],
                    [7, 1, 0],
                    [6, 9, 3, 6, 10, 9],
                    [7, 10, 8, 10, 9, 8],
                    [],
                    [6, 0, 4],
                    [],
                    [11, 1, 4, 11, 3, 1],
                    [2, 4, 6],
                    [2, 0, 4, 2, 4, 6],
                    [2, 4, 6],
                    [1, 4, 2, 4, 6, 2],
                    [],
                    [6, 0, 4],
                    [],
                    [2, 11, 3, 6, 9, 4, 6, 10, 9],
                    [8, 6, 1, 8, 1, 3],
                    [10, 0, 6, 0, 4, 6],
                    [8, 0, 3, 9, 6, 10, 9, 4, 6],
                    [10, 4, 6, 10, 9, 4],
                    [],
                    [],
                    [],
                    [5, 3, 1],
                    [],
                    [0, 6, 2],
                    [],
                    [7, 4, 8, 5, 2, 1, 5, 6, 2],
                    [],
                    [],
                    [2, 4, 0],
                    [7, 4, 8, 2, 11, 3, 10, 5, 6],
                    [7, 1, 3],
                    [5, 6, 10, 0, 9, 1, 8, 7, 4],
                    [5, 6, 10, 7, 0, 3, 7, 4, 0],
                    [10, 5, 6, 4, 8, 7],
                    [9, 11, 8],
                    [3, 5, 6],
                    [0, 5, 11, 0, 11, 8],
                    [6, 3, 5, 3, 1, 5],
                    [3, 9, 6, 3, 8, 9],
                    [9, 6, 0, 6, 2, 0],
                    [0, 3, 8, 2, 5, 6, 2, 1, 5],
                    [1, 6, 2, 1, 5, 6],
                    [9, 11, 8],
                    [1, 0, 9, 6, 10, 5, 11, 3, 2],
                    [6, 10, 5, 2, 8, 0, 2, 11, 8],
                    [3, 2, 11, 10, 5, 6],
                    [10, 5, 6, 9, 3, 8, 9, 1, 3],
                    [0, 9, 1, 5, 6, 10],
                    [8, 0, 3, 10, 5, 6],
                    [10, 5, 6],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [1, 10, 2, 9, 11, 6, 9, 8, 11],
                    [],
                    [],
                    [6, 0, 2],
                    [3, 6, 9, 3, 2, 6],
                    [3, 5, 1],
                    [0, 5, 1, 0, 11, 5],
                    [0, 3, 5],
                    [6, 9, 11, 9, 8, 11],
                    [],
                    [],
                    [],
                    [4, 5, 9, 7, 1, 10, 7, 3, 1],
                    [],
                    [11, 6, 7, 2, 4, 5, 2, 0, 4],
                    [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                    [6, 7, 11, 1, 10, 2, 9, 4, 5],
                    [],
                    [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                    [9, 4, 5, 0, 6, 7, 0, 2, 6],
                    [4, 5, 9, 6, 3, 2, 6, 7, 3],
                    [6, 7, 11, 5, 3, 8, 5, 1, 3],
                    [6, 7, 11, 4, 1, 0, 4, 5, 1],
                    [4, 5, 9, 3, 8, 0, 11, 6, 7],
                    [9, 4, 5, 7, 11, 6],
                    [],
                    [],
                    [0, 6, 4],
                    [8, 6, 4, 8, 1, 6],
                    [],
                    [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                    [10, 2, 1, 6, 0, 3, 6, 4, 0],
                    [10, 2, 1, 11, 4, 8, 11, 6, 4],
                    [4, 2, 6],
                    [1, 0, 9, 2, 4, 8, 2, 6, 4],
                    [2, 4, 0, 2, 6, 4],
                    [8, 2, 4, 2, 6, 4],
                    [11, 4, 1, 11, 6, 4],
                    [0, 9, 1, 4, 11, 6, 4, 8, 11],
                    [3, 6, 0, 6, 4, 0],
                    [8, 6, 4, 8, 11, 6],
                    [10, 8, 9],
                    [6, 3, 9, 6, 7, 3],
                    [6, 7, 1],
                    [10, 7, 1, 7, 3, 1],
                    [7, 11, 6, 8, 10, 2, 8, 9, 10],
                    [11, 6, 7, 10, 0, 9, 10, 2, 0],
                    [2, 1, 10, 7, 11, 6, 8, 0, 3],
                    [1, 10, 2, 6, 7, 11],
                    [7, 2, 6, 7, 9, 2],
                    [1, 0, 9, 3, 6, 7, 3, 2, 6],
                    [7, 0, 6, 0, 2, 6],
                    [2, 7, 3, 2, 6, 7],
                    [7, 11, 6, 3, 9, 1, 3, 8, 9],
                    [9, 1, 0, 11, 6, 7],
                    [0, 3, 8, 11, 6, 7],
                    [11, 6, 7],
                    [],
                    [],
                    [],
                    [],
                    [5, 3, 7],
                    [8, 5, 2, 8, 7, 5],
                    [5, 3, 7],
                    [1, 10, 2, 5, 8, 7, 5, 9, 8],
                    [1, 7, 5],
                    [1, 7, 5],
                    [9, 2, 7, 9, 7, 5],
                    [11, 3, 2, 8, 5, 9, 8, 7, 5],
                    [1, 3, 7, 1, 7, 5],
                    [0, 7, 1, 7, 5, 1],
                    [9, 3, 5, 3, 7, 5],
                    [9, 7, 5, 9, 8, 7],
                    [8, 10, 11],
                    [3, 4, 10, 3, 10, 11],
                    [8, 10, 11],
                    [5, 9, 4, 1, 11, 3, 1, 10, 11],
                    [2, 4, 5],
                    [5, 2, 4, 2, 0, 4],
                    [0, 3, 8, 5, 9, 4, 10, 2, 1],
                    [2, 1, 10, 9, 4, 5],
                    [2, 8, 5, 2, 11, 8],
                    [3, 2, 11, 1, 4, 5, 1, 0, 4],
                    [9, 4, 5, 8, 2, 11, 8, 0, 2],
                    [11, 3, 2, 9, 4, 5],
                    [8, 5, 3, 5, 1, 3],
                    [5, 0, 4, 5, 1, 0],
                    [3, 8, 0, 4, 5, 9],
                    [9, 4, 5],
                    [11, 9, 10],
                    [11, 9, 10],
                    [1, 11, 4, 1, 10, 11],
                    [8, 7, 4, 11, 1, 10, 11, 3, 1],
                    [2, 7, 9, 2, 9, 10],
                    [4, 8, 7, 0, 10, 2, 0, 9, 10],
                    [2, 1, 10, 0, 7, 4, 0, 3, 7],
                    [10, 2, 1, 8, 7, 4],
                    [1, 7, 4],
                    [3, 2, 11, 4, 8, 7, 9, 1, 0],
                    [11, 4, 2, 4, 0, 2],
                    [2, 11, 3, 7, 4, 8],
                    [4, 1, 7, 1, 3, 7],
                    [1, 0, 9, 8, 7, 4],
                    [3, 4, 0, 3, 7, 4],
                    [8, 7, 4],
                    [8, 9, 10, 8, 10, 11],
                    [3, 9, 11, 9, 10, 11],
                    [0, 10, 8, 10, 11, 8],
                    [10, 3, 1, 10, 11, 3],
                    [2, 8, 10, 8, 9, 10],
                    [9, 2, 0, 9, 10, 2],
                    [8, 0, 3, 1, 10, 2],
                    [10, 2, 1],
                    [1, 11, 9, 11, 8, 9],
                    [11, 3, 2, 0, 9, 1],
                    [11, 0, 2, 11, 8, 0],
                    [11, 3, 2],
                    [8, 1, 3, 8, 9, 1],
                    [9, 1, 0],
                    [8, 0, 3],
                    []
                  ];
                  this.edgeTable2 = [
                    0,
                    265,
                    515,
                    778,
                    2060,
                    2309,
                    2575,
                    2822,
                    1030,
                    1295,
                    1541,
                    1804,
                    3082,
                    3331,
                    3593,
                    3840,
                    400,
                    153,
                    915,
                    666,
                    2460,
                    2197,
                    2975,
                    2710,
                    1430,
                    1183,
                    1941,
                    1692,
                    3482,
                    3219,
                    3993,
                    3728,
                    560,
                    825,
                    51,
                    314,
                    2620,
                    2869,
                    2111,
                    2358,
                    1590,
                    1855,
                    1077,
                    1340,
                    3642,
                    3891,
                    3129,
                    3376,
                    928,
                    681,
                    419,
                    170,
                    2988,
                    2725,
                    2479,
                    2214,
                    1958,
                    1711,
                    1445,
                    1196,
                    4010,
                    3747,
                    3497,
                    3232,
                    2240,
                    2505,
                    2755,
                    3018,
                    204,
                    453,
                    719,
                    966,
                    3270,
                    3535,
                    3781,
                    4044,
                    1226,
                    1475,
                    1737,
                    1984,
                    2384,
                    2137,
                    2899,
                    2650,
                    348,
                    85,
                    863,
                    598,
                    3414,
                    3167,
                    3925,
                    3676,
                    1370,
                    1107,
                    1881,
                    1616,
                    2800,
                    3065,
                    2291,
                    2554,
                    764,
                    1013,
                    255,
                    502,
                    3830,
                    4095,
                    3317,
                    3580,
                    1786,
                    2035,
                    1273,
                    1520,
                    2912,
                    2665,
                    2403,
                    2154,
                    876,
                    613,
                    367,
                    102,
                    3942,
                    3695,
                    3429,
                    3180,
                    1898,
                    1635,
                    1385,
                    1120,
                    1120,
                    1385,
                    1635,
                    1898,
                    3180,
                    3429,
                    3695,
                    3942,
                    102,
                    367,
                    613,
                    876,
                    2154,
                    2403,
                    2665,
                    2912,
                    1520,
                    1273,
                    2035,
                    1786,
                    3580,
                    3317,
                    4095,
                    3830,
                    502,
                    255,
                    1013,
                    764,
                    2554,
                    2291,
                    3065,
                    2800,
                    1616,
                    1881,
                    1107,
                    1370,
                    3676,
                    3925,
                    3167,
                    3414,
                    598,
                    863,
                    85,
                    348,
                    2650,
                    2899,
                    2137,
                    2384,
                    1984,
                    1737,
                    1475,
                    1226,
                    4044,
                    3781,
                    3535,
                    3270,
                    966,
                    719,
                    453,
                    204,
                    3018,
                    2755,
                    2505,
                    2240,
                    3232,
                    3497,
                    3747,
                    4010,
                    1196,
                    1445,
                    1711,
                    1958,
                    2214,
                    2479,
                    2725,
                    2988,
                    170,
                    419,
                    681,
                    928,
                    3376,
                    3129,
                    3891,
                    3642,
                    1340,
                    1077,
                    1855,
                    1590,
                    2358,
                    2111,
                    2869,
                    2620,
                    314,
                    51,
                    825,
                    560,
                    3728,
                    3993,
                    3219,
                    3482,
                    1692,
                    1941,
                    1183,
                    1430,
                    2710,
                    2975,
                    2197,
                    2460,
                    666,
                    915,
                    153,
                    400,
                    3840,
                    3593,
                    3331,
                    3082,
                    1804,
                    1541,
                    1295,
                    1030,
                    2822,
                    2575,
                    2309,
                    2060,
                    778,
                    515,
                    265,
                    0
                  ];
                  this.triTable2 = [
                    [],
                    [8, 3, 0],
                    [9, 0, 1],
                    [8, 3, 1, 8, 1, 9],
                    [11, 2, 3],
                    [11, 2, 0, 11, 0, 8],
                    [11, 2, 3, 0, 1, 9],
                    [2, 1, 11, 1, 9, 11, 11, 9, 8],
                    [10, 1, 2],
                    [8, 3, 0, 1, 2, 10],
                    [9, 0, 2, 9, 2, 10],
                    [3, 2, 8, 2, 10, 8, 8, 10, 9],
                    [10, 1, 3, 10, 3, 11],
                    [1, 0, 10, 0, 8, 10, 10, 8, 11],
                    [0, 3, 9, 3, 11, 9, 9, 11, 10],
                    [8, 10, 9, 8, 11, 10],
                    [8, 4, 7],
                    [3, 0, 4, 3, 4, 7],
                    [1, 9, 0, 8, 4, 7],
                    [9, 4, 1, 4, 7, 1, 1, 7, 3],
                    [2, 3, 11, 7, 8, 4],
                    [7, 11, 4, 11, 2, 4, 4, 2, 0],
                    [3, 11, 2, 4, 7, 8, 9, 0, 1],
                    [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4],
                    [10, 1, 2, 8, 4, 7],
                    [2, 10, 1, 0, 4, 7, 0, 7, 3],
                    [4, 7, 8, 0, 2, 10, 0, 10, 9],
                    [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],
                    [8, 4, 7, 11, 10, 1, 11, 1, 3],
                    [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],
                    [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],
                    [7, 11, 4, 4, 11, 9, 11, 10, 9],
                    [9, 5, 4],
                    [3, 0, 8, 4, 9, 5],
                    [5, 4, 0, 5, 0, 1],
                    [4, 8, 5, 8, 3, 5, 5, 3, 1],
                    [11, 2, 3, 9, 5, 4],
                    [9, 5, 4, 8, 11, 2, 8, 2, 0],
                    [3, 11, 2, 1, 5, 4, 1, 4, 0],
                    [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5],
                    [2, 10, 1, 9, 5, 4],
                    [0, 8, 3, 5, 4, 9, 10, 1, 2],
                    [10, 5, 2, 5, 4, 2, 2, 4, 0],
                    [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],
                    [5, 4, 9, 1, 3, 11, 1, 11, 10],
                    [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],
                    [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],
                    [4, 8, 5, 5, 8, 10, 8, 11, 10],
                    [9, 5, 7, 9, 7, 8],
                    [0, 9, 3, 9, 5, 3, 3, 5, 7],
                    [8, 0, 7, 0, 1, 7, 7, 1, 5],
                    [1, 7, 3, 1, 5, 7],
                    [11, 2, 3, 8, 9, 5, 8, 5, 7],
                    [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],
                    [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],
                    [2, 1, 11, 11, 1, 7, 1, 5, 7],
                    [1, 2, 10, 5, 7, 8, 5, 8, 9],
                    [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],
                    [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],
                    [10, 5, 2, 2, 5, 3, 5, 7, 3],
                    [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                    [9, 1, 0, 10, 7, 11, 10, 5, 7],
                    [3, 8, 0, 7, 10, 5, 7, 11, 10],
                    [11, 5, 7, 11, 10, 5],
                    [11, 7, 6],
                    [0, 8, 3, 11, 7, 6],
                    [9, 0, 1, 11, 7, 6],
                    [7, 6, 11, 3, 1, 9, 3, 9, 8],
                    [2, 3, 7, 2, 7, 6],
                    [8, 7, 0, 7, 6, 0, 0, 6, 2],
                    [1, 9, 0, 3, 7, 6, 3, 6, 2],
                    [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],
                    [1, 2, 10, 6, 11, 7],
                    [2, 10, 1, 7, 6, 11, 8, 3, 0],
                    [11, 7, 6, 10, 9, 0, 10, 0, 2],
                    [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],
                    [6, 10, 7, 10, 1, 7, 7, 1, 3],
                    [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],
                    [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],
                    [6, 10, 7, 7, 10, 8, 10, 9, 8],
                    [8, 4, 6, 8, 6, 11],
                    [11, 3, 6, 3, 0, 6, 6, 0, 4],
                    [0, 1, 9, 4, 6, 11, 4, 11, 8],
                    [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],
                    [3, 8, 2, 8, 4, 2, 2, 4, 6],
                    [2, 0, 4, 2, 4, 6],
                    [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6],
                    [9, 4, 1, 1, 4, 2, 4, 6, 2],
                    [10, 1, 2, 11, 8, 4, 11, 4, 6],
                    [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],
                    [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],
                    [2, 11, 3, 6, 9, 4, 6, 10, 9],
                    [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],
                    [1, 0, 10, 10, 0, 6, 0, 4, 6],
                    [8, 0, 3, 9, 6, 10, 9, 4, 6],
                    [10, 4, 6, 10, 9, 4],
                    [9, 5, 4, 7, 6, 11],
                    [4, 9, 5, 3, 0, 8, 11, 7, 6],
                    [6, 11, 7, 4, 0, 1, 4, 1, 5],
                    [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1],
                    [4, 9, 5, 6, 2, 3, 6, 3, 7],
                    [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],
                    [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3],
                    [7, 4, 8, 5, 2, 1, 5, 6, 2],
                    [6, 11, 7, 1, 2, 10, 9, 5, 4],
                    [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],
                    [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],
                    [7, 4, 8, 2, 11, 3, 10, 5, 6],
                    [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],
                    [5, 6, 10, 0, 9, 1, 8, 7, 4],
                    [5, 6, 10, 7, 0, 3, 7, 4, 0],
                    [10, 5, 6, 4, 8, 7],
                    [5, 6, 9, 6, 11, 9, 9, 11, 8],
                    [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],
                    [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],
                    [11, 3, 6, 6, 3, 5, 3, 1, 5],
                    [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],
                    [5, 6, 9, 9, 6, 0, 6, 2, 0],
                    [0, 3, 8, 2, 5, 6, 2, 1, 5],
                    [1, 6, 2, 1, 5, 6],
                    [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],
                    [1, 0, 9, 6, 10, 5, 11, 3, 2],
                    [6, 10, 5, 2, 8, 0, 2, 11, 8],
                    [3, 2, 11, 10, 5, 6],
                    [10, 5, 6, 9, 3, 8, 9, 1, 3],
                    [0, 9, 1, 5, 6, 10],
                    [8, 0, 3, 10, 5, 6],
                    [10, 5, 6],
                    [10, 6, 5],
                    [8, 3, 0, 10, 6, 5],
                    [0, 1, 9, 5, 10, 6],
                    [10, 6, 5, 9, 8, 3, 9, 3, 1],
                    [3, 11, 2, 10, 6, 5],
                    [6, 5, 10, 2, 0, 8, 2, 8, 11],
                    [1, 9, 0, 6, 5, 10, 11, 2, 3],
                    [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11],
                    [1, 2, 6, 1, 6, 5],
                    [0, 8, 3, 2, 6, 5, 2, 5, 1],
                    [5, 9, 6, 9, 0, 6, 6, 0, 2],
                    [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6],
                    [11, 6, 3, 6, 5, 3, 3, 5, 1],
                    [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],
                    [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],
                    [5, 9, 6, 6, 9, 11, 9, 8, 11],
                    [10, 6, 5, 4, 7, 8],
                    [5, 10, 6, 7, 3, 0, 7, 0, 4],
                    [5, 10, 6, 0, 1, 9, 8, 4, 7],
                    [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],
                    [7, 8, 4, 2, 3, 11, 10, 6, 5],
                    [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],
                    [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                    [6, 7, 11, 1, 10, 2, 9, 4, 5],
                    [7, 8, 4, 5, 1, 2, 5, 2, 6],
                    [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                    [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6],
                    [4, 5, 9, 6, 3, 2, 6, 7, 3],
                    [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],
                    [6, 7, 11, 4, 1, 0, 4, 5, 1],
                    [4, 5, 9, 3, 8, 0, 11, 6, 7],
                    [9, 4, 5, 7, 11, 6],
                    [10, 6, 4, 10, 4, 9],
                    [8, 3, 0, 9, 10, 6, 9, 6, 4],
                    [1, 10, 0, 10, 6, 0, 0, 6, 4],
                    [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],
                    [2, 3, 11, 6, 4, 9, 6, 9, 10],
                    [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                    [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],
                    [10, 2, 1, 11, 4, 8, 11, 6, 4],
                    [9, 1, 4, 1, 2, 4, 4, 2, 6],
                    [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4],
                    [2, 4, 0, 2, 6, 4],
                    [3, 2, 8, 8, 2, 4, 2, 6, 4],
                    [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],
                    [0, 9, 1, 4, 11, 6, 4, 8, 11],
                    [11, 6, 3, 3, 6, 0, 6, 4, 0],
                    [8, 6, 4, 8, 11, 6],
                    [6, 7, 10, 7, 8, 10, 10, 8, 9],
                    [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],
                    [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],
                    [6, 7, 10, 10, 7, 1, 7, 3, 1],
                    [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],
                    [11, 6, 7, 10, 0, 9, 10, 2, 0],
                    [2, 1, 10, 7, 11, 6, 8, 0, 3],
                    [1, 10, 2, 6, 7, 11],
                    [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],
                    [1, 0, 9, 3, 6, 7, 3, 2, 6],
                    [8, 0, 7, 7, 0, 6, 0, 2, 6],
                    [2, 7, 3, 2, 6, 7],
                    [7, 11, 6, 3, 9, 1, 3, 8, 9],
                    [9, 1, 0, 11, 6, 7],
                    [0, 3, 8, 11, 6, 7],
                    [11, 6, 7],
                    [11, 7, 5, 11, 5, 10],
                    [3, 0, 8, 7, 5, 10, 7, 10, 11],
                    [9, 0, 1, 10, 11, 7, 10, 7, 5],
                    [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],
                    [10, 2, 5, 2, 3, 5, 5, 3, 7],
                    [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],
                    [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],
                    [1, 10, 2, 5, 8, 7, 5, 9, 8],
                    [2, 11, 1, 11, 7, 1, 1, 7, 5],
                    [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],
                    [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],
                    [11, 3, 2, 8, 5, 9, 8, 7, 5],
                    [1, 3, 7, 1, 7, 5],
                    [8, 7, 0, 0, 7, 1, 7, 5, 1],
                    [0, 3, 9, 9, 3, 5, 3, 7, 5],
                    [9, 7, 5, 9, 8, 7],
                    [4, 5, 8, 5, 10, 8, 8, 10, 11],
                    [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],
                    [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],
                    [5, 9, 4, 1, 11, 3, 1, 10, 11],
                    [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],
                    [10, 2, 5, 5, 2, 4, 2, 0, 4],
                    [0, 3, 8, 5, 9, 4, 10, 2, 1],
                    [2, 1, 10, 9, 4, 5],
                    [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],
                    [3, 2, 11, 1, 4, 5, 1, 0, 4],
                    [9, 4, 5, 8, 2, 11, 8, 0, 2],
                    [11, 3, 2, 9, 4, 5],
                    [4, 5, 8, 8, 5, 3, 5, 1, 3],
                    [5, 0, 4, 5, 1, 0],
                    [3, 8, 0, 4, 5, 9],
                    [9, 4, 5],
                    [7, 4, 11, 4, 9, 11, 11, 9, 10],
                    [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],
                    [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],
                    [8, 7, 4, 11, 1, 10, 11, 3, 1],
                    [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],
                    [4, 8, 7, 0, 10, 2, 0, 9, 10],
                    [2, 1, 10, 0, 7, 4, 0, 3, 7],
                    [10, 2, 1, 8, 7, 4],
                    [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],
                    [3, 2, 11, 4, 8, 7, 9, 1, 0],
                    [7, 4, 11, 11, 4, 2, 4, 0, 2],
                    [2, 11, 3, 7, 4, 8],
                    [9, 1, 4, 4, 1, 7, 1, 3, 7],
                    [1, 0, 9, 8, 7, 4],
                    [3, 4, 0, 3, 7, 4],
                    [8, 7, 4],
                    [8, 9, 10, 8, 10, 11],
                    [0, 9, 3, 3, 9, 11, 9, 10, 11],
                    [1, 10, 0, 0, 10, 8, 10, 11, 8],
                    [10, 3, 1, 10, 11, 3],
                    [3, 8, 2, 2, 8, 10, 8, 9, 10],
                    [9, 2, 0, 9, 10, 2],
                    [8, 0, 3, 1, 10, 2],
                    [10, 2, 1],
                    [2, 11, 1, 1, 11, 9, 11, 8, 9],
                    [11, 3, 2, 0, 9, 1],
                    [11, 0, 2, 11, 8, 0],
                    [11, 3, 2],
                    [8, 1, 3, 8, 9, 1],
                    [9, 1, 0],
                    [8, 0, 3],
                    []
                  ];
                }
                march(data, verts, faces, spec) {
                  let fulltable = !!spec.fulltable;
                  let origin = spec.hasOwnProperty("origin") && spec.origin.hasOwnProperty("x") ? spec.origin : { x: 0, y: 0, z: 0 };
                  let voxel = !!spec.voxel;
                  let transform = spec.matrix;
                  let nX = spec.nX || 0;
                  let nY = spec.nY || 0;
                  let nZ = spec.nZ || 0;
                  let scale = spec.scale || 1;
                  let unitCube = null;
                  if (spec.unitCube) {
                    unitCube = spec.unitCube;
                  } else {
                    unitCube = { x: scale, y: scale, z: scale };
                  }
                  let vertnums = new Int32Array(nX * nY * nZ);
                  let i, il;
                  for (i = 0, il = vertnums.length; i < il; ++i)
                    vertnums[i] = -1;
                  let getVertex = function(i2, j, k, code, p1, p2) {
                    let pt = { x: 0, y: 0, z: 0 };
                    let val1 = !!(code & 1 << p1);
                    let val2 = !!(code & 1 << p2);
                    let p = p1;
                    if (!val1 && val2)
                      p = p2;
                    if (p & 1)
                      k++;
                    if (p & 2)
                      j++;
                    if (p & 4)
                      i2++;
                    if (transform) {
                      let vpt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(i2, j, k);
                      vpt = vpt.applyMatrix4(transform);
                      pt = { x: vpt.x, y: vpt.y, z: vpt.z };
                    } else {
                      pt.x = origin.x + unitCube.x * i2;
                      pt.y = origin.y + unitCube.y * j;
                      pt.z = origin.z + unitCube.z * k;
                    }
                    let index = (nY * i2 + j) * nZ + k;
                    if (!voxel) {
                      if (vertnums[index] < 0) {
                        vertnums[index] = verts.length;
                        verts.push(pt);
                      }
                      return vertnums[index];
                    } else {
                      verts.push(pt);
                      return verts.length - 1;
                    }
                  };
                  let intersects = new Int32Array(12);
                  let etable = fulltable ? this.edgeTable2 : this.edgeTable;
                  let tritable = fulltable ? this.triTable2 : this.triTable;
                  for (i = 0; i < nX - 1; ++i) {
                    for (let j = 0; j < nY - 1; ++j) {
                      for (let k = 0; k < nZ - 1; ++k) {
                        let code = 0;
                        for (let p = 0; p < 8; ++p) {
                          let index = (nY * (i + ((p & 4) >> 2)) + j + ((p & 2) >> 1)) * nZ + k + (p & 1);
                          let val = !!(data[index] & this.ISDONE);
                          code |= val << p;
                        }
                        if (code === 0 || code === 255)
                          continue;
                        let ecode = etable[code];
                        if (ecode === 0)
                          continue;
                        let ttable = tritable[code];
                        if (ecode & 1)
                          intersects[0] = getVertex(i, j, k, code, 0, 1);
                        if (ecode & 2)
                          intersects[1] = getVertex(i, j, k, code, 1, 3);
                        if (ecode & 4)
                          intersects[2] = getVertex(i, j, k, code, 3, 2);
                        if (ecode & 8)
                          intersects[3] = getVertex(i, j, k, code, 2, 0);
                        if (ecode & 16)
                          intersects[4] = getVertex(i, j, k, code, 4, 5);
                        if (ecode & 32)
                          intersects[5] = getVertex(i, j, k, code, 5, 7);
                        if (ecode & 64)
                          intersects[6] = getVertex(i, j, k, code, 7, 6);
                        if (ecode & 128)
                          intersects[7] = getVertex(i, j, k, code, 6, 4);
                        if (ecode & 256)
                          intersects[8] = getVertex(i, j, k, code, 0, 4);
                        if (ecode & 512)
                          intersects[9] = getVertex(i, j, k, code, 1, 5);
                        if (ecode & 1024)
                          intersects[10] = getVertex(i, j, k, code, 3, 7);
                        if (ecode & 2048)
                          intersects[11] = getVertex(i, j, k, code, 2, 6);
                        for (let t = 0; t < ttable.length; t += 3) {
                          let a = intersects[ttable[t]], b = intersects[ttable[t + 1]], c = intersects[ttable[t + 2]];
                          if (voxel && t >= 3) {
                            verts.push(verts[a]);
                            a = verts.length - 1;
                            verts.push(verts[b]);
                            b = verts.length - 1;
                            verts.push(verts[c]);
                            c = verts.length - 1;
                          }
                          faces.push(a);
                          faces.push(b);
                          faces.push(c);
                        }
                      }
                    }
                  }
                }
                laplacianSmooth(numiter, verts, faces) {
                  let tps = new Array(verts.length);
                  let i, il, j, jl, k;
                  for (i = 0, il = verts.length; i < il; i++)
                    tps[i] = {
                      x: 0,
                      y: 0,
                      z: 0
                    };
                  let vertdeg = new Array(20);
                  let flagvert;
                  for (i = 0; i < 20; i++)
                    vertdeg[i] = new Array(verts.length);
                  for (i = 0, il = verts.length; i < il; i++)
                    vertdeg[0][i] = 0;
                  for (i = 0, il = faces.length / 3; i < il; i++) {
                    let aoffset = i * 3, boffset = i * 3 + 1, coffset = i * 3 + 2;
                    flagvert = true;
                    for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                      if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[aoffset]]++;
                      vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];
                    }
                    flagvert = true;
                    for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                      if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[aoffset]]++;
                      vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];
                    }
                    flagvert = true;
                    for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                      if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[boffset]]++;
                      vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];
                    }
                    flagvert = true;
                    for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                      if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[boffset]]++;
                      vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];
                    }
                    flagvert = true;
                    for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {
                      if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[coffset]]++;
                      vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];
                    }
                    flagvert = true;
                    for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {
                      if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {
                        flagvert = false;
                        break;
                      }
                    }
                    if (flagvert) {
                      vertdeg[0][faces[coffset]]++;
                      vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];
                    }
                  }
                  let wt = 1;
                  let wt2 = 0.5;
                  for (k = 0; k < numiter; k++) {
                    for (i = 0, il = verts.length; i < il; i++) {
                      if (vertdeg[0][i] < 3) {
                        tps[i].x = verts[i].x;
                        tps[i].y = verts[i].y;
                        tps[i].z = verts[i].z;
                      } else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {
                        tps[i].x = 0;
                        tps[i].y = 0;
                        tps[i].z = 0;
                        for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                          tps[i].x += verts[vertdeg[j + 1][i]].x;
                          tps[i].y += verts[vertdeg[j + 1][i]].y;
                          tps[i].z += verts[vertdeg[j + 1][i]].z;
                        }
                        tps[i].x += wt2 * verts[i].x;
                        tps[i].y += wt2 * verts[i].y;
                        tps[i].z += wt2 * verts[i].z;
                        tps[i].x /= wt2 + vertdeg[0][i];
                        tps[i].y /= wt2 + vertdeg[0][i];
                        tps[i].z /= wt2 + vertdeg[0][i];
                      } else {
                        tps[i].x = 0;
                        tps[i].y = 0;
                        tps[i].z = 0;
                        for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                          tps[i].x += verts[vertdeg[j + 1][i]].x;
                          tps[i].y += verts[vertdeg[j + 1][i]].y;
                          tps[i].z += verts[vertdeg[j + 1][i]].z;
                        }
                        tps[i].x += wt * verts[i].x;
                        tps[i].y += wt * verts[i].y;
                        tps[i].z += wt * verts[i].z;
                        tps[i].x /= wt + vertdeg[0][i];
                        tps[i].y /= wt + vertdeg[0][i];
                        tps[i].z /= wt + vertdeg[0][i];
                      }
                    }
                    for (i = 0, il = verts.length; i < il; i++) {
                      verts[i].x = tps[i].x;
                      verts[i].y = tps[i].y;
                      verts[i].z = tps[i].z;
                    }
                  }
                }
              }
              ;
              let MarchingCube = new MarchingCubeInitializer();
              class PointGrid {
                constructor(length, width, height) {
                  this.data = new Int32Array(length * width * height * 3);
                  this.width = width;
                  this.height = height;
                }
                // set position x,y,z to pt, which has ix,iy,and iz
                set(x, y, z, pt) {
                  let index = ((x * this.width + y) * this.height + z) * 3;
                  this.data[index] = pt.ix;
                  this.data[index + 1] = pt.iy;
                  this.data[index + 2] = pt.iz;
                }
                // return point at x,y,z
                get(x, y, z) {
                  let index = ((x * this.width + y) * this.height + z) * 3;
                  return {
                    ix: this.data[index],
                    iy: this.data[index + 1],
                    iz: this.data[index + 2]
                  };
                }
              }
              ;
              class ProteinSurface2 {
                constructor() {
                  this.INOUT = 1;
                  this.ISDONE = 2;
                  this.ISBOUND = 4;
                  this.ptranx = 0;
                  this.ptrany = 0;
                  this.ptranz = 0;
                  this.probeRadius = 1.4;
                  this.defaultScaleFactor = 2;
                  this.scaleFactor = this.defaultScaleFactor;
                  this.pHeight = 0;
                  this.pWidth = 0;
                  this.pLength = 0;
                  this.cutRadius = 0;
                  this.vpBits = null;
                  this.vpDistance = null;
                  this.vpAtomID = null;
                  this.pminx = 0;
                  this.pminy = 0;
                  this.pminz = 0;
                  this.pmaxx = 0;
                  this.pmaxy = 0;
                  this.pmaxz = 0;
                  this.depty = {};
                  this.widxz = {};
                  this.faces = [];
                  this.verts = [];
                  this.vdwRadii = {
                    "H": 1.2,
                    "Li": 1.82,
                    "Na": 2.27,
                    "K": 2.75,
                    "C": 1.7,
                    "N": 1.55,
                    "O": 1.52,
                    "F": 1.47,
                    "P": 1.8,
                    "S": 1.8,
                    "CL": 1.75,
                    "BR": 1.85,
                    "SE": 1.9,
                    "ZN": 1.39,
                    "CU": 1.4,
                    "NI": 1.63,
                    "X": 2
                  };
                  this.nb = [
                    new Int32Array([1, 0, 0]),
                    new Int32Array([-1, 0, 0]),
                    new Int32Array([0, 1, 0]),
                    new Int32Array([0, -1, 0]),
                    new Int32Array([0, 0, 1]),
                    new Int32Array([0, 0, -1]),
                    new Int32Array([1, 1, 0]),
                    new Int32Array([1, -1, 0]),
                    new Int32Array([-1, 1, 0]),
                    new Int32Array([-1, -1, 0]),
                    new Int32Array([1, 0, 1]),
                    new Int32Array([1, 0, -1]),
                    new Int32Array([-1, 0, 1]),
                    new Int32Array([-1, 0, -1]),
                    new Int32Array([0, 1, 1]),
                    new Int32Array([0, 1, -1]),
                    new Int32Array([0, -1, 1]),
                    new Int32Array([0, -1, -1]),
                    new Int32Array([1, 1, 1]),
                    new Int32Array([1, 1, -1]),
                    new Int32Array([1, -1, 1]),
                    new Int32Array([-1, 1, 1]),
                    new Int32Array([1, -1, -1]),
                    new Int32Array([-1, -1, 1]),
                    new Int32Array([-1, 1, -1]),
                    new Int32Array([-1, -1, -1])
                  ];
                  if (!ProteinSurface2.MarchingCube) {
                    ProteinSurface2.MarchingCube = new MarchingCubeInitializer();
                  }
                }
                getVDWIndex(atom) {
                  if (!atom.elem || typeof this.vdwRadii[atom.elem] == "undefined") {
                    return "X";
                  }
                  return atom.elem;
                }
                getFacesAndVertices(atomlist) {
                  let atomsToShow = {};
                  for (let i = 0, il = atomlist.length; i < il; i++)
                    atomsToShow[atomlist[i]] = true;
                  let vertices = this.verts;
                  for (let i = 0, il = vertices.length; i < il; i++) {
                    vertices[i].x = vertices[i].x / this.scaleFactor - this.ptranx;
                    vertices[i].y = vertices[i].y / this.scaleFactor - this.ptrany;
                    vertices[i].z = vertices[i].z / this.scaleFactor - this.ptranz;
                  }
                  let finalfaces = [];
                  for (let i = 0, il = this.faces.length; i < il; i += 3) {
                    let fa = this.faces[i], fb = this.faces[i + 1], fc = this.faces[i + 2];
                    let a = vertices[fa].atomid, b = vertices[fb].atomid, c = vertices[fc].atomid;
                    let which = a;
                    if (b < which)
                      which = b;
                    if (c < which)
                      which = c;
                    if (!atomsToShow[which]) {
                      continue;
                    }
                    if (fa !== fb && fb !== fc && fa !== fc) {
                      finalfaces.push(fa);
                      finalfaces.push(fb);
                      finalfaces.push(fc);
                    }
                  }
                  this.vpBits = null;
                  this.vpDistance = null;
                  this.vpAtomID = null;
                  return {
                    "vertices": vertices,
                    "faces": finalfaces
                  };
                }
                initparm(extent, btype, volume) {
                  if (volume > 1e6)
                    this.scaleFactor = this.defaultScaleFactor / 2;
                  let margin = 1 / this.scaleFactor * 5.5;
                  this.pminx = extent[0][0];
                  this.pmaxx = extent[1][0];
                  this.pminy = extent[0][1];
                  this.pmaxy = extent[1][1];
                  this.pminz = extent[0][2];
                  this.pmaxz = extent[1][2];
                  if (!btype) {
                    this.pminx -= margin;
                    this.pminy -= margin;
                    this.pminz -= margin;
                    this.pmaxx += margin;
                    this.pmaxy += margin;
                    this.pmaxz += margin;
                  } else {
                    this.pminx -= this.probeRadius + margin;
                    this.pminy -= this.probeRadius + margin;
                    this.pminz -= this.probeRadius + margin;
                    this.pmaxx += this.probeRadius + margin;
                    this.pmaxy += this.probeRadius + margin;
                    this.pmaxz += this.probeRadius + margin;
                  }
                  this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor;
                  this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor;
                  this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor;
                  this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor;
                  this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor;
                  this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor;
                  this.ptranx = -this.pminx;
                  this.ptrany = -this.pminy;
                  this.ptranz = -this.pminz;
                  this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1;
                  this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1;
                  this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1;
                  this.boundingatom(btype);
                  this.cutRadius = this.probeRadius * this.scaleFactor;
                  this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight);
                  this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight);
                  this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);
                }
                boundingatom(btype) {
                  let tradius = {};
                  for (const i in this.vdwRadii) {
                    let r = this.vdwRadii[i];
                    if (!btype)
                      tradius[i] = r * this.scaleFactor + 0.5;
                    else
                      tradius[i] = (r + this.probeRadius) * this.scaleFactor + 0.5;
                    let sradius = tradius[i] * tradius[i];
                    this.widxz[i] = Math.floor(tradius[i]) + 1;
                    this.depty[i] = new Int32Array(this.widxz[i] * this.widxz[i]);
                    let indx = 0;
                    for (let j = 0; j < this.widxz[i]; j++) {
                      for (let k = 0; k < this.widxz[i]; k++) {
                        let txz = j * j + k * k;
                        if (txz > sradius)
                          this.depty[i][indx] = -1;
                        else {
                          let tdept = Math.sqrt(sradius - txz);
                          this.depty[i][indx] = Math.floor(tdept);
                        }
                        indx++;
                      }
                    }
                  }
                }
                fillvoxels(atoms, atomlist) {
                  for (let i = 0, il = this.vpBits.length; i < il; i++) {
                    this.vpBits[i] = 0;
                    this.vpDistance[i] = -1;
                    this.vpAtomID[i] = -1;
                  }
                  for (let i in atomlist) {
                    let atom = atoms[atomlist[i]];
                    if (atom === void 0)
                      continue;
                    this.fillAtom(atom, atoms);
                  }
                  for (let i = 0, il = this.vpBits.length; i < il; i++)
                    if (this.vpBits[i] & this.INOUT)
                      this.vpBits[i] |= this.ISDONE;
                }
                fillAtom(atom, atoms) {
                  let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));
                  let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));
                  let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));
                  let at = this.getVDWIndex(atom);
                  let nind = 0;
                  let pWH = this.pWidth * this.pHeight;
                  for (let i = 0, n = this.widxz[at]; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                      if (this.depty[at][nind] != -1) {
                        for (let ii = -1; ii < 2; ii++) {
                          for (let jj = -1; jj < 2; jj++) {
                            for (let kk = -1; kk < 2; kk++) {
                              if (ii !== 0 && jj !== 0 && kk !== 0) {
                                let mi = ii * i;
                                let mk = kk * j;
                                for (let k = 0; k <= this.depty[at][nind]; k++) {
                                  let mj = k * jj;
                                  let si = cx + mi;
                                  let sj = cy + mj;
                                  let sk = cz + mk;
                                  if (si < 0 || sj < 0 || sk < 0 || si >= this.pLength || sj >= this.pWidth || sk >= this.pHeight)
                                    continue;
                                  let index = si * pWH + sj * this.pHeight + sk;
                                  if (!(this.vpBits[index] & this.INOUT)) {
                                    this.vpBits[index] |= this.INOUT;
                                    this.vpAtomID[index] = atom.serial;
                                  } else {
                                    let atom2 = atoms[this.vpAtomID[index]];
                                    if (atom2.serial != atom.serial) {
                                      let ox = cx + mi - Math.floor(0.5 + this.scaleFactor * (atom2.x + this.ptranx));
                                      let oy = cy + mj - Math.floor(0.5 + this.scaleFactor * (atom2.y + this.ptrany));
                                      let oz = cz + mk - Math.floor(0.5 + this.scaleFactor * (atom2.z + this.ptranz));
                                      if (mi * mi + mj * mj + mk * mk < ox * ox + oy * oy + oz * oz)
                                        this.vpAtomID[index] = atom.serial;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      nind++;
                    }
                  }
                }
                fillvoxelswaals(atoms, atomlist) {
                  for (let i = 0, il = this.vpBits.length; i < il; i++)
                    this.vpBits[i] &= ~this.ISDONE;
                  for (let i in atomlist) {
                    let atom = atoms[atomlist[i]];
                    if (atom === void 0)
                      continue;
                    this.fillAtomWaals(atom, atoms);
                  }
                }
                fillAtomWaals(atom, atoms) {
                  let nind = 0;
                  let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));
                  let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));
                  let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));
                  let at = this.getVDWIndex(atom);
                  let pWH = this.pWidth * this.pHeight;
                  for (let i = 0, n = this.widxz[at]; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                      if (this.depty[at][nind] != -1) {
                        for (let ii = -1; ii < 2; ii++) {
                          for (let jj = -1; jj < 2; jj++) {
                            for (let kk = -1; kk < 2; kk++) {
                              if (ii !== 0 && jj !== 0 && kk !== 0) {
                                let mi = ii * i;
                                let mk = kk * j;
                                for (let k = 0; k <= this.depty[at][nind]; k++) {
                                  let mj = k * jj;
                                  let si = cx + mi;
                                  let sj = cy + mj;
                                  let sk = cz + mk;
                                  if (si < 0 || sj < 0 || sk < 0 || si >= this.pLength || sj >= this.pWidth || sk >= this.pHeight)
                                    continue;
                                  let index = si * pWH + sj * this.pHeight + sk;
                                  if (!(this.vpBits[index] & this.ISDONE)) {
                                    this.vpBits[index] |= this.ISDONE;
                                    this.vpAtomID[index] = atom.serial;
                                  } else {
                                    let atom2 = atoms[this.vpAtomID[index]];
                                    if (atom2.serial != atom.serial) {
                                      let ox = cx + mi - Math.floor(0.5 + this.scaleFactor * (atom2.x + this.ptranx));
                                      let oy = cy + mj - Math.floor(0.5 + this.scaleFactor * (atom2.y + this.ptrany));
                                      let oz = cz + mk - Math.floor(0.5 + this.scaleFactor * (atom2.z + this.ptranz));
                                      if (mi * mi + mj * mj + mk * mk < ox * ox + oy * oy + oz * oz)
                                        this.vpAtomID[index] = atom.serial;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      nind++;
                    }
                  }
                }
                buildboundary() {
                  let pWH = this.pWidth * this.pHeight;
                  for (let i = 0; i < this.pLength; i++) {
                    for (let j = 0; j < this.pHeight; j++) {
                      for (let k = 0; k < this.pWidth; k++) {
                        let index = i * pWH + k * this.pHeight + j;
                        if (this.vpBits[index] & this.INOUT) {
                          let ii = 0;
                          while (ii < 26) {
                            let ti = i + this.nb[ii][0], tj = j + this.nb[ii][2], tk = k + this.nb[ii][1];
                            if (ti > -1 && ti < this.pLength && tk > -1 && tk < this.pWidth && tj > -1 && tj < this.pHeight && !(this.vpBits[ti * pWH + tk * this.pHeight + tj] & this.INOUT)) {
                              this.vpBits[index] |= this.ISBOUND;
                              break;
                            } else
                              ii++;
                          }
                        }
                      }
                    }
                  }
                }
                fastdistancemap() {
                  let boundPoint = new PointGrid(this.pLength, this.pWidth, this.pHeight);
                  let pWH = this.pWidth * this.pHeight;
                  let cutRSq = this.cutRadius * this.cutRadius;
                  let inarray = [];
                  let outarray = [];
                  let index;
                  for (let i = 0; i < this.pLength; i++) {
                    for (let j = 0; j < this.pWidth; j++) {
                      for (let k = 0; k < this.pHeight; k++) {
                        index = i * pWH + j * this.pHeight + k;
                        this.vpBits[index] &= ~this.ISDONE;
                        if (this.vpBits[index] & this.INOUT) {
                          if (this.vpBits[index] & this.ISBOUND) {
                            let triple = {
                              ix: i,
                              iy: j,
                              iz: k
                            };
                            boundPoint.set(i, j, k, triple);
                            inarray.push(triple);
                            this.vpDistance[index] = 0;
                            this.vpBits[index] |= this.ISDONE;
                            this.vpBits[index] &= ~this.ISBOUND;
                          }
                        }
                      }
                    }
                  }
                  do {
                    outarray = this.fastoneshell(inarray, boundPoint);
                    inarray = [];
                    for (let i = 0, n = outarray.length; i < n; i++) {
                      index = pWH * outarray[i].ix + this.pHeight * outarray[i].iy + outarray[i].iz;
                      this.vpBits[index] &= ~this.ISBOUND;
                      if (this.vpDistance[index] <= 1.0404 * cutRSq) {
                        inarray.push({
                          ix: outarray[i].ix,
                          iy: outarray[i].iy,
                          iz: outarray[i].iz
                        });
                      }
                    }
                  } while (inarray.length !== 0);
                  inarray = [];
                  outarray = [];
                  boundPoint = null;
                  let cutsf = this.scaleFactor - 0.5;
                  if (cutsf < 0)
                    cutsf = 0;
                  let cutoff = cutRSq - 0.5 / (0.1 + cutsf);
                  for (let i = 0; i < this.pLength; i++) {
                    for (let j = 0; j < this.pWidth; j++) {
                      for (let k = 0; k < this.pHeight; k++) {
                        index = i * pWH + j * this.pHeight + k;
                        this.vpBits[index] &= ~this.ISBOUND;
                        if (this.vpBits[index] & this.INOUT) {
                          if (!(this.vpBits[index] & this.ISDONE) || this.vpBits[index] & this.ISDONE && this.vpDistance[index] >= cutoff) {
                            this.vpBits[index] |= this.ISBOUND;
                          }
                        }
                      }
                    }
                  }
                }
                fastoneshell(inarray, boundPoint) {
                  let tx, ty, tz;
                  let dx, dy, dz;
                  let square;
                  let bp, index;
                  let outarray = [];
                  if (inarray.length === 0)
                    return outarray;
                  let tnv = {
                    ix: -1,
                    iy: -1,
                    iz: -1
                  };
                  let pWH = this.pWidth * this.pHeight;
                  for (let i = 0, n = inarray.length; i < n; i++) {
                    tx = inarray[i].ix;
                    ty = inarray[i].iy;
                    tz = inarray[i].iz;
                    bp = boundPoint.get(tx, ty, tz);
                    for (let j = 0; j < 6; j++) {
                      tnv.ix = tx + this.nb[j][0];
                      tnv.iy = ty + this.nb[j][1];
                      tnv.iz = tz + this.nb[j][2];
                      if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth && tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                        index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;
                        if (this.vpBits[index] & this.INOUT && !(this.vpBits[index] & this.ISDONE)) {
                          boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          this.vpDistance[index] = square;
                          this.vpBits[index] |= this.ISDONE;
                          this.vpBits[index] |= this.ISBOUND;
                          outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                          });
                        } else if (this.vpBits[index] & this.INOUT && this.vpBits[index] & this.ISDONE) {
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          if (square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            this.vpDistance[index] = square;
                            if (!(this.vpBits[index] & this.ISBOUND)) {
                              this.vpBits[index] |= this.ISBOUND;
                              outarray.push({
                                ix: tnv.ix,
                                iy: tnv.iy,
                                iz: tnv.iz
                              });
                            }
                          }
                        }
                      }
                    }
                  }
                  for (let i = 0, n = inarray.length; i < n; i++) {
                    tx = inarray[i].ix;
                    ty = inarray[i].iy;
                    tz = inarray[i].iz;
                    bp = boundPoint.get(tx, ty, tz);
                    for (let j = 6; j < 18; j++) {
                      tnv.ix = tx + this.nb[j][0];
                      tnv.iy = ty + this.nb[j][1];
                      tnv.iz = tz + this.nb[j][2];
                      if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth && tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                        index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;
                        if (this.vpBits[index] & this.INOUT && !(this.vpBits[index] & this.ISDONE)) {
                          boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          this.vpDistance[index] = square;
                          this.vpBits[index] |= this.ISDONE;
                          this.vpBits[index] |= this.ISBOUND;
                          outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                          });
                        } else if (this.vpBits[index] & this.INOUT && this.vpBits[index] & this.ISDONE) {
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          if (square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            this.vpDistance[index] = square;
                            if (!(this.vpBits[index] & this.ISBOUND)) {
                              this.vpBits[index] |= this.ISBOUND;
                              outarray.push({
                                ix: tnv.ix,
                                iy: tnv.iy,
                                iz: tnv.iz
                              });
                            }
                          }
                        }
                      }
                    }
                  }
                  for (let i = 0, n = inarray.length; i < n; i++) {
                    tx = inarray[i].ix;
                    ty = inarray[i].iy;
                    tz = inarray[i].iz;
                    bp = boundPoint.get(tx, ty, tz);
                    for (let j = 18; j < 26; j++) {
                      tnv.ix = tx + this.nb[j][0];
                      tnv.iy = ty + this.nb[j][1];
                      tnv.iz = tz + this.nb[j][2];
                      if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth && tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                        index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;
                        if (this.vpBits[index] & this.INOUT && !(this.vpBits[index] & this.ISDONE)) {
                          boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          this.vpDistance[index] = square;
                          this.vpBits[index] |= this.ISDONE;
                          this.vpBits[index] |= this.ISBOUND;
                          outarray.push({
                            ix: tnv.ix,
                            iy: tnv.iy,
                            iz: tnv.iz
                          });
                        } else if (this.vpBits[index] & this.INOUT && this.vpBits[index] & this.ISDONE) {
                          dx = tnv.ix - bp.ix;
                          dy = tnv.iy - bp.iy;
                          dz = tnv.iz - bp.iz;
                          square = dx * dx + dy * dy + dz * dz;
                          if (square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            this.vpDistance[index] = square;
                            if (!(this.vpBits[index] & this.ISBOUND)) {
                              this.vpBits[index] |= this.ISBOUND;
                              outarray.push({
                                ix: tnv.ix,
                                iy: tnv.iy,
                                iz: tnv.iz
                              });
                            }
                          }
                        }
                      }
                    }
                  }
                  return outarray;
                }
                marchingcubeinit(stype) {
                  for (let i = 0, lim = this.vpBits.length; i < lim; i++) {
                    if (stype == 1) {
                      this.vpBits[i] &= ~this.ISBOUND;
                    } else if (stype == 4) {
                      this.vpBits[i] &= ~this.ISDONE;
                      if (this.vpBits[i] & this.ISBOUND)
                        this.vpBits[i] |= this.ISDONE;
                      this.vpBits[i] &= ~this.ISBOUND;
                    } else if (stype == 2) {
                      if (this.vpBits[i] & this.ISBOUND && this.vpBits[i] & this.ISDONE)
                        this.vpBits[i] &= ~this.ISBOUND;
                      else if (this.vpBits[i] & this.ISBOUND && !(this.vpBits[i] & this.ISDONE))
                        this.vpBits[i] |= this.ISDONE;
                    } else if (stype == 3) {
                      this.vpBits[i] &= ~this.ISBOUND;
                    }
                  }
                }
                marchingcube(stype) {
                  this.marchingcubeinit(stype);
                  this.verts = [];
                  this.faces = [];
                  ProteinSurface2.MarchingCube.march(this.vpBits, this.verts, this.faces, {
                    smooth: 1,
                    nX: this.pLength,
                    nY: this.pWidth,
                    nZ: this.pHeight
                  });
                  let pWH = this.pWidth * this.pHeight;
                  for (let i = 0, vlen = this.verts.length; i < vlen; i++) {
                    this.verts[i].atomid = this.vpAtomID[this.verts[i].x * pWH + this.pHeight * this.verts[i].y + this.verts[i].z];
                  }
                  ProteinSurface2.MarchingCube.laplacianSmooth(1, this.verts, this.faces);
                }
              }
              ProteinSurface2.MarchingCube = new MarchingCubeInitializer();
              ;
            },
            /***/
            "./src/SurfaceWorker.js"() {
              $3Dmol.workerString = (function() {
                self.onmessage = function(oEvent) {
                  var obj = oEvent.data;
                  var type = obj.type;
                  if (type < 0) {
                    self.atomData = obj.atoms;
                    self.volume = obj.volume;
                    self.ps = new ProteinSurface();
                  } else {
                    var ps = self.ps;
                    ps.initparm(obj.expandedExtent, type == 1 ? false : true, self.volume);
                    ps.fillvoxels(self.atomData, obj.extendedAtoms);
                    ps.buildboundary();
                    if (type === 4 || type === 2) {
                      ps.fastdistancemap();
                      ps.boundingatom(false);
                      ps.fillvoxelswaals(self.atomData, obj.extendedAtoms);
                    }
                    ps.marchingcube(type);
                    var VandF = ps.getFacesAndVertices(obj.atomsToShow);
                    self.postMessage(VandF);
                  }
                };
              }).toString().replace(/(^.*?\{|\}$)/g, "");
              $3Dmol.workerString += ";\nfunction _classCallCheck() {};";
              $3Dmol.workerString += ";\n" + $3Dmol.Vector3.toString();
              $3Dmol.workerString += ";\n" + $3Dmol.MarchingCubeInitializer.toString() + ";\n\n";
              $3Dmol.workerString += ";\n" + $3Dmol.PointGrid.toString() + ";\n";
              $3Dmol.workerString += ";\nvar ProteinSurface = " + $3Dmol.ProteinSurface.toString() + ";\n";
              $3Dmol.SurfaceWorker = window.URL ? window.URL.createObjectURL(new Blob([$3Dmol.workerString], { type: "text/javascript" })) : void 0;
            },
            /***/
            "./src/VolumeData.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                VolumeData: () => (
                  /* binding */
                  VolumeData
                )
                /* harmony export */
              });
              var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _parsers_VASP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./parsers/VASP */
                "./src/parsers/VASP.ts"
              );
              var _parsers_CUBE__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./parsers/CUBE */
                "./src/parsers/CUBE.ts"
              );
              var pako__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! pako */
                "./node_modules/pako/dist/pako.esm.mjs"
              );
              ;
              class VolumeData {
                constructor(str, format, options) {
                  this.unit = {
                    x: 1,
                    y: 1,
                    z: 1
                  };
                  this.origin = {
                    x: 0,
                    y: 0,
                    z: 0
                  };
                  this.size = {
                    x: 0,
                    y: 0,
                    z: 0
                  };
                  this.data = new Float32Array([]);
                  this.matrix = null;
                  this.inversematrix = null;
                  this.isbinary = /* @__PURE__ */ new Set(["ccp4", "CCP4"]);
                  this.getCoordinates = function(index) {
                    var x = index / (this.size.y * this.size.z);
                    var y = index % (this.size.y * this.size.z);
                    var z = index % this.size.z;
                    x *= this.unit.x;
                    y *= this.unit.y;
                    z *= this.unit.z;
                    x += this.origin.x;
                    y += this.origin.y;
                    z += this.origin.z;
                    return { x, y, z };
                  };
                  this.vasp = function(str2) {
                    var lines = str2.replace(/^\s+/, "").split(/[\n\r]/);
                    var atomicData = (0, _parsers_VASP__WEBPACK_IMPORTED_MODULE_2__.VASP)(str2)[0];
                    var natoms = atomicData.length;
                    if (natoms == 0) {
                      console.warn("No good formating of CHG or CHGCAR file, not atomic information provided in the file.");
                      this.data = [];
                      return;
                    }
                    var l_units = 1.889725992;
                    var e_units = 0.036749309;
                    var convFactor = parseFloat(lines[1]);
                    var v;
                    v = lines[2].replace(/^\s+/, "").split(/\s+/);
                    var xVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);
                    v = lines[3].replace(/^\s+/, "").split(/\s+/);
                    var yVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);
                    v = lines[4].replace(/^\s+/, "").split(/\s+/);
                    var zVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);
                    var vol = xVec.x * (yVec.y * zVec.z - zVec.y * yVec.z) - yVec.x * (xVec.y * zVec.z - zVec.y * xVec.z) + zVec.x * (xVec.y * yVec.z - yVec.y * xVec.z);
                    vol = Math.abs(vol) / Math.pow(l_units, 3);
                    var vol_scale = 1 / vol;
                    lines.splice(0, 2 + 3 + 2 + 1 + natoms + 1);
                    var lineArr = lines[0].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                    var nX = Math.abs(parseFloat(lineArr[0]));
                    var nY = Math.abs(parseFloat(lineArr[1]));
                    var nZ = Math.abs(parseFloat(lineArr[2]));
                    var origin = this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    this.size = { x: nX, y: nY, z: nZ };
                    this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xVec.x, yVec.y, zVec.z);
                    xVec = xVec.multiplyScalar(1 / (l_units * nX));
                    yVec = yVec.multiplyScalar(1 / (l_units * nY));
                    zVec = zVec.multiplyScalar(1 / (l_units * nZ));
                    if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0 || zVec.y != 0) {
                      this.matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0, 0, 0, 1);
                      this.matrix = this.matrix.multiplyMatrices(this.matrix, new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().makeTranslation(origin.x, origin.y, origin.z));
                      this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                      this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                    }
                    lines.splice(0, 1);
                    var raw = lines.join(" ");
                    raw = raw.replace(/^\s+/, "");
                    var rawArray = raw.split(/[\s\r]+/);
                    rawArray.splice(nX * nY * nZ + 1);
                    var preConvertedData = Float32Array.from(rawArray, parseFloat);
                    for (var i = 0; i < preConvertedData.length; i++) {
                      preConvertedData[i] = preConvertedData[i] * vol_scale * e_units;
                    }
                    this.data = preConvertedData;
                  };
                  this.dx = function(str2) {
                    var lines = str2.split(/[\n\r]+/);
                    var m;
                    var recounts = /gridpositions\s+counts\s+(\d+)\s+(\d+)\s+(\d+)/;
                    var reorig = /^origin\s+(\S+)\s+(\S+)\s+(\S+)/;
                    var redelta = /^delta\s+(\S+)\s+(\S+)\s+(\S+)/;
                    var follows = /data follows/;
                    var i = 0;
                    for (i = 0; i < lines.length; i++) {
                      var line = lines[i];
                      if (m = recounts.exec(line)) {
                        var nX = parseInt(m[1]);
                        var nY = parseInt(m[2]);
                        var nZ = parseInt(m[3]);
                        this.size = { x: nX, y: nY, z: nZ };
                      } else if (m = redelta.exec(line)) {
                        var xunit = parseFloat(m[1]);
                        if (parseFloat(m[2]) != 0 || parseFloat(m[3]) != 0) {
                          console.warn("Non-orthogonal delta matrix not currently supported in dx format");
                        }
                        i += 1;
                        line = lines[i];
                        m = redelta.exec(line);
                        if (m == null) {
                          console.error("Parse error in dx delta matrix");
                          return;
                        }
                        var yunit = parseFloat(m[2]);
                        if (parseFloat(m[1]) != 0 || parseFloat(m[3]) != 0) {
                          console.warn("Non-orthogonal delta matrix not currently supported in dx format");
                        }
                        i += 1;
                        line = lines[i];
                        m = redelta.exec(line);
                        if (m == null) {
                          console.error("Parse error in dx delta matrix");
                          return;
                        }
                        var zunit = parseFloat(m[3]);
                        if (parseFloat(m[1]) != 0 || parseFloat(m[2]) != 0) {
                          console.warn("Non-orthogonal delta matrix not currently supported in dx format");
                        }
                        this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xunit, yunit, zunit);
                      } else if (m = reorig.exec(line)) {
                        var xorig = parseFloat(m[1]);
                        var yorig = parseFloat(m[2]);
                        var zorig = parseFloat(m[3]);
                        this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xorig, yorig, zorig);
                      } else if (m = follows.exec(line)) {
                        break;
                      }
                    }
                    i += 1;
                    if (!this.size || !this.origin || !this.unit || !this.size) {
                      console.error("Error parsing dx format");
                      return;
                    }
                    var raw = lines.splice(i).join(" ");
                    var rawArray = raw.split(/[\s\r]+/);
                    this.data = Float32Array.from(rawArray, parseFloat);
                  };
                  format = format.toLowerCase();
                  if (/\.gz$/.test(format)) {
                    format = format.replace(/\.gz$/, "");
                    try {
                      if (this[format] && this.isbinary.has(format)) {
                        if (typeof str == "string") {
                          str = (0, _utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(str);
                        }
                        str = (0, pako__WEBPACK_IMPORTED_MODULE_4__.inflate)(str);
                      } else {
                        str = new TextDecoder("utf-8").decode((0, pako__WEBPACK_IMPORTED_MODULE_4__.inflate)(str));
                      }
                    } catch (err) {
                      console.error(err);
                    }
                  }
                  if (this[format]) {
                    if (this.isbinary.has(format) && typeof str == "string") {
                      str = (0, _utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(str);
                    }
                    this[format](str);
                  }
                  if (options) {
                    if (options.negate) {
                      for (let i = 0, n = this.data.length; i < n; i++) {
                        this.data[i] = -this.data[i];
                      }
                    }
                    if (options.normalize) {
                      var total = 0;
                      for (let i = 0, n = this.data.length; i < n; i++) {
                        total += this.data[i];
                      }
                      var mean = total / this.data.length;
                      total = 0;
                      for (let i = 0, n = this.data.length; i < n; i++) {
                        var diff = this.data[i] - mean;
                        total += diff * diff;
                      }
                      var variance = total / this.data.length;
                      for (let i = 0, n = this.data.length; i < n; i++) {
                        this.data[i] = (this.data[i] - mean) / variance;
                      }
                    }
                  }
                }
                /**
                 * @function $3Dmol.VolumeData.getIndex
                 * @param {number} x,y,z - the coordinates
                 * @returns - index into flat array closest to provided coordinate; -1 if invalid
                 */
                getIndex(x, y, z) {
                  if (this.matrix) {
                    if (this.inversematrix == null) {
                      this.inversematrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().getInverse(this.matrix);
                    }
                    var pt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(x, y, z);
                    pt = pt.applyMatrix4(this.inversematrix);
                    x = pt.x;
                    y = pt.y;
                    z = pt.z;
                  } else {
                    x -= this.origin.x;
                    y -= this.origin.y;
                    z -= this.origin.z;
                    x /= this.unit.x;
                    y /= this.unit.y;
                    z /= this.unit.z;
                  }
                  x = Math.round(x);
                  y = Math.round(y);
                  z = Math.round(z);
                  if (x < 0 || x >= this.size.x)
                    return -1;
                  if (y < 0 || y >= this.size.y)
                    return -1;
                  if (z < 0 || z >= this.size.z)
                    return -1;
                  return x * this.size.y * this.size.z + y * this.size.z + z;
                }
                /**
                 * @function $3Dmol.VolumeData.getVal
                 * @param {number} x,y,z - the coordinates
                 * @returns - value closest to provided coordinate; zero if coordinate invalid
                 */
                getVal(x, y, z) {
                  let i = this.getIndex(x, y, z);
                  if (i < 0)
                    return 0;
                  return this.data[i];
                }
                // parse cube data
                cube(str) {
                  var lines = str.split(/\r?\n/);
                  if (lines.length < 6)
                    return;
                  var cryst = (0, _parsers_CUBE__WEBPACK_IMPORTED_MODULE_3__.CUBE)(str, {}).modelData[0].cryst;
                  var lineArr = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  var atomsnum = parseFloat(lineArr[0]);
                  var natoms = Math.abs(atomsnum);
                  this.origin = cryst.origin;
                  this.size = cryst.size;
                  this.unit = cryst.unit;
                  this.matrix = cryst.matrix4;
                  var headerlines = 6;
                  if (atomsnum < 0)
                    headerlines++;
                  var raw = lines.splice(natoms + headerlines).join(" ");
                  raw = raw.replace(/^\s+/, "");
                  var rawArray = raw.split(/[\s\r]+/);
                  this.data = Float32Array.from(rawArray, parseFloat);
                }
                //parse cp4 files
                ccp4(bin) {
                  var header = {};
                  bin = new Int8Array(bin);
                  var intView = new Int32Array(bin.buffer, 0, 56);
                  var floatView = new Float32Array(bin.buffer, 0, 56);
                  var dv = new DataView(bin.buffer);
                  header.MAP = String.fromCharCode(dv.getUint8(52 * 4), dv.getUint8(52 * 4 + 1), dv.getUint8(52 * 4 + 2), dv.getUint8(52 * 4 + 3));
                  header.MACHST = [dv.getUint8(53 * 4), dv.getUint8(53 * 4 + 1)];
                  if (header.MACHST[0] === 17 && header.MACHST[1] === 17) {
                    var n = bin.byteLength;
                    for (var i = 0; i < n; i += 4) {
                      dv.setFloat32(i, dv.getFloat32(i), true);
                    }
                  }
                  header.NX = intView[0];
                  header.NY = intView[1];
                  header.NZ = intView[2];
                  header.MODE = intView[3];
                  header.NXSTART = intView[4];
                  header.NYSTART = intView[5];
                  header.NZSTART = intView[6];
                  header.MX = intView[7];
                  header.MY = intView[8];
                  header.MZ = intView[9];
                  header.xlen = floatView[10];
                  header.ylen = floatView[11];
                  header.zlen = floatView[12];
                  header.alpha = floatView[13];
                  header.beta = floatView[14];
                  header.gamma = floatView[15];
                  header.MAPC = intView[16];
                  header.MAPR = intView[17];
                  header.MAPS = intView[18];
                  header.DMIN = floatView[19];
                  header.DMAX = floatView[20];
                  header.DMEAN = floatView[21];
                  header.ISPG = intView[22];
                  header.NSYMBT = intView[23];
                  header.LSKFLG = intView[24];
                  header.originX = floatView[49];
                  header.originY = floatView[50];
                  header.originZ = floatView[51];
                  header.ARMS = floatView[54];
                  var h = header;
                  var basisX = [
                    h.xlen,
                    0,
                    0
                  ];
                  var basisY = [
                    h.ylen * Math.cos(Math.PI / 180 * h.gamma),
                    h.ylen * Math.sin(Math.PI / 180 * h.gamma),
                    0
                  ];
                  var basisZ = [
                    h.zlen * Math.cos(Math.PI / 180 * h.beta),
                    h.zlen * (Math.cos(Math.PI / 180 * h.alpha) - Math.cos(Math.PI / 180 * h.gamma) * Math.cos(Math.PI / 180 * h.beta)) / Math.sin(Math.PI / 180 * h.gamma),
                    0
                  ];
                  basisZ[2] = Math.sqrt(h.zlen * h.zlen * Math.sin(Math.PI / 180 * h.beta) * Math.sin(Math.PI / 180 * h.beta) - basisZ[1] * basisZ[1]);
                  var basis = [0, basisX, basisY, basisZ];
                  var nxyz = [0, h.MX, h.MY, h.MZ];
                  var mapcrs = [0, h.MAPC, h.MAPR, h.MAPS];
                  this.matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                  this.matrix.set(basis[mapcrs[1]][0] / nxyz[mapcrs[1]], basis[mapcrs[2]][0] / nxyz[mapcrs[2]], basis[mapcrs[3]][0] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][1] / nxyz[mapcrs[1]], basis[mapcrs[2]][1] / nxyz[mapcrs[2]], basis[mapcrs[3]][1] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][2] / nxyz[mapcrs[1]], basis[mapcrs[2]][2] / nxyz[mapcrs[2]], basis[mapcrs[3]][2] / nxyz[mapcrs[3]], 0, 0, 0, 0, 1);
                  this.matrix = this.matrix.multiplyMatrices(this.matrix, new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().makeTranslation(h.NXSTART + h.originX, h.NYSTART + h.originY, h.NZSTART + h.originZ));
                  this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                  this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                  this.size = { x: header.NX, y: header.NY, z: header.NZ };
                  this.dimensionorder = [header.MAPC, header.MAPR, header.MAPS];
                  var data = new Float32Array(bin.buffer, 1024 + header.NSYMBT);
                  var NX = header.NX, NY = header.NY, NZ = header.NZ;
                  this.data = new Float32Array(NX * NY * NZ);
                  for (let i2 = 0; i2 < NX; i2++) {
                    for (let j = 0; j < NY; j++) {
                      for (let k = 0; k < NZ; k++) {
                        this.data[(i2 * NY + j) * NZ + k] = data[(k * NY + j) * NX + i2];
                      }
                    }
                  }
                }
              }
              ;
            },
            /***/
            "./src/VolumetricRender.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                GLVolumetricRender: () => (
                  /* binding */
                  GLVolumetricRender
                )
                /* harmony export */
              });
              var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL/shapes */
                "./src/WebGL/shapes/index.ts"
              );
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _GLShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./GLShape */
                "./src/GLShape.ts"
              );
              ;
              class GLVolumetricRender {
                static interpolateArray(data, fitCount) {
                  function linearInterpolate(before2, after2, atPoint2) {
                    return before2 + (after2 - before2) * atPoint2;
                  }
                  var newData = [];
                  var springFactor = (data.length - 1) / (fitCount - 1);
                  newData[0] = data[0];
                  for (var i = 1; i < fitCount - 1; i++) {
                    var tmp = i * springFactor;
                    var before = Math.floor(tmp);
                    var after = Math.ceil(tmp);
                    var atPoint = tmp - before;
                    newData[i] = linearInterpolate(data[before], data[after], atPoint);
                  }
                  newData[fitCount - 1] = data[data.length - 1];
                  return newData;
                }
                constructor(data, spec, viewer) {
                  this.hidden = false;
                  this.boundingSphere = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_0__.Sphere();
                  this.renderedShapeObj = null;
                  this.shapeObj = null;
                  this.subsamples = 5;
                  this.data = null;
                  this.transferfunctionbuffer = [];
                  this.min = 0;
                  this.max = 0;
                  spec = spec || {};
                  var transferfn = Object.assign([], spec.transferfn);
                  this.subsamples = spec.subsamples || 5;
                  let TRANSFER_BUFFER_SIZE = 256;
                  transferfn.forEach(function(a) {
                    a.value = parseFloat(a.value);
                  });
                  transferfn.sort(function(a, b) {
                    return a.value - b.value;
                  });
                  this.min = transferfn[0].value;
                  if (transferfn.length == 0)
                    transferfn.push(transferfn[0]);
                  this.max = transferfn[transferfn.length - 1].value;
                  var pos1, pos2, color1, color2, R, G, B, A, alpha1, alpha2;
                  for (let i = 0; i < transferfn.length - 1; i++) {
                    color1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(transferfn[i].color);
                    color2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(transferfn[i + 1].color);
                    alpha1 = transferfn[i].opacity;
                    alpha2 = transferfn[i + 1].opacity;
                    pos1 = Math.floor((transferfn[i].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));
                    pos2 = Math.floor((transferfn[i + 1].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));
                    if (pos1 == pos2)
                      continue;
                    R = GLVolumetricRender.interpolateArray([color1.r * 255, color2.r * 255], pos2 - pos1);
                    G = GLVolumetricRender.interpolateArray([color1.g * 255, color2.g * 255], pos2 - pos1);
                    B = GLVolumetricRender.interpolateArray([color1.b * 255, color2.b * 255], pos2 - pos1);
                    A = GLVolumetricRender.interpolateArray([alpha1 * 255, alpha2 * 255], pos2 - pos1);
                    for (let j = 0; j < R.length; j++) {
                      this.transferfunctionbuffer.push(R[j]);
                      this.transferfunctionbuffer.push(G[j]);
                      this.transferfunctionbuffer.push(B[j]);
                      this.transferfunctionbuffer.push(A[j]);
                    }
                  }
                  this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer);
                  if (data.matrix) {
                    let start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    let end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(data.size.x, data.size.y, data.size.z);
                    let unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                    start.applyMatrix4(data.matrix);
                    end.applyMatrix4(data.matrix);
                    unit.applyMatrix4(data.matrix).sub(start);
                    this.extent = [[start.x, start.y, start.z], [end.x, end.y, end.z]];
                    for (let i = 1; i < 7; i++) {
                      end.x = i & 1 ? data.size.x : 0;
                      end.y = i & 2 ? data.size.y : 0;
                      end.z = i & 4 ? data.size.z : 0;
                      end.applyMatrix4(data.matrix);
                      this.extent[0][0] = Math.min(this.extent[0][0], end.x);
                      this.extent[0][1] = Math.min(this.extent[0][1], end.y);
                      this.extent[0][2] = Math.min(this.extent[0][2], end.z);
                      this.extent[1][0] = Math.max(this.extent[1][0], end.x);
                      this.extent[1][1] = Math.max(this.extent[1][1], end.y);
                      this.extent[1][2] = Math.max(this.extent[1][2], end.z);
                    }
                    let xoff = end.x - start.x;
                    let yoff = end.y - start.y;
                    let zoff = end.z - start.z;
                    this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);
                    this.minunit = Math.min(Math.min(unit.x, unit.y), unit.z);
                    this.texmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().identity().scale({ x: data.size.x, y: data.size.y, z: data.size.z });
                    this.texmatrix = this.texmatrix.multiplyMatrices(data.matrix, this.texmatrix);
                    this.texmatrix = this.texmatrix.getInverse(this.texmatrix);
                  } else {
                    this.texmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().identity();
                    let xoff = data.unit.x * data.size.x;
                    let yoff = data.unit.y * data.size.y;
                    let zoff = data.unit.z * data.size.z;
                    this.texmatrix.makeTranslation(-data.origin.x / xoff, -data.origin.y / yoff, -data.origin.z / zoff);
                    this.texmatrix.scale({ x: 1 / xoff, y: 1 / yoff, z: 1 / zoff });
                    this.minunit = Math.min(Math.min(data.unit.x, data.unit.y), data.unit.z);
                    this.extent = [
                      [data.origin.x, data.origin.y, data.origin.z],
                      [data.origin.x + xoff, data.origin.y + yoff, data.origin.z + zoff]
                    ];
                    this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);
                  }
                  var shape = new _GLShape__WEBPACK_IMPORTED_MODULE_4__.GLShape({});
                  shape.addBox({
                    corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },
                    dimensions: {
                      w: this.extent[1][0] - this.extent[0][0],
                      h: this.extent[1][1] - this.extent[0][1],
                      d: this.extent[1][2] - this.extent[0][2]
                    }
                  });
                  this.geo = shape.finalize();
                  this.boundingSphere.center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3((this.extent[0][0] + this.extent[1][0]) / 2, (this.extent[0][1] + this.extent[1][1]) / 2, (this.extent[0][2] + this.extent[1][2]) / 2);
                  this.boundingSphere.radius = this.maxdepth / 2;
                  if (spec.coords === void 0 && spec.selection !== void 0) {
                    if (viewer) {
                      spec.coords = viewer.selectedAtoms(spec.selection);
                    } else {
                      console.log("Need to provide viewer to volumetric renderer if selection specified.");
                    }
                  }
                  if (spec.coords !== void 0 && spec.seldist !== void 0) {
                    let mask = new Uint8Array(data.data.length);
                    let d = spec.seldist;
                    let d2 = d * d;
                    for (let i = 0, n = spec.coords.length; i < n; i++) {
                      let c = spec.coords[i];
                      let minx = c.x - d, miny = c.y - d, minz = c.z - d;
                      let maxx = c.x + d, maxy = c.y + d, maxz = c.z + d;
                      if (data.getIndex(minx, miny, minz) >= 0 || data.getIndex(maxx, maxy, maxz) >= 0) {
                        for (let x = minx; x < maxx; x += this.minunit) {
                          for (let y = miny; y < maxy; y += this.minunit) {
                            for (let z = minz; z < maxz; z += this.minunit) {
                              let idx = data.getIndex(x, y, z);
                              if (idx >= 0 && !mask[idx]) {
                                let distsq = (x - c.x) * (x - c.x) + (y - c.y) * (y - c.y) + (z - c.z) * (z - c.z);
                                if (distsq < d2) {
                                  mask[idx] = 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    for (let i = 0, n = data.data.length; i < n; i++) {
                      if (mask[i] == 0)
                        data.data[i] = Infinity;
                    }
                  }
                  this.data = data;
                }
                /**
                 * Initialize webgl objects for rendering
                 * @param {Object3D} group
                 *
                 */
                globj(group) {
                  if (this.renderedShapeObj) {
                    group.remove(this.renderedShapeObj);
                    this.renderedShapeObj = null;
                  }
                  if (this.hidden)
                    return;
                  this.shapeObj = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Object3D();
                  var material = null;
                  var texture = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Texture(this.data, true);
                  var transfertexture = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Texture(this.transferfunctionbuffer, false);
                  texture.needsUpdate = true;
                  transfertexture.needsUpdate = true;
                  transfertexture.flipY = false;
                  material = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.VolumetricMaterial({
                    transferfn: transfertexture,
                    transfermin: this.min,
                    transfermax: this.max,
                    map: texture,
                    extent: this.extent,
                    maxdepth: this.maxdepth,
                    texmatrix: this.texmatrix,
                    unit: this.minunit,
                    subsamples: this.subsamples
                  });
                  var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Mesh(this.geo, material);
                  this.shapeObj.add(mesh);
                  this.renderedShapeObj = this.shapeObj.clone();
                  group.add(this.renderedShapeObj);
                }
                removegl(group) {
                  if (this.renderedShapeObj) {
                    if (this.renderedShapeObj.geometry !== void 0)
                      this.renderedShapeObj.geometry.dispose();
                    if (this.renderedShapeObj.material !== void 0)
                      this.renderedShapeObj.material.dispose();
                    group.remove(this.renderedShapeObj);
                    this.renderedShapeObj = null;
                  }
                  this.shapeObj = null;
                }
                get position() {
                  return this.boundingSphere.center;
                }
                get x() {
                  return this.boundingSphere.center.x;
                }
                get y() {
                  return this.boundingSphere.center.y;
                }
                get z() {
                  return this.boundingSphere.center.z;
                }
              }
            },
            /***/
            "./src/WebGL/Camera.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Camera: () => (
                  /* binding */
                  Camera
                )
                /* harmony export */
              });
              var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./core */
                "./src/WebGL/core/index.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./math */
                "./src/WebGL/math/index.ts"
              );
              class Camera extends _core__WEBPACK_IMPORTED_MODULE_0__.Object3D {
                constructor(fov = 50, aspect = 1, near = 0.1, far = 2e3, ortho = false) {
                  super();
                  this.projectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                  this.projectionMatrixInverse = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                  this.matrixWorldInverse = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                  this.fov = fov;
                  this.aspect = aspect;
                  this.near = near;
                  this.far = far;
                  var center = this.position.z;
                  this.right = center * Math.tan(Math.PI / 180 * fov);
                  this.left = -this.right;
                  this.top = this.right / this.aspect;
                  this.bottom = -this.top;
                  this.ortho = !!ortho;
                  this.updateProjectionMatrix();
                }
                lookAt(vector) {
                  this.matrix.lookAt(this.position, vector, this.up);
                  if (this.rotationAutoUpdate) {
                    if (this.useQuaternion === false && this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_1__.Vector3) {
                      this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);
                    } else {
                      console.error("Unimplemented math operation.");
                    }
                  }
                }
                updateProjectionMatrix() {
                  if (this.ortho) {
                    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
                  } else {
                    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
                  }
                  this.projectionMatrixInverse.getInverse(this.projectionMatrix);
                }
              }
            },
            /***/
            "./src/WebGL/Fog.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Fog: () => (
                  /* binding */
                  Fog
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../colors */
                "./src/colors.ts"
              );
              class Fog {
                constructor(hex, near = 1, far = 1e3) {
                  this.name = "";
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(hex);
                  this.near = near;
                  this.far = far;
                }
                clone() {
                  return new Fog(this.color.getHex(), this.near, this.far);
                }
              }
            },
            /***/
            "./src/WebGL/Renderer.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Renderer: () => (
                  /* binding */
                  Renderer
                )
                /* harmony export */
              });
              var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./Camera */
                "./src/WebGL/Camera.ts"
              );
              var _constants_Sides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./constants/Sides */
                "./src/WebGL/constants/Sides.ts"
              );
              var _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./constants/TextureConstants */
                "./src/WebGL/constants/TextureConstants.ts"
              );
              var _core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./core */
                "./src/WebGL/core/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../colors */
                "./src/colors.ts"
              );
              var _materials__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./materials */
                "./src/WebGL/materials/index.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./math */
                "./src/WebGL/math/index.ts"
              );
              var _objects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./objects */
                "./src/WebGL/objects/index.ts"
              );
              var _shaders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./shaders */
                "./src/WebGL/shaders/index.ts"
              );
              var _SpritePlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./SpritePlugin */
                "./src/WebGL/SpritePlugin.ts"
              );
              var _offscreen_singleton = null;
              var _gl_singleton = null;
              class Renderer {
                constructor(parameters) {
                  this.context = null;
                  this.devicePixelRatio = 1;
                  this.sortObjects = true;
                  this.autoUpdateObjects = true;
                  this.autoUpdateScene = true;
                  this.info = {
                    memory: {
                      programs: 0,
                      geometries: 0,
                      textures: 0
                    },
                    render: {
                      calls: 0,
                      vertices: 0,
                      faces: 0,
                      points: 0
                    }
                  };
                  this._offscreen = null;
                  this._bitmap = null;
                  this._programs = [];
                  this._programs_counter = 0;
                  this._webglversion = 1;
                  this._currentProgram = null;
                  this._currentMaterialId = -1;
                  this._currentGeometryGroupHash = null;
                  this._currentCamera = null;
                  this._geometryGroupCounter = 0;
                  this._oldDoubleSided = -1;
                  this._oldFlipSided = -1;
                  this._oldDepthTest = -1;
                  this._oldDepthWrite = -1;
                  this._oldPolygonOffset = null;
                  this._oldLineWidth = null;
                  this._viewportWidth = 0;
                  this._viewportHeight = 0;
                  this._currentWidth = 0;
                  this._currentHeight = 0;
                  this._enabledAttributes = {};
                  this._vector3 = new _math__WEBPACK_IMPORTED_MODULE_6__.Vector3();
                  this._worldInverse = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._projInverse = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._textureMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._fullProjModelMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._fullProjModelMatrixInv = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._direction = new _math__WEBPACK_IMPORTED_MODULE_6__.Vector3();
                  this._lightsNeedUpdate = true;
                  this._lights = {
                    ambient: [0, 0, 0],
                    directional: {
                      length: 0,
                      colors: [],
                      positions: []
                    },
                    point: {
                      length: 0,
                      colors: [],
                      positions: [],
                      distances: []
                    },
                    spot: {
                      length: 0,
                      colors: [],
                      positions: [],
                      distances: [],
                      directions: [],
                      anglesCos: [],
                      exponents: []
                    },
                    hemi: {
                      length: 0,
                      skyColors: [],
                      groundColors: [],
                      positions: []
                    }
                  };
                  this.sprites = new _SpritePlugin__WEBPACK_IMPORTED_MODULE_9__.SpritePlugin();
                  this._screenshader = null;
                  this._AOshader = null;
                  this._blurshader = null;
                  this._vertexattribpos = null;
                  this._aovertexattribpos = null;
                  this._blurvertexattribpos = null;
                  this._screenQuadVBO = null;
                  this._fb = null;
                  this._targetTexture = null;
                  this._depthTexture = null;
                  this._shadingTexture = null;
                  this._scratchTexture = null;
                  this._upscale = null;
                  this._AOstrength = 1;
                  this._AOradius = 5;
                  this.SHADE_TEXTURE = 3;
                  parameters = parameters || {};
                  this.row = parameters.row;
                  this.col = parameters.col;
                  this.rows = parameters.rows;
                  this.cols = parameters.cols;
                  this._canvas = parameters.canvas !== void 0 ? parameters.canvas : document.createElement("canvas");
                  this._precision = parameters.precision !== void 0 ? parameters.precision : "highp";
                  this._alpha = parameters.alpha !== void 0 ? parameters.alpha : true;
                  this._premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true;
                  this._antialias = parameters.antialias !== void 0 ? parameters.antialias : false;
                  this._upscale = parameters.upscale !== void 0 ? parameters.upscale : this._antialias;
                  this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false;
                  this._clearColor = parameters.clearColor !== void 0 ? new _colors__WEBPACK_IMPORTED_MODULE_4__.Color(parameters.clearColor) : new _colors__WEBPACK_IMPORTED_MODULE_4__.Color(0);
                  this._clearAlpha = parameters.clearAlpha !== void 0 ? parameters.clearAlpha : 0;
                  this._outlineMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.MeshOutlineMaterial(parameters.outline);
                  this._outlineSphereImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.SphereImposterOutlineMaterial(parameters.outline);
                  this._outlineStickImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.StickImposterOutlineMaterial(parameters.outline);
                  this._outlineEnabled = !!parameters.outline;
                  this._AOEnabled = !!parameters.ambientOcclusion;
                  if (parameters.ambientOcclusion && typeof parameters.ambientOcclusion.strength !== "undefined") {
                    this._AOstrength = parseFloat(parameters.ambientOcclusion.strength);
                  }
                  if (this._AOstrength == 0) {
                    this._AOEnabled = false;
                  }
                  if (parameters.ambientOcclusion && typeof parameters.ambientOcclusion.radius !== "undefined") {
                    this._AOradius = parseFloat(parameters.ambientOcclusion.radius);
                  }
                  this.domElement = this._canvas;
                  this._canvas.id = parameters.id;
                  if (parameters.containerWidth == 0 || parameters.containerHeight == 0) {
                    return;
                  }
                  this.initGL();
                  this.setDefaultGLState();
                  this.context = this._gl;
                  if (this.isWebGL1()) {
                    this._extInstanced = this._gl.getExtension("ANGLE_instanced_arrays");
                  } else {
                    this._extInstanced = {
                      vertexAttribDivisorANGLE: this._gl.vertexAttribDivisor.bind(this._gl),
                      drawElementsInstancedANGLE: this._gl.drawElementsInstanced.bind(this._gl)
                    };
                  }
                  this._extFragDepth = this._gl.getExtension("EXT_frag_depth");
                  this._extFloatLinear = this._gl.getExtension("OES_texture_float_linear");
                  this._extColorBufferFloat = this._gl.getExtension("EXT_color_buffer_float");
                  this.sprites.init(this);
                }
                // API
                supportedExtensions() {
                  return {
                    supportsAIA: Boolean(this._extInstanced),
                    supportsImposters: Boolean(this._extFragDepth) || !this.isWebGL1(),
                    regen: false
                  };
                }
                getContext() {
                  return this._gl;
                }
                getCanvas() {
                  return this._canvas;
                }
                isLost() {
                  return this._gl == null || this._gl.isContextLost();
                }
                getPrecision() {
                  return this._precision;
                }
                setClearColorHex(hex, alpha) {
                  this._clearColor.setHex(hex);
                  this._clearAlpha = alpha;
                  if (!this.isLost()) {
                    this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
                  }
                }
                enableOutline(parameters) {
                  this._outlineMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.MeshOutlineMaterial(parameters);
                  this._outlineSphereImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.SphereImposterOutlineMaterial(parameters);
                  this._outlineStickImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.StickImposterOutlineMaterial(parameters);
                  this._outlineEnabled = true;
                }
                disableOutline() {
                  this._outlineEnabled = false;
                }
                enableAmbientOcclusion(parameters) {
                  if (parameters) {
                    if (parameters.strength)
                      this._AOstrength = parameters.strength;
                    if (parameters.scale)
                      this._AOradius = parameters.scale;
                  }
                  this._AOEnabled = this._AOstrength > 0;
                }
                disableAmbientOcclusion() {
                  this._AOEnabled = false;
                }
                setViewport() {
                  if (this._offscreen) {
                    this._offscreen.width = this._canvas.width;
                    this._offscreen.height = this._canvas.height;
                  }
                  if (this.rows != void 0 && this.cols != void 0 && this.row != void 0 && this.col != void 0) {
                    if (!this.isLost()) {
                      var wid = this._gl.drawingBufferWidth / this.cols;
                      var hei = this._gl.drawingBufferHeight / this.rows;
                      this._viewportWidth = wid;
                      this._viewportHeight = hei;
                      this._gl.enable(this._gl.SCISSOR_TEST);
                      this._gl.scissor(wid * this.col, hei * this.row, wid, hei);
                      this._gl.viewport(wid * this.col, hei * this.row, wid, hei);
                    }
                  }
                }
                setSize(width, height) {
                  this.devicePixelRatio = window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1;
                  if (this._upscale && this.devicePixelRatio < 2)
                    this.devicePixelRatio = 2;
                  this._canvas.width = width * this.devicePixelRatio;
                  this._canvas.height = height * this.devicePixelRatio;
                  this._canvas.style.width = width + "px";
                  this._canvas.style.height = height + "px";
                  if (this.rows != void 0 && this.cols != void 0 && this.row != void 0 && this.col != void 0) {
                    if (!this.isLost()) {
                      this._viewportWidth = this._gl.drawingBufferWidth / this.cols;
                      this._viewportHeight = this._gl.drawingBufferHeight / this.rows;
                    }
                    this.setViewport();
                  } else {
                    this._viewportWidth = this._canvas.width;
                    this._viewportHeight = this._canvas.height;
                    if (!this.isLost()) {
                      this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
                    }
                  }
                  this.initFrameBuffer();
                }
                clear(color, depth, stencil) {
                  var bits = 0;
                  if (color === void 0 || color)
                    bits |= this._gl.COLOR_BUFFER_BIT;
                  if (depth === void 0 || depth)
                    bits |= this._gl.DEPTH_BUFFER_BIT;
                  if (stencil === void 0 || stencil)
                    bits |= this._gl.STENCIL_BUFFER_BIT;
                  this._gl.clear(bits);
                }
                setMaterialFaces(material, reflected) {
                  var doubleSided = material.side === _constants_Sides__WEBPACK_IMPORTED_MODULE_1__.DoubleSide;
                  var flipSided = material.side === _constants_Sides__WEBPACK_IMPORTED_MODULE_1__.BackSide;
                  if (!material.imposter)
                    flipSided = reflected ? !flipSided : flipSided;
                  if (this._oldDoubleSided !== doubleSided) {
                    if (doubleSided) {
                      this._gl.disable(this._gl.CULL_FACE);
                    } else {
                      this._gl.enable(this._gl.CULL_FACE);
                    }
                    this._oldDoubleSided = doubleSided;
                  }
                  if (this._oldFlipSided !== flipSided) {
                    if (flipSided) {
                      this._gl.frontFace(this._gl.CW);
                    } else {
                      this._gl.frontFace(this._gl.CCW);
                    }
                    this._oldFlipSided = flipSided;
                  }
                  this._gl.cullFace(this._gl.BACK);
                }
                setDepthTest(depthTest) {
                  if (this._oldDepthTest !== depthTest) {
                    if (depthTest) {
                      this._gl.enable(this._gl.DEPTH_TEST);
                    } else {
                      this._gl.disable(this._gl.DEPTH_TEST);
                    }
                    this._oldDepthTest = depthTest;
                  }
                }
                setDepthWrite(depthWrite) {
                  if (this._oldDepthWrite !== depthWrite) {
                    this._gl.depthMask(depthWrite);
                    this._oldDepthWrite = depthWrite;
                  }
                }
                setBlending(blending) {
                  if (!blending) {
                    this._gl.disable(this._gl.BLEND);
                  } else {
                    this._gl.enable(this._gl.BLEND);
                    this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD);
                    this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
                  }
                }
                // TODO: need to set up shader attributes and uniforms as attributes on
                // material object after attaching prgm
                // We need to attach appropriate uniform variables to material after shaders
                // have been chosen
                initMaterial(material, lights, fog, objects) {
                  material.addEventListener("dispose", this.onMaterialDispose.bind(this));
                  var parameters, shaderID;
                  shaderID = material.shaderID;
                  if (shaderID) {
                    var shader = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib[shaderID];
                    material.vertexShader = shader.vertexShader;
                    material.fragmentShader = shader.fragmentShader;
                    material.uniforms = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderUtils.clone(shader.uniforms);
                    if (material.shaded) {
                      material.makeShaded(this.SHADE_TEXTURE);
                    }
                  }
                  parameters = {
                    wireframe: material.wireframe,
                    fragdepth: material.imposter,
                    volumetric: material.volumetric,
                    shaded: material.shaded
                  };
                  material.program = this.buildProgram(material.fragmentShader, material.vertexShader, material.uniforms, parameters);
                }
                renderBuffer(camera, lights, fog, material, geometryGroup, object) {
                  if (!material.visible)
                    return;
                  var program, attributes;
                  program = this.setProgram(camera, lights, fog, material, object, this);
                  if (!program)
                    return;
                  attributes = program.attributes;
                  var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 16777215 + program.id * 2 + wireframeBit;
                  if (geometryGroupHash !== this._currentGeometryGroupHash) {
                    this._currentGeometryGroupHash = geometryGroupHash;
                    updateBuffers = true;
                  }
                  if (updateBuffers) {
                    this.disableAttributes();
                    if (attributes.position >= 0) {
                      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
                      this.enableAttribute(attributes.position);
                      this._gl.vertexAttribPointer(attributes.position, 3, this._gl.FLOAT, false, 0, 0);
                    }
                    if (attributes.color >= 0) {
                      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
                      this.enableAttribute(attributes.color);
                      this._gl.vertexAttribPointer(attributes.color, 3, this._gl.FLOAT, false, 0, 0);
                    }
                    if (attributes.normal >= 0) {
                      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
                      this.enableAttribute(attributes.normal);
                      this._gl.vertexAttribPointer(attributes.normal, 3, this._gl.FLOAT, false, 0, 0);
                    }
                    if (attributes.offset >= 0) {
                      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);
                      this.enableAttribute(attributes.offset);
                      this._gl.vertexAttribPointer(attributes.offset, 3, this._gl.FLOAT, false, 0, 0);
                    }
                    if (attributes.radius >= 0) {
                      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);
                      this.enableAttribute(attributes.radius);
                      this._gl.vertexAttribPointer(attributes.radius, 1, this._gl.FLOAT, false, 0, 0);
                    }
                  }
                  var faceCount, lineCount;
                  if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh) {
                    if (material.shaderID === "instanced") {
                      var sphereGeometryGroup = material.sphere.geometryGroups[0];
                      if (updateBuffers) {
                        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
                        this._gl.bufferData(this._gl.ARRAY_BUFFER, sphereGeometryGroup.vertexArray, this._gl.STATIC_DRAW);
                        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
                        this._gl.bufferData(this._gl.ARRAY_BUFFER, sphereGeometryGroup.normalArray, this._gl.STATIC_DRAW);
                        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
                        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, sphereGeometryGroup.faceArray, this._gl.STATIC_DRAW);
                      }
                      faceCount = sphereGeometryGroup.faceidx;
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 1);
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 1);
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 1);
                      this._extInstanced.drawElementsInstancedANGLE(this._gl.TRIANGLES, faceCount, this._gl.UNSIGNED_SHORT, 0, geometryGroup.radiusArray.length);
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 0);
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 0);
                      this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 0);
                    } else if (material.wireframe) {
                      lineCount = geometryGroup.lineidx;
                      this.setLineWidth(material.wireframeLinewidth);
                      if (updateBuffers)
                        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
                      this._gl.drawElements(this._gl.LINES, lineCount, this._gl.UNSIGNED_SHORT, 0);
                    } else {
                      faceCount = geometryGroup.faceidx;
                      if (updateBuffers)
                        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
                      this._gl.drawElements(this._gl.TRIANGLES, faceCount, this._gl.UNSIGNED_SHORT, 0);
                    }
                    this.info.render.calls++;
                    this.info.render.vertices += faceCount;
                    this.info.render.faces += faceCount / 3;
                  } else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {
                    lineCount = geometryGroup.vertices;
                    this.setLineWidth(material.linewidth);
                    this._gl.drawArrays(this._gl.LINES, 0, lineCount);
                    this.info.render.calls++;
                  }
                }
                /* clear out the shading textures */
                clearShading() {
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0);
                  this.clear(false, true, false);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
                }
                /* Setup the shading buffer to reflect desired shading (ambient occlusion) values.
                  Only the matching object with materialType are considered. */
                setShading(scene, camera, materialType) {
                  let lights = scene.__lights;
                  let fog = scene.fog;
                  let renderList = [];
                  for (let i = 0, il = scene.__webglObjects.length; i < il; i++) {
                    let webglObject = scene.__webglObjects[i];
                    if (webglObject.render && webglObject[materialType]) {
                      renderList.push(webglObject);
                    }
                  }
                  if (renderList.length == 0)
                    return;
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0);
                  this._gl.framebufferTexture2D(
                    this._gl.FRAMEBUFFER,
                    this._gl.COLOR_ATTACHMENT0,
                    this._gl.TEXTURE_2D,
                    null,
                    //don't write colors (can we do this?)
                    0
                  );
                  this.renderObjects(scene.__webglObjects, true, materialType + "Depth", camera, lights, fog, false);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._scratchTexture, 0);
                  this.clear(false, true, false);
                  this._gl.useProgram(this._AOshader);
                  this._currentProgram = this._AOshader;
                  this.setDepthTest(-1);
                  this.setDepthWrite(-1);
                  let p_uniforms = this._AOshader.uniforms;
                  this._gl.uniform1f(p_uniforms.total_strength, this._AOstrength);
                  this._gl.uniform1f(p_uniforms.radius, this._AOradius);
                  this._fullProjModelMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  this._fullProjModelMatrixInv = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                  let object = renderList[0].object;
                  this._fullProjModelMatrix.multiplyMatrices(camera.projectionMatrix, object._modelViewMatrix);
                  this._fullProjModelMatrixInv.getInverse(this._fullProjModelMatrix);
                  this._gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, this._fullProjModelMatrix.elements);
                  this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._fullProjModelMatrixInv.elements);
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);
                  this._gl.enableVertexAttribArray(this._aovertexattribpos);
                  this._gl.vertexAttribPointer(this._aovertexattribpos, 2, this._gl.FLOAT, false, 0, 0);
                  this._gl.activeTexture(this._gl.TEXTURE0);
                  this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);
                  this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0);
                  this.clear(false, true, false);
                  this._gl.useProgram(this._blurshader);
                  this._currentProgram = this._blurshader;
                  this.setDepthTest(-1);
                  this.setDepthWrite(-1);
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);
                  this._gl.enableVertexAttribArray(this._blurvertexattribpos);
                  this._gl.vertexAttribPointer(this._blurvertexattribpos, 2, this._gl.FLOAT, false, 0, 0);
                  this._gl.activeTexture(this._gl.TEXTURE0);
                  this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture);
                  this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
                }
                render(scene, camera) {
                  if (camera instanceof _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera === false) {
                    console.error("Renderer.render: camera is not an instance of Camera.");
                    return;
                  }
                  var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;
                  this._currentMaterialId = -1;
                  this._lightsNeedUpdate = true;
                  if (this.autoUpdateScene)
                    scene.updateMatrixWorld();
                  if (camera.parent === void 0)
                    camera.updateMatrixWorld();
                  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
                  if (this.isLost()) {
                    return;
                  }
                  if (this.autoUpdateObjects)
                    this.initWebGLObjects(scene);
                  this.info.render.calls = 0;
                  this.info.render.vertices = 0;
                  this.info.render.faces = 0;
                  this.info.render.points = 0;
                  this._currentWidth = this._viewportWidth;
                  this._currentHeight = this._viewportHeight;
                  this.setViewport();
                  this.setFrameBuffer();
                  this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
                  this.clear(true, true, true);
                  renderList = scene.__webglObjects;
                  let hasvolumetric = false;
                  let hasAO = this._AOEnabled;
                  for (i = 0, il = renderList.length; i < il; i++) {
                    webglObject = renderList[i];
                    object = webglObject.object;
                    webglObject.render = false;
                    if (object.visible) {
                      this.setupMatrices(object, camera);
                      this.unrollBufferMaterial(webglObject);
                      webglObject.render = true;
                      if (webglObject.volumetric)
                        hasvolumetric = true;
                      if (webglObject.hasAO)
                        hasAO = true;
                    }
                  }
                  this.setBlending(false);
                  if (hasAO) {
                    this.setShading(scene, camera, "opaque");
                  }
                  this.renderObjects(scene.__webglObjects, true, "opaque", camera, lights, fog, false);
                  if (hasAO) {
                    this.clearShading();
                  }
                  this.renderSprites(scene, camera, false);
                  this.renderObjects(scene.__webglObjects, true, "transparentDepth", camera, lights, fog, true);
                  this.renderObjects(scene.__webglObjects, false, "transparent", camera, lights, fog, true);
                  if (hasvolumetric && this._fb) {
                    this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, null, 0);
                    this.renderObjects(scene.__webglObjects, false, "volumetric", camera, lights, fog, true);
                  }
                  this.renderFrameBuffertoScreen();
                  this.setDepthTest(true);
                  this.setDepthWrite(true);
                  this.renderSprites(scene, camera, true);
                  if (this._bitmap) {
                    const bitmap = this._offscreen.transferToImageBitmap();
                    this._bitmap.transferFromImageBitmap(bitmap);
                    bitmap.close();
                  }
                }
                //setup framebuffer for drawing into, assumes buffers already allocated
                setFrameBuffer() {
                  if (this.isWebGL1() || !this._fb)
                    return;
                  let width = this._viewportWidth;
                  let height = this._viewportHeight;
                  this._gl.enable(this._gl.SCISSOR_TEST);
                  this._gl.scissor(0, 0, width, height);
                  this._gl.viewport(0, 0, width, height);
                  this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);
                  this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, width, height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                  this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);
                  this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, width, height, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                  if (this._shadingTexture) {
                    this._gl.deleteTexture(this._shadingTexture);
                    this._shadingTexture = this._gl.createTexture();
                    this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);
                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, width, height, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                    this._gl.deleteTexture(this._scratchTexture);
                    this._scratchTexture = this._gl.createTexture();
                    this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture);
                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, width, height, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                  }
                  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0);
                  this._gl.clearDepth(1);
                  this._gl.clear(this._gl.DEPTH_BUFFER_BIT);
                  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
                }
                //allocate buffers for framebuffer, needs to be called with every resize
                initFrameBuffer() {
                  if (this.isWebGL1())
                    return;
                  let width = this._viewportWidth;
                  let height = this._viewportHeight;
                  this._gl.enable(this._gl.SCISSOR_TEST);
                  this._gl.scissor(0, 0, width, height);
                  this._gl.viewport(0, 0, width, height);
                  this._targetTexture = this._gl.createTexture();
                  this._depthTexture = this._gl.createTexture();
                  this._shadingTexture = this._gl.createTexture();
                  this._scratchTexture = this._gl.createTexture();
                  this._fb = this._gl.createFramebuffer();
                  var screenshader = this._antialias ? _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib.screenaa : _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib.screen;
                  this._screenshader = this.buildProgram(screenshader.fragmentShader, screenshader.vertexShader, screenshader.uniforms, {});
                  this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, "vertexPosition");
                  var verts = [
                    // First triangle:
                    1,
                    1,
                    -1,
                    1,
                    -1,
                    -1,
                    // Second triangle:
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    1
                  ];
                  this._screenQuadVBO = this._gl.createBuffer();
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);
                  this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(verts), this._gl.STATIC_DRAW);
                  let aoshader = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib.ssao;
                  this._AOshader = this.buildProgram(aoshader.fragmentShader, aoshader.vertexShader, aoshader.uniforms, {});
                  this._aovertexattribpos = this._gl.getAttribLocation(this._AOshader, "vertexPosition");
                  let bshader = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib.blur;
                  this._blurshader = this.buildProgram(bshader.fragmentShader, bshader.vertexShader, bshader.uniforms, {});
                  this._blurvertexattribpos = this._gl.getAttribLocation(this._blurshader, "vertexPosition");
                }
                renderFrameBuffertoScreen() {
                  if (this.isWebGL1() || this._fb === null)
                    return;
                  this.setViewport();
                  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
                  this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
                  this._gl.frontFace(this._gl.CCW);
                  this._gl.cullFace(this._gl.BACK);
                  this._gl.useProgram(this._screenshader);
                  this._currentProgram = this._screenshader;
                  this.setDepthTest(-1);
                  this.setDepthWrite(-1);
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);
                  this._gl.enableVertexAttribArray(this._vertexattribpos);
                  this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, false, 0, 0);
                  this._gl.activeTexture(this._gl.TEXTURE0);
                  this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);
                  this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
                }
                initWebGLObjects(scene) {
                  if (!scene.__webglObjects) {
                    scene.__webglObjects = [];
                    scene.__webglObjectsImmediate = [];
                    scene.__webglSprites = [];
                    scene.__webglFlares = [];
                  }
                  if (scene.__objectsAdded.length) {
                    while (scene.__objectsAdded.length) {
                      this.addObject(scene.__objectsAdded[0], scene);
                      scene.__objectsAdded.splice(0, 1);
                    }
                    this._currentGeometryGroupHash = -1;
                  }
                  while (scene.__objectsRemoved.length) {
                    this.removeObject(scene.__objectsRemoved[0], scene);
                    scene.__objectsRemoved.splice(0, 1);
                  }
                  for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {
                    this.updateObject(scene.__webglObjects[o].object);
                  }
                }
                getYRatio() {
                  if (this.rows !== void 0 && this.row !== void 0)
                    return this.rows;
                  return 1;
                }
                getXRatio() {
                  if (this.cols !== void 0 && this.col !== void 0)
                    return this.cols;
                  return 1;
                }
                getAspect(width, height) {
                  if (width == void 0 || height == void 0) {
                    width = this._canvas.width;
                    height = this._canvas.height;
                  }
                  var aspect = width / height;
                  if (this.rows != void 0 && this.cols != void 0 && this.row != void 0 && this.col != void 0) {
                    var wid = width / this.cols;
                    var hei = height / this.rows;
                    aspect = wid / hei;
                  }
                  return aspect;
                }
                setTexture(texture, slot, is3D) {
                  if (texture.needsUpdate) {
                    if (!texture.__webglInit) {
                      texture.__webglInit = true;
                      texture.addEventListener("dispose", this.onTextureDispose.bind(this));
                      texture.__webglTexture = this._gl.createTexture();
                      this.info.memory.textures++;
                    }
                    this._gl.activeTexture(this._gl.TEXTURE0 + slot);
                    var gltextureType = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D;
                    this._gl.bindTexture(gltextureType, texture.__webglTexture);
                    this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
                    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
                    this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, texture.unpackAlignment);
                    var glFormat = this.paramToGL(texture.format), glType = this.paramToGL(texture.type);
                    if (!is3D) {
                      var image = texture.image;
                      var width = image.width;
                      var height = image.height;
                      if (typeof width === "undefined") {
                        width = image.length;
                        if (glFormat == this._gl.RGBA) {
                          width /= 4;
                        }
                        height = 1;
                      }
                      this.setTextureParameters(this._gl.TEXTURE_2D, texture);
                      if (!this.isWebGL1()) {
                        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, width, height, 0, glFormat, glType, texture.image);
                      } else {
                        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
                      }
                    } else {
                      this.setTextureParameters(this._gl.TEXTURE_3D, texture);
                      this._gl.texImage3D(this._gl.TEXTURE_3D, 0, this._gl.R32F, texture.image.size.z, texture.image.size.y, texture.image.size.x, 0, this._gl.RED, this._gl.FLOAT, texture.image.data);
                    }
                    texture.needsUpdate = false;
                    if (texture.onUpdate)
                      texture.onUpdate();
                  } else {
                    this._gl.activeTexture(this._gl.TEXTURE0 + slot);
                    if (is3D)
                      this._gl.bindTexture(this._gl.TEXTURE_3D, texture.__webglTexture);
                    else
                      this._gl.bindTexture(this._gl.TEXTURE_2D, texture.__webglTexture);
                  }
                }
                supportsVolumetric() {
                  return !this.isWebGL1();
                }
                enableAttribute(attribute) {
                  if (!this._enabledAttributes[attribute]) {
                    this._gl.enableVertexAttribArray(attribute);
                    this._enabledAttributes[attribute] = true;
                  }
                }
                disableAttributes() {
                  for (let attribute in this._enabledAttributes) {
                    if (this._enabledAttributes[attribute]) {
                      this._gl.disableVertexAttribArray(attribute);
                      this._enabledAttributes[attribute] = false;
                    }
                  }
                }
                setPolygonOffset(polygonOffset, offsetFactor, offsetUnits) {
                  if (this._oldPolygonOffset !== polygonOffset) {
                    if (polygonOffset)
                      this._gl.enable(this._gl.POLYGON_OFFSET_FILL);
                    else
                      this._gl.disable(this._gl.POLYGON_OFFSET_FILL);
                  }
                }
                setLineWidth(width) {
                  if (width !== this._oldLineWidth) {
                    this._gl.lineWidth(width);
                    this._oldLineWidth = width;
                  }
                }
                deallocateGeometry(geometry) {
                  geometry.__webglInit = void 0;
                  if (geometry.__webglVertexBuffer !== void 0)
                    this._gl.deleteBuffer(geometry.__webglVertexBuffer);
                  if (geometry.__webglColorBuffer !== void 0)
                    this._gl.deleteBuffer(geometry.__webglColorBuffer);
                  if (geometry.geometryGroups !== void 0) {
                    for (var g = 0, gl = geometry.groups; g < gl; g++) {
                      var geometryGroup = geometry.geometryGroups[g];
                      if (geometryGroup.__webglVertexBuffer !== void 0)
                        this._gl.deleteBuffer(geometryGroup.__webglVertexBuffer);
                      if (geometryGroup.__webglColorBuffer !== void 0)
                        this._gl.deleteBuffer(geometryGroup.__webglColorBuffer);
                      if (geometryGroup.__webglNormalBuffer !== void 0)
                        this._gl.deleteBuffer(geometryGroup.__webglNormalBuffer);
                      if (geometryGroup.__webglFaceBuffer !== void 0)
                        this._gl.deleteBuffer(geometryGroup.__webglFaceBuffer);
                      if (geometryGroup.__webglLineBuffer !== void 0)
                        this._gl.deleteBuffer(geometryGroup.__webglLineBuffer);
                    }
                  }
                }
                deallocateMaterial(material) {
                  var program = material.program;
                  if (program === void 0)
                    return;
                  material.program = void 0;
                  var i, il, programInfo;
                  var deleteProgram = false;
                  for (i = 0, il = this._programs.length; i < il; i++) {
                    programInfo = this._programs[i];
                    if (programInfo.program === program) {
                      programInfo.usedTimes--;
                      if (programInfo.usedTimes === 0) {
                        deleteProgram = true;
                      }
                      break;
                    }
                  }
                  if (deleteProgram === true) {
                    var newPrograms = [];
                    for (i = 0, il = this._programs.length; i < il; i++) {
                      programInfo = this._programs[i];
                      if (programInfo.program !== program) {
                        newPrograms.push(programInfo);
                      }
                    }
                    this._programs = newPrograms;
                    this._gl.deleteProgram(program);
                    this.info.memory.programs--;
                  }
                }
                deallocateTexture(texture) {
                  if (texture.image && texture.image.__webglTextureCube) {
                    this._gl.deleteTexture(texture.image.__webglTextureCube);
                  } else {
                    if (!texture.__webglInit)
                      return;
                    texture.__webglInit = false;
                    this._gl.deleteTexture(texture.__webglTexture);
                  }
                }
                onGeometryDispose(event) {
                  var geometry = event.target;
                  geometry.removeEventListener("dispose", this.onGeometryDispose);
                  this.deallocateGeometry(geometry);
                  this.info.memory.geometries--;
                }
                onTextureDispose(event) {
                  var texture = event.target;
                  texture.removeEventListener("dispose", this.onTextureDispose);
                  this.deallocateTexture(texture);
                  this.info.memory.textures--;
                }
                onMaterialDispose(event) {
                  var material = event.target;
                  material.removeEventListener("dispose", this.onMaterialDispose);
                  this.deallocateMaterial(material);
                }
                // Compile and return shader
                getShader(type, str) {
                  var shader;
                  if (!this.isWebGL1() && !str.startsWith("#version")) {
                    str = str.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
                    if (type == "fragment") {
                      str = str.replace(/varying/g, "in");
                    } else {
                      str = str.replace(/varying/g, "out");
                    }
                    str = str.replace(/attribute/g, "in");
                    str = str.replace(/texture2D/g, "texture");
                    str = str.replace(/\/\/DEFINEFRAGCOLOR/g, "out vec4 glFragColor;");
                    str = str.replace(/gl_FragColor/g, "glFragColor");
                    str = "#version 300 es\n" + str;
                  }
                  if (type === "fragment")
                    shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
                  else if (type === "vertex")
                    shader = this._gl.createShader(this._gl.VERTEX_SHADER);
                  if (shader == null)
                    return null;
                  this._gl.shaderSource(shader, str);
                  this._gl.compileShader(shader);
                  if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                    console.error(this._gl.getShaderInfoLog(shader));
                    console.error("could not initialize shader");
                    return null;
                  }
                  return shader;
                }
                // Compile appropriate shaders (if necessary) from source code and attach to
                // gl program.
                buildProgram(fragmentShader, vertexShader, uniforms, parameters) {
                  var p, pl, program, code;
                  var chunks = [];
                  chunks.push(fragmentShader);
                  chunks.push(vertexShader);
                  for (p in parameters) {
                    chunks.push(p);
                    chunks.push(parameters[p]);
                  }
                  code = chunks.join();
                  for (p = 0, pl = this._programs.length; p < pl; p++) {
                    var programInfo = this._programs[p];
                    if (programInfo.code === code) {
                      programInfo.usedTimes++;
                      return programInfo.program;
                    }
                  }
                  if (this.isWebGL1()) {
                    if (parameters.volumetric)
                      throw new Error("Volumetric rendering requires webgl2 which is not supported by your hardware.");
                  }
                  program = this._gl.createProgram();
                  if (program == null)
                    return null;
                  var precision = this._precision;
                  var prefix = "precision " + precision + " float;";
                  var prefix_vertex = [
                    parameters.volumetric ? "#version 300 es" : "",
                    prefix
                  ].join("\n");
                  var prefix_fragment = [
                    parameters.volumetric ? "#version 300 es" : "",
                    parameters.fragdepth && this.isWebGL1() ? "#extension GL_EXT_frag_depth: enable" : "",
                    parameters.shaded ? "#define SHADED 1" : "",
                    parameters.wireframe ? "#define WIREFRAME 1" : "",
                    prefix
                  ].join("\n");
                  var glFragmentShader = this.getShader("fragment", prefix_fragment + fragmentShader);
                  var glVertexShader = this.getShader("vertex", prefix_vertex + vertexShader);
                  if (glVertexShader != null)
                    this._gl.attachShader(program, glVertexShader);
                  if (glFragmentShader != null)
                    this._gl.attachShader(program, glFragmentShader);
                  this._gl.linkProgram(program);
                  if (!this._gl.getProgramParameter(program, this._gl.LINK_STATUS))
                    console.error("Could not initialize shader");
                  program.uniforms = {};
                  program.attributes = {};
                  var identifiers, u, i;
                  identifiers = [
                    "viewMatrix",
                    "modelViewMatrix",
                    "projectionMatrix",
                    "normalMatrix",
                    "vWidth",
                    "vHeight"
                  ];
                  for (u in uniforms)
                    identifiers.push(u);
                  for (i = 0; i < identifiers.length; i++) {
                    var uniformVar = identifiers[i];
                    program.uniforms[uniformVar] = this._gl.getUniformLocation(program, uniformVar);
                  }
                  identifiers = [
                    "position",
                    "normal",
                    "color",
                    "lineDistance",
                    "offset",
                    "radius"
                  ];
                  for (i = 0; i < identifiers.length; i++) {
                    var attributeVar = identifiers[i];
                    program.attributes[attributeVar] = this._gl.getAttribLocation(program, attributeVar);
                  }
                  program.id = this._programs_counter++;
                  this._programs.push({
                    program,
                    code,
                    usedTimes: 1
                  });
                  this.info.memory.programs = this._programs.length;
                  return program;
                }
                setProgram(camera, lights, fog, material, object, renderer) {
                  if (material.needsUpdate) {
                    if (material.program)
                      this.deallocateMaterial(material);
                    this.initMaterial(material, lights, fog, object);
                    material.needsUpdate = false;
                  }
                  if (material.program == null)
                    return null;
                  var refreshMaterial = false;
                  var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;
                  if (program != this._currentProgram) {
                    this._gl.useProgram(program);
                    this._currentProgram = program;
                    refreshMaterial = true;
                  }
                  if (material.id != this._currentMaterialId) {
                    this._currentMaterialId = material.id;
                    refreshMaterial = true;
                  }
                  if (camera != this._currentCamera) {
                    this._currentCamera = camera;
                    refreshMaterial = true;
                  }
                  if (p_uniforms.projectionMatrix) {
                    this._gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
                  }
                  if (p_uniforms.modelViewMatrix) {
                    this._gl.uniformMatrix4fv(p_uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
                  }
                  if (p_uniforms.normalMatrix) {
                    this._gl.uniformMatrix3fv(p_uniforms.normalMatrix, false, object._normalMatrix.elements);
                  }
                  if (p_uniforms.projinv) {
                    this._projInverse.getInverse(camera.projectionMatrix);
                    this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._projInverse.elements);
                  }
                  if (p_uniforms.viewMatrix) {
                    this._gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
                  }
                  if (p_uniforms.vWidth) {
                    this._gl.uniform1f(p_uniforms.vWidth, this._viewportWidth);
                  }
                  if (p_uniforms.vHeight) {
                    this._gl.uniform1f(p_uniforms.vHeight, this._viewportHeight);
                  }
                  if (refreshMaterial) {
                    m_uniforms.fogColor.value = fog.color;
                    m_uniforms.fogNear.value = fog.near;
                    m_uniforms.fogFar.value = fog.far;
                    if (material.shaderID.startsWith("lambert") || material.shaderID === "instanced" || material.shaderID.endsWith("imposter")) {
                      if (this._lightsNeedUpdate) {
                        this.setupLights(program, lights);
                        this._lightsNeedUpdate = false;
                      }
                      m_uniforms.directionalLightColor.value = this._lights.directional.colors;
                      m_uniforms.directionalLightDirection.value = this._lights.directional.positions;
                    } else if (material.shaderID.endsWith("outline")) {
                      m_uniforms.outlineColor.value = material.outlineColor;
                      m_uniforms.outlineWidth.value = material.outlineWidth;
                      m_uniforms.outlinePushback.value = material.outlinePushback;
                      m_uniforms.outlineMaxPixels.value = material.outlineMaxPixels * this.devicePixelRatio;
                    } else if (material.shaderID === "volumetric") {
                      object._modelViewMatrix.getScale(this._direction);
                      this._worldInverse.getInverse(object._modelViewMatrix);
                      this._projInverse.getInverse(camera.projectionMatrix);
                      this._textureMatrix.multiplyMatrices(object.material.texmatrix, this._worldInverse);
                      this._gl.uniformMatrix4fv(p_uniforms.textmat, false, this._textureMatrix.elements);
                      this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._projInverse.elements);
                      let invscale = Math.min(Math.min(this._direction.x, this._direction.y), this._direction.z);
                      m_uniforms.step.value = object.material.unit * invscale;
                      m_uniforms.maxdepth.value = object.material.maxdepth * invscale;
                      m_uniforms.transfermax.value = object.material.transfermax;
                      m_uniforms.transfermin.value = object.material.transfermin;
                      m_uniforms.subsamples.value = object.material.subsamples;
                      renderer.setTexture(object.material.transferfn, 4, false);
                      renderer.setTexture(object.material.map, 3, true);
                      this._gl.activeTexture(this._gl.TEXTURE5);
                      this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);
                    }
                    m_uniforms.opacity.value = material.opacity;
                    this.loadMaterialUniforms(p_uniforms, m_uniforms);
                  }
                  if (m_uniforms.shading) {
                    if (m_uniforms.shading.value == 3) {
                      this._gl.activeTexture(this._gl.TEXTURE0 + this.SHADE_TEXTURE);
                      this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);
                    } else {
                      console.error("Invalid shading textures.");
                    }
                  }
                  return program;
                }
                loadMaterialUniforms(p_uniforms, m_uniforms) {
                  var uniformVar, type, uniformVal, uniformLoc;
                  for (uniformVar in m_uniforms) {
                    if (!p_uniforms[uniformVar])
                      continue;
                    type = m_uniforms[uniformVar].type;
                    uniformVal = m_uniforms[uniformVar].value;
                    uniformLoc = p_uniforms[uniformVar];
                    if (type === "f")
                      this._gl.uniform1f(uniformLoc, uniformVal);
                    else if (type === "i")
                      this._gl.uniform1i(uniformLoc, uniformVal);
                    else if (type === "fv")
                      this._gl.uniform3fv(uniformLoc, uniformVal);
                    else if (type === "c")
                      this._gl.uniform3f(uniformLoc, uniformVal.r, uniformVal.g, uniformVal.b);
                    else if (type === "f4")
                      this._gl.uniform4f(uniformLoc, uniformVal[0], uniformVal[1], uniformVal[2], uniformVal[3]);
                  }
                }
                // Objects adding
                addObject(object, scene) {
                  var g, gl, geometry, geometryGroup;
                  if (!object.__webglInit) {
                    object.__webglInit = true;
                    object._modelViewMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
                    object._normalMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix3();
                    if (object.geometry !== void 0 && object.geometry.__webglInit === void 0) {
                      object.geometry.__webglInit = true;
                      object.geometry.addEventListener("dispose", this.onGeometryDispose.bind(this));
                    }
                    if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {
                      geometry = object.geometry;
                      for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {
                        geometryGroup = geometry.geometryGroups[g];
                        geometryGroup.id = this._geometryGroupCounter++;
                        if (!geometryGroup.__webglVertexBuffer) {
                          if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh) {
                            this.createMeshBuffers(geometryGroup);
                            geometry.elementsNeedUpdate = true;
                            geometry.normalsNeedUpdate = true;
                          } else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line)
                            this.createLineBuffers(geometryGroup);
                          geometry.verticesNeedUpdate = true;
                          geometry.colorsNeedUpdate = true;
                        }
                      }
                    }
                  }
                  if (!object.__webglActive) {
                    if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {
                      geometry = object.geometry;
                      for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {
                        geometryGroup = geometry.geometryGroups[g];
                        this.addBuffer(scene.__webglObjects, geometryGroup, object);
                      }
                    } else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Sprite)
                      scene.__webglSprites.push(object);
                    object.__webglActive = true;
                  }
                }
                updateObject(object) {
                  var geometry = object.geometry, geometryGroup;
                  if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {
                    for (var g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {
                      geometryGroup = geometry.geometryGroups[g];
                      if (geometry.verticesNeedUpdate || geometry.elementsNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate) {
                        this.setBuffers(geometryGroup, this._gl.STATIC_DRAW);
                      }
                    }
                    geometry.verticesNeedUpdate = false;
                    geometry.elementsNeedUpdate = false;
                    geometry.normalsNeedUpdate = false;
                    geometry.colorsNeedUpdate = false;
                    geometry.buffersNeedUpdate = false;
                  }
                }
                removeObject(object, scene) {
                  if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line)
                    this.removeInstances(scene.__webglObjects, object);
                  else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Sprite)
                    this.removeInstancesDirect(scene.__webglSprites, object);
                  object.__webglActive = false;
                }
                removeInstances(objList, object) {
                  for (var o = objList.length - 1; o >= 0; --o) {
                    if (objList[o].object === object)
                      objList.splice(o, 1);
                  }
                }
                removeInstancesDirect(objList, object) {
                  for (var o = objList.length - 1; o >= 0; --o) {
                    if (objList[o] === object)
                      objList.splice(o, 1);
                  }
                }
                unrollBufferMaterial(globject) {
                  var object = globject.object;
                  var material = object.material;
                  if (material.volumetric) {
                    globject.opaque = null;
                    globject.transparent = null;
                    globject.volumetric = material;
                  } else if (material.transparent) {
                    globject.opaque = null;
                    globject.volumetric = null;
                    globject.transparent = material;
                    if (!material.wireframe) {
                      let blankMaterial = material.clone();
                      blankMaterial.opacity = 0;
                      globject.transparentDepth = blankMaterial;
                    }
                  } else {
                    globject.opaque = material;
                    globject.transparent = null;
                    globject.volumetric = null;
                    if (!material.wireframe) {
                      let blankMaterial = material.clone();
                      blankMaterial.opacity = 0;
                      globject.opaqueDepth = blankMaterial;
                    }
                    if (material.hasAO) {
                      globject.hasAO = true;
                    }
                    if (this._AOEnabled || globject.hasAO) {
                      globject.opaqueShaded = material.clone();
                      globject.opaqueShaded.shaded = true;
                    }
                  }
                }
                setBuffers(geometryGroup, hint) {
                  var vertexArray = geometryGroup.vertexArray;
                  var colorArray = geometryGroup.colorArray;
                  if (geometryGroup.__webglOffsetBuffer !== void 0) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);
                  } else {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);
                  }
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
                  this._gl.bufferData(this._gl.ARRAY_BUFFER, colorArray, hint);
                  if (geometryGroup.normalArray && geometryGroup.__webglNormalBuffer !== void 0) {
                    var normalArray = geometryGroup.normalArray;
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, normalArray, hint);
                  }
                  if (geometryGroup.radiusArray && geometryGroup.__webglRadiusBuffer !== void 0) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, geometryGroup.radiusArray, hint);
                  }
                  if (geometryGroup.faceArray && geometryGroup.__webglFaceBuffer !== void 0) {
                    var faceArray = geometryGroup.faceArray;
                    this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
                    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
                  }
                  if (geometryGroup.lineArray && geometryGroup.__webglLineBuffer !== void 0) {
                    var lineArray = geometryGroup.lineArray;
                    this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
                    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
                  }
                }
                // Creates appropriate gl buffers for geometry chunk
                // TODO: do we need line buffer for mesh objects?
                // Also, can we integrate this with createLineBuffers?
                createMeshBuffers(geometryGroup) {
                  if (geometryGroup.radiusArray) {
                    geometryGroup.__webglRadiusBuffer = this._gl.createBuffer();
                  }
                  if (geometryGroup.useOffset) {
                    geometryGroup.__webglOffsetBuffer = this._gl.createBuffer();
                  }
                  geometryGroup.__webglVertexBuffer = this._gl.createBuffer();
                  geometryGroup.__webglNormalBuffer = this._gl.createBuffer();
                  geometryGroup.__webglColorBuffer = this._gl.createBuffer();
                  geometryGroup.__webglFaceBuffer = this._gl.createBuffer();
                  geometryGroup.__webglLineBuffer = this._gl.createBuffer();
                  this.info.memory.geometries++;
                }
                createLineBuffers(geometry) {
                  geometry.__webglVertexBuffer = this._gl.createBuffer();
                  geometry.__webglColorBuffer = this._gl.createBuffer();
                  this.info.memory.geometries++;
                }
                addBuffer(objlist, buffer, object) {
                  objlist.push({
                    buffer,
                    object,
                    opaque: null,
                    transparent: null
                  });
                }
                setupMatrices(object, camera) {
                  object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                  object._normalMatrix.getInverse(object._modelViewMatrix);
                  object._normalMatrix.transpose();
                }
                // Fallback filters for non-power-of-2 textures
                filterFallback(filter) {
                  return this._gl.LINEAR;
                }
                setTextureParameters(textureType, texture) {
                  if (textureType == this._gl.TEXTURE_2D) {
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));
                  } else {
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                    this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE);
                    if (this._extColorBufferFloat && this._extFloatLinear) {
                      this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
                      this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
                    } else {
                      this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
                      this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
                    }
                  }
                }
                // Map constants to WebGL constants
                paramToGL(p) {
                  if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.UnsignedByteType)
                    return this._gl.UNSIGNED_BYTE;
                  if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.RGBAFormat)
                    return this._gl.RGBA;
                  if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.NearestFilter)
                    return this._gl.NEAREST;
                  return 0;
                }
                setupLights(program, lights) {
                  var l, ll, light, r = 0, g = 0, b = 0, color, intensity, zlights = this._lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, dirLength = 0, dirOffset = 0;
                  for (l = 0, ll = lights.length; l < ll; l++) {
                    light = lights[l];
                    color = light.color;
                    intensity = light.intensity;
                    if (light instanceof _core__WEBPACK_IMPORTED_MODULE_3__.Light) {
                      this._direction.getPositionFromMatrix(light.matrixWorld);
                      this._vector3.getPositionFromMatrix(light.target.matrixWorld);
                      this._direction.sub(this._vector3);
                      this._direction.normalize();
                      if (this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)
                        continue;
                      dirPositions[dirOffset] = this._direction.x;
                      dirPositions[dirOffset + 1] = this._direction.y;
                      dirPositions[dirOffset + 2] = this._direction.z;
                      dirColors[dirOffset] = color.r * intensity;
                      dirColors[dirOffset + 1] = color.g * intensity;
                      dirColors[dirOffset + 2] = color.b * intensity;
                      dirOffset += 3;
                      dirLength++;
                    }
                  }
                  zlights.ambient[0] = r;
                  zlights.ambient[1] = g;
                  zlights.ambient[2] = b;
                  zlights.directional.length = dirLength;
                }
                initGL() {
                  try {
                    if (OffscreenCanvas && !(this.rows != void 0 && this.cols != void 0 && this.row != void 0 && this.col != void 0)) {
                      if (_gl_singleton == null || _gl_singleton.isContextLost()) {
                        _offscreen_singleton = new OffscreenCanvas(this._canvas.width, this._canvas.height);
                        _gl_singleton = _offscreen_singleton.getContext("webgl2", {
                          alpha: true,
                          premultipliedAlpha: this._premultipliedAlpha,
                          antialias: this._antialias,
                          preserveDrawingBuffer: this._preserveDrawingBuffer
                        });
                      }
                      this._offscreen = _offscreen_singleton;
                      this._gl = _gl_singleton;
                      this._bitmap = this._canvas.getContext("bitmaprenderer", {
                        alpha: true
                      });
                    } else {
                      if (!(this._gl = this._canvas.getContext("webgl2", {
                        alpha: this._alpha,
                        premultipliedAlpha: this._premultipliedAlpha,
                        antialias: this._antialias,
                        preserveDrawingBuffer: this._preserveDrawingBuffer
                      }))) {
                        if (!(this._gl = this._canvas.getContext("experimental-webgl", {
                          alpha: this._alpha,
                          premultipliedAlpha: this._premultipliedAlpha,
                          antialias: this._antialias,
                          preserveDrawingBuffer: this._preserveDrawingBuffer
                        }))) {
                          if (!(this._gl = this._canvas.getContext("webgl", {
                            alpha: this._alpha,
                            premultipliedAlpha: this._premultipliedAlpha,
                            antialias: this._antialias,
                            preserveDrawingBuffer: this._preserveDrawingBuffer
                          }))) {
                            throw "Error creating WebGL context.";
                          }
                        }
                      }
                    }
                    var vers = this._gl.getParameter(this._gl.VERSION);
                    this._webglversion = parseInt(vers[6]);
                  } catch (error) {
                    console.error(error);
                  }
                }
                isWebGL1() {
                  return this._webglversion == 1;
                }
                setDefaultGLState() {
                  this._gl.clearDepth(1);
                  this._gl.clearStencil(0);
                  this._gl.enable(this._gl.DEPTH_TEST);
                  this._gl.depthFunc(this._gl.LEQUAL);
                  this._gl.frontFace(this._gl.CCW);
                  this._gl.cullFace(this._gl.BACK);
                  this._gl.enable(this._gl.CULL_FACE);
                  this._gl.enable(this._gl.BLEND);
                  this._gl.blendEquation(this._gl.FUNC_ADD);
                  this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
                  this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
                }
                // rendering
                renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending) {
                  var webglObject, object, buffer, material, start, end, delta;
                  if (reverse) {
                    start = renderList.length - 1;
                    end = -1;
                    delta = -1;
                  } else {
                    start = 0;
                    end = renderList.length;
                    delta = 1;
                  }
                  for (var i = start; i !== end; i += delta) {
                    webglObject = renderList[i];
                    if (webglObject.render) {
                      object = webglObject.object;
                      buffer = webglObject.buffer;
                      material = webglObject[materialType];
                      if ((webglObject.hasAO || this._AOEnabled) && webglObject[materialType + "Shaded"]) {
                        material = webglObject[materialType + "Shaded"];
                      }
                      if (!material)
                        continue;
                      this.setBlending(useBlending);
                      this.setDepthTest(material.depthTest);
                      this.setDepthWrite(material.depthWrite);
                      this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
                      var reflected = object._modelViewMatrix.isReflected();
                      this.setMaterialFaces(material, reflected);
                      this.renderBuffer(camera, lights, fog, material, buffer, object);
                      if ((this._outlineEnabled || material.outline) && !material.wireframe && material.shaderID !== "basic" && material.opacity !== 0) {
                        let outmat = this._outlineMaterial;
                        if (material.shaderID == "sphereimposter") {
                          outmat = this._outlineSphereImposterMaterial;
                        } else if (material.shaderID == "stickimposter") {
                          outmat = this._outlineStickImposterMaterial;
                        }
                        this.renderBuffer(camera, lights, fog, outmat, buffer, object);
                      }
                    }
                  }
                }
                renderSprites(scene, camera, inFront) {
                  this._currentGeometryGroupHash = -1;
                  this._currentProgram = null;
                  this._currentCamera = null;
                  this._oldDepthWrite = -1;
                  this._oldDepthTest = -1;
                  this._oldDoubleSided = -1;
                  this._currentMaterialId = -1;
                  this._oldFlipSided = -1;
                  this._lightsNeedUpdate = true;
                  this.sprites.render(scene, camera, this._currentWidth, this._currentHeight, inFront);
                  this._currentGeometryGroupHash = -1;
                  this._currentProgram = null;
                  this._currentCamera = null;
                  this._oldDepthWrite = -1;
                  this._oldDepthTest = -1;
                  this._oldDoubleSided = -1;
                  this._currentMaterialId = -1;
                  this._oldFlipSided = -1;
                }
              }
            },
            /***/
            "./src/WebGL/SpritePlugin.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SpritePlugin: () => (
                  /* binding */
                  SpritePlugin
                )
                /* harmony export */
              });
              var _shaders_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./shaders/index */
                "./src/WebGL/shaders/index.ts"
              );
              class SpritePlugin {
                constructor() {
                  this.sprite = {
                    vertices: null,
                    faces: null,
                    vertexBuffer: null,
                    elementBuffer: null,
                    program: null,
                    attributes: {},
                    uniforms: null
                  };
                }
                init(renderer) {
                  this.gl = renderer.context;
                  this.renderer = renderer;
                  this.precision = renderer.getPrecision();
                  this.sprite.vertices = new Float32Array(8 + 8);
                  this.sprite.faces = new Uint16Array(6);
                  var i = 0;
                  this.sprite.vertices[i++] = -1;
                  this.sprite.vertices[i++] = -1;
                  this.sprite.vertices[i++] = 0;
                  this.sprite.vertices[i++] = 0;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = -1;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = 0;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = -1;
                  this.sprite.vertices[i++] = 1;
                  this.sprite.vertices[i++] = 0;
                  this.sprite.vertices[i++] = 1;
                  i = 0;
                  this.sprite.faces[i++] = 0;
                  this.sprite.faces[i++] = 1;
                  this.sprite.faces[i++] = 2;
                  this.sprite.faces[i++] = 0;
                  this.sprite.faces[i++] = 2;
                  this.sprite.faces[i++] = 3;
                  this.sprite.vertexBuffer = this.gl.createBuffer();
                  this.sprite.elementBuffer = this.gl.createBuffer();
                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);
                  this.gl.bufferData(this.gl.ARRAY_BUFFER, this.sprite.vertices, this.gl.STATIC_DRAW);
                  this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);
                  this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.faces, this.gl.STATIC_DRAW);
                  this.sprite.program = this.createProgram(
                    _shaders_index__WEBPACK_IMPORTED_MODULE_0__.ShaderLib.sprite,
                    this.precision || 1
                    /** added default to single precision */
                  );
                  this.sprite.attributes = {};
                  const uniforms = {};
                  this.sprite.attributes.position = this.gl.getAttribLocation(this.sprite.program, "position");
                  this.sprite.attributes.uv = this.gl.getAttribLocation(this.sprite.program, "uv");
                  uniforms.uvOffset = this.gl.getUniformLocation(this.sprite.program, "uvOffset");
                  uniforms.uvScale = this.gl.getUniformLocation(this.sprite.program, "uvScale");
                  uniforms.rotation = this.gl.getUniformLocation(this.sprite.program, "rotation");
                  uniforms.scale = this.gl.getUniformLocation(this.sprite.program, "scale");
                  uniforms.alignment = this.gl.getUniformLocation(this.sprite.program, "alignment");
                  uniforms.color = this.gl.getUniformLocation(this.sprite.program, "color");
                  uniforms.map = this.gl.getUniformLocation(this.sprite.program, "map");
                  uniforms.opacity = this.gl.getUniformLocation(this.sprite.program, "opacity");
                  uniforms.useScreenCoordinates = this.gl.getUniformLocation(this.sprite.program, "useScreenCoordinates");
                  uniforms.screenPosition = this.gl.getUniformLocation(this.sprite.program, "screenPosition");
                  uniforms.modelViewMatrix = this.gl.getUniformLocation(this.sprite.program, "modelViewMatrix");
                  uniforms.projectionMatrix = this.gl.getUniformLocation(this.sprite.program, "projectionMatrix");
                  uniforms.fogNear = this.gl.getUniformLocation(this.sprite.program, "fogNear");
                  uniforms.fogFar = this.gl.getUniformLocation(this.sprite.program, "fogFar");
                  uniforms.fogColor = this.gl.getUniformLocation(this.sprite.program, "fogColor");
                  uniforms.alphaTest = this.gl.getUniformLocation(this.sprite.program, "alphaTest");
                  this.sprite.uniforms = uniforms;
                }
                render(scene, camera, viewportWidth, viewportHeight, inFront) {
                  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                  if (!this.gl)
                    throw new Error("WebGLRenderer not initialized");
                  let sprites = [];
                  (_a = scene === null || scene === void 0 ? void 0 : scene.__webglSprites) === null || _a === void 0 ? void 0 : _a.forEach((sprite2) => {
                    if (inFront && sprite2.material.depthTest == false) {
                      sprites.push(sprite2);
                    } else if (!inFront && sprite2.material.depthTest) {
                      sprites.push(sprite2);
                    }
                  });
                  let nSprites = sprites.length;
                  if (!nSprites)
                    return;
                  const attributes = this.sprite.attributes;
                  const uniforms = this.sprite.uniforms;
                  if (!uniforms)
                    throw new Error("Uniforms not defined");
                  var halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;
                  this.gl.useProgram(this.sprite.program);
                  this.gl.enableVertexAttribArray(attributes.position);
                  this.gl.enableVertexAttribArray(attributes.uv);
                  this.gl.disable(this.gl.CULL_FACE);
                  this.gl.enable(this.gl.BLEND);
                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);
                  this.gl.vertexAttribPointer(attributes.position, 2, this.gl.FLOAT, false, 2 * 8, 0);
                  this.gl.vertexAttribPointer(attributes.uv, 2, this.gl.FLOAT, false, 2 * 8, 8);
                  this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);
                  this.gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
                  this.gl.activeTexture(this.gl.TEXTURE0);
                  this.gl.uniform1i(uniforms.map, 0);
                  var fog = scene.fog;
                  if (fog) {
                    this.gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                    this.gl.uniform1f(uniforms.fogNear, fog.near);
                    this.gl.uniform1f(uniforms.fogFar, fog.far);
                  } else {
                    this.gl.uniform1f(uniforms.fogNear, 0);
                    this.gl.uniform1f(uniforms.fogFar, 0);
                  }
                  var i;
                  let sprite;
                  let material;
                  let size;
                  let scale = [];
                  for (i = 0; i < nSprites; i++) {
                    sprite = sprites[i];
                    material = sprite.material;
                    if (!material)
                      continue;
                    if (material.depthTest == false && !inFront)
                      continue;
                    if (!sprite.visible || material.opacity === 0)
                      continue;
                    if (!material.useScreenCoordinates) {
                      sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                      sprite.z = -sprite._modelViewMatrix.elements[14];
                    } else {
                      sprite.z = -sprite.position.z;
                    }
                  }
                  sprites.sort(painterSortStable);
                  for (i = 0; i < nSprites; i++) {
                    sprite = sprites[i];
                    material = sprite.material;
                    if (!material)
                      continue;
                    if (!sprite.visible || material.opacity === 0)
                      continue;
                    if (material.map && material.map.image && material.map.image.width) {
                      this.gl.uniform1f((uniforms === null || uniforms === void 0 ? void 0 : uniforms.alphaTest) || null, material.alphaTest);
                      var w = material.map.image.width;
                      var h = material.map.image.height;
                      scale[0] = w * this.renderer.devicePixelRatio / viewportWidth;
                      scale[1] = h * this.renderer.devicePixelRatio / viewportHeight;
                      if (material.useScreenCoordinates === true) {
                        this.gl.uniform1i(uniforms.useScreenCoordinates, 1);
                        this.gl.uniform3f(uniforms.screenPosition, (sprite.position.x * this.renderer.devicePixelRatio - halfViewportWidth) / halfViewportWidth, (halfViewportHeight - sprite.position.y * this.renderer.devicePixelRatio) / halfViewportHeight, Math.max(0, Math.min(1, sprite.position.z)));
                      } else {
                        this.gl.uniform1i(uniforms.useScreenCoordinates, 0);
                        this.gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
                      }
                      size = 1 / (material.scaleByViewport ? viewportHeight : 1);
                      scale[0] *= size * sprite.scale.x;
                      scale[1] *= size * sprite.scale.y;
                      let alignx = (_b = material === null || material === void 0 ? void 0 : material.alignment) === null || _b === void 0 ? void 0 : _b.x, aligny = (_c = material === null || material === void 0 ? void 0 : material.alignment) === null || _c === void 0 ? void 0 : _c.y;
                      if (material.screenOffset) {
                        alignx = (alignx || 0) + 2 * material.screenOffset.x / w;
                        aligny = (aligny || 0) + 2 * material.screenOffset.y / h;
                      }
                      this.gl.uniform2f(uniforms.uvScale, ((_d = material === null || material === void 0 ? void 0 : material.uvScale) === null || _d === void 0 ? void 0 : _d.x) || 1, ((_e = material === null || material === void 0 ? void 0 : material.uvScale) === null || _e === void 0 ? void 0 : _e.y) || 1);
                      this.gl.uniform2f(uniforms.uvOffset, ((_f = material === null || material === void 0 ? void 0 : material.uvOffset) === null || _f === void 0 ? void 0 : _f.x) || 0, ((_g = material === null || material === void 0 ? void 0 : material.uvOffset) === null || _g === void 0 ? void 0 : _g.y) || 0);
                      this.gl.uniform2f(uniforms.alignment, alignx || 0, aligny || 0);
                      this.gl.uniform1f(uniforms.opacity, material.opacity);
                      this.gl.uniform3f(uniforms.color, ((_h = material === null || material === void 0 ? void 0 : material.color) === null || _h === void 0 ? void 0 : _h.r) || 0, ((_j = material === null || material === void 0 ? void 0 : material.color) === null || _j === void 0 ? void 0 : _j.g) || 0, ((_k = material === null || material === void 0 ? void 0 : material.color) === null || _k === void 0 ? void 0 : _k.b) || 0);
                      this.gl.uniform1f(uniforms.rotation, sprite.rotation);
                      this.gl.uniform2fv(uniforms.scale, scale);
                      this.renderer.setDepthTest(material.depthTest);
                      this.renderer.setDepthWrite(material.depthWrite);
                      this.renderer.setTexture(material.map, 0);
                      this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
                    }
                  }
                  this.gl.enable(this.gl.CULL_FACE);
                }
                createProgram(shader, precision) {
                  if (!this.gl)
                    throw new Error("WebGL Rendering context not found");
                  var program = this.gl.createProgram();
                  if (!program)
                    throw new Error("Error creating webgl program");
                  var fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
                  var vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
                  if (!fragmentShader)
                    throw new Error("Unable to create fragment shader SpritePlugin.createProgram");
                  if (!vertexShader)
                    throw new Error("Unable to create vertex shader SpritePlugin.createProgram");
                  var prefix = "precision " + precision + " float;\n";
                  this.gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
                  this.gl.shaderSource(vertexShader, prefix + shader.vertexShader);
                  this.gl.compileShader(fragmentShader);
                  this.gl.compileShader(vertexShader);
                  if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS) || !this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {
                    throw new Error(`Error compiling shader: 
      ${this.gl.getShaderInfoLog(fragmentShader)} 
      ${this.gl.getShaderInfoLog(vertexShader)}`);
                  }
                  this.gl.attachShader(program, fragmentShader);
                  this.gl.attachShader(program, vertexShader);
                  this.gl.linkProgram(program);
                  if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS))
                    console.error("Could not initialize shader");
                  return program;
                }
              }
              function painterSortStable(a, b) {
                if (a.z !== b.z) {
                  return b.z - a.z;
                } else {
                  return b.id - a.id;
                }
              }
            },
            /***/
            "./src/WebGL/constants/Coloring.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Coloring: () => (
                  /* binding */
                  Coloring
                )
                /* harmony export */
              });
              var Coloring;
              (function(Coloring2) {
                Coloring2[Coloring2["NoColors"] = 0] = "NoColors";
                Coloring2[Coloring2["FaceColors"] = 1] = "FaceColors";
                Coloring2[Coloring2["VertexColors"] = 2] = "VertexColors";
              })(Coloring || (Coloring = {}));
            },
            /***/
            "./src/WebGL/constants/Shading.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Shading: () => (
                  /* binding */
                  Shading
                )
                /* harmony export */
              });
              var Shading;
              (function(Shading2) {
                Shading2[Shading2["NoShading"] = 0] = "NoShading";
                Shading2[Shading2["FlatShading"] = 1] = "FlatShading";
                Shading2[Shading2["SmoothShading"] = 2] = "SmoothShading";
              })(Shading || (Shading = {}));
            },
            /***/
            "./src/WebGL/constants/Sides.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                BackSide: () => (
                  /* binding */
                  BackSide
                ),
                /* harmony export */
                DoubleSide: () => (
                  /* binding */
                  DoubleSide
                ),
                /* harmony export */
                FrontSide: () => (
                  /* binding */
                  FrontSide
                )
                /* harmony export */
              });
              const FrontSide = 0;
              const BackSide = 1;
              const DoubleSide = 2;
            },
            /***/
            "./src/WebGL/constants/SpriteAlignment.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SpriteAlignment: () => (
                  /* binding */
                  SpriteAlignment
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              const SpriteAlignment = {
                topLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, -1),
                topCenter: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, -1),
                topRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, -1),
                centerLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 0),
                center: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),
                centerRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, 0),
                bottomLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),
                bottomCenter: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 1),
                bottomRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, 1)
              };
            },
            /***/
            "./src/WebGL/constants/TextureConstants.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ClampToEdgeWrapping: () => (
                  /* binding */
                  ClampToEdgeWrapping
                ),
                /* harmony export */
                FloatType: () => (
                  /* binding */
                  FloatType
                ),
                /* harmony export */
                LinearFilter: () => (
                  /* binding */
                  LinearFilter
                ),
                /* harmony export */
                LinearMipMapLinearFilter: () => (
                  /* binding */
                  LinearMipMapLinearFilter
                ),
                /* harmony export */
                NearestFilter: () => (
                  /* binding */
                  NearestFilter
                ),
                /* harmony export */
                R32Format: () => (
                  /* binding */
                  R32Format
                ),
                /* harmony export */
                RFormat: () => (
                  /* binding */
                  RFormat
                ),
                /* harmony export */
                RGBAFormat: () => (
                  /* binding */
                  RGBAFormat
                ),
                /* harmony export */
                UnsignedByteType: () => (
                  /* binding */
                  UnsignedByteType
                )
                /* harmony export */
              });
              const ClampToEdgeWrapping = 1001;
              const LinearFilter = 1006;
              const NearestFilter = 1007;
              const LinearMipMapLinearFilter = 1008;
              const UnsignedByteType = 1009;
              const FloatType = 1010;
              const RGBAFormat = 1021;
              const RFormat = 1022;
              const R32Format = 1023;
            },
            /***/
            "./src/WebGL/constants/TextureOperations.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                TextureOperations: () => (
                  /* binding */
                  TextureOperations
                )
                /* harmony export */
              });
              var TextureOperations;
              (function(TextureOperations2) {
                TextureOperations2[TextureOperations2["MultiplyOperation"] = 0] = "MultiplyOperation";
                TextureOperations2[TextureOperations2["MixOperation"] = 1] = "MixOperation";
                TextureOperations2[TextureOperations2["AddOperation"] = 2] = "AddOperation";
              })(TextureOperations || (TextureOperations = {}));
            },
            /***/
            "./src/WebGL/constants/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                BackSide: () => (
                  /* reexport safe */
                  _Sides__WEBPACK_IMPORTED_MODULE_1__.BackSide
                ),
                /* harmony export */
                ClampToEdgeWrapping: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping
                ),
                /* harmony export */
                Coloring: () => (
                  /* reexport safe */
                  _Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring
                ),
                /* harmony export */
                DoubleSide: () => (
                  /* reexport safe */
                  _Sides__WEBPACK_IMPORTED_MODULE_1__.DoubleSide
                ),
                /* harmony export */
                FloatType: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.FloatType
                ),
                /* harmony export */
                FrontSide: () => (
                  /* reexport safe */
                  _Sides__WEBPACK_IMPORTED_MODULE_1__.FrontSide
                ),
                /* harmony export */
                LinearFilter: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.LinearFilter
                ),
                /* harmony export */
                LinearMipMapLinearFilter: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.LinearMipMapLinearFilter
                ),
                /* harmony export */
                NearestFilter: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.NearestFilter
                ),
                /* harmony export */
                R32Format: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.R32Format
                ),
                /* harmony export */
                RFormat: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.RFormat
                ),
                /* harmony export */
                RGBAFormat: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat
                ),
                /* harmony export */
                Shading: () => (
                  /* reexport safe */
                  _Shading__WEBPACK_IMPORTED_MODULE_2__.Shading
                ),
                /* harmony export */
                SpriteAlignment: () => (
                  /* reexport safe */
                  _SpriteAlignment__WEBPACK_IMPORTED_MODULE_3__.SpriteAlignment
                ),
                /* harmony export */
                TextureOperations: () => (
                  /* reexport safe */
                  _TextureOperations__WEBPACK_IMPORTED_MODULE_5__.TextureOperations
                ),
                /* harmony export */
                UnsignedByteType: () => (
                  /* reexport safe */
                  _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType
                )
                /* harmony export */
              });
              var _Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./Coloring */
                "./src/WebGL/constants/Coloring.ts"
              );
              var _Sides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Sides */
                "./src/WebGL/constants/Sides.ts"
              );
              var _Shading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Shading */
                "./src/WebGL/constants/Shading.ts"
              );
              var _SpriteAlignment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./SpriteAlignment */
                "./src/WebGL/constants/SpriteAlignment.ts"
              );
              var _TextureConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./TextureConstants */
                "./src/WebGL/constants/TextureConstants.ts"
              );
              var _TextureOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./TextureOperations */
                "./src/WebGL/constants/TextureOperations.ts"
              );
            },
            /***/
            "./src/WebGL/core/EventDispatcher.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                EventDispatcher: () => (
                  /* binding */
                  EventDispatcher
                )
                /* harmony export */
              });
              class EventDispatcher {
                constructor() {
                  this.listeners = {};
                }
                dispatchEvent(event) {
                  var listenerArray = this.listeners[event.type];
                  if (listenerArray !== void 0) {
                    event.target = this;
                    for (var i = 0, l = listenerArray.length; i < l; i++)
                      listenerArray[i].call(this, event);
                  }
                }
                removeEventListener(type, listener) {
                  if (!listener) {
                    this.listeners[type] = [];
                  } else {
                    var index = this.listeners[type].indexOf(listener);
                    if (index !== -1)
                      this.listeners[type].splice(index, 1);
                  }
                }
                addEventListener(type, listener) {
                  if (this.listeners[type] === void 0)
                    this.listeners[type] = [];
                  if (this.listeners[type].indexOf(listener) === -1)
                    this.listeners[type].push(listener);
                }
              }
            },
            /***/
            "./src/WebGL/core/Geometry.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Geometry: () => (
                  /* binding */
                  Geometry
                ),
                /* harmony export */
                GeometryGroup: () => (
                  /* binding */
                  GeometryGroup
                ),
                /* harmony export */
                GeometryIDCount: () => (
                  /* binding */
                  GeometryIDCount
                )
                /* harmony export */
              });
              var _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../materials/LineBasicMaterial */
                "./src/WebGL/materials/LineBasicMaterial.ts"
              );
              var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./EventDispatcher */
                "./src/WebGL/core/EventDispatcher.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              const BUFFERSIZE = 65535;
              class GeometryGroup {
                constructor(id = 0) {
                  this.vertexArray = null;
                  this.colorArray = null;
                  this.normalArray = null;
                  this.radiusArray = null;
                  this.faceArray = null;
                  this.lineArray = null;
                  this.atomArray = Array();
                  this.vertices = 0;
                  this.faceidx = 0;
                  this.lineidx = 0;
                  this.__inittedArrays = false;
                  this.id = id;
                }
                setColor(color) {
                  var v = this.vertexArray;
                  var c = this.colorArray;
                  if (!v)
                    throw new Error("vertex array not initialized");
                  if (!c)
                    throw new Error("color array not initialized");
                  let col = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(color);
                  for (var i = 0; i < v.length; i += 3) {
                    c[i] = col.r;
                    c[i + 1] = col.g;
                    c[i + 2] = col.b;
                  }
                }
                setColors(setcolor) {
                  var v = this.vertexArray;
                  var c = this.colorArray;
                  if (!v)
                    throw new Error("vertex array not initialized");
                  if (!c)
                    throw new Error("color array not initialized");
                  if (v.length != c.length) {
                    console.log("Cannot re-color geometry group due to mismatched lengths.");
                    return;
                  }
                  for (var i = 0; i < v.length; i += 3) {
                    var col = setcolor(v[i], v[i + 1], v[i + 2]);
                    if (!(col instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color)) {
                      col = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(col);
                    }
                    c[i] = col.r;
                    c[i + 1] = col.g;
                    c[i + 2] = col.b;
                  }
                }
                getNumVertices() {
                  return this.vertices;
                }
                getVertices() {
                  return this.vertexArray;
                }
                getCentroid() {
                  if (!this.vertexArray)
                    throw new Error("vertex array not initialized");
                  var centroid = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3();
                  var offset, x, y, z;
                  for (var i = 0; i < this.vertices; ++i) {
                    offset = i * 3;
                    x = this.vertexArray[offset];
                    y = this.vertexArray[offset + 1];
                    z = this.vertexArray[offset + 2];
                    centroid.x += x;
                    centroid.y += y;
                    centroid.z += z;
                  }
                  centroid.divideScalar(this.vertices);
                  return centroid;
                }
                //setup normals - vertex and face array must exist
                setNormals() {
                  var faces = this.faceArray;
                  var verts = this.vertexArray;
                  var norms = this.normalArray;
                  if (!this.vertices || !this.faceidx)
                    return;
                  if (!faces)
                    throw new Error("face array not initialized");
                  if (!verts)
                    throw new Error("vertex array not initialized");
                  if (!norms)
                    throw new Error("normal array not initialized");
                  var a, b, c, vA, vB, vC, norm;
                  for (var i = 0; i < faces.length / 3; ++i) {
                    a = faces[i * 3] * 3;
                    b = faces[i * 3 + 1] * 3;
                    c = faces[i * 3 + 2] * 3;
                    vA = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[a], verts[a + 1], verts[a + 2]);
                    vB = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[b], verts[b + 1], verts[b + 2]);
                    vC = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[c], verts[c + 1], verts[c + 2]);
                    vA.subVectors(vA, vB);
                    vC.subVectors(vC, vB);
                    vC.cross(vA);
                    norm = vC;
                    norm.normalize();
                    norms[a] += norm.x;
                    norms[b] += norm.x;
                    norms[c] += norm.x;
                    norms[a + 1] += norm.y;
                    norms[b + 1] += norm.y;
                    norms[c + 1] += norm.y;
                    norms[a + 2] += norm.z;
                    norms[b + 2] += norm.z;
                    norms[c + 2] += norm.z;
                  }
                }
                /* sets line index array from face arr
                Note - assumes all faces are triangles (i.e. there will
                be an extra diagonal for four-sided faces - user should
                specify linearr for custom shape generation to show wireframe squares
                as rectangles rather than two triangles) */
                setLineIndices() {
                  if (!this.faceidx)
                    return;
                  if (this.lineArray && this.lineArray.length == this.faceidx * 2 && this.lineidx == this.faceidx * 2)
                    return;
                  var faceArr = this.faceArray, lineArr = this.lineArray = new Uint16Array(this.faceidx * 2);
                  this.lineidx = this.faceidx * 2;
                  if (!faceArr)
                    throw new Error("face array not initialized");
                  for (var i = 0; i < this.faceidx / 3; ++i) {
                    var faceoffset = i * 3;
                    var lineoffset = faceoffset * 2;
                    var a = faceArr[faceoffset], b = faceArr[faceoffset + 1], c = faceArr[faceoffset + 2];
                    lineArr[lineoffset] = a;
                    lineArr[lineoffset + 1] = b;
                    lineArr[lineoffset + 2] = a;
                    lineArr[lineoffset + 3] = c;
                    lineArr[lineoffset + 4] = b;
                    lineArr[lineoffset + 5] = c;
                  }
                }
                vrml(indent, material) {
                  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
                  var ret = "";
                  ret += indent + "Shape {\n" + indent + " appearance Appearance {\n" + indent + "  material Material {\n" + indent + "   diffuseColor " + ((_a = material === null || material === void 0 ? void 0 : material.color) === null || _a === void 0 ? void 0 : _a.r) + " " + ((_b = material === null || material === void 0 ? void 0 : material.color) === null || _b === void 0 ? void 0 : _b.g) + " " + ((_c = material === null || material === void 0 ? void 0 : material.color) === null || _c === void 0 ? void 0 : _c.b) + "\n";
                  if (material.wireframe && this.colorArray) {
                    let c = this.colorArray;
                    ret += indent + "    emissiveColor " + c[0] + " " + c[1] + " " + c[2] + "\n";
                  }
                  if (material === null || material === void 0 ? void 0 : material.transparent) {
                    ret += indent + "   transparency " + (1 - material.opacity) + "\n";
                  }
                  ret += indent + "  }\n";
                  ret += indent + " }\n";
                  var oldindent = indent;
                  indent += " ";
                  if (material instanceof _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial || material.wireframe) {
                    ret += indent + "geometry IndexedLineSet {\n" + indent + " colorPerVertex TRUE\n" + indent + " coord Coordinate {\n" + indent + "  point [\n";
                    let x, y, z;
                    for (let i = 0; i < this.vertices; ++i) {
                      let offset = i * 3;
                      x = (_d = this.vertexArray) === null || _d === void 0 ? void 0 : _d[offset];
                      y = (_e = this.vertexArray) === null || _e === void 0 ? void 0 : _e[offset + 1];
                      z = (_f = this.vertexArray) === null || _f === void 0 ? void 0 : _f[offset + 2];
                      ret += indent + "   " + x + " " + y + " " + z + ",\n";
                    }
                    ret += indent + "  ]\n";
                    ret += indent + " }\n";
                    if (this.colorArray && !material.wireframe) {
                      ret += indent + " color Color {\n" + indent + "  color [\n";
                      for (let i = 0; i < this.vertices; ++i) {
                        let offset = i * 3;
                        x = this.colorArray[offset];
                        y = this.colorArray[offset + 1];
                        z = this.colorArray[offset + 2];
                        ret += indent + "   " + x + " " + y + " " + z + ",\n";
                      }
                      ret += indent + "  ]\n";
                      ret += indent + " }\n";
                    }
                    ret += indent + " coordIndex [\n";
                    if (material.wireframe && this.faceArray) {
                      for (let i = 0; i < this.faceidx; i += 3) {
                        x = (_g = this.faceArray) === null || _g === void 0 ? void 0 : _g[i];
                        y = (_h = this.faceArray) === null || _h === void 0 ? void 0 : _h[i + 1];
                        z = (_j = this.faceArray) === null || _j === void 0 ? void 0 : _j[i + 2];
                        ret += indent + "  " + x + ", " + y + ", " + z + ", -1,\n";
                      }
                    } else {
                      for (let i = 0; i < this.vertices - 1; i += 2) {
                        ret += indent + "  " + i + ", " + (i + 1) + ", -1,\n";
                      }
                    }
                    ret += indent + " ]\n";
                    ret += indent + "}\n";
                  } else {
                    ret += indent + "geometry IndexedFaceSet {\n" + indent + " colorPerVertex TRUE\n" + indent + " normalPerVertex TRUE\n" + indent + " solid FALSE\n";
                    ret += indent + " coord Coordinate {\n" + indent + "  point [\n";
                    let x, y, z;
                    for (let i = 0; i < this.vertices; ++i) {
                      let offset = i * 3;
                      x = (_k = this.vertexArray) === null || _k === void 0 ? void 0 : _k[offset];
                      y = (_l = this.vertexArray) === null || _l === void 0 ? void 0 : _l[offset + 1];
                      z = (_m = this.vertexArray) === null || _m === void 0 ? void 0 : _m[offset + 2];
                      ret += indent + "   " + x + " " + y + " " + z + ",\n";
                    }
                    ret += indent + "  ]\n";
                    ret += indent + " }\n";
                    ret += indent + " normal Normal {\n" + indent + "  vector [\n";
                    for (let i = 0; i < this.vertices; ++i) {
                      let offset = i * 3;
                      x = (_o = this.normalArray) === null || _o === void 0 ? void 0 : _o[offset];
                      y = (_p = this.normalArray) === null || _p === void 0 ? void 0 : _p[offset + 1];
                      z = (_q = this.normalArray) === null || _q === void 0 ? void 0 : _q[offset + 2];
                      ret += indent + "   " + x + " " + y + " " + z + ",\n";
                    }
                    ret += indent + "  ]\n";
                    ret += indent + " }\n";
                    if (this.colorArray) {
                      ret += indent + " color Color {\n" + indent + "  color [\n";
                      for (let i = 0; i < this.vertices; ++i) {
                        let offset = i * 3;
                        x = this.colorArray[offset];
                        y = this.colorArray[offset + 1];
                        z = this.colorArray[offset + 2];
                        ret += indent + "   " + x + " " + y + " " + z + ",\n";
                      }
                      ret += indent + "  ]\n";
                      ret += indent + " }\n";
                    }
                    ret += indent + " coordIndex [\n";
                    for (let i = 0; i < this.faceidx; i += 3) {
                      x = (_r = this.faceArray) === null || _r === void 0 ? void 0 : _r[i];
                      y = (_s = this.faceArray) === null || _s === void 0 ? void 0 : _s[i + 1];
                      z = (_t = this.faceArray) === null || _t === void 0 ? void 0 : _t[i + 2];
                      ret += indent + "  " + x + ", " + y + ", " + z + ", -1,\n";
                    }
                    ret += indent + " ]\n";
                    ret += indent + "}\n";
                  }
                  ret += oldindent + "}";
                  return ret;
                }
                truncateArrayBuffers(mesh = true, reallocatemem = false) {
                  var vertexArr = this.vertexArray, colorArr = this.colorArray, normalArr = this.normalArray, faceArr = this.faceArray, lineArr = this.lineArray, radiusArr = this.radiusArray;
                  this.vertexArray = (vertexArr === null || vertexArr === void 0 ? void 0 : vertexArr.subarray(0, this.vertices * 3)) || null;
                  this.colorArray = (colorArr === null || colorArr === void 0 ? void 0 : colorArr.subarray(0, this.vertices * 3)) || null;
                  if (mesh) {
                    this.normalArray = (normalArr === null || normalArr === void 0 ? void 0 : normalArr.subarray(0, this.vertices * 3)) || null;
                    this.faceArray = (faceArr === null || faceArr === void 0 ? void 0 : faceArr.subarray(0, this.faceidx)) || null;
                    if (this.lineidx > 0)
                      this.lineArray = (lineArr === null || lineArr === void 0 ? void 0 : lineArr.subarray(0, this.lineidx)) || null;
                    else
                      this.lineArray = new Uint16Array(0);
                  } else {
                    this.normalArray = new Float32Array(0);
                    this.faceArray = new Uint16Array(0);
                    this.lineArray = new Uint16Array(0);
                  }
                  if (radiusArr) {
                    this.radiusArray = radiusArr.subarray(0, this.vertices);
                  }
                  if (reallocatemem) {
                    if (this.normalArray)
                      this.normalArray = new Float32Array(this.normalArray);
                    if (this.faceArray)
                      this.faceArray = new Uint16Array(this.faceArray);
                    if (this.lineArray)
                      this.lineArray = new Uint16Array(this.lineArray);
                    if (this.vertexArray)
                      this.vertexArray = new Float32Array(this.vertexArray);
                    if (this.colorArray)
                      this.colorArray = new Float32Array(this.colorArray);
                    if (this.radiusArray)
                      this.radiusArray = new Float32Array(this.radiusArray);
                  }
                  this.__inittedArrays = true;
                }
              }
              class Geometry extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
                constructor(mesh = false, radii = false, offset = false) {
                  super();
                  this.name = "";
                  this.hasTangents = false;
                  this.dynamic = true;
                  this.verticesNeedUpdate = false;
                  this.elementsNeedUpdate = false;
                  this.normalsNeedUpdate = false;
                  this.colorsNeedUpdate = false;
                  this.buffersNeedUpdate = false;
                  this.imposter = false;
                  this.instanced = false;
                  this.geometryGroups = [];
                  this.groups = 0;
                  this.id = GeometryIDCount++;
                  this.mesh = mesh;
                  this.radii = radii;
                  this.offset = offset;
                }
                //Get geometry group to accomodate addVertices new vertices - create
                // new group if necessary
                updateGeoGroup(addVertices = 0) {
                  var _a;
                  var retGroup = this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;
                  if (!retGroup || retGroup.vertices + addVertices > (((_a = retGroup === null || retGroup === void 0 ? void 0 : retGroup.vertexArray) === null || _a === void 0 ? void 0 : _a.length) || 0) / 3)
                    retGroup = this.addGeoGroup();
                  return retGroup;
                }
                //return comma separated list of IndexedFace (or Line) sets from geometry groups
                vrml(indent, material) {
                  var ret = "";
                  var len = this.geometryGroups.length;
                  for (var g = 0; g < len; g++) {
                    var geoGroup = this.geometryGroups[g];
                    ret += geoGroup.vrml(indent, material) + ",\n";
                  }
                  return ret;
                }
                addGeoGroup() {
                  var ret = new GeometryGroup(this.geometryGroups.length);
                  this.geometryGroups.push(ret);
                  this.groups = this.geometryGroups.length;
                  ret.vertexArray = new Float32Array(BUFFERSIZE * 3);
                  ret.colorArray = new Float32Array(BUFFERSIZE * 3);
                  if (this.mesh) {
                    ret.normalArray = new Float32Array(BUFFERSIZE * 3);
                    ret.faceArray = new Uint16Array(BUFFERSIZE * 6);
                    ret.lineArray = new Uint16Array(BUFFERSIZE * 6);
                  }
                  if (this.radii) {
                    ret.radiusArray = new Float32Array(BUFFERSIZE);
                  }
                  ret.useOffset = this.offset;
                  return ret;
                }
                setUpNormals(...args) {
                  for (var g = 0; g < this.groups; g++) {
                    var geoGroup = this.geometryGroups[g];
                    geoGroup.setNormals(...args);
                  }
                }
                setColors(...setcolor) {
                  var len = this.geometryGroups.length;
                  for (var g = 0; g < len; g++) {
                    var geoGroup = this.geometryGroups[g];
                    geoGroup.setColors(...setcolor);
                  }
                }
                setColor(...setcolor) {
                  let len = this.geometryGroups.length;
                  for (var g = 0; g < len; g++) {
                    var geoGroup = this.geometryGroups[g];
                    geoGroup.setColor(...setcolor);
                  }
                }
                setUpWireframe(...lineIndexArgs) {
                  let len = this.geometryGroups.length;
                  for (var g = 0; g < len; g++) {
                    var geoGroup = this.geometryGroups[g];
                    geoGroup.setLineIndices(...lineIndexArgs);
                  }
                }
                //After vertices, colors, etc are collected in regular or typed arrays,
                //  create typed arrays from regular arrays if they don't already exist,
                initTypedArrays() {
                  for (var g = 0; g < this.groups; g++) {
                    var group = this.geometryGroups[g];
                    if (group.__inittedArrays === true)
                      continue;
                    group.truncateArrayBuffers(this.mesh, false);
                  }
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
                get vertices() {
                  var vertices = 0;
                  for (var g = 0; g < this.groups; g++)
                    vertices += this.geometryGroups[g].vertices;
                  return vertices;
                }
              }
              let GeometryIDCount = 0;
            },
            /***/
            "./src/WebGL/core/Object3D.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Light: () => (
                  /* binding */
                  Light
                ),
                /* harmony export */
                Object3D: () => (
                  /* binding */
                  Object3D
                ),
                /* harmony export */
                Object3DIDCount: () => (
                  /* binding */
                  Object3DIDCount
                ),
                /* harmony export */
                Scene: () => (
                  /* binding */
                  Scene
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              let Object3DIDCount = 0;
              class Object3D {
                constructor() {
                  this.id = Object3DIDCount++;
                  this.name = "";
                  this.children = [];
                  this.position = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                  this.rotation = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                  this.matrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                  this.matrixWorld = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                  this.quaternion = new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
                  this.eulerOrder = "XYZ";
                  this.up = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
                  this.scale = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);
                  this.matrixAutoUpdate = true;
                  this.matrixWorldNeedsUpdate = true;
                  this.rotationAutoUpdate = true;
                  this.useQuaternion = false;
                  this.visible = true;
                }
                lookAt(vector) {
                  this.matrix.lookAt(vector, this.position, this.up);
                  if (this.rotationAutoUpdate) {
                    if (this.useQuaternion === true)
                      console.error("Unimplemented math operation.");
                    else if (this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3)
                      this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);
                  }
                }
                //add child object
                add(object) {
                  if (object === this) {
                    console.error("Can't add $3Dmol.Object3D to itself");
                    return;
                  }
                  object.parent = this;
                  this.children.push(object);
                  var scene = this;
                  while (scene.parent !== void 0)
                    scene = scene.parent;
                  if (scene !== void 0 && scene instanceof Scene)
                    scene.__addObject(object);
                }
                remove(object) {
                  var index = this.children.indexOf(object);
                  if (index !== -1) {
                    object.parent = void 0;
                    this.children.splice(index, 1);
                    var scene = this;
                    while (scene.parent !== void 0)
                      scene = scene.parent;
                    if (scene !== void 0 && scene instanceof Scene)
                      scene.__removeObject(object);
                  }
                }
                //convert to vrml
                vrml(indent) {
                  if (!indent)
                    indent = " ";
                  var theta = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w);
                  var x = 0, y = 0, z = 0;
                  if (theta != 0) {
                    let st = Math.sin(theta / 2);
                    x = this.quaternion.x / st;
                    y = this.quaternion.y / st;
                    z = this.quaternion.z / st;
                  }
                  var ret = indent + "Transform {\n" + indent + " center " + this.position.x + " " + this.position.y + " " + this.position.z + "\n" + indent + " rotation " + x + " " + y + " " + z + " " + theta + "\n" + indent + " children [\n";
                  if (this.geometry) {
                    ret += this.geometry.vrml(indent, this.material);
                  }
                  for (var i = 0; i < this.children.length; i++) {
                    ret += this.children[i].vrml(indent + " ") + ",\n";
                  }
                  ret += " ]\n";
                  ret += "}";
                  return ret;
                }
                updateMatrix() {
                  this.matrix.setPosition(this.position);
                  if (this.useQuaternion === false && this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3) {
                    this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder);
                  } else {
                    this.matrix.setRotationFromQuaternion(this.quaternion);
                  }
                  if (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1)
                    this.matrix.scale(this.scale);
                  this.matrixWorldNeedsUpdate = true;
                }
                updateMatrixWorld(force) {
                  if (this.matrixAutoUpdate === true)
                    this.updateMatrix();
                  if (this.matrixWorldNeedsUpdate === true || force === true) {
                    if (this.parent === void 0)
                      this.matrixWorld.copy(this.matrix);
                    else
                      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                  }
                  this.matrixWorldNeedsUpdate = false;
                  for (var i = 0; i < this.children.length; i++) {
                    this.children[i].updateMatrixWorld(true);
                  }
                }
                clone(object) {
                  if (object === void 0)
                    object = new Object3D();
                  object.name = this.name;
                  object.up.copy(this.up);
                  object.position.copy(this.position);
                  if (object.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3 && this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3) {
                    object.rotation.copy(this.rotation);
                  } else {
                    object.rotation = this.rotation;
                  }
                  object.eulerOrder = this.eulerOrder;
                  object.scale.copy(this.scale);
                  object.rotationAutoUpdate = this.rotationAutoUpdate;
                  object.matrix.copy(this.matrix);
                  object.matrixWorld.copy(this.matrixWorld);
                  object.quaternion.copy(this.quaternion);
                  object.matrixAutoUpdate = this.matrixAutoUpdate;
                  object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
                  object.useQuaternion = this.useQuaternion;
                  object.visible = this.visible;
                  for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    object.add(child.clone());
                  }
                  return object;
                }
                setVisible(val) {
                  this.visible = val;
                  for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    child.setVisible(val);
                  }
                }
              }
              class Scene extends Object3D {
                constructor() {
                  super(...arguments);
                  this.fog = null;
                  this.overrideMaterial = null;
                  this.matrixAutoUpdate = false;
                  this.__objects = [];
                  this.__lights = [];
                  this.__objectsAdded = [];
                  this.__objectsRemoved = [];
                }
                __addObject(object) {
                  if (object instanceof Light) {
                    if (this.__lights.indexOf(object) === -1)
                      this.__lights.push(object);
                    if (object.target && object.target.parent === void 0)
                      this.add(object.target);
                  } else {
                    if (this.__objects.indexOf(object) === -1) {
                      this.__objects.push(object);
                      this.__objectsAdded.push(object);
                      var idx = this.__objectsRemoved.indexOf(object);
                      if (idx !== -1)
                        this.__objectsRemoved.splice(idx, 1);
                    }
                  }
                  for (var i = 0; i < object.children.length; i++)
                    this.__addObject(object.children[i]);
                }
                __removeObject(object) {
                  var idx;
                  if (object instanceof Light) {
                    idx = this.__lights.indexOf(object);
                    if (idx !== -1)
                      this.__lights.splice(idx, 1);
                  } else {
                    idx = this.__objects.indexOf(object);
                    if (idx !== -1) {
                      this.__objects.splice(idx, 1);
                      this.__objectsRemoved.push(object);
                      var ai = this.__objectsAdded.indexOf(object);
                      if (ai !== -1)
                        this.__objectsAdded.splice(idx, 1);
                    }
                  }
                  for (var i = 0; i < object.children.length; i++)
                    this.__removeObject(object.children[i]);
                }
              }
              class Light extends Object3D {
                constructor(hex, intensity = 1) {
                  super();
                  this.position = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
                  this.target = new Object3D();
                  this.castShadow = false;
                  this.onlyShadow = false;
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_1__.Color(hex);
                  this.intensity = intensity;
                }
              }
            },
            /***/
            "./src/WebGL/core/Projector.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Projector: () => (
                  /* binding */
                  Projector
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              const viewProjectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
              class Projector {
                static unprojectVector(vector, camera) {
                  camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);
                  viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);
                  return vector.applyProjection(viewProjectionMatrix);
                }
                static projectVector(vector, camera) {
                  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
                  viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                  return vector.applyProjection(viewProjectionMatrix);
                }
                projectVector(vector, camera) {
                  return Projector.projectVector(vector, camera);
                }
                unprojectVector(vector, camera) {
                  return Projector.unprojectVector(vector, camera);
                }
              }
            },
            /***/
            "./src/WebGL/core/Raycaster.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Raycaster: () => (
                  /* binding */
                  Raycaster
                ),
                /* harmony export */
                intersectObject: () => (
                  /* binding */
                  intersectObject
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../shapes */
                "./src/WebGL/shapes/index.ts"
              );
              const descSort = (a, b) => {
                return a.distance - b.distance;
              };
              const viewProjectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
              class Raycaster {
                constructor(origin, direction, far, near) {
                  this.precision = 1e-4;
                  this.linePrecision = 0.2;
                  this.ray = new _math__WEBPACK_IMPORTED_MODULE_0__.Ray(origin, direction);
                  if (this.ray.direction.lengthSq() > 0)
                    this.ray.direction.normalize();
                  this.near = near || 0;
                  this.far = far || Infinity;
                }
                set(origin, direction) {
                  this.ray.set(origin, direction);
                }
                setFromCamera(coords, camera) {
                  if (!camera.ortho) {
                    this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                    this.ray.direction.set(coords.x, coords.y, coords.z);
                    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);
                    viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);
                    this.ray.direction.applyProjection(viewProjectionMatrix);
                    this.ray.direction.sub(this.ray.origin).normalize();
                  } else {
                    this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                    this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                  }
                }
                intersectObjects(group, objects) {
                  var intersects = [];
                  for (var i = 0, l = objects.length; i < l; i++)
                    intersectObject(group, objects[i], this, intersects);
                  intersects.sort(descSort);
                  return intersects;
                }
              }
              const clamp = (x) => {
                return Math.min(Math.max(x, -1), 1);
              };
              var sphere = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere();
              var cylinder = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder();
              var triangle = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle();
              var w_0 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              var v1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              var v2 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              var v3 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              var matrixPosition = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              function intersectObject(group, clickable, raycaster, intersects) {
                matrixPosition.getPositionFromMatrix(group.matrixWorld);
                if (clickable.intersectionShape === void 0)
                  return intersects;
                if (clickable.hidden)
                  return intersects;
                var intersectionShape = clickable.intersectionShape;
                var precision = raycaster.linePrecision;
                precision *= group.matrixWorld.getMaxScaleOnAxis();
                var precisionSq = precision * precision;
                if (clickable.boundingSphere !== void 0 && clickable.boundingSphere instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere) {
                  sphere.copy(clickable.boundingSphere);
                  sphere.applyMatrix4(group.matrixWorld);
                  if (!raycaster.ray.isIntersectionSphere(sphere)) {
                    return intersects;
                  }
                }
                var i, il, norm, normProj, cylProj, rayProj, distance, closestDistSq, denom, discriminant, s, t, s_c, t_c;
                for (i = 0, il = intersectionShape.triangle.length; i < il; i++) {
                  if (intersectionShape.triangle[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle) {
                    triangle.copy(intersectionShape.triangle[i]);
                    triangle.applyMatrix4(group.matrixWorld);
                    norm = triangle.getNormal();
                    normProj = raycaster.ray.direction.dot(norm);
                    if (normProj >= 0)
                      continue;
                    w_0.subVectors(triangle.a, raycaster.ray.origin);
                    distance = norm.dot(w_0) / normProj;
                    if (distance < 0)
                      continue;
                    v1.copy(raycaster.ray.direction).multiplyScalar(distance).add(raycaster.ray.origin);
                    v1.sub(triangle.a);
                    v2.copy(triangle.b).sub(triangle.a);
                    v3.copy(triangle.c).sub(triangle.a);
                    var b_dot_c = v2.dot(v3);
                    var b_sq = v2.lengthSq();
                    var c_sq = v3.lengthSq();
                    t = (b_sq * v1.dot(v3) - b_dot_c * v1.dot(v2)) / (b_sq * c_sq - b_dot_c * b_dot_c);
                    if (t < 0 || t > 1)
                      continue;
                    s = (v1.dot(v2) - t * b_dot_c) / b_sq;
                    if (s < 0 || s > 1 || s + t > 1)
                      continue;
                    else {
                      intersects.push({ clickable, distance });
                    }
                  }
                }
                for (i = 0, il = intersectionShape.cylinder.length; i < il; i++) {
                  if (intersectionShape.cylinder[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder) {
                    cylinder.copy(intersectionShape.cylinder[i]);
                    cylinder.applyMatrix4(group.matrixWorld);
                    w_0.subVectors(cylinder.c1, raycaster.ray.origin);
                    cylProj = w_0.dot(cylinder.direction);
                    rayProj = w_0.dot(raycaster.ray.direction);
                    normProj = clamp(raycaster.ray.direction.dot(cylinder.direction));
                    denom = 1 - normProj * normProj;
                    if (denom === 0)
                      continue;
                    s_c = (normProj * rayProj - cylProj) / denom;
                    t_c = (rayProj - normProj * cylProj) / denom;
                    v1.copy(cylinder.direction).multiplyScalar(s_c).add(cylinder.c1);
                    v2.copy(raycaster.ray.direction).multiplyScalar(t_c).add(raycaster.ray.origin);
                    closestDistSq = v3.subVectors(v1, v2).lengthSq();
                    var radiusSq = cylinder.radius * cylinder.radius;
                    if (closestDistSq <= radiusSq) {
                      discriminant = (normProj * cylProj - rayProj) * (normProj * cylProj - rayProj) - denom * (w_0.lengthSq() - cylProj * cylProj - radiusSq);
                      if (discriminant <= 0)
                        t = distance = Math.sqrt(closestDistSq);
                      else
                        t = distance = (rayProj - normProj * cylProj - Math.sqrt(discriminant)) / denom;
                      s = normProj * t - cylProj;
                      if (s < 0 || s * s > cylinder.lengthSq() || t < 0)
                        continue;
                      else
                        intersects.push({ clickable, distance });
                    }
                  }
                }
                for (i = 0, il = intersectionShape.line.length; i < il; i += 2) {
                  v1.copy(intersectionShape.line[i]);
                  v1.applyMatrix4(group.matrixWorld);
                  v2.copy(intersectionShape.line[i + 1]);
                  v2.applyMatrix4(group.matrixWorld);
                  v3.subVectors(v2, v1);
                  var bondLengthSq = v3.lengthSq();
                  v3.normalize();
                  w_0.subVectors(v1, raycaster.ray.origin);
                  var lineProj = w_0.dot(v3);
                  rayProj = w_0.dot(raycaster.ray.direction);
                  normProj = clamp(raycaster.ray.direction.dot(v3));
                  denom = 1 - normProj * normProj;
                  if (denom === 0)
                    continue;
                  s_c = (normProj * rayProj - lineProj) / denom;
                  t_c = (rayProj - normProj * lineProj) / denom;
                  v1.add(v3.multiplyScalar(s_c));
                  v2.copy(raycaster.ray.direction).multiplyScalar(t_c).add(raycaster.ray.origin);
                  closestDistSq = v3.subVectors(v2, v1).lengthSq();
                  if (closestDistSq < precisionSq && s_c * s_c < bondLengthSq)
                    intersects.push({ clickable, distance: t_c });
                }
                for (i = 0, il = intersectionShape.sphere.length; i < il; i++) {
                  if (intersectionShape.sphere[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere) {
                    sphere.copy(intersectionShape.sphere[i]);
                    sphere.applyMatrix4(group.matrixWorld);
                    if (raycaster.ray.isIntersectionSphere(sphere)) {
                      v1.subVectors(sphere.center, raycaster.ray.origin);
                      var distanceToCenter = v1.dot(raycaster.ray.direction);
                      discriminant = distanceToCenter * distanceToCenter - (v1.lengthSq() - sphere.radius * sphere.radius);
                      if (distanceToCenter < 0)
                        return intersects;
                      if (discriminant <= 0)
                        distance = distanceToCenter;
                      else
                        distance = distanceToCenter - Math.sqrt(discriminant);
                      intersects.push({ clickable, distance });
                    }
                  }
                }
                return intersects;
              }
              ;
            },
            /***/
            "./src/WebGL/core/Texture.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Texture: () => (
                  /* binding */
                  Texture
                ),
                /* harmony export */
                TextureIdCount: () => (
                  /* binding */
                  TextureIdCount
                )
                /* harmony export */
              });
              var _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../constants/TextureConstants */
                "./src/WebGL/constants/TextureConstants.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./EventDispatcher */
                "./src/WebGL/core/EventDispatcher.ts"
              );
              var _UVMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./UVMapping */
                "./src/WebGL/core/UVMapping.ts"
              );
              class Texture extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__.EventDispatcher {
                constructor(image, is3D) {
                  super();
                  this.id = TextureIdCount++;
                  this.name = "";
                  this.image = image;
                  this.mapping = new _UVMapping__WEBPACK_IMPORTED_MODULE_3__.UVMapping();
                  this.wrapS = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;
                  this.wrapT = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;
                  this.anisotropy = 1;
                  if (is3D) {
                    this.format = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.RFormat;
                    this.type = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.FloatType;
                    this.premultiplyAlpha = false;
                    this.flipY = false;
                    this.unpackAlignment = 1;
                    this.magFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;
                    this.minFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;
                  } else {
                    this.format = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;
                    this.type = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;
                    this.offset = new _math__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0);
                    this.repeat = new _math__WEBPACK_IMPORTED_MODULE_1__.Vector2(1, 1);
                    this.premultiplyAlpha = false;
                    this.flipY = true;
                    this.unpackAlignment = 4;
                    this.magFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
                    this.minFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter;
                  }
                  this.needsUpdate = false;
                  this.onUpdate = null;
                }
                clone(texture = new Texture()) {
                  texture.image = this.image;
                  texture.mapping = this.mapping;
                  texture.wrapS = this.wrapS;
                  texture.wrapT = this.wrapT;
                  texture.magFilter = this.magFilter;
                  texture.minFilter = this.minFilter;
                  texture.anisotropy = this.anisotropy;
                  texture.format = this.format;
                  texture.type = this.type;
                  texture.offset.copy(this.offset);
                  texture.repeat.copy(this.repeat);
                  texture.premultiplyAlpha = this.premultiplyAlpha;
                  texture.flipY = this.flipY;
                  texture.unpackAlignment = this.unpackAlignment;
                  return texture;
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
              }
              let TextureIdCount = 0;
            },
            /***/
            "./src/WebGL/core/UVMapping.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                UVMapping: () => (
                  /* binding */
                  UVMapping
                )
                /* harmony export */
              });
              class UVMapping {
              }
              ;
            },
            /***/
            "./src/WebGL/core/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                EventDispatcher: () => (
                  /* reexport safe */
                  _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher
                ),
                /* harmony export */
                Geometry: () => (
                  /* reexport safe */
                  _Geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry
                ),
                /* harmony export */
                GeometryGroup: () => (
                  /* reexport safe */
                  _Geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryGroup
                ),
                /* harmony export */
                GeometryIDCount: () => (
                  /* reexport safe */
                  _Geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryIDCount
                ),
                /* harmony export */
                Light: () => (
                  /* reexport safe */
                  _Object3D__WEBPACK_IMPORTED_MODULE_2__.Light
                ),
                /* harmony export */
                Object3D: () => (
                  /* reexport safe */
                  _Object3D__WEBPACK_IMPORTED_MODULE_2__.Object3D
                ),
                /* harmony export */
                Object3DIDCount: () => (
                  /* reexport safe */
                  _Object3D__WEBPACK_IMPORTED_MODULE_2__.Object3DIDCount
                ),
                /* harmony export */
                Projector: () => (
                  /* reexport safe */
                  _Projector__WEBPACK_IMPORTED_MODULE_3__.Projector
                ),
                /* harmony export */
                Raycaster: () => (
                  /* reexport safe */
                  _Raycaster__WEBPACK_IMPORTED_MODULE_4__.Raycaster
                ),
                /* harmony export */
                Scene: () => (
                  /* reexport safe */
                  _Object3D__WEBPACK_IMPORTED_MODULE_2__.Scene
                ),
                /* harmony export */
                Texture: () => (
                  /* reexport safe */
                  _Texture__WEBPACK_IMPORTED_MODULE_5__.Texture
                ),
                /* harmony export */
                TextureIdCount: () => (
                  /* reexport safe */
                  _Texture__WEBPACK_IMPORTED_MODULE_5__.TextureIdCount
                ),
                /* harmony export */
                UVMapping: () => (
                  /* reexport safe */
                  _UVMapping__WEBPACK_IMPORTED_MODULE_6__.UVMapping
                ),
                /* harmony export */
                intersectObject: () => (
                  /* reexport safe */
                  _Raycaster__WEBPACK_IMPORTED_MODULE_4__.intersectObject
                )
                /* harmony export */
              });
              var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./EventDispatcher */
                "./src/WebGL/core/EventDispatcher.ts"
              );
              var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Geometry */
                "./src/WebGL/core/Geometry.ts"
              );
              var _Object3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Object3D */
                "./src/WebGL/core/Object3D.ts"
              );
              var _Projector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./Projector */
                "./src/WebGL/core/Projector.ts"
              );
              var _Raycaster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./Raycaster */
                "./src/WebGL/core/Raycaster.ts"
              );
              var _Texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./Texture */
                "./src/WebGL/core/Texture.ts"
              );
              var _UVMapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./UVMapping */
                "./src/WebGL/core/UVMapping.ts"
              );
            },
            /***/
            "./src/WebGL/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                BackSide: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.BackSide
                ),
                /* harmony export */
                Camera: () => (
                  /* reexport safe */
                  _Camera__WEBPACK_IMPORTED_MODULE_7__.Camera
                ),
                /* harmony export */
                ClampToEdgeWrapping: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping
                ),
                /* harmony export */
                Coloring: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.Coloring
                ),
                /* harmony export */
                Cylinder: () => (
                  /* reexport safe */
                  _shapes__WEBPACK_IMPORTED_MODULE_6__.Cylinder
                ),
                /* harmony export */
                DoubleSide: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
                ),
                /* harmony export */
                EventDispatcher: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher
                ),
                /* harmony export */
                FloatType: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.FloatType
                ),
                /* harmony export */
                Fog: () => (
                  /* reexport safe */
                  _Fog__WEBPACK_IMPORTED_MODULE_8__.Fog
                ),
                /* harmony export */
                FrontSide: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.FrontSide
                ),
                /* harmony export */
                Geometry: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Geometry
                ),
                /* harmony export */
                GeometryGroup: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.GeometryGroup
                ),
                /* harmony export */
                GeometryIDCount: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.GeometryIDCount
                ),
                /* harmony export */
                ImposterMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.ImposterMaterial
                ),
                /* harmony export */
                InstancedMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.InstancedMaterial
                ),
                /* harmony export */
                Light: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Light
                ),
                /* harmony export */
                Line: () => (
                  /* reexport safe */
                  _objects__WEBPACK_IMPORTED_MODULE_4__.Line
                ),
                /* harmony export */
                LineBasicMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial
                ),
                /* harmony export */
                LineStyle: () => (
                  /* reexport safe */
                  _objects__WEBPACK_IMPORTED_MODULE_4__.LineStyle
                ),
                /* harmony export */
                LinearFilter: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.LinearFilter
                ),
                /* harmony export */
                LinearMipMapLinearFilter: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter
                ),
                /* harmony export */
                Material: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.Material
                ),
                /* harmony export */
                MaterialIdCount: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.MaterialIdCount
                ),
                /* harmony export */
                Matrix3: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Matrix3
                ),
                /* harmony export */
                Matrix4: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Matrix4
                ),
                /* harmony export */
                Mesh: () => (
                  /* reexport safe */
                  _objects__WEBPACK_IMPORTED_MODULE_4__.Mesh
                ),
                /* harmony export */
                MeshDoubleLambertMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.MeshDoubleLambertMaterial
                ),
                /* harmony export */
                MeshLambertMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.MeshLambertMaterial
                ),
                /* harmony export */
                MeshOutlineMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.MeshOutlineMaterial
                ),
                /* harmony export */
                NearestFilter: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter
                ),
                /* harmony export */
                Object3D: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Object3D
                ),
                /* harmony export */
                Object3DIDCount: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Object3DIDCount
                ),
                /* harmony export */
                Projector: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Projector
                ),
                /* harmony export */
                Quaternion: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Quaternion
                ),
                /* harmony export */
                R32Format: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.R32Format
                ),
                /* harmony export */
                RFormat: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.RFormat
                ),
                /* harmony export */
                RGBAFormat: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat
                ),
                /* harmony export */
                Ray: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Ray
                ),
                /* harmony export */
                Raycaster: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Raycaster
                ),
                /* harmony export */
                Renderer: () => (
                  /* reexport safe */
                  _Renderer__WEBPACK_IMPORTED_MODULE_9__.Renderer
                ),
                /* harmony export */
                Scene: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Scene
                ),
                /* harmony export */
                ShaderLib: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.ShaderLib
                ),
                /* harmony export */
                ShaderUtils: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.ShaderUtils
                ),
                /* harmony export */
                Shading: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.Shading
                ),
                /* harmony export */
                Sphere: () => (
                  /* reexport safe */
                  _shapes__WEBPACK_IMPORTED_MODULE_6__.Sphere
                ),
                /* harmony export */
                SphereImposterMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.SphereImposterMaterial
                ),
                /* harmony export */
                SphereImposterOutlineMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.SphereImposterOutlineMaterial
                ),
                /* harmony export */
                Sprite: () => (
                  /* reexport safe */
                  _objects__WEBPACK_IMPORTED_MODULE_4__.Sprite
                ),
                /* harmony export */
                SpriteAlignment: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment
                ),
                /* harmony export */
                SpriteMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial
                ),
                /* harmony export */
                SpritePlugin: () => (
                  /* reexport safe */
                  _SpritePlugin__WEBPACK_IMPORTED_MODULE_10__.SpritePlugin
                ),
                /* harmony export */
                StickImposterMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.StickImposterMaterial
                ),
                /* harmony export */
                StickImposterOutlineMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.StickImposterOutlineMaterial
                ),
                /* harmony export */
                Texture: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.Texture
                ),
                /* harmony export */
                TextureIdCount: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.TextureIdCount
                ),
                /* harmony export */
                TextureOperations: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.TextureOperations
                ),
                /* harmony export */
                Triangle: () => (
                  /* reexport safe */
                  _shapes__WEBPACK_IMPORTED_MODULE_6__.Triangle
                ),
                /* harmony export */
                UVMapping: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.UVMapping
                ),
                /* harmony export */
                UnsignedByteType: () => (
                  /* reexport safe */
                  _constants__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType
                ),
                /* harmony export */
                Vector2: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Vector2
                ),
                /* harmony export */
                Vector3: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.Vector3
                ),
                /* harmony export */
                VolumetricMaterial: () => (
                  /* reexport safe */
                  _materials__WEBPACK_IMPORTED_MODULE_2__.VolumetricMaterial
                ),
                /* harmony export */
                basic: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.basic
                ),
                /* harmony export */
                clamp: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.clamp
                ),
                /* harmony export */
                clone: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.clone
                ),
                /* harmony export */
                conversionMatrix3: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.conversionMatrix3
                ),
                /* harmony export */
                degToRad: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_3__.degToRad
                ),
                /* harmony export */
                instanced: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.instanced
                ),
                /* harmony export */
                intersectObject: () => (
                  /* reexport safe */
                  _core__WEBPACK_IMPORTED_MODULE_1__.intersectObject
                ),
                /* harmony export */
                lambert: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.lambert
                ),
                /* harmony export */
                lambertdouble: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.lambertdouble
                ),
                /* harmony export */
                outline: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.outline
                ),
                /* harmony export */
                screen: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.screen
                ),
                /* harmony export */
                screenaa: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.screenaa
                ),
                /* harmony export */
                sphereimposter: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.sphereimposter
                ),
                /* harmony export */
                sphereimposteroutline: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.sphereimposteroutline
                ),
                /* harmony export */
                sprite: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.sprite
                ),
                /* harmony export */
                stickimposter: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.stickimposter
                ),
                /* harmony export */
                stickimposteroutline: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.stickimposteroutline
                ),
                /* harmony export */
                volumetric: () => (
                  /* reexport safe */
                  _shaders__WEBPACK_IMPORTED_MODULE_5__.volumetric
                )
                /* harmony export */
              });
              var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./constants */
                "./src/WebGL/constants/index.ts"
              );
              var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./core */
                "./src/WebGL/core/index.ts"
              );
              var _materials__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./materials */
                "./src/WebGL/materials/index.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./math */
                "./src/WebGL/math/index.ts"
              );
              var _objects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./objects */
                "./src/WebGL/objects/index.ts"
              );
              var _shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./shaders */
                "./src/WebGL/shaders/index.ts"
              );
              var _shapes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./shapes */
                "./src/WebGL/shapes/index.ts"
              );
              var _Camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./Camera */
                "./src/WebGL/Camera.ts"
              );
              var _Fog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./Fog */
                "./src/WebGL/Fog.ts"
              );
              var _Renderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./Renderer */
                "./src/WebGL/Renderer.ts"
              );
              var _SpritePlugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./SpritePlugin */
                "./src/WebGL/SpritePlugin.ts"
              );
            },
            /***/
            "./src/WebGL/materials/ImposterMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ImposterMaterial: () => (
                  /* binding */
                  ImposterMaterial
                )
                /* harmony export */
              });
              var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./../constants/Coloring */
                "./src/WebGL/constants/Coloring.ts"
              );
              var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./../constants/Shading */
                "./src/WebGL/constants/Shading.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class ImposterMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {
                constructor(parameters) {
                  super();
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(16777215);
                  this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(1048575);
                  this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(0);
                  this.imposter = true;
                  this.wrapAround = false;
                  this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1);
                  this.map = void 0;
                  this.lightMap = null;
                  this.specularMap = null;
                  this.envMap = null;
                  this.reflectivity = 1;
                  this.refractionRatio = 0.98;
                  this.fog = true;
                  this.wireframe = false;
                  this.wireframeLinewidth = 1;
                  this.wireframeLinecap = "round";
                  this.wireframeLinejoin = "round";
                  this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;
                  this.shaderID = null;
                  this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;
                  this.skinning = false;
                  this.setValues(parameters);
                }
                clone(material = new ImposterMaterial()) {
                  super.clone.call(this, material);
                  material.color.copy(this.color);
                  material.ambient.copy(this.ambient);
                  material.emissive.copy(this.emissive);
                  material.wrapAround = this.wrapAround;
                  material.wrapRGB.copy(this.wrapRGB);
                  material.map = this.map;
                  material.lightMap = this.lightMap;
                  material.specularMap = this.specularMap;
                  material.envMap = this.envMap;
                  material.combine = this.combine;
                  material.reflectivity = this.reflectivity;
                  material.refractionRatio = this.refractionRatio;
                  material.fog = this.fog;
                  material.shading = this.shading;
                  material.shaderID = this.shaderID;
                  material.vertexColors = this.vertexColors;
                  material.skinning = this.skinning;
                  material.morphTargets = this.morphTargets;
                  material.morphNormals = this.morphNormals;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/InstancedMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                InstancedMaterial: () => (
                  /* binding */
                  InstancedMaterial
                )
                /* harmony export */
              });
              var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../constants/Coloring */
                "./src/WebGL/constants/Coloring.ts"
              );
              var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../constants/Shading */
                "./src/WebGL/constants/Shading.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class InstancedMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {
                constructor(parameters) {
                  super();
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(16777215);
                  this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(1048575);
                  this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(0);
                  this.wrapAround = false;
                  this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1);
                  this.map = void 0;
                  this.lightMap = null;
                  this.specularMap = null;
                  this.envMap = null;
                  this.reflectivity = 1;
                  this.refractionRatio = 0.98;
                  this.fog = true;
                  this.wireframe = false;
                  this.wireframeLinewidth = 1;
                  this.wireframeLinecap = "round";
                  this.wireframeLinejoin = "round";
                  this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;
                  this.shaderID = "instanced";
                  this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;
                  this.skinning = false;
                  this.sphere = null;
                  this.setValues(parameters);
                }
                clone(material = new InstancedMaterial()) {
                  super.clone.call(this, material);
                  material.color.copy(this.color);
                  material.ambient.copy(this.ambient);
                  material.emissive.copy(this.emissive);
                  material.wrapAround = this.wrapAround;
                  material.wrapRGB.copy(this.wrapRGB);
                  material.map = this.map;
                  material.lightMap = this.lightMap;
                  material.specularMap = this.specularMap;
                  material.envMap = this.envMap;
                  material.combine = this.combine;
                  material.reflectivity = this.reflectivity;
                  material.refractionRatio = this.refractionRatio;
                  material.fog = this.fog;
                  material.shading = this.shading;
                  material.shaderID = this.shaderID;
                  material.vertexColors = this.vertexColors;
                  material.skinning = this.skinning;
                  material.morphTargets = this.morphTargets;
                  material.morphNormals = this.morphNormals;
                  material.sphere = this.sphere;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/LineBasicMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                LineBasicMaterial: () => (
                  /* binding */
                  LineBasicMaterial
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class LineBasicMaterial extends _Material__WEBPACK_IMPORTED_MODULE_1__.Material {
                constructor(parameters) {
                  super();
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);
                  this.linewidth = 1;
                  this.linecap = "round";
                  this.linejoin = "round";
                  this.vertexColors = false;
                  this.fog = true;
                  this.shaderID = "basic";
                  this.setValues(parameters);
                }
                clone(material = new LineBasicMaterial()) {
                  super.clone.call(this, material);
                  material.color.copy(this.color);
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/Material.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Material: () => (
                  /* binding */
                  Material
                ),
                /* harmony export */
                MaterialIdCount: () => (
                  /* binding */
                  MaterialIdCount
                )
                /* harmony export */
              });
              var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../constants/Sides */
                "./src/WebGL/constants/Sides.ts"
              );
              var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../core */
                "./src/WebGL/core/index.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              class Material extends _core__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
                constructor() {
                  super(...arguments);
                  this.id = MaterialIdCount++;
                  this.name = "";
                  this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.FrontSide;
                  this.opacity = 1;
                  this.transparent = false;
                  this.depthTest = true;
                  this.depthWrite = true;
                  this.polygonOffset = false;
                  this.polygonOffsetFactor = 0;
                  this.polygonOffsetUnits = 0;
                  this.alphaTest = 0;
                  this.visible = true;
                  this.needsUpdate = true;
                  this.outline = false;
                  this.wireframe = false;
                  this.shaded = false;
                }
                setValues(values = {}) {
                  if (values === void 0)
                    return;
                  for (var key in values) {
                    var newValue = values[key];
                    if (newValue === void 0) {
                      console.warn("$3Dmol.Material: '" + key + "' parameter is undefined.");
                      continue;
                    }
                    if (key in this) {
                      var currentValue = this[key];
                      if (currentValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color && newValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color) {
                        currentValue.copy(newValue);
                      } else if (currentValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color) {
                        currentValue.set(newValue);
                      } else if (currentValue instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Vector3 && newValue instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Vector3) {
                        currentValue.copy(newValue);
                      } else {
                        this[key] = newValue;
                      }
                    }
                  }
                }
                //TODO: might want to look into blending equations
                clone(material = new Material()) {
                  material.name = this.name;
                  material.side = this.side;
                  material.opacity = this.opacity;
                  material.transparent = this.transparent;
                  material.depthTest = this.depthTest;
                  material.depthWrite = this.depthWrite;
                  material.polygonOffset = this.polygonOffset;
                  material.polygonOffsetFactor = this.polygonOffsetFactor;
                  material.polygonOffsetUnits = this.polygonOffsetUnits;
                  material.alphaTest = this.alphaTest;
                  material.overdraw = this.overdraw;
                  material.visible = this.visible;
                  return material;
                }
                makeShaded(sTex) {
                  this.shaded = true;
                  if (this.uniforms) {
                    this.uniforms.shading = { type: "i", value: sTex };
                    this.uniforms.vWidth = { type: "f", value: 1 };
                    this.uniforms.vHeight = { type: "f", value: 1 };
                  }
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
              }
              let MaterialIdCount = 0;
            },
            /***/
            "./src/WebGL/materials/MeshDoubleLambertMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MeshDoubleLambertMaterial: () => (
                  /* binding */
                  MeshDoubleLambertMaterial
                )
                /* harmony export */
              });
              var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./../constants/Sides */
                "./src/WebGL/constants/Sides.ts"
              );
              var _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./MeshLambertMaterial */
                "./src/WebGL/materials/MeshLambertMaterial.ts"
              );
              class MeshDoubleLambertMaterial extends _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial {
                constructor(parameters) {
                  super(parameters);
                  this.shaderID = "lambertdouble";
                  this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;
                  this.outline = false;
                }
                clone(material = new MeshDoubleLambertMaterial()) {
                  super.clone.call(this, material);
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/MeshLambertMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MeshLambertMaterial: () => (
                  /* binding */
                  MeshLambertMaterial
                )
                /* harmony export */
              });
              var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./../constants/Coloring */
                "./src/WebGL/constants/Coloring.ts"
              );
              var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./../constants/Shading */
                "./src/WebGL/constants/Shading.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              class MeshLambertMaterial extends _Material__WEBPACK_IMPORTED_MODULE_2__.Material {
                constructor(parameters) {
                  super();
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(16777215);
                  this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(1048575);
                  this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0);
                  this.wrapAround = false;
                  this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1);
                  this.map = void 0;
                  this.lightMap = null;
                  this.specularMap = null;
                  this.envMap = null;
                  this.reflectivity = 1;
                  this.refractionRatio = 0.98;
                  this.fog = true;
                  this.wireframe = false;
                  this.wireframeLinewidth = 1;
                  this.wireframeLinecap = "round";
                  this.wireframeLinejoin = "round";
                  this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;
                  this.shaderID = "lambert";
                  this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;
                  this.skinning = false;
                  this.setValues(parameters);
                }
                clone(material = new MeshLambertMaterial()) {
                  super.clone.call(this, material);
                  material.color.copy(this.color);
                  material.ambient.copy(this.ambient);
                  material.emissive.copy(this.emissive);
                  material.wrapAround = this.wrapAround;
                  material.wrapRGB.copy(this.wrapRGB);
                  material.map = this.map;
                  material.lightMap = this.lightMap;
                  material.specularMap = this.specularMap;
                  material.envMap = this.envMap;
                  material.combine = this.combine;
                  material.reflectivity = this.reflectivity;
                  material.refractionRatio = this.refractionRatio;
                  material.fog = this.fog;
                  material.shading = this.shading;
                  material.shaderID = this.shaderID;
                  material.vertexColors = this.vertexColors;
                  material.skinning = this.skinning;
                  material.morphTargets = this.morphTargets;
                  material.morphNormals = this.morphNormals;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/MeshOutlineMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MeshOutlineMaterial: () => (
                  /* binding */
                  MeshOutlineMaterial
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class MeshOutlineMaterial extends _Material__WEBPACK_IMPORTED_MODULE_1__.Material {
                constructor(parameters) {
                  super();
                  parameters = parameters || {};
                  this.fog = true;
                  this.shaderID = "outline";
                  this.wireframe = false;
                  this.outlineColor = _colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(parameters.color || new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0));
                  this.outlineWidth = parameters.width || 0.1;
                  this.outlinePushback = parameters.pushback || 1;
                  this.outlineMaxPixels = parameters.maxpixels || 0;
                }
                clone(material = new MeshOutlineMaterial()) {
                  super.clone.call(this, material);
                  material.fog = this.fog;
                  material.shaderID = this.shaderID;
                  material.wireframe = this.wireframe;
                  material.outlineColor = this.outlineColor;
                  material.outlineWidth = this.outlineWidth;
                  material.outlinePushback = this.outlinePushback;
                  material.outlineMaxPixels = this.outlineMaxPixels;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/SphereImposterMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SphereImposterMaterial: () => (
                  /* binding */
                  SphereImposterMaterial
                )
                /* harmony export */
              });
              var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./ImposterMaterial */
                "./src/WebGL/materials/ImposterMaterial.ts"
              );
              class SphereImposterMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial {
                constructor(parameters) {
                  super(parameters);
                  this.shaderID = "sphereimposter";
                  this.setValues(parameters);
                }
                clone(material = new SphereImposterMaterial()) {
                  super.clone.call(this, material);
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/SphereImposterOutlineMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SphereImposterOutlineMaterial: () => (
                  /* binding */
                  SphereImposterOutlineMaterial
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./ImposterMaterial */
                "./src/WebGL/materials/ImposterMaterial.ts"
              );
              class SphereImposterOutlineMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__.ImposterMaterial {
                constructor(parameters) {
                  super(parameters);
                  parameters = parameters || {};
                  this.shaderID = "sphereimposteroutline";
                  this.outlineColor = _colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(parameters.color || new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0));
                  this.outlineWidth = parameters.width || 0.1;
                  this.outlinePushback = parameters.pushback || 1;
                  this.outlineMaxPixels = parameters.maxpixels || 0;
                  this.setValues(parameters);
                }
                clone(material = new SphereImposterOutlineMaterial()) {
                  super.clone.call(this, material);
                  material.outlineColor = this.outlineColor;
                  material.outlineWidth = this.outlineWidth;
                  material.outlinePushback = this.outlinePushback;
                  material.outlineMaxPixels = this.outlineMaxPixels;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/SpriteMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SpriteMaterial: () => (
                  /* binding */
                  SpriteMaterial
                )
                /* harmony export */
              });
              var _constants_SpriteAlignment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../constants/SpriteAlignment */
                "./src/WebGL/constants/SpriteAlignment.ts"
              );
              var _core_Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../core/Texture */
                "./src/WebGL/core/Texture.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class SpriteMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {
                constructor(parameters) {
                  super();
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__2.Color(16777215);
                  this.map = new _core_Texture__WEBPACK_IMPORTED_MODULE_1__.Texture();
                  this.useScreenCoordinates = true;
                  this.fog = false;
                  this.uvOffset = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, 0);
                  this.uvScale = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector2(1, 1);
                  this.depthTest = !this.useScreenCoordinates;
                  this.sizeAttenuation = !this.useScreenCoordinates;
                  this.screenOffset = this.screenOffset;
                  this.scaleByViewPort = !this.sizeAttenuation;
                  this.alignment = _constants_SpriteAlignment__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment.center.clone();
                  this.setValues(parameters);
                  parameters = parameters || {};
                  if (parameters.depthTest === void 0)
                    this.depthTest = !this.useScreenCoordinates;
                  if (parameters.sizeAttenuation === void 0)
                    this.sizeAttenuation = !this.useScreenCoordinates;
                  if (parameters.scaleByViewPort === void 0)
                    this.scaleByViewPort = !this.sizeAttenuation;
                }
                clone(material = new SpriteMaterial()) {
                  super.clone.call(this, material);
                  material.color.copy(this.color);
                  material.map = this.map;
                  material.useScreenCoordinates = this.useScreenCoordinates;
                  material.screenOffset = this.screenOffset;
                  material.sizeAttenuation = this.sizeAttenuation;
                  material.scaleByViewport = this.scaleByViewPort;
                  material.alignment.copy(this.alignment);
                  material.uvOffset.copy(this.uvOffset);
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/StickImposterMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                StickImposterMaterial: () => (
                  /* binding */
                  StickImposterMaterial
                )
                /* harmony export */
              });
              var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./ImposterMaterial */
                "./src/WebGL/materials/ImposterMaterial.ts"
              );
              class StickImposterMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial {
                constructor(parameters) {
                  super(parameters);
                  this.shaderID = "stickimposter";
                  this.setValues(parameters);
                }
                clone(material = new StickImposterMaterial()) {
                  super.clone.call(this, material);
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/StickImposterOutlineMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                StickImposterOutlineMaterial: () => (
                  /* binding */
                  StickImposterOutlineMaterial
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./ImposterMaterial */
                "./src/WebGL/materials/ImposterMaterial.ts"
              );
              class StickImposterOutlineMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__.ImposterMaterial {
                constructor(parameters = {}) {
                  super(parameters);
                  this.shaderID = "stickimposteroutline";
                  this.outlineColor = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);
                  this.outlineWidth = 0.1;
                  this.outlinePushback = 1;
                  this.outlineMaxPixels = 0;
                  if (parameters.color)
                    this.outlineColor = _colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(parameters.color);
                  if (parameters.width)
                    this.outlineWidth = parameters.width;
                  if (parameters.pushback)
                    this.outlinePushback = parameters.pushback;
                  if (parameters.maxpixels)
                    this.outlineMaxPixels = parameters.maxpixels;
                  this.setValues(parameters);
                }
                clone(material = new StickImposterOutlineMaterial()) {
                  super.clone.call(this, material);
                  material.outlineColor = this.outlineColor;
                  material.outlineWidth = this.outlineWidth;
                  material.outlinePushback = this.outlinePushback;
                  material.outlineMaxPixels = this.outlineMaxPixels;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/VolumetricMaterial.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                VolumetricMaterial: () => (
                  /* binding */
                  VolumetricMaterial
                )
                /* harmony export */
              });
              var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../constants/Sides */
                "./src/WebGL/constants/Sides.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../../colors */
                "./src/colors.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              class VolumetricMaterial extends _Material__WEBPACK_IMPORTED_MODULE_2__.Material {
                constructor(parameters) {
                  super();
                  this.transparent = false;
                  this.volumetric = true;
                  this.color = new _colors__WEBPACK_IMPORTED_MODULE_1__.Color(16777215);
                  this.transferfn = null;
                  this.map = void 0;
                  this.extent = [];
                  this.maxdepth = 100;
                  this.unit = 0;
                  this.texmatrix = null;
                  this.transfermin = -1;
                  this.transfermax = 1;
                  this.subsamples = 5;
                  this.shaderID = "volumetric";
                  this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.FrontSide;
                  this.setValues(parameters);
                }
                clone(material = new VolumetricMaterial()) {
                  super.clone.call(this, material);
                  material.transparent = this.transparent;
                  material.volumetric = this.volumetric;
                  material.color = this.color;
                  material.transferfn = this.transferfn;
                  material.map = this.map;
                  material.extent = this.extent;
                  material.maxdepth = this.maxdepth;
                  material.unit = this.unit;
                  material.texmatrix = this.texmatrix;
                  material.transfermin = this.transfermin;
                  material.transfermax = this.transfermax;
                  material.subsamples = this.subsamples;
                  material.shaderID = this.shaderID;
                  material.side = this.side;
                  return material;
                }
              }
            },
            /***/
            "./src/WebGL/materials/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ImposterMaterial: () => (
                  /* reexport safe */
                  _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial
                ),
                /* harmony export */
                InstancedMaterial: () => (
                  /* reexport safe */
                  _InstancedMaterial__WEBPACK_IMPORTED_MODULE_1__.InstancedMaterial
                ),
                /* harmony export */
                LineBasicMaterial: () => (
                  /* reexport safe */
                  _LineBasicMaterial__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial
                ),
                /* harmony export */
                Material: () => (
                  /* reexport safe */
                  _Material__WEBPACK_IMPORTED_MODULE_3__.Material
                ),
                /* harmony export */
                MaterialIdCount: () => (
                  /* reexport safe */
                  _Material__WEBPACK_IMPORTED_MODULE_3__.MaterialIdCount
                ),
                /* harmony export */
                MeshDoubleLambertMaterial: () => (
                  /* reexport safe */
                  _MeshDoubleLambertMaterial__WEBPACK_IMPORTED_MODULE_4__.MeshDoubleLambertMaterial
                ),
                /* harmony export */
                MeshLambertMaterial: () => (
                  /* reexport safe */
                  _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_5__.MeshLambertMaterial
                ),
                /* harmony export */
                MeshOutlineMaterial: () => (
                  /* reexport safe */
                  _MeshOutlineMaterial__WEBPACK_IMPORTED_MODULE_6__.MeshOutlineMaterial
                ),
                /* harmony export */
                SphereImposterMaterial: () => (
                  /* reexport safe */
                  _SphereImposterMaterial__WEBPACK_IMPORTED_MODULE_7__.SphereImposterMaterial
                ),
                /* harmony export */
                SphereImposterOutlineMaterial: () => (
                  /* reexport safe */
                  _SphereImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_8__.SphereImposterOutlineMaterial
                ),
                /* harmony export */
                SpriteMaterial: () => (
                  /* reexport safe */
                  _SpriteMaterial__WEBPACK_IMPORTED_MODULE_9__.SpriteMaterial
                ),
                /* harmony export */
                StickImposterMaterial: () => (
                  /* reexport safe */
                  _StickImposterMaterial__WEBPACK_IMPORTED_MODULE_10__.StickImposterMaterial
                ),
                /* harmony export */
                StickImposterOutlineMaterial: () => (
                  /* reexport safe */
                  _StickImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_11__.StickImposterOutlineMaterial
                ),
                /* harmony export */
                VolumetricMaterial: () => (
                  /* reexport safe */
                  _VolumetricMaterial__WEBPACK_IMPORTED_MODULE_12__.VolumetricMaterial
                )
                /* harmony export */
              });
              var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./ImposterMaterial */
                "./src/WebGL/materials/ImposterMaterial.ts"
              );
              var _InstancedMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./InstancedMaterial */
                "./src/WebGL/materials/InstancedMaterial.ts"
              );
              var _LineBasicMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./LineBasicMaterial */
                "./src/WebGL/materials/LineBasicMaterial.ts"
              );
              var _Material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./Material */
                "./src/WebGL/materials/Material.ts"
              );
              var _MeshDoubleLambertMaterial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./MeshDoubleLambertMaterial */
                "./src/WebGL/materials/MeshDoubleLambertMaterial.ts"
              );
              var _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./MeshLambertMaterial */
                "./src/WebGL/materials/MeshLambertMaterial.ts"
              );
              var _MeshOutlineMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./MeshOutlineMaterial */
                "./src/WebGL/materials/MeshOutlineMaterial.ts"
              );
              var _SphereImposterMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./SphereImposterMaterial */
                "./src/WebGL/materials/SphereImposterMaterial.ts"
              );
              var _SphereImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./SphereImposterOutlineMaterial */
                "./src/WebGL/materials/SphereImposterOutlineMaterial.ts"
              );
              var _SpriteMaterial__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./SpriteMaterial */
                "./src/WebGL/materials/SpriteMaterial.ts"
              );
              var _StickImposterMaterial__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./StickImposterMaterial */
                "./src/WebGL/materials/StickImposterMaterial.ts"
              );
              var _StickImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                /*! ./StickImposterOutlineMaterial */
                "./src/WebGL/materials/StickImposterOutlineMaterial.ts"
              );
              var _VolumetricMaterial__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                /*! ./VolumetricMaterial */
                "./src/WebGL/materials/VolumetricMaterial.ts"
              );
            },
            /***/
            "./src/WebGL/math/Quaternion.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Quaternion: () => (
                  /* binding */
                  Quaternion
                )
                /* harmony export */
              });
              class Quaternion {
                constructor(x, y, z, w) {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w !== void 0 ? w : 1;
                }
                set(x, y, z, w) {
                  this.x = x;
                  this.y = y;
                  this.z = z;
                  this.w = w;
                  return this;
                }
                copy(q) {
                  this.x = q.x;
                  this.y = q.y;
                  this.z = q.z;
                  this.w = q.w;
                  return this;
                }
                conjugate() {
                  this.x *= -1;
                  this.y *= -1;
                  this.z *= -1;
                  return this;
                }
                inverse() {
                  return this.conjugate().normalize();
                }
                length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                }
                lengthxyz() {
                  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                normalize() {
                  let l = this.length();
                  if (l === 0) {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 1;
                  } else {
                    l = 1 / l;
                    this.x *= l;
                    this.y *= l;
                    this.z *= l;
                    this.w *= l;
                  }
                  return this;
                }
                multiply(q) {
                  return this.multiplyQuaternions(this, q);
                }
                multiplyScalar(s) {
                  this.x *= s;
                  this.y *= s;
                  this.z *= s;
                  this.w *= s;
                  return this;
                }
                multiplyQuaternions(a, b) {
                  const qax = a.x;
                  const qay = a.y;
                  const qaz = a.z;
                  const qaw = a.w;
                  const qbx = b.x;
                  const qby = b.y;
                  const qbz = b.z;
                  const qbw = b.w;
                  this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                  this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                  this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                  this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                  return this;
                }
                sub(q) {
                  this.x -= q.x;
                  this.y -= q.y;
                  this.z -= q.z;
                  this.w -= q.w;
                  return this;
                }
                clone() {
                  return new Quaternion(this.x, this.y, this.z, this.w);
                }
                setFromEuler(e) {
                  const c1 = Math.cos(e.x / 2);
                  const c2 = Math.cos(e.y / 2);
                  const c3 = Math.cos(e.z / 2);
                  const s1 = Math.sin(e.x / 2);
                  const s2 = Math.sin(e.y / 2);
                  const s3 = Math.sin(e.z / 2);
                  this.x = s1 * c2 * c3 + c1 * s2 * s3;
                  this.y = c1 * s2 * c3 - s1 * c2 * s3;
                  this.z = c1 * c2 * s3 + s1 * s2 * c3;
                  this.w = c1 * c2 * c3 - s1 * s2 * s3;
                  return this;
                }
              }
            },
            /***/
            "./src/WebGL/math/Vector2.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Vector2: () => (
                  /* binding */
                  Vector2
                )
                /* harmony export */
              });
              class Vector2 {
                constructor(x, y) {
                  this.x = x || 0;
                  this.y = y || 0;
                }
                set(x, y) {
                  this.x = x;
                  this.y = y;
                  return this;
                }
                subVectors(a, b) {
                  this.x = a.x - b.x;
                  this.y = a.y - b.y;
                  return this;
                }
                copy(v) {
                  this.x = v.x;
                  this.y = v.y;
                  return this;
                }
                clone() {
                  return new Vector2(this.x, this.y);
                }
              }
            },
            /***/
            "./src/WebGL/math/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Matrix3: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_5__.Matrix3
                ),
                /* harmony export */
                Matrix4: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_5__.Matrix4
                ),
                /* harmony export */
                Quaternion: () => (
                  /* reexport safe */
                  _Quaternion__WEBPACK_IMPORTED_MODULE_0__.Quaternion
                ),
                /* harmony export */
                Ray: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_5__.Ray
                ),
                /* harmony export */
                Vector2: () => (
                  /* reexport safe */
                  _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2
                ),
                /* harmony export */
                Vector3: () => (
                  /* reexport safe */
                  _math__WEBPACK_IMPORTED_MODULE_5__.Vector3
                ),
                /* harmony export */
                clamp: () => (
                  /* reexport safe */
                  _utils_clamp__WEBPACK_IMPORTED_MODULE_2__.clamp
                ),
                /* harmony export */
                conversionMatrix3: () => (
                  /* reexport safe */
                  _utils_conversionMatrix3__WEBPACK_IMPORTED_MODULE_3__.conversionMatrix3
                ),
                /* harmony export */
                degToRad: () => (
                  /* reexport safe */
                  _utils_degToRad__WEBPACK_IMPORTED_MODULE_4__.degToRad
                )
                /* harmony export */
              });
              var _Quaternion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./Quaternion */
                "./src/WebGL/math/Quaternion.ts"
              );
              var _Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Vector2 */
                "./src/WebGL/math/Vector2.ts"
              );
              var _utils_clamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./utils/clamp */
                "./src/WebGL/math/utils/clamp.ts"
              );
              var _utils_conversionMatrix3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./utils/conversionMatrix3 */
                "./src/WebGL/math/utils/conversionMatrix3.ts"
              );
              var _utils_degToRad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./utils/degToRad */
                "./src/WebGL/math/utils/degToRad.ts"
              );
              var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./math */
                "./src/WebGL/math/math.ts"
              );
            },
            /***/
            "./src/WebGL/math/math.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Matrix3: () => (
                  /* binding */
                  Matrix3
                ),
                /* harmony export */
                Matrix4: () => (
                  /* binding */
                  Matrix4
                ),
                /* harmony export */
                Ray: () => (
                  /* binding */
                  Ray
                ),
                /* harmony export */
                Vector3: () => (
                  /* binding */
                  Vector3
                )
                /* harmony export */
              });
              var _utils_degToRad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/degToRad */
                "./src/WebGL/math/utils/degToRad.ts"
              );
              var _utils_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/clamp */
                "./src/WebGL/math/utils/clamp.ts"
              );
              var mRotation;
              var mScale;
              var x;
              var y;
              var z;
              class Matrix4 {
                constructor(n11 = 1, n12 = 0, n13 = 0, n14 = 0, n21 = 0, n22 = 1, n23 = 0, n24 = 0, n31 = 0, n32 = 0, n33 = 1, n34 = 0, n41 = 0, n42 = 0, n43 = 0, n44 = 1) {
                  if (typeof n11 !== "undefined" && typeof n11 !== "number") {
                    this.elements = new Float32Array(n11);
                  } else {
                    this.elements = new Float32Array(16);
                    this.elements[0] = n11;
                    this.elements[4] = n12;
                    this.elements[8] = n13;
                    this.elements[12] = n14;
                    this.elements[1] = n21;
                    this.elements[5] = n22;
                    this.elements[9] = n23;
                    this.elements[13] = n24;
                    this.elements[2] = n31;
                    this.elements[6] = n32;
                    this.elements[10] = n33;
                    this.elements[14] = n34;
                    this.elements[3] = n41;
                    this.elements[7] = n42;
                    this.elements[11] = n43;
                    this.elements[15] = n44;
                  }
                }
                // eslint-disable-next-line no-unused-vars, class-methods-use-this
                makeScale(x2, y2, z2) {
                  throw new Error("Method not implemented.");
                }
                set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                  const te = this.elements;
                  te[0] = n11;
                  te[4] = n12;
                  te[8] = n13;
                  te[12] = n14;
                  te[1] = n21;
                  te[5] = n22;
                  te[9] = n23;
                  te[13] = n24;
                  te[2] = n31;
                  te[6] = n32;
                  te[10] = n33;
                  te[14] = n34;
                  te[3] = n41;
                  te[7] = n42;
                  te[11] = n43;
                  te[15] = n44;
                  return this;
                }
                identity() {
                  this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                  return this;
                }
                copy(m) {
                  const me = m.elements;
                  this.set(me[0], me[4], me[8], me[12], me[1], me[5], me[9], me[13], me[2], me[6], me[10], me[14], me[3], me[7], me[11], me[15]);
                  return this;
                }
                matrix3FromTopLeft() {
                  const te = this.elements;
                  return new Matrix3(te[0], te[4], te[8], te[1], te[5], te[9], te[2], te[6], te[10]);
                }
                setRotationFromEuler(v, order) {
                  const te = this.elements;
                  const { x: x2, y: y2, z: z2 } = v;
                  const a = Math.cos(x2);
                  const b = Math.sin(x2);
                  const c = Math.cos(y2);
                  const d = Math.sin(y2);
                  const e = Math.cos(z2);
                  const f = Math.sin(z2);
                  if (order === void 0 || order === "XYZ") {
                    const ae = a * e;
                    const af = a * f;
                    const be = b * e;
                    const bf = b * f;
                    te[0] = c * e;
                    te[4] = -c * f;
                    te[8] = d;
                    te[1] = af + be * d;
                    te[5] = ae - bf * d;
                    te[9] = -b * c;
                    te[2] = bf - ae * d;
                    te[6] = be + af * d;
                    te[10] = a * c;
                  } else
                    console.error(`Error with matrix4 setRotationFromEuler. Order: ${order}`);
                  return this;
                }
                setRotationFromQuaternion(q) {
                  const te = this.elements;
                  const { x: x2, y: y2, z: z2, w } = q;
                  const x22 = x2 + x2;
                  const y22 = y2 + y2;
                  const z22 = z2 + z2;
                  const xx = x2 * x22;
                  const xy = x2 * y22;
                  const xz = x2 * z22;
                  const yy = y2 * y22;
                  const yz = y2 * z22;
                  const zz = z2 * z22;
                  const wx = w * x22;
                  const wy = w * y22;
                  const wz = w * z22;
                  te[0] = 1 - (yy + zz);
                  te[4] = xy - wz;
                  te[8] = xz + wy;
                  te[1] = xy + wz;
                  te[5] = 1 - (xx + zz);
                  te[9] = yz - wx;
                  te[2] = xz - wy;
                  te[6] = yz + wx;
                  te[10] = 1 - (xx + yy);
                  return this;
                }
                multiplyMatrices(a, b) {
                  const ae = a.elements;
                  const be = b.elements;
                  const te = this.elements;
                  const a11 = ae[0];
                  const a12 = ae[4];
                  const a13 = ae[8];
                  const a14 = ae[12];
                  const a21 = ae[1];
                  const a22 = ae[5];
                  const a23 = ae[9];
                  const a24 = ae[13];
                  const a31 = ae[2];
                  const a32 = ae[6];
                  const a33 = ae[10];
                  const a34 = ae[14];
                  const a41 = ae[3];
                  const a42 = ae[7];
                  const a43 = ae[11];
                  const a44 = ae[15];
                  const b11 = be[0];
                  const b12 = be[4];
                  const b13 = be[8];
                  const b14 = be[12];
                  const b21 = be[1];
                  const b22 = be[5];
                  const b23 = be[9];
                  const b24 = be[13];
                  const b31 = be[2];
                  const b32 = be[6];
                  const b33 = be[10];
                  const b34 = be[14];
                  const b41 = be[3];
                  const b42 = be[7];
                  const b43 = be[11];
                  const b44 = be[15];
                  te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                  te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                  te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                  te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                  te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                  te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                  te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                  te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                  te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                  te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                  te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                  te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                  te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                  te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                  te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                  te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                  return this;
                }
                multiplyScalar(s) {
                  const te = this.elements;
                  te[0] *= s;
                  te[4] *= s;
                  te[8] *= s;
                  te[12] *= s;
                  te[1] *= s;
                  te[5] *= s;
                  te[9] *= s;
                  te[13] *= s;
                  te[2] *= s;
                  te[6] *= s;
                  te[10] *= s;
                  te[14] *= s;
                  te[3] *= s;
                  te[7] *= s;
                  te[11] *= s;
                  te[15] *= s;
                  return this;
                }
                makeTranslation(x2, y2, z2) {
                  this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
                  return this;
                }
                // snap values close to integers to their integer value
                // useful and identifying identity matrices
                snap(digits) {
                  if (!digits)
                    digits = 4;
                  const mult = Math.pow(10, 4);
                  const te = this.elements;
                  for (let i = 0; i < 16; i++) {
                    const rounded = Math.round(te[i]);
                    if (rounded === Math.round(te[i] * mult) / mult) {
                      te[i] = rounded;
                    }
                  }
                  return this;
                }
                transpose() {
                  const te = this.elements;
                  let tmp;
                  tmp = te[1];
                  te[1] = te[4];
                  te[4] = tmp;
                  tmp = te[2];
                  te[2] = te[8];
                  te[8] = tmp;
                  tmp = te[6];
                  te[6] = te[9];
                  te[9] = tmp;
                  tmp = te[3];
                  te[3] = te[12];
                  te[12] = tmp;
                  tmp = te[7];
                  te[7] = te[13];
                  te[13] = tmp;
                  tmp = te[11];
                  te[11] = te[14];
                  te[14] = tmp;
                  return this;
                }
                setPosition(v) {
                  const te = this.elements;
                  te[12] = v.x;
                  te[13] = v.y;
                  te[14] = v.z;
                  return this;
                }
                translate(v) {
                  const te = this.elements;
                  te[12] += v.x;
                  te[13] += v.y;
                  te[14] += v.z;
                  return this;
                }
                getInverse(m, throwOnInvertible) {
                  const te = this.elements;
                  const me = m.elements;
                  const n11 = me[0];
                  const n12 = me[4];
                  const n13 = me[8];
                  const n14 = me[12];
                  const n21 = me[1];
                  const n22 = me[5];
                  const n23 = me[9];
                  const n24 = me[13];
                  const n31 = me[2];
                  const n32 = me[6];
                  const n33 = me[10];
                  const n34 = me[14];
                  const n41 = me[3];
                  const n42 = me[7];
                  const n43 = me[11];
                  const n44 = me[15];
                  te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
                  te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
                  te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
                  te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                  te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
                  te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
                  te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
                  te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
                  te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
                  te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
                  te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
                  te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
                  te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
                  te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
                  te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
                  te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
                  const det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
                  if (det === 0) {
                    const msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                    if (throwOnInvertible || false) {
                      throw new Error(msg);
                    } else {
                      console.warn(msg);
                    }
                    this.identity();
                    return this;
                  }
                  this.multiplyScalar(1 / det);
                  return this;
                }
                isReflected() {
                  const te = this.elements;
                  const m0 = te[0];
                  const m3 = te[4];
                  const m6 = te[8];
                  const m1 = te[1];
                  const m4 = te[5];
                  const m7 = te[9];
                  const m2 = te[2];
                  const m5 = te[6];
                  const m8 = te[10];
                  const determinant = m0 * m4 * m8 + // +aei
                  m1 * m5 * m6 + // +bfg
                  m2 * m3 * m7 - // +cdh
                  m2 * m4 * m6 - // -ceg
                  m1 * m3 * m8 - // -bdi
                  m0 * m5 * m7;
                  return determinant < 0;
                }
                scale(v) {
                  const te = this.elements;
                  const { x: x2 } = v;
                  const { y: y2 } = v;
                  const { z: z2 } = v;
                  te[0] *= x2;
                  te[4] *= y2;
                  te[8] *= z2;
                  te[1] *= x2;
                  te[5] *= y2;
                  te[9] *= z2;
                  te[2] *= x2;
                  te[6] *= y2;
                  te[10] *= z2;
                  te[3] *= x2;
                  te[7] *= y2;
                  te[11] *= z2;
                  return this;
                }
                getMaxScaleOnAxis() {
                  const te = this.elements;
                  const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                  const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                  const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                  return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
                }
                makeFrustum(left, right, bottom, top, near, far) {
                  const te = this.elements;
                  const x2 = 2 * near / (right - left);
                  const y2 = 2 * near / (top - bottom);
                  const a = (right + left) / (right - left);
                  const b = (top + bottom) / (top - bottom);
                  const c = -(far + near) / (far - near);
                  const d = -2 * far * near / (far - near);
                  te[0] = x2;
                  te[4] = 0;
                  te[8] = a;
                  te[12] = 0;
                  te[1] = 0;
                  te[5] = y2;
                  te[9] = b;
                  te[13] = 0;
                  te[2] = 0;
                  te[6] = 0;
                  te[10] = c;
                  te[14] = d;
                  te[3] = 0;
                  te[7] = 0;
                  te[11] = -1;
                  te[15] = 0;
                  return this;
                }
                makePerspective(fov, aspect, near, far) {
                  const ymax = near * Math.tan((0, _utils_degToRad__WEBPACK_IMPORTED_MODULE_0__.degToRad)(fov * 0.5));
                  const ymin = -ymax;
                  const xmin = ymin * aspect;
                  const xmax = ymax * aspect;
                  return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
                }
                makeOrthographic(left, right, top, bottom, near, far) {
                  const te = this.elements;
                  const w = 1 / (right - left);
                  const h = 1 / (top - bottom);
                  const p = 1 / (far - near);
                  const x2 = (right + left) * w;
                  const y2 = (top + bottom) * h;
                  const z2 = (far + near) * p;
                  te[0] = 2 * w;
                  te[4] = 0;
                  te[8] = 0;
                  te[12] = -x2;
                  te[1] = 0;
                  te[5] = 2 * h;
                  te[9] = 0;
                  te[13] = -y2;
                  te[2] = 0;
                  te[6] = 0;
                  te[10] = -2 * p;
                  te[14] = -z2;
                  te[3] = 0;
                  te[7] = 0;
                  te[11] = 0;
                  te[15] = 1;
                  return this;
                }
                isEqual(m) {
                  const me = m.elements;
                  const te = this.elements;
                  if (te[0] === me[0] && te[4] === me[4] && te[8] === me[8] && te[12] === me[12] && te[1] === me[1] && te[5] === me[5] && te[9] === me[9] && te[13] === me[13] && te[2] === me[2] && te[6] === me[6] && te[10] === me[10] && te[14] === me[14] && te[3] === me[3] && te[7] === me[7] && te[11] === me[11] && te[15] === me[15]) {
                    return true;
                  }
                  return false;
                }
                clone() {
                  const te = this.elements;
                  return new Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);
                }
                isIdentity() {
                  const te = this.elements;
                  if (te[0] === 1 && te[4] === 0 && te[8] === 0 && te[12] === 0 && te[1] === 0 && te[5] === 1 && te[9] === 0 && te[13] === 0 && te[2] === 0 && te[6] === 0 && te[10] === 1 && te[14] === 0 && te[3] === 0 && te[7] === 0 && te[11] === 0 && te[15] === 1) {
                    return true;
                  }
                  return false;
                }
                // return true if elements are with digits of identity
                isNearlyIdentity(digits) {
                  const snapped = this.clone().snap(digits);
                  return snapped.isIdentity();
                }
                getScale(scale) {
                  const te = this.elements;
                  scale = scale || new Vector3();
                  x.set(te[0], te[1], te[2]);
                  y.set(te[4], te[5], te[6]);
                  z.set(te[8], te[9], te[10]);
                  scale.x = x.length();
                  scale.y = y.length();
                  scale.z = z.length();
                  return scale;
                }
                lookAt(eye, target, up) {
                  const te = this.elements;
                  z.subVectors(eye, target).normalize();
                  if (z.length() === 0) {
                    z.z = 1;
                  }
                  x.crossVectors(up, z).normalize();
                  if (x.length() === 0) {
                    z.x += 1e-4;
                    x.crossVectors(up, z).normalize();
                  }
                  y.crossVectors(z, x);
                  te[0] = x.x;
                  te[4] = y.x;
                  te[8] = z.x;
                  te[1] = x.y;
                  te[5] = y.y;
                  te[9] = z.y;
                  te[2] = x.z;
                  te[6] = y.z;
                  te[10] = z.z;
                  return this;
                }
                compose(translation, rotation, scale) {
                  const te = this.elements;
                  mRotation.identity();
                  mRotation.setRotationFromQuaternion(rotation);
                  mScale.makeScale(scale.x, scale.y, scale.z);
                  this.multiplyMatrices(mRotation, mScale);
                  te[12] = translation.x;
                  te[13] = translation.y;
                  te[14] = translation.z;
                  return this;
                }
              }
              mRotation = new Matrix4();
              mScale = new Matrix4();
              class Vector3 {
                constructor(x2, y2, z2) {
                  this.x = x2 || 0;
                  this.y = y2 || 0;
                  this.z = z2 || 0;
                  this.atomid = void 0;
                }
                set(x2, y2, z2) {
                  this.x = x2;
                  this.y = y2;
                  this.z = z2;
                  return this;
                }
                copy(v) {
                  this.x = v.x;
                  this.y = v.y;
                  this.z = v.z;
                  return this;
                }
                add(v) {
                  this.x += v.x;
                  this.y += v.y;
                  this.z += v.z;
                  return this;
                }
                addVectors(a, b) {
                  this.x = a.x + b.x;
                  this.y = a.y + b.y;
                  this.z = a.z + b.z;
                  return this;
                }
                multiplyVectors(a, b) {
                  this.x = a.x * b.x;
                  this.y = a.y * b.y;
                  this.z = a.z * b.z;
                  return this;
                }
                sub(v) {
                  this.x -= v.x;
                  this.y -= v.y;
                  this.z -= v.z;
                  return this;
                }
                subVectors(a, b) {
                  this.x = a.x - b.x;
                  this.y = a.y - b.y;
                  this.z = a.z - b.z;
                  return this;
                }
                multiplyScalar(s) {
                  this.x *= s;
                  this.y *= s;
                  this.z *= s;
                  return this;
                }
                divideScalar(s) {
                  if (s !== 0) {
                    this.x /= s;
                    this.y /= s;
                    this.z /= s;
                  } else {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                  }
                  return this;
                }
                // accumulate maximum
                max(s) {
                  this.x = Math.max(this.x, s.x);
                  this.y = Math.max(this.y, s.y);
                  this.z = Math.max(this.z, s.z);
                  return this;
                }
                // accumulate min
                min(s) {
                  this.x = Math.min(this.x, s.x);
                  this.y = Math.min(this.y, s.y);
                  this.z = Math.min(this.z, s.z);
                  return this;
                }
                distanceTo(v) {
                  return Math.sqrt(this.distanceToSquared(v));
                }
                distanceToSquared(v) {
                  const dx = this.x - v.x;
                  const dy = this.y - v.y;
                  const dz = this.z - v.z;
                  return dx * dx + dy * dy + dz * dz;
                }
                applyMatrix3(m) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  const e = m.elements;
                  this.x = e[0] * x2 + e[3] * y2 + e[6] * z2;
                  this.y = e[1] * x2 + e[4] * y2 + e[7] * z2;
                  this.z = e[2] * x2 + e[5] * y2 + e[8] * z2;
                  return this;
                }
                applyMatrix4(m) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  const e = m.elements;
                  this.x = e[0] * x2 + e[4] * y2 + e[8] * z2 + e[12];
                  this.y = e[1] * x2 + e[5] * y2 + e[9] * z2 + e[13];
                  this.z = e[2] * x2 + e[6] * y2 + e[10] * z2 + e[14];
                  return this;
                }
                applyProjection(m) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  const e = m.elements;
                  const d = e[3] * x2 + e[7] * y2 + e[11] * z2 + e[15];
                  this.x = (e[0] * x2 + e[4] * y2 + e[8] * z2 + e[12]) / d;
                  this.y = (e[1] * x2 + e[5] * y2 + e[9] * z2 + e[13]) / d;
                  this.z = (e[2] * x2 + e[6] * y2 + e[10] * z2 + e[14]) / d;
                  return this;
                }
                applyQuaternion(q) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  const qx = q.x;
                  const qy = q.y;
                  const qz = q.z;
                  const qw = q.w;
                  const t = {};
                  t.x = 2 * (y2 * qz - z2 * qy);
                  t.y = 2 * (z2 * qx - x2 * qz);
                  t.z = 2 * (x2 * qy - y2 * qx);
                  const t2 = {};
                  t2.x = t.y * qz - t.z * qy;
                  t2.y = t.z * qx - t.x * qz;
                  t2.z = t.x * qy - t.y * qx;
                  this.x = x2 + qw * t.x + t2.x;
                  this.y = y2 + qw * t.y + t2.y;
                  this.z = z2 + qw * t.z + t2.z;
                  return this;
                }
                negate() {
                  return this.multiplyScalar(-1);
                }
                dot(v) {
                  return this.x * v.x + this.y * v.y + this.z * v.z;
                }
                length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                lengthSq() {
                  return this.x * this.x + this.y * this.y + this.z * this.z;
                }
                normalize() {
                  return this.divideScalar(this.length());
                }
                cross(v) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  this.x = y2 * v.z - z2 * v.y;
                  this.y = z2 * v.x - x2 * v.z;
                  this.z = x2 * v.y - y2 * v.x;
                  return this;
                }
                crossVectors(a, b) {
                  this.x = a.y * b.z - a.z * b.y;
                  this.y = a.z * b.x - a.x * b.z;
                  this.z = a.x * b.y - a.y * b.x;
                  return this;
                }
                equals(b) {
                  return this.x == b.x && this.y == b.y && this.z == b.z;
                }
                getPositionFromMatrix(m) {
                  this.x = m.elements[12];
                  this.y = m.elements[13];
                  this.z = m.elements[14];
                  return this;
                }
                setEulerFromRotationMatrix(m, order) {
                  const te = m.elements;
                  const m11 = te[0];
                  const m12 = te[4];
                  const m13 = te[8];
                  const m22 = te[5];
                  const m23 = te[9];
                  const m32 = te[6];
                  const m33 = te[10];
                  if (order === void 0 || order === "XYZ") {
                    this.y = Math.asin((0, _utils_clamp__WEBPACK_IMPORTED_MODULE_1__.clamp)(m13, -1, 1));
                    if (Math.abs(m13) < 0.99999) {
                      this.x = Math.atan2(-m23, m33);
                      this.z = Math.atan2(-m12, m11);
                    } else {
                      this.x = Math.atan2(m32, m22);
                      this.z = 0;
                    }
                  } else {
                    console.error(`Error with vector's setEulerFromRotationMatrix: Unknown order: ${order}`);
                  }
                  return this;
                }
                rotateAboutVector(axis, ang) {
                  axis.normalize();
                  const cosang = Math.cos(ang);
                  const sinang = Math.sin(ang);
                  const term1 = this.clone().multiplyScalar(cosang);
                  const term2 = axis.clone().cross(this).multiplyScalar(sinang);
                  const term3 = axis.clone().multiplyScalar(axis.clone().dot(this)).multiplyScalar(1 - cosang);
                  const rot = term1.add(term2).add(term3);
                  this.x = rot.x;
                  this.y = rot.y;
                  this.z = rot.z;
                  return this;
                }
                setFromMatrixPosition(m) {
                  const e = m.elements;
                  this.x = e[12];
                  this.y = e[13];
                  this.z = e[14];
                  return this;
                }
                // unproject is defined after Matrix4
                transformDirection(m) {
                  const { x: x2 } = this;
                  const { y: y2 } = this;
                  const { z: z2 } = this;
                  const e = m.elements;
                  this.x = e[0] * x2 + e[4] * y2 + e[8] * z2;
                  this.y = e[1] * x2 + e[5] * y2 + e[9] * z2;
                  this.z = e[2] * x2 + e[6] * y2 + e[10] * z2;
                  return this.normalize();
                }
                clone() {
                  return new Vector3(this.x, this.y, this.z);
                }
                unproject(camera) {
                  const mat4 = mRotation;
                  mat4.multiplyMatrices(camera.matrixWorld, mat4.getInverse(camera.projectionMatrix));
                  return this.applyMatrix4(mat4);
                }
              }
              x = new Vector3();
              y = new Vector3();
              z = new Vector3();
              class Matrix3 {
                constructor(n11 = 1, n12 = 0, n13 = 0, n21 = 0, n22 = 1, n23 = 0, n31 = 0, n32 = 0, n33 = 1) {
                  this.elements = new Float32Array(9);
                  this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
                }
                set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                  const te = this.elements;
                  te[0] = n11;
                  te[3] = n12;
                  te[6] = n13;
                  te[1] = n21;
                  te[4] = n22;
                  te[7] = n23;
                  te[2] = n31;
                  te[5] = n32;
                  te[8] = n33;
                  return this;
                }
                identity() {
                  this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                  return this;
                }
                copy(m) {
                  const me = m.elements;
                  this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
                }
                multiplyScalar(s) {
                  const te = this.elements;
                  te[0] *= s;
                  te[3] *= s;
                  te[6] *= s;
                  te[1] *= s;
                  te[4] *= s;
                  te[7] *= s;
                  te[2] *= s;
                  te[5] *= s;
                  te[8] *= s;
                  return this;
                }
                getInverse3(matrix) {
                  const me = matrix.elements;
                  const te = this.elements;
                  te[0] = me[4] * me[8] - me[5] * me[7];
                  te[3] = me[6] * me[5] - me[3] * me[8];
                  te[6] = me[3] * me[7] - me[6] * me[4];
                  te[1] = me[7] * me[2] - me[1] * me[8];
                  te[4] = me[0] * me[8] - me[6] * me[2];
                  te[7] = me[1] * me[6] - me[0] * me[7];
                  te[2] = me[1] * me[5] - me[2] * me[4];
                  te[5] = me[2] * me[3] - me[0] * me[5];
                  te[8] = me[0] * me[4] - me[1] * me[3];
                  const det = me[0] * te[0] + me[3] * te[1] + me[6] * te[2];
                  this.multiplyScalar(1 / det);
                  return this;
                }
                getInverse(matrix, throwOnInvertible) {
                  const me = matrix.elements;
                  const te = this.elements;
                  te[0] = me[10] * me[5] - me[6] * me[9];
                  te[1] = -me[10] * me[1] + me[2] * me[9];
                  te[2] = me[6] * me[1] - me[2] * me[5];
                  te[3] = -me[10] * me[4] + me[6] * me[8];
                  te[4] = me[10] * me[0] - me[2] * me[8];
                  te[5] = -me[6] * me[0] + me[2] * me[4];
                  te[6] = me[9] * me[4] - me[5] * me[8];
                  te[7] = -me[9] * me[0] + me[1] * me[8];
                  te[8] = me[5] * me[0] - me[1] * me[4];
                  const det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
                  if (det === 0) {
                    const msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                    if (throwOnInvertible || false) {
                      throw new Error(msg);
                    } else {
                      console.warn(msg);
                    }
                    this.identity();
                    return this;
                  }
                  this.multiplyScalar(1 / det);
                  return this;
                }
                // https://en.wikipedia.org/wiki/Determinant
                getDeterminant() {
                  const m = this.elements;
                  const determinant = m[0] * m[4] * m[8] + // +aei
                  m[1] * m[5] * m[6] + // +bfg
                  m[2] * m[3] * m[7] - // +cdh
                  m[2] * m[4] * m[6] - // -ceg
                  m[1] * m[3] * m[8] - // -bdi
                  m[0] * m[5] * m[7];
                  return determinant;
                }
                transpose() {
                  let tmp;
                  const m = this.elements;
                  tmp = m[1];
                  m[1] = m[3];
                  m[3] = tmp;
                  tmp = m[2];
                  m[2] = m[6];
                  m[6] = tmp;
                  tmp = m[5];
                  m[5] = m[7];
                  m[7] = tmp;
                  return this;
                }
                clone() {
                  const te = this.elements;
                  return new Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);
                }
                getMatrix4() {
                  const m = this.elements;
                  return new Matrix4(m[0], m[3], m[6], 0, m[1], m[4], m[7], 0, m[2], m[5], m[8], 0);
                }
              }
              class Ray {
                constructor(origin, direction) {
                  this.origin = origin !== void 0 ? origin : new Vector3();
                  this.direction = direction !== void 0 ? direction : new Vector3();
                }
                set(origin, direction) {
                  this.origin.copy(origin);
                  this.direction.copy(direction);
                  return this;
                }
                copy(ray) {
                  this.origin.copy(ray.origin);
                  this.direction.copy(ray.direction);
                  return this;
                }
                at(t, optionalTarget) {
                  const result = optionalTarget || new Vector3();
                  return result.copy(this.direction).multiplyScalar(t).add(this.origin);
                }
                recast(t) {
                  const v1 = x;
                  this.origin.copy(this.at(t, v1));
                  return this;
                }
                closestPointToPoint(point, optionalTarget) {
                  const result = optionalTarget || new Vector3();
                  result.subVectors(point, this.origin);
                  const directionDistance = result.dot(this.direction);
                  return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                }
                distanceToPoint(point) {
                  const v1 = x;
                  const directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                  v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                  return v1.distanceTo(point);
                }
                // eslint-disable-next-line class-methods-use-this
                isIntersectionCylinder() {
                }
                isIntersectionSphere(sphere) {
                  return this.distanceToPoint(sphere.center) <= sphere.radius;
                }
                isIntersectionPlane(plane) {
                  const denominator = plane.normal.dot(this.direction);
                  if (denominator !== 0)
                    return true;
                  if (plane.distanceToPoint(this.origin) === 0)
                    return true;
                  return false;
                }
                distanceToPlane(plane) {
                  const denominator = plane.normal.dot(this.direction);
                  if (denominator === 0) {
                    if (plane.distanceToPoint(this.origin) === 0)
                      return 0;
                    return void 0;
                  }
                  const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                  return t;
                }
                intersectPlane(plane, optionalTarget) {
                  const t = this.distanceToPlane(plane);
                  if (t === void 0)
                    return void 0;
                  return this.at(t, optionalTarget);
                }
                applyMatrix4(matrix4) {
                  this.direction.add(this.origin).applyMatrix4(matrix4);
                  this.origin.applyMatrix4(matrix4);
                  this.direction.sub(this.origin);
                  return this;
                }
                clone() {
                  return new Ray().copy(this);
                }
              }
            },
            /***/
            "./src/WebGL/math/utils/clamp.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                clamp: () => (
                  /* binding */
                  clamp
                )
                /* harmony export */
              });
              function clamp(x, min, max) {
                return Math.min(Math.max(x, min), max);
              }
            },
            /***/
            "./src/WebGL/math/utils/conversionMatrix3.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                conversionMatrix3: () => (
                  /* binding */
                  conversionMatrix3
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/math.ts"
              );
              function conversionMatrix3(a, b, c, alpha, beta, gamma) {
                alpha = alpha * Math.PI / 180;
                beta = beta * Math.PI / 180;
                gamma = gamma * Math.PI / 180;
                const sqr = (x) => {
                  return x * x;
                };
                const cosAlpha = Math.cos(alpha);
                const cosBeta = Math.cos(beta);
                const cosGamma = Math.cos(gamma);
                const sinGamma = Math.sin(gamma);
                const conversionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix3(a, b * cosGamma, c * cosBeta, 0, b * sinGamma, c * (cosAlpha - cosBeta * cosGamma) / sinGamma, 0, 0, c * Math.sqrt(1 - sqr(cosAlpha) - sqr(cosBeta) - sqr(cosGamma) + 2 * cosAlpha * cosBeta * cosGamma) / sinGamma);
                return conversionMatrix;
              }
            },
            /***/
            "./src/WebGL/math/utils/degToRad.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                degToRad: () => (
                  /* binding */
                  degToRad
                )
                /* harmony export */
              });
              const degreeToRadiansFactor = Math.PI / 180;
              function degToRad(deg) {
                return deg * degreeToRadiansFactor;
              }
            },
            /***/
            "./src/WebGL/objects/Line.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Line: () => (
                  /* binding */
                  Line
                ),
                /* harmony export */
                LineStyle: () => (
                  /* binding */
                  LineStyle
                )
                /* harmony export */
              });
              var _materials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../materials */
                "./src/WebGL/materials/index.ts"
              );
              var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../core */
                "./src/WebGL/core/index.ts"
              );
              var LineStyle;
              (function(LineStyle2) {
                LineStyle2[LineStyle2["LineStrip"] = 0] = "LineStrip";
                LineStyle2[LineStyle2["LinePieces"] = 1] = "LinePieces";
              })(LineStyle || (LineStyle = {}));
              class Line extends _core__WEBPACK_IMPORTED_MODULE_1__.Object3D {
                constructor(geometry, material = new _materials__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
                  color: Math.random() * 16777215
                }), type = LineStyle.LineStrip) {
                  super();
                  this.geometry = geometry;
                  this.material = material;
                  this.type = type;
                }
                clone(object = new Line(this.geometry, this.material, this.type)) {
                  super.clone.call(this, object);
                  return object;
                }
              }
            },
            /***/
            "./src/WebGL/objects/Mesh.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Mesh: () => (
                  /* binding */
                  Mesh
                )
                /* harmony export */
              });
              var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../core */
                "./src/WebGL/core/index.ts"
              );
              class Mesh extends _core__WEBPACK_IMPORTED_MODULE_0__.Object3D {
                constructor(geometry, material) {
                  super();
                  this.geometry = geometry;
                  this.material = material;
                }
                clone(object) {
                  if (object === void 0)
                    object = new Mesh(this.geometry, this.material);
                  super.clone.call(this, object);
                  return object;
                }
              }
            },
            /***/
            "./src/WebGL/objects/Sprite.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Sprite: () => (
                  /* binding */
                  Sprite
                )
                /* harmony export */
              });
              var _materials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../materials */
                "./src/WebGL/materials/index.ts"
              );
              var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../core */
                "./src/WebGL/core/index.ts"
              );
              class Sprite extends _core__WEBPACK_IMPORTED_MODULE_1__.Object3D {
                constructor(material = new _materials__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial()) {
                  super();
                  this.material = material;
                  this.rotation3d = this.rotation;
                  this.rotation = 0;
                }
                updateMatrix() {
                  this.matrix.setPosition(this.position);
                  this.rotation3d.set(0, 0, this.rotation);
                  this.matrix.setRotationFromEuler(this.rotation3d);
                  if (this.scale.x !== 1 || this.scale.y !== 1)
                    this.matrix.scale(this.scale);
                  this.matrixWorldNeedsUpdate = true;
                }
                clone(object = new Sprite(this.material)) {
                  _core__WEBPACK_IMPORTED_MODULE_1__.Object3D.prototype.clone.call(this, object);
                  return object;
                }
              }
            },
            /***/
            "./src/WebGL/objects/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Line: () => (
                  /* reexport safe */
                  _Line__WEBPACK_IMPORTED_MODULE_0__.Line
                ),
                /* harmony export */
                LineStyle: () => (
                  /* reexport safe */
                  _Line__WEBPACK_IMPORTED_MODULE_0__.LineStyle
                ),
                /* harmony export */
                Mesh: () => (
                  /* reexport safe */
                  _Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh
                ),
                /* harmony export */
                Sprite: () => (
                  /* reexport safe */
                  _Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite
                )
                /* harmony export */
              });
              var _Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./Line */
                "./src/WebGL/objects/Line.ts"
              );
              var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Mesh */
                "./src/WebGL/objects/Mesh.ts"
              );
              var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Sprite */
                "./src/WebGL/objects/Sprite.ts"
              );
            },
            /***/
            "./src/WebGL/shaders/ShaderType.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
            },
            /***/
            "./src/WebGL/shaders/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ShaderLib: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderLib
                ),
                /* harmony export */
                ShaderUtils: () => (
                  /* reexport safe */
                  _utils__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils
                ),
                /* harmony export */
                basic: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.basic
                ),
                /* harmony export */
                clone: () => (
                  /* reexport safe */
                  _utils__WEBPACK_IMPORTED_MODULE_1__.clone
                ),
                /* harmony export */
                instanced: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.instanced
                ),
                /* harmony export */
                lambert: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.lambert
                ),
                /* harmony export */
                lambertdouble: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.lambertdouble
                ),
                /* harmony export */
                outline: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.outline
                ),
                /* harmony export */
                screen: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.screen
                ),
                /* harmony export */
                screenaa: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.screenaa
                ),
                /* harmony export */
                sphereimposter: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.sphereimposter
                ),
                /* harmony export */
                sphereimposteroutline: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.sphereimposteroutline
                ),
                /* harmony export */
                sprite: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.sprite
                ),
                /* harmony export */
                stickimposter: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.stickimposter
                ),
                /* harmony export */
                stickimposteroutline: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.stickimposteroutline
                ),
                /* harmony export */
                volumetric: () => (
                  /* reexport safe */
                  _lib__WEBPACK_IMPORTED_MODULE_0__.volumetric
                )
                /* harmony export */
              });
              var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./lib */
                "./src/WebGL/shaders/lib/index.ts"
              );
              var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils */
                "./src/WebGL/shaders/utils/index.ts"
              );
              var _ShaderType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./ShaderType */
                "./src/WebGL/shaders/ShaderType.ts"
              );
            },
            /***/
            "./src/WebGL/shaders/lib/basic/basic.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 viewMatrix;\nuniform float opacity;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nvarying vec3 vColor;\nvarying vec4 mvPosition;\n\n//DEFINEFRAGCOLOR\nvoid main() {\n    gl_FragColor = vec4( vColor, opacity );\n    if(fogNear != fogFar) {\n        float depth = -mvPosition.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/basic/basic.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n\nattribute vec3 position;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n    vColor = color;\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/basic/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                basic: () => (
                  /* binding */
                  basic
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/basic/uniforms.ts"
              );
              var _basic_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./basic.frag */
                "./src/WebGL/shaders/lib/basic/basic.frag"
              );
              var _basic_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./basic.vert */
                "./src/WebGL/shaders/lib/basic/basic.vert"
              );
              const basic = {
                vertexShader: _basic_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                fragmentShader: _basic_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/basic/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/blur/blur.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "const float INV_TOTAL_SAMPLES_FACTOR = 1.0 / 9.0;\nuniform highp sampler2D inTex;\nvarying highp vec2 vTexCoords;\n    \nvoid main() {\n \n vec2 texelSize = 1.0 / vec2(textureSize(inTex,0));\n float blurred_visibility_factor = 0.0f;\n for (int t = -1; t <= 1; ++t) {\n  for (int s = -1; s <= 1; ++s) {\n   vec2 offset = vec2(float(s), float(t)) * texelSize;\n   blurred_visibility_factor += texture2D(inTex, vTexCoords + offset).r;\n  }\n }\n    \n gl_FragDepthEXT = blurred_visibility_factor * INV_TOTAL_SAMPLES_FACTOR;\n \n}";
            },
            /***/
            "./src/WebGL/shaders/lib/blur/blur.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "attribute vec2 vertexPosition;\nvarying highp vec2 vTexCoords;\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main() {\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\n}\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/blur/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                blur: () => (
                  /* binding */
                  blur
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/blur/uniforms.ts"
              );
              var _blur_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./blur.frag */
                "./src/WebGL/shaders/lib/blur/blur.frag"
              );
              var _blur_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./blur.vert */
                "./src/WebGL/shaders/lib/blur/blur.vert"
              );
              const blur = {
                fragmentShader: _blur_frag__WEBPACK_IMPORTED_MODULE_1__["default"],
                vertexShader: _blur_vert__WEBPACK_IMPORTED_MODULE_2__["default"],
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/blur/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              const uniforms = {};
            },
            /***/
            "./src/WebGL/shaders/lib/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ShaderLib: () => (
                  /* binding */
                  ShaderLib
                ),
                /* harmony export */
                basic: () => (
                  /* reexport safe */
                  _basic__WEBPACK_IMPORTED_MODULE_0__.basic
                ),
                /* harmony export */
                instanced: () => (
                  /* reexport safe */
                  _instanced__WEBPACK_IMPORTED_MODULE_1__.instanced
                ),
                /* harmony export */
                lambert: () => (
                  /* reexport safe */
                  _lambert__WEBPACK_IMPORTED_MODULE_2__.lambert
                ),
                /* harmony export */
                lambertdouble: () => (
                  /* reexport safe */
                  _lambertdouble__WEBPACK_IMPORTED_MODULE_3__.lambertdouble
                ),
                /* harmony export */
                outline: () => (
                  /* reexport safe */
                  _outline__WEBPACK_IMPORTED_MODULE_4__.outline
                ),
                /* harmony export */
                screen: () => (
                  /* reexport safe */
                  _screen__WEBPACK_IMPORTED_MODULE_5__.screen
                ),
                /* harmony export */
                screenaa: () => (
                  /* reexport safe */
                  _screenaa__WEBPACK_IMPORTED_MODULE_6__.screenaa
                ),
                /* harmony export */
                sphereimposter: () => (
                  /* reexport safe */
                  _sphereimposter__WEBPACK_IMPORTED_MODULE_7__.sphereimposter
                ),
                /* harmony export */
                sphereimposteroutline: () => (
                  /* reexport safe */
                  _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__.sphereimposteroutline
                ),
                /* harmony export */
                sprite: () => (
                  /* reexport safe */
                  _sprite__WEBPACK_IMPORTED_MODULE_9__.sprite
                ),
                /* harmony export */
                stickimposter: () => (
                  /* reexport safe */
                  _stickimposter__WEBPACK_IMPORTED_MODULE_10__.stickimposter
                ),
                /* harmony export */
                stickimposteroutline: () => (
                  /* reexport safe */
                  _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__.stickimposteroutline
                ),
                /* harmony export */
                volumetric: () => (
                  /* reexport safe */
                  _volumetric__WEBPACK_IMPORTED_MODULE_12__.volumetric
                )
                /* harmony export */
              });
              var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./basic */
                "./src/WebGL/shaders/lib/basic/index.ts"
              );
              var _instanced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./instanced */
                "./src/WebGL/shaders/lib/instanced/index.ts"
              );
              var _lambert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./lambert */
                "./src/WebGL/shaders/lib/lambert/index.ts"
              );
              var _lambertdouble__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./lambertdouble */
                "./src/WebGL/shaders/lib/lambertdouble/index.ts"
              );
              var _outline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./outline */
                "./src/WebGL/shaders/lib/outline/index.ts"
              );
              var _screen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./screen */
                "./src/WebGL/shaders/lib/screen/index.ts"
              );
              var _screenaa__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./screenaa */
                "./src/WebGL/shaders/lib/screenaa/index.ts"
              );
              var _sphereimposter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./sphereimposter */
                "./src/WebGL/shaders/lib/sphereimposter/index.ts"
              );
              var _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./sphereimposteroutline */
                "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts"
              );
              var _sprite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./sprite */
                "./src/WebGL/shaders/lib/sprite/index.ts"
              );
              var _stickimposter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./stickimposter */
                "./src/WebGL/shaders/lib/stickimposter/index.ts"
              );
              var _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                /*! ./stickimposteroutline */
                "./src/WebGL/shaders/lib/stickimposteroutline/index.ts"
              );
              var _volumetric__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                /*! ./volumetric */
                "./src/WebGL/shaders/lib/volumetric/index.ts"
              );
              var _ssao__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                /*! ./ssao */
                "./src/WebGL/shaders/lib/ssao/index.ts"
              );
              var _blur__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                /*! ./blur */
                "./src/WebGL/shaders/lib/blur/index.ts"
              );
              const ShaderLib = {
                basic: _basic__WEBPACK_IMPORTED_MODULE_0__.basic,
                blur: _blur__WEBPACK_IMPORTED_MODULE_14__.blur,
                instanced: _instanced__WEBPACK_IMPORTED_MODULE_1__.instanced,
                lambert: _lambert__WEBPACK_IMPORTED_MODULE_2__.lambert,
                lambertdouble: _lambertdouble__WEBPACK_IMPORTED_MODULE_3__.lambertdouble,
                outline: _outline__WEBPACK_IMPORTED_MODULE_4__.outline,
                screen: _screen__WEBPACK_IMPORTED_MODULE_5__.screen,
                screenaa: _screenaa__WEBPACK_IMPORTED_MODULE_6__.screenaa,
                ssao: _ssao__WEBPACK_IMPORTED_MODULE_13__.ssao,
                sphereimposter: _sphereimposter__WEBPACK_IMPORTED_MODULE_7__.sphereimposter,
                sphereimposteroutline: _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__.sphereimposteroutline,
                sprite: _sprite__WEBPACK_IMPORTED_MODULE_9__.sprite,
                stickimposter: _stickimposter__WEBPACK_IMPORTED_MODULE_10__.stickimposter,
                stickimposteroutline: _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__.stickimposteroutline,
                volumetric: _volumetric__WEBPACK_IMPORTED_MODULE_12__.volumetric
              };
            },
            /***/
            "./src/WebGL/shaders/lib/instanced/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                instanced: () => (
                  /* binding */
                  instanced
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/instanced/uniforms.ts"
              );
              var _instanced_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./instanced.frag */
                "./src/WebGL/shaders/lib/instanced/instanced.frag"
              );
              var _instanced_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./instanced.vert */
                "./src/WebGL/shaders/lib/instanced/instanced.vert"
              );
              const instanced = {
                fragmentShader: _instanced_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _instanced_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/instanced/instanced.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 viewMatrix;\nuniform float opacity;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#ifdef SHADED\nuniform highp sampler2D shading;\n#endif\nvarying vec3 vLightFront;\nvarying vec3 vColor;\n//DEFINEFRAGCOLOR\n\nvoid main() {\n\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n\n    #ifndef WIREFRAME\n    gl_FragColor.xyz *= vLightFront;\n    #endif\n\n#ifdef SHADED\n    ivec2 dim = textureSize(shading,0);\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\n    vColor *= shadowFactor;\n#endif\n    gl_FragColor = gl_FragColor * vec4( vColor, opacity );\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n}\n\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/instanced/instanced.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\n\nattribute vec3 offset;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\nattribute float radius;\n\nvarying vec3 vColor;\nvarying vec3 vLightFront;\n\nvoid main() {\n\n    vColor = color;\n\n    vec3 objectNormal = normal;\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );\n\n    vLightFront = vec3( 0.0 );\n\n    transformedNormal = normalize( transformedNormal );\n\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\n    vec3 dirVector = normalize( lDirection.xyz );\n    float dotProduct = dot( transformedNormal, dirVector );\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/instanced/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                directionalLightColor: { type: "fv", value: [] },
                directionalLightDirection: { type: "fv", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/lambert/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                lambert: () => (
                  /* binding */
                  lambert
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/lambert/uniforms.ts"
              );
              var _lambert_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./lambert.frag */
                "./src/WebGL/shaders/lib/lambert/lambert.frag"
              );
              var _lambert_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./lambert.vert */
                "./src/WebGL/shaders/lib/lambert/lambert.vert"
              );
              const lambert = {
                fragmentShader: _lambert_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _lambert_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/lambert/lambert.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 viewMatrix;\nuniform float opacity;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#ifdef SHADED\nuniform highp sampler2D shading;\n#endif\nvarying vec3 vLightFront;\nvarying vec3 vColor;\nvarying vec4 mvPosition;\n\n\n//DEFINEFRAGCOLOR\n\nvoid main() {\n\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n\n    #ifndef WIREFRAME\n    gl_FragColor.xyz *= vLightFront;\n    #endif\n#ifdef SHADED\n    ivec2 dim = textureSize(shading,0);\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\n    vColor *= shadowFactor;\n#endif\n    gl_FragColor = gl_FragColor * vec4( vColor, opacity );\n\n    if(fogNear != fogFar) {\n        float depth = -mvPosition.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/lambert/lambert.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvarying vec3 vLightFront;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n    vColor = color;\n\n    vec3 objectNormal = normal;\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n    vLightFront = vec3( 0.0 );\n\n    transformedNormal = normalize( transformedNormal );\n\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\n    vec3 dirVector = normalize( lDirection.xyz );\n    float dotProduct = dot( transformedNormal, dirVector );\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\n\n    gl_Position = projectionMatrix * mvPosition;\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/lambert/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                directionalLightColor: { type: "fv", value: [] },
                directionalLightDirection: { type: "fv", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/lambertdouble/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                lambertdouble: () => (
                  /* binding */
                  lambertdouble
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts"
              );
              var _lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./lambertdouble.frag */
                "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag"
              );
              var _lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./lambertdouble.vert */
                "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert"
              );
              const lambertdouble = {
                fragmentShader: _lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n#ifdef SHADED\nuniform highp sampler2D shading;\n#endif\n\nuniform mat4 viewMatrix;\nuniform float opacity;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying vec3 vLightFront;\nvarying vec3 vLightBack;\n\nvarying vec3 vColor;\nvarying vec4 mvPosition;\n\n//DEFINEFRAGCOLOR\n\nvoid main() {\n\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n\n    #ifndef WIREFRAME\n    if ( gl_FrontFacing )\n       gl_FragColor.xyz *= vLightFront;\n    else\n       gl_FragColor.xyz *= vLightBack;\n    #endif\n\n    vec3 color = vColor;\n#ifdef SHADED\n    ivec2 dim = textureSize(shading,0);\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\n    color *= shadowFactor;\n#endif\n    gl_FragColor = gl_FragColor * vec4( color, opacity );\n\n    if(fogNear != fogFar) {\n        float depth = -mvPosition.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n\n}\n\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvarying vec3 vLightFront;\nvarying vec3 vLightBack;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n    vColor = color;\n\n    vec3 objectNormal = normal;\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n    vLightFront = vec3( 0.0 );\n    vLightBack = vec3( 0.0 );\n\n    transformedNormal = normalize( transformedNormal );\n\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\n    vec3 dirVector = normalize( lDirection.xyz );\n    float dotProduct = dot( transformedNormal, dirVector );\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\n    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                directionalLightColor: { type: "fv", value: [] },
                directionalLightDirection: { type: "fv", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/outline/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                outline: () => (
                  /* binding */
                  outline
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/outline/uniforms.ts"
              );
              var _outline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./outline.frag */
                "./src/WebGL/shaders/lib/outline/outline.frag"
              );
              var _outline_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./outline.vert */
                "./src/WebGL/shaders/lib/outline/outline.vert"
              );
              const outline = {
                fragmentShader: _outline_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _outline_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/outline/outline.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform float opacity;\nuniform vec3 outlineColor;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying vec4 mvPosition;\n//DEFINEFRAGCOLOR\n\nvoid main() {\n    gl_FragColor = vec4( outlineColor, 1 );\n\n    if(fogNear != fogFar) {\n        float depth = -mvPosition.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n}\n\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/outline/outline.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float outlineWidth;\nuniform float outlinePushback;\nuniform float vWidth;\nuniform float vHeight;\nuniform float outlineMaxPixels;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\n\nvarying vec4 mvPosition;\n\nvoid main() {\n\n    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    mvPosition.xy += norm.xy*outlineWidth;\n    vec4 outpos = projectionMatrix * mvPosition;\n\n    if(outlineMaxPixels > 0.0) {\n        vec4 unadjusted = projectionMatrix*modelViewMatrix * vec4( position, 1.0 );\n        float w = outpos.w;\n        //normalize homogeneous coords\n        unadjusted /= unadjusted.w;\n        outpos /= outpos.w;\n        vec2 diff = outpos.xy-unadjusted.xy;\n        //put into pixels\n        diff.x *= vWidth;\n        diff.y *= vHeight;\n        if ( length(diff) > outlineMaxPixels) {\n            vec2 ndiff = normalize(diff)*outlineMaxPixels;\n            ndiff.x /= vWidth;\n            ndiff.y /= vHeight;\n            outpos.xy = unadjusted.xy;\n            outpos.xy += ndiff;\n        }\n        outpos *= w; //if I don't do this things blow up\n    }\n    gl_Position = outpos;\n    mvPosition.z -= outlinePushback; //go backwards in model space\n    vec4 pushpos = projectionMatrix*mvPosition; //project to get z in projection space, I'm probably missing some simple math to do the same thing..\n    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/outline/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                outlineColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0) },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                outlineWidth: { type: "f", value: 0.1 },
                outlinePushback: { type: "f", value: 1 },
                outlineMaxPixels: { type: "f", value: 0 }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/screen/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                screen: () => (
                  /* binding */
                  screen
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/screen/uniforms.ts"
              );
              var _screen_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./screen.frag */
                "./src/WebGL/shaders/lib/screen/screen.frag"
              );
              var _screen_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./screen.vert */
                "./src/WebGL/shaders/lib/screen/screen.vert"
              );
              const screen = {
                fragmentShader: _screen_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _screen_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/screen/screen.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform sampler2D colormap;\nvarying highp vec2 vTexCoords;\nuniform vec2 dimensions;\n//DEFINEFRAGCOLOR\nvoid main (void) {\n   gl_FragColor = texture2D(colormap, vTexCoords);\n\n   //gl_FragColor.g = gl_FragColor.b =  gl_FragColor.r; //debug shading \n}\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/screen/screen.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "attribute vec2 vertexPosition;\nvarying highp vec2 vTexCoords;\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main() {\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\n}\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/screen/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              const uniforms = {};
            },
            /***/
            "./src/WebGL/shaders/lib/screenaa/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                screenaa: () => (
                  /* binding */
                  screenaa
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/screenaa/uniforms.ts"
              );
              var _screenaa_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./screenaa.frag */
                "./src/WebGL/shaders/lib/screenaa/screenaa.frag"
              );
              var _screenaa_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./screenaa.vert */
                "./src/WebGL/shaders/lib/screenaa/screenaa.vert"
              );
              const screenaa = {
                fragmentShader: _screenaa_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _screenaa_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/screenaa/screenaa.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n        \nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nuniform sampler2D tColor;\nvarying highp vec2 vTexCoords;\n\n// adapted from https://github.com/kosua20/Rendu\n// MIT License Copyright (c) 2017 Simon Rodriguez\n// by way of molstar (https://github.com/molstar/molstar/blob/master/src/mol-gl/shader/fxaa.frag.ts)\n\n#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n\nfloat rgb2luma(vec3 rgb){\n    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));\n}\n\nfloat sampleLuma(vec2 uv) {\n    return rgb2luma(texture2D(tColor, uv).rgb);\n}\n\nfloat sampleLuma(vec2 uv, float uOffset, float vOffset) {\n    uv += vec2(uOffset, vOffset);\n    return sampleLuma(uv);\n}\n\n//DEFINEFRAGCOLOR\nvoid main(void) {\n    ivec2 dim = textureSize(tColor,0);\n    vec2 dimensions = vec2(float(dim.x),float(dim.y));\n    vec2 inverseScreenSize = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);\n    vec2 coords = vTexCoords;\n\n    vec4 colorCenter = texture2D(tColor, coords);\n    float dEdgeThresholdMin = 0.0312;\n    float dEdgeThresholdMax = 0.125;\n    int dIterations = 12;\n    float dSubpixelQuality = 0.3;\n\n    // Luma at the current fragment\n    float lumaCenter = rgb2luma(colorCenter.rgb);\n\n    // Luma at the four direct neighbours of the current fragment.\n    float lumaDown = sampleLuma(coords, 0.0, -inverseScreenSize.y);\n    float lumaUp = sampleLuma(coords, 0.0, inverseScreenSize.y);\n    float lumaLeft = sampleLuma(coords, -inverseScreenSize.x, 0.0);\n    float lumaRight = sampleLuma(coords, inverseScreenSize.x, 0.0);\n\n    // Find the maximum and minimum luma around the current fragment.\n    float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));\n\n    // Compute the delta.\n    float lumaRange = lumaMax - lumaMin;\n\n    // If the luma variation is lower that a threshold (or if we are in a really dark area),\n    // we are not on an edge, don't perform any AA.\n    if (lumaRange < max(dEdgeThresholdMin, lumaMax * dEdgeThresholdMax)) {\n        gl_FragColor = colorCenter;\n        return;\n    }\n\n    // Query the 4 remaining corners lumas.\n    float lumaDownLeft = sampleLuma(coords, -inverseScreenSize.x, -inverseScreenSize.y);\n    float lumaUpRight = sampleLuma(coords, inverseScreenSize.x, inverseScreenSize.y);\n    float lumaUpLeft = sampleLuma(coords, -inverseScreenSize.x, inverseScreenSize.y);\n    float lumaDownRight = sampleLuma(coords, inverseScreenSize.x, -inverseScreenSize.y);\n\n    // Combine the four edges lumas (using intermediary variables for future computations\n    // with the same values).\n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n\n    // Same for corners\n    float lumaLeftCorners = lumaDownLeft + lumaUpLeft;\n    float lumaDownCorners = lumaDownLeft + lumaDownRight;\n    float lumaRightCorners = lumaDownRight + lumaUpRight;\n    float lumaUpCorners = lumaUpRight + lumaUpLeft;\n\n    // Compute an estimation of the gradient along the horizontal and vertical axis.\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaLeftCorners) + abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 + abs(-2.0 * lumaRight + lumaRightCorners);\n    float edgeVertical = abs(-2.0 * lumaUp + lumaUpCorners) + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 + abs(-2.0 * lumaDown + lumaDownCorners);\n\n    // Is the local edge horizontal or vertical ?\n    bool isHorizontal = (edgeHorizontal >= edgeVertical);\n\n    // Choose the step size (one pixel) accordingly.\n    float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;\n\n    // Select the two neighboring texels lumas in the opposite direction to the local edge.\n    float luma1 = isHorizontal ? lumaDown : lumaLeft;\n    float luma2 = isHorizontal ? lumaUp : lumaRight;\n    // Compute gradients in this direction.\n    float gradient1 = luma1 - lumaCenter;\n    float gradient2 = luma2 - lumaCenter;\n\n    // Which direction is the steepest ?\n    bool is1Steepest = abs(gradient1) >= abs(gradient2);\n\n    // Gradient in the corresponding direction, normalized.\n    float gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));\n\n    // Average luma in the correct direction.\n    float lumaLocalAverage = 0.0;\n    if(is1Steepest){\n        // Switch the direction\n        stepLength = -stepLength;\n        lumaLocalAverage = 0.5 * (luma1 + lumaCenter);\n    } else {\n        lumaLocalAverage = 0.5 * (luma2 + lumaCenter);\n    }\n\n    // Shift UV in the correct direction by half a pixel.\n    vec2 currentUv = coords;\n    if(isHorizontal){\n        currentUv.y += stepLength * 0.5;\n    } else {\n        currentUv.x += stepLength * 0.5;\n    }\n\n    // Compute offset (for each iteration step) in the right direction.\n    vec2 offset = isHorizontal ? vec2(inverseScreenSize.x, 0.0) : vec2(0.0, inverseScreenSize.y);\n    // Compute UVs to explore on each side of the edge, orthogonally.\n    // The QUALITY allows us to step faster.\n    vec2 uv1 = currentUv - offset * QUALITY(0);\n    vec2 uv2 = currentUv + offset * QUALITY(0);\n\n    // Read the lumas at both current extremities of the exploration segment,\n    // and compute the delta wrt to the local average luma.\n    float lumaEnd1 = sampleLuma(uv1);\n    float lumaEnd2 = sampleLuma(uv2);\n    lumaEnd1 -= lumaLocalAverage;\n    lumaEnd2 -= lumaLocalAverage;\n\n    // If the luma deltas at the current extremities is larger than the local gradient,\n    // we have reached the side of the edge.\n    bool reached1 = abs(lumaEnd1) >= gradientScaled;\n    bool reached2 = abs(lumaEnd2) >= gradientScaled;\n    bool reachedBoth = reached1 && reached2;\n\n    // If the side is not reached, we continue to explore in this direction.\n    if(!reached1){\n        uv1 -= offset * QUALITY(1);\n    }\n    if(!reached2){\n        uv2 += offset * QUALITY(1);\n    }\n\n    // If both sides have not been reached, continue to explore.\n    if(!reachedBoth){\n        for(int i = 2; i < dIterations; i++){\n            // If needed, read luma in 1st direction, compute delta.\n            if(!reached1){\n                lumaEnd1 = sampleLuma(uv1);\n                lumaEnd1 = lumaEnd1 - lumaLocalAverage;\n            }\n            // If needed, read luma in opposite direction, compute delta.\n            if(!reached2){\n                lumaEnd2 = sampleLuma(uv2);\n                lumaEnd2 = lumaEnd2 - lumaLocalAverage;\n            }\n            // If the luma deltas at the current extremities is larger than the local gradient,\n            // we have reached the side of the edge.\n            reached1 = abs(lumaEnd1) >= gradientScaled;\n            reached2 = abs(lumaEnd2) >= gradientScaled;\n            reachedBoth = reached1 && reached2;\n\n            // If the side is not reached, we continue to explore in this direction,\n            // with a variable quality.\n            if(!reached1){\n                uv1 -= offset * QUALITY(i);\n            }\n            if(!reached2){\n                uv2 += offset * QUALITY(i);\n            }\n\n            // If both sides have been reached, stop the exploration.\n            if(reachedBoth){\n                break;\n            }\n        }\n    }\n\n    // Compute the distances to each side edge of the edge (!).\n    float distance1 = isHorizontal ? (coords.x - uv1.x) : (coords.y - uv1.y);\n    float distance2 = isHorizontal ? (uv2.x - coords.x) : (uv2.y - coords.y);\n\n    // In which direction is the side of the edge closer ?\n    bool isDirection1 = distance1 < distance2;\n    float distanceFinal = min(distance1, distance2);\n\n    // Thickness of the edge.\n    float edgeThickness = (distance1 + distance2);\n\n    // Is the luma at center smaller than the local average ?\n    bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;\n\n    // If the luma at center is smaller than at its neighbour,\n    // the delta luma at each end should be positive (same variation).\n    bool correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;\n    bool correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;\n\n    // Only keep the result in the direction of the closer side of the edge.\n    bool correctVariation = isDirection1 ? correctVariation1 : correctVariation2;\n\n    // UV offset: read in the direction of the closest side of the edge.\n    float pixelOffset = - distanceFinal / edgeThickness + 0.5;\n\n    // If the luma variation is incorrect, do not offset.\n    float finalOffset = correctVariation ? pixelOffset : 0.0;\n\n    // Sub-pixel shifting\n    // Full weighted average of the luma over the 3x3 neighborhood.\n    float lumaAverage = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);\n    // Ratio of the delta between the global average and the center luma,\n    // over the luma range in the 3x3 neighborhood.\n    float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter) / lumaRange, 0.0, 1.0);\n    float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;\n    // Compute a sub-pixel offset based on this delta.\n    float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * float(dSubpixelQuality);\n\n    // Pick the biggest of the two offsets.\n    finalOffset = max(finalOffset, subPixelOffsetFinal);\n\n    // Compute the final UV coordinates.\n    vec2 finalUv = coords;\n    if(isHorizontal){\n        finalUv.y += finalOffset * stepLength;\n    } else {\n        finalUv.x += finalOffset * stepLength;\n    }\n\n    // Read the color at the new UV coordinates, and use it.\n    gl_FragColor = texture2D(tColor, finalUv);\n}        \n\n/* old fxaa implementation\nuniform highp sampler2D colormap;\nvarying highp vec2 vTexCoords;\n\n\n// Basic FXAA implementation based on the code on geeks3d.com \n#define FXAA_REDUCE_MIN (1.0/ 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 8.0\n\n\nvec4 applyFXAA(vec2 fragCoord, highp sampler2D tex)\n{\n    vec4 color;\n    ivec2 dim = textureSize(tex,0);\n    vec2 dimensions = vec2(float(dim.x),float(dim.y));\n    vec2 inverseVP = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);\n    vec4 rgbNW = texture2D(tex, fragCoord + vec2(-1.0, -1.0) * inverseVP);\n    vec4 rgbNE = texture2D(tex, fragCoord + vec2(1.0, -1.0) * inverseVP);\n    vec4 rgbSW = texture2D(tex, fragCoord + vec2(-1.0, 1.0) * inverseVP);\n    vec4 rgbSE = texture2D(tex, fragCoord + vec2(1.0, 1.0) * inverseVP);\n    vec4 rgbM  = texture2D(tex, fragCoord );\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW.xyz, luma);\n    float lumaNE = dot(rgbNE.xyz, luma);\n    float lumaSW = dot(rgbSW.xyz, luma);\n    float lumaSE = dot(rgbSE.xyz, luma);\n    float lumaM  = dot(rgbM.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n            dir * rcpDirMin)) * inverseVP;\n\n    vec4 rgbA = 0.5 * (\n        texture2D(tex, fragCoord + dir * (1.0 / 3.0 - 0.5)) +\n        texture2D(tex, fragCoord  + dir * (2.0 / 3.0 - 0.5)));\n    vec4 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord  + dir * -0.5) +\n        texture2D(tex, fragCoord  + dir * 0.5));\n\n    float lumaB = dot(rgbB.xyz, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = rgbA;\n    else\n        color = rgbB;\n\n    return color;\n}\n\n\n//DEFINEFRAGCOLOR\nvoid main (void) {\n    ivec2 dim = textureSize(colormap,0);\n\n  gl_FragColor = applyFXAA(vTexCoords, colormap);\n}\n        \n*/";
            },
            /***/
            "./src/WebGL/shaders/lib/screenaa/screenaa.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "attribute vec2 vertexPosition;\nvarying highp vec2 vTexCoords;\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main() {\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\n}\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/screenaa/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              const uniforms = {};
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposter/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                sphereimposter: () => (
                  /* binding */
                  sphereimposter
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts"
              );
              var _sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./sphereimposter.frag */
                "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag"
              );
              var _sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./sphereimposter.vert */
                "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert"
              );
              const sphereimposter = {
                vertexShader: _sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                fragmentShader: _sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\nuniform mat4 viewMatrix;\nuniform float opacity;\nuniform mat4 projectionMatrix;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float uDepth;\nuniform vec3 directionalLightColor[ 1 ];\n\nvarying vec3 vColor;\nvarying vec2 mapping;\nvarying float rval;\nvarying vec3 vLight;\nvarying vec3 center;\n\n#ifdef SHADED\nuniform highp sampler2D shading;\n#endif\n\n//DEFINEFRAGCOLOR\n\nvoid main() {\n    float lensqr = dot(mapping,mapping);\n    float rsqr = rval*rval;\n    if(lensqr > rsqr)\n       discard;\n    float z = sqrt(rsqr-lensqr);\n    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);\n    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);\n    float ndcDepth = clipPos.z / clipPos.w;\n    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\n    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));\n    float dotProduct = dot( norm, vLight );\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;\n    vec3 color = vLight*vColor;\n#ifdef SHADED\n    ivec2 dim = textureSize(shading,0);\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\n    color *= shadowFactor;\n#endif    \n    gl_FragColor = vec4(color, opacity*opacity );\n\n    if(fogNear != fogFar) {\n        float depth = -cameraPos.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n     \n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\n\nvarying vec2 mapping;\nvarying vec3 vColor;\nvarying float rval;\nvarying vec3 vLight;\nvarying vec3 center;\n\nvoid main() {\n\n    vColor = color;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    center = mvPosition.xyz;\n    vec4 projPosition = projectionMatrix * mvPosition;\n    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\n    vLight = normalize( lDirection.xyz );\n    mapping = normal.xy;\n    rval = abs(normal.x);\n    gl_Position = projPosition+adjust;\n\n}\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                directionalLightColor: { type: "fv", value: [] },
                directionalLightDirection: { type: "fv", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                sphereimposteroutline: () => (
                  /* binding */
                  sphereimposteroutline
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts"
              );
              var _sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./sphereimposteroutline.frag */
                "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag"
              );
              var _sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./sphereimposteroutline.vert */
                "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert"
              );
              const sphereimposteroutline = {
                fragmentShader: _sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform float opacity;\nuniform vec3 outlineColor;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform mat4 projectionMatrix;\nvarying vec2 mapping;\nvarying float rval;\nvarying vec3 center;\n\nuniform float outlinePushback;\n\n//DEFINEFRAGCOLOR\n\nvoid main() {\n    float lensqr = dot(mapping,mapping);\n    float rsqr = rval*rval;\n    if(lensqr > rsqr)\n       discard;\n    float z = sqrt(rsqr-lensqr);\n    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);\n    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);\n    float ndcDepth = clipPos.z / clipPos.w;\n    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\n    gl_FragColor = vec4(outlineColor, 1 );\n\n    if(fogNear != fogFar) {\n        float depth = -cameraPos.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n}\n\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float outlineWidth;\nuniform float outlinePushback;\nuniform float outlineMaxPixels;\nuniform float vWidth;\nuniform float vHeight;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\n\nvarying vec2 mapping;\nvarying float rval;\nvarying vec3 center;\n\nvoid main() {\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    center = mvPosition.xyz;\n    vec4 projPosition = projectionMatrix * mvPosition;\n    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);\n\n    vec4 adjust = projectionMatrix* vec4(norm,normal.z,1.0); \n    mapping = norm.xy;\n    rval = abs(norm.x);\n    gl_Position = projPosition+vec4(adjust.xy,0.0,0.0);\n\n    if(outlineMaxPixels > 0.0) {\n        vec4 unadjusted = projectionMatrix*vec4(center.x+normal.x, center.y,center.z,1.0); \n        vec4 ccoord = projectionMatrix*vec4(center.xyz,1.0);\n        adjust = projectionMatrix* vec4(center.x+norm.x,center.y,center.z,1.0); \n        //subtract center \n        unadjusted.xyz -= ccoord.xyz;\n        adjust.xyz -= ccoord.xyz;\n        unadjusted /= unadjusted.w;\n        adjust /= adjust.w;\n        float diff = abs(adjust.x-unadjusted.x);\n        diff *= vWidth;\n        if(diff > outlineMaxPixels) {\n            \n            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth;\n            //adjsut reval by ratio of lengths\n            rval *= fixlen/abs(adjust.x);\n        }\n\n    }\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                outlineColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0) },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                outlineWidth: { type: "f", value: 0.1 },
                outlinePushback: { type: "f", value: 1 },
                outlineMaxPixels: { type: "f", value: 0 }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/sprite/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                sprite: () => (
                  /* binding */
                  sprite
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/sprite/uniforms.ts"
              );
              var _sprite_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./sprite.frag */
                "./src/WebGL/shaders/lib/sprite/sprite.frag"
              );
              var _sprite_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./sprite.vert */
                "./src/WebGL/shaders/lib/sprite/sprite.vert"
              );
              const sprite = {
                fragmentShader: _sprite_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _sprite_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/sprite/sprite.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\n\nvarying vec2 vUV;\n//DEFINEFRAGCOLOR\n\nvoid main() {\n\n    vec4 texture = texture2D(map, vUV);\n\n    if (texture.a <= alphaTest) discard;\n\n    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);\n\n    if (fogNear != fogFar) {\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w; //probably wrong\n        float fogFactor = smoothstep(fogNear, fogFar, depth);        \n        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);\n    }\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sprite/sprite.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform int useScreenCoordinates;\nuniform vec3 screenPosition;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 alignment;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\n\nattribute vec2 position;\nattribute vec2 uv;\n\nvarying vec2 vUV;\n\nvoid main() {\n\n    vUV = uvOffset + uv * uvScale;\n\n    vec2 alignedPosition = position + alignment;\n\n    vec2 rotatedPosition;\n    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;\n    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;\n\n    vec4 finalPosition;\n\n    if(useScreenCoordinates != 0) {\n        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);\n    }\n\n    else {\n        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;\n        finalPosition.xy += rotatedPosition; \n    }\n\n    gl_Position = finalPosition;\n\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/sprite/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              const uniforms = {};
            },
            /***/
            "./src/WebGL/shaders/lib/ssao/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ssao: () => (
                  /* binding */
                  ssao
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/ssao/uniforms.ts"
              );
              var _ssao_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./ssao.frag */
                "./src/WebGL/shaders/lib/ssao/ssao.frag"
              );
              var _ssao_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./ssao.vert */
                "./src/WebGL/shaders/lib/ssao/ssao.vert"
              );
              const ssao = {
                fragmentShader: _ssao_frag__WEBPACK_IMPORTED_MODULE_1__["default"],
                vertexShader: _ssao_vert__WEBPACK_IMPORTED_MODULE_2__["default"],
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/ssao/ssao.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform sampler2D depthmap;\nvarying highp vec2 vTexCoords;\nuniform float vWidth;\nuniform float vHeight;\nuniform float total_strength;\nuniform float radius;\nuniform mat4 projinv;\nuniform mat4 projectionMatrix;\n\n//code for pseudorandom vector from chatgpt\nfloat hash(vec3 p) {\n    p = fract(p * vec3(0.1031, 0.1030, 0.0973));\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\n// Generate a pseudorandom vec3 from a seed vec3\nvec3 pseudorandomVec3(vec3 seed) {\n    vec3 randomVec;\n    randomVec.x = hash(seed);\n    randomVec.y = hash(seed + vec3(1.0, 0.0, 17.1));\n    randomVec.z = hash(seed + vec3(0.0, 13.23, 0.0));\n    return randomVec;\n}\n\nvoid main(void)\n{   \n   const float base = 0.2;\n   const float area = 0.75;\n   const int cycles = 1;\n\n   const int samples = 64;\n   vec3 sample_sphere[64] = vec3[](\n      vec3(0.091258,-0.510164,0.000000),\n      vec3(-0.204347,-0.872967,0.187199),\n      vec3(0.009690,-0.263696,-0.110414),\n      vec3(0.175208,-0.563987,0.228527),\n      vec3(-0.001824,-0.003113,-0.000323),\n      vec3(0.411134,-0.719869,-0.261530),\n      vec3(-0.074272,-0.377368,0.276290),\n      vec3(-0.147773,-0.381587,-0.284529),\n      vec3(0.173317,-0.199635,0.063295),\n      vec3(-0.186452,-0.199460,0.076965),\n      vec3(0.143985,-0.308160,-0.307687),\n      vec3(0.053194,-0.148286,0.169589),\n      vec3(-0.547656,-0.486476,-0.317378),\n      vec3(0.020804,-0.015092,-0.004574),\n      vec3(-0.038006,-0.043165,0.054059),\n      vec3(-0.094795,-0.443908,-0.731525),\n      vec3(0.547552,-0.396466,0.461477),\n      vec3(-0.176886,-0.089989,0.007315),\n      vec3(0.074401,-0.048840,-0.074039),\n      vec3(-0.008240,-0.075697,0.178197),\n      vec3(-0.307880,-0.185053,-0.368943),\n      vec3(0.309520,-0.108483,0.041646),\n      vec3(-0.773478,-0.292946,0.538166),\n      vec3(0.184487,-0.231594,-0.820065),\n      vec3(0.207318,-0.100531,0.361797),\n      vec3(-0.173306,-0.037737,-0.055289),\n      vec3(0.548102,-0.105342,-0.253237),\n      vec3(-0.119342,-0.043907,0.285162),\n      vec3(-0.270247,-0.087861,-0.751357),\n      vec3(0.449312,-0.039777,0.236146),\n      vec3(-0.743773,-0.036095,0.196056),\n      vec3(0.148819,-0.004300,-0.231448),\n      vec3(0.008773,0.000809,0.051047),\n      vec3(-0.461467,0.027390,-0.357386),\n      vec3(0.169626,0.013338,-0.014053),\n      vec3(-0.043786,0.007095,0.047331),\n      vec3(0.004821,0.140371,-0.988260),\n      vec3(0.092402,0.023994,0.101860),\n      vec3(-0.295335,0.061530,-0.027372),\n      vec3(0.024903,0.007537,-0.018901),\n      vec3(-0.081463,0.125402,0.447794),\n      vec3(-0.397119,0.231805,-0.631062),\n      vec3(0.163853,0.059014,0.044905),\n      vec3(-0.495220,0.214357,0.254139),\n      vec3(0.306123,0.373687,-0.825715),\n      vec3(0.021665,0.026737,0.053220),\n      vec3(-0.208231,0.117129,-0.098685),\n      vec3(0.139749,0.080968,-0.043086),\n      vec3(-0.153599,0.182814,0.262090),\n      vec3(-0.159673,0.496777,-0.743568),\n      vec3(0.134797,0.117152,0.095753),\n      vec3(-0.155626,0.120533,0.019395),\n      vec3(0.042311,0.054462,-0.049709),\n      vec3(0.001257,0.031288,0.034468),\n      vec3(-0.002271,0.003199,-0.002304),\n      vec3(0.662104,0.717307,0.033854),\n      vec3(-0.373100,0.576021,0.308274),\n      vec3(0.024233,0.231316,-0.173688),\n      vec3(0.161311,0.420217,0.234273),\n      vec3(-0.045248,0.078031,-0.010411),\n      vec3(0.167453,0.376942,-0.094872),\n      vec3(-0.056194,0.433247,0.173218),\n      vec3(-0.016224,0.123149,-0.035569),\n      vec3(0.067127,0.407641,0.028479)\n   );\n\n   float depth = texture2D(depthmap, vTexCoords).r;\n   if(depth == 1.0) {\n      discard;\n   }\n\n   vec4 screen_position = vec4(vTexCoords, depth,1.0);\n   vec4 pos = projinv*screen_position;\n   pos /= pos.w;\n   vec3 position = pos.xyz;\n\n   //approximate the normal from the depth map; I find this simpler\n   //than trying to recompute the exact normal within every possible object shader\n\n   //pixel offset positions in screen space\n   ivec2 dim = textureSize(depthmap,0);\n   vec2 offset1 = vec2(0.0,1.0/float(dim.y));\n   vec2 offset2 = vec2(1.0/float(dim.x),0.0);\n   float depth1 = texture2D(depthmap, vTexCoords + offset1).r;\n   float depth2 = texture2D(depthmap, vTexCoords + offset2).r;\n   \n   vec3 p1 = vec3(screen_position.xy+offset1, depth1 - depth);\n   vec3 p2 = vec3(screen_position.xy+offset2, depth2 - depth);\n\n   //convert to model space\n   vec4 pos1 = projinv*vec4(p1,1);\n   pos1 /= pos1.w;\n   vec4 pos2 = projinv*vec4(p2,1);\n   pos2 /= pos2.w;\n\n   vec3 normal = normalize(cross(pos1.xyz-position, pos2.xyz-position)); //model normal, important we normalize in model space\n\n   //pseudo random number\n\n   float occlusion = 0.0;\n   for(int c = 0; c < cycles; c++) {\n   vec3 random = normalize(pseudorandomVec3(position+float(c)));\n   for(int i=0; i < samples; i++) {\n\n      vec3 ray = radius * reflect(sample_sphere[i],random);\n      vec3 hemi_ray = position + sign(dot(ray,normal)) * ray; //model space\n      vec4 hemi_screen = projectionMatrix*vec4(hemi_ray,1.0);\n      hemi_screen /= hemi_screen.w;\n      \n      float occ_depth = texture2D(depthmap, clamp(hemi_screen.xy,0.0,1.0)).r;\n      float difference = hemi_screen.z - occ_depth;\n      \n      occlusion += step(0.0, difference) * (1.0-smoothstep(0.0, area, difference));\n   }\n   }\n   float ao = 1.0 - total_strength * occlusion * (1.0 / float(cycles*samples));\n   gl_FragDepthEXT = clamp(ao+base,0.0,1.0);\n\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/ssao/ssao.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "attribute vec2 vertexPosition;\nvarying highp vec2 vTexCoords;\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main() {\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\n}\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/ssao/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              const uniforms = {
                total_strength: { type: "f", value: 1 },
                radius: { type: "f", value: 5 },
                projinv: { type: "mat4", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposter/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                stickimposter: () => (
                  /* binding */
                  stickimposter
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/stickimposter/uniforms.ts"
              );
              var _stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./stickimposterFragmentShader.partial.frag */
                "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag"
              );
              var _stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./stickimposter.partial.frag */
                "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag"
              );
              var _stickimposter_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./stickimposter.vert */
                "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert"
              );
              const fragmentShader = [_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__["default"], _stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2__["default"]].join("\n");
              const stickimposter = {
                fragmentShader,
                vertexShader: _stickimposter_vert__WEBPACK_IMPORTED_MODULE_3__["default"],
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "    float dotProduct = dot( norm, vLight );\n    vec3 light = vec3( max( dotProduct, 0.0 ) );\n    color *= light;\n#ifdef SHADED\n    ivec2 dim = textureSize(shading,0);\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\n    color *= shadowFactor;\n#endif    \n    gl_FragColor = vec4(color, opacity*opacity );\n    if(fogNear != fogFar) {\n        float depth = -qi.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\nattribute float radius;\n\nvarying vec3 vColor;\nvarying vec3 vLight;\nvarying vec3 cposition;\nvarying vec3 p1;\nvarying vec3 p2;\nvarying float r;\n\nvoid main() {\n\n    vColor = color; vColor.z = abs(vColor.z); //z indicates which vertex and so would vary\n    r = abs(radius);\n    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder\n    vec4 pt = modelViewMatrix*vec4(position, 1.0);\n    vec4 mvPosition = pt;\n    p1 = pt.xyz; p2 = to.xyz;\n    vec3 norm = to.xyz-pt.xyz;\n    float mult = 1.1; //slop to account for perspective of sphere\n    if(length(p1) > length(p2)) { //billboard at level of closest point\n       mvPosition = to;\n    }\n    vec3 n = normalize(mvPosition.xyz);\n    bool isperspective = (projectionMatrix[3][3] == 0.0);\n//intersect with the plane defined by the camera looking at the billboard point\n    if(color.z >= 0.0) { //p1\n       if(isperspective) { //perspective\n         vec3 pnorm = normalize(p1);\n         float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);\n         mvPosition.xyz = p1+t*pnorm; \n       } else { //orthographic\n         mvPosition.xyz = p1;\n       }\n    } else {\n      if(isperspective) { //perspective\n         vec3 pnorm = normalize(p2);\n         float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);\n         mvPosition.xyz = p2+t*pnorm;\n       } else { //orthographic\n         mvPosition.xyz = p2;\n       } \n       mult *= -1.0;\n    }\n\n    if(isperspective) { //perspective\n      vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;\n      vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;\n      mvPosition.xyz +=  mult*(cr + doublecr).xyz;\n    } else {\n      vec3 cr = normalize(cross(vec3(0.0,0.0,-1.0),norm))*radius;\n      vec3 doublecr = normalize(cross(vec3(0.0,0.0,-1.0),cr))*radius;\n      mvPosition.xyz +=  mult*(cr + doublecr).xyz;     \n    }\n\n    cposition = mvPosition.xyz;\n    gl_Position = projectionMatrix * mvPosition;\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\n    vLight = normalize( lDirection.xyz )*directionalLightColor[0]; //not really sure this is right, but color is always white so..\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform float opacity;\nuniform mat4 projectionMatrix;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying vec3 vLight;\nvarying vec3 vColor;\nvarying vec3 cposition;\nvarying vec3 p1;\nvarying vec3 p2;\nvarying float r;\n\n#ifdef SHADED\nuniform highp sampler2D shading;\n#endif\n\n//DEFINEFRAGCOLOR\n\n//cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf\n//also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl\n//with a bit more care (caps) this could be a general cylinder imposter (see also outline)\nvoid main() {\n    vec3 color = abs(vColor);\n    vec3 pos = cposition;\n    vec3 p = pos; //ray point\n    vec3 v = vec3(0.0,0.0,-1.0); //ray normal - orthographic\n    if(projectionMatrix[3][3] == 0.0) v = normalize(pos); //ray normal - perspective\n    vec3 pa = p1; //cyl start\n    vec3 va = normalize(p2-p1); //cyl norm\n    vec3 tmp1 = v-(dot(v,va)*va);\n    vec3 deltap = p-pa;\n    float A = dot(tmp1,tmp1);\n    if(A == 0.0) discard;\n    vec3 tmp2 = deltap-(dot(deltap,va)*va);\n    float B = 2.0*dot(tmp1, tmp2);\n    float C = dot(tmp2,tmp2)-r*r;\n//quadratic equation!\n    float det = (B*B) - (4.0*A*C);\n    if(det < 0.0) discard;\n    float sqrtDet = sqrt(det);\n    float posT = (-B+sqrtDet)/(2.0*A);\n    float negT = (-B-sqrtDet)/(2.0*A);\n    float intersectionT = min(posT,negT);\n    vec3 qi = p+v*intersectionT;\n    float dotp1 = dot(va,qi-p1);\n    float dotp2 = dot(va,qi-p2);\n    vec3 norm;\n    if( dotp1 < 0.0 || dotp2 > 0.0) { //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0\n       vec3 cp;\n       if( dotp1 < 0.0) {  \n//        if(vColor.x < 0.0 ) discard; //color sign bit indicates if we should cap or not\n        cp = p1;\n       } else {\n//          if(vColor.y < 0.0 ) discard;\n          cp = p2;\n       }\n       vec3 diff = p-cp;\n       A = dot(v,v);\n       B = dot(diff,v)*2.0;\n       C = dot(diff,diff)-r*r;\n       det = (B*B) - (4.0*C);\n       if(det < 0.0) discard;\n       sqrtDet = sqrt(det);\n       posT = (-B+sqrtDet)/(2.0);\n       negT = (-B-sqrtDet)/(2.0);\n       float t = min(posT,negT);\n       qi = p+v*t; \n       norm = normalize(qi-cp); \n    } else {\n       norm = normalize(qi-(dotp1*va + p1));\n    }\n    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);\n    float ndcDepth = clipPos.z / clipPos.w;\n    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\n    gl_FragDepthEXT = depth;";
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposter/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                directionalLightColor: { type: "fv", value: [] },
                directionalLightDirection: { type: "fv", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposteroutline/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                stickimposteroutline: () => (
                  /* binding */
                  stickimposteroutline
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts"
              );
              var _stickimposter_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../stickimposter/stickimposterFragmentShader.partial.frag */
                "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag"
              );
              var _stickimposteroutline_partial_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./stickimposteroutline.partial.frag */
                "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.partial.frag"
              );
              var _stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./stickimposteroutline.vert */
                "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert"
              );
              const fragmentShader = _stickimposter_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__["default"] + _stickimposteroutline_partial_frag__WEBPACK_IMPORTED_MODULE_2__["default"];
              const stickimposteroutline = {
                fragmentShader,
                vertexShader: _stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_3__["default"],
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.partial.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n    gl_FragColor = vec4(color, opacity*opacity );\n    if(fogNear != fogFar) {\n        float depth = -qi.z;\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    }\n}";
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 directionalLightColor[ 1 ];\nuniform vec3 directionalLightDirection[ 1 ];\nuniform vec3 outlineColor;\nuniform float outlineWidth;\nuniform float outlinePushback;\nuniform float outlineMaxPixels;\nuniform float vWidth;\nuniform mat4 projinv;\n\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 color;\nattribute float radius;\n\nvarying vec3 vColor;\nvarying vec3 vLight;\nvarying vec3 cposition;\nvarying vec3 p1;\nvarying vec3 p2;\nvarying float r;\n\nvoid main() {\n\n    vColor = outlineColor;\n    float rad = radius+sign(radius)*outlineWidth;\n    r = abs(rad);\n\n    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder\n    vec4 pt = modelViewMatrix*vec4(position, 1.0);\n//pushback\n    float scale = 1.0;\n    if(projectionMatrix[3][3] != 0.0) { //orthographic\n        to.z -= outlinePushback;\n        pt.z -= outlinePushback;\n    } else { //perspective\n        vec4 midbefore = pt;\n        if(length(to.xyz) < length(pt)) {\n            midbefore = to;\n        }\n        vec4 midafter = midbefore;\n        midafter.xyz += normalize(midbefore.xyz)*outlinePushback;\n\n        to.xyz += normalize(to.xyz)*outlinePushback;\n        pt.xyz += normalize(pt.xyz)*outlinePushback;\n\n        //figure out a scaling factor for radius to account for perspective setback\n        vec4 midbeforer = vec4(midbefore.x+rad,midbefore.y, midbefore.z, midbefore.w);\n        vec4 midafterr = vec4(midafter.x+rad,midafter.y, midafter.z, midafter.w);\n\n        vec4 mb = projectionMatrix*midbefore;\n        vec4 mbr = projectionMatrix*midbeforer;\n        vec4 ma = projectionMatrix*midafter;\n        vec4 mar = projectionMatrix*midafterr;\n        mb /= mb.w;\n        mbr /= mbr.w;\n        ma /= ma.w;\n        mar /= mar.w;\n        scale = abs((mbr.x-mb.x)/(mar.x-ma.x));\n        rad *= scale;\n        r = abs(rad);\n    }\n    vec4 mvPosition = pt;\n    p1 = pt.xyz; p2 = to.xyz;\n    vec3 norm = to.xyz-pt.xyz;\n    float mult = 1.1; //slop to account for perspective of sphere\n    if(length(p1) > length(p2)) { //billboard at level of closest point\n       mvPosition = to;\n    }\n\n    vec3 n = normalize(mvPosition.xyz);\n//intersect with the plane defined by the camera looking at the billboard point\n    if(color.z >= 0.0) { //p1\n       vec3 pnorm = normalize(p1);\n       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);\n       mvPosition.xyz = p1+t*pnorm;\n    } else {\n       vec3 pnorm = normalize(p2);\n       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);\n       mvPosition.xyz = p2+t*pnorm;\n       mult *= -1.0;\n    }\n\n    if(outlineMaxPixels > 0.0) {\n        vec4 cpos = mvPosition;\n        vec4 unadjusted = projectionMatrix*vec4(cpos.x+abs(scale*radius), cpos.y,cpos.z,cpos.w); \n        vec4 ccoord = projectionMatrix*cpos;\n        vec4 adjust = projectionMatrix*vec4(cpos.x+r,cpos.y,cpos.z,cpos.w); \n        unadjusted /= unadjusted.w;\n        adjust /= adjust.w;\n        unadjusted.xyz -= ccoord.xyz/ccoord.w;\n        adjust.xyz -= ccoord.xyz/ccoord.w;\n        float diff = abs(adjust.x-unadjusted.x);\n        diff *= vWidth; //this should now be in pixels\n        if(diff > outlineMaxPixels) {\n            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth; \n            vec4 pcoord = ccoord;\n            pcoord.x += fixlen*pcoord.w;\n            vec4 altc = projinv*pcoord;\n            r= abs(altc.x-cpos.x);\n        }\n    }\n\n    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;\n    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;\n    mvPosition.xy +=  mult*(cr + doublecr).xy;\n    cposition = mvPosition.xyz;\n    gl_Position = projectionMatrix * mvPosition;\n    vLight = vec3(1.0,1.0,1.0);\n}\n\n";
            },
            /***/
            "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                outlineColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0) },
                outlineWidth: { type: "f", value: 0.1 },
                outlinePushback: { type: "f", value: 1 },
                outlineMaxPixels: { type: "f", value: 0 },
                projinv: { type: "mat4", value: [] }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/volumetric/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                volumetric: () => (
                  /* binding */
                  volumetric
                )
                /* harmony export */
              });
              var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./uniforms */
                "./src/WebGL/shaders/lib/volumetric/uniforms.ts"
              );
              var _volumetric_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./volumetric.frag */
                "./src/WebGL/shaders/lib/volumetric/volumetric.frag"
              );
              var _volumetric_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./volumetric.vert */
                "./src/WebGL/shaders/lib/volumetric/volumetric.vert"
              );
              const volumetric = {
                fragmentShader: _volumetric_frag__WEBPACK_IMPORTED_MODULE_1__["default"].replace("#define GLSLIFY 1", ""),
                vertexShader: _volumetric_vert__WEBPACK_IMPORTED_MODULE_2__["default"].replace("#define GLSLIFY 1", ""),
                uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms
              };
            },
            /***/
            "./src/WebGL/shaders/lib/volumetric/uniforms.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                uniforms: () => (
                  /* binding */
                  uniforms
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../../colors */
                "./src/colors.ts"
              );
              const uniforms = {
                opacity: { type: "f", value: 1 },
                fogColor: { type: "c", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1) },
                fogNear: { type: "f", value: 1 },
                fogFar: { type: "f", value: 2e3 },
                data: { type: "i", value: 3 },
                colormap: { type: "i", value: 4 },
                depthmap: { type: "i", value: 5 },
                step: { type: "f", value: 1 },
                //length of a step
                maxdepth: { type: "f", value: 100 },
                //how far to step along ray before stopping
                subsamples: { type: "f", value: 5 },
                //how many substeps to take
                textmat: { type: "mat4", value: [] },
                projinv: { type: "mat4", value: [] },
                transfermin: { type: "f", value: -0.2 },
                transfermax: { type: "f", value: 0.2 }
              };
            },
            /***/
            "./src/WebGL/shaders/lib/volumetric/volumetric.frag"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "\nuniform highp sampler3D data;\nuniform highp sampler2D colormap;\nuniform highp sampler2D depthmap;\n\n\nuniform mat4 textmat;\nuniform mat4 projinv;\nuniform mat4 projectionMatrix;\n\nuniform float step;\nuniform float subsamples;\nuniform float maxdepth;\nuniform float transfermin;\nuniform float transfermax;\nin  vec4 mvPosition;\nout vec4 color;\nvoid main(void) {\n\n   vec4 pos = mvPosition;\n   bool seengood = false;\n   float i = 0.0;\n   color = vec4(1,1,1,0);\n   float increment = 1.0/subsamples;\n   float maxsteps = (maxdepth*subsamples/step);\n//there's probably a better way to do this..\n//calculate farthest possible point in model coordinates\n   vec4 maxpos = vec4(pos.x,pos.y,pos.z-maxdepth,1.0);\n// convert to projection\n   maxpos = projectionMatrix*maxpos;\n   vec4 startp = projectionMatrix*pos;\n// homogonize\n   maxpos /= maxpos.w;\n   startp /= startp.w;\n//take x,y from start and z from max\n   maxpos = vec4(startp.x,startp.y,maxpos.z,1.0);\n//convert back to model space\n   maxpos = projinv*maxpos;\n   maxpos /= maxpos.w;\n   float incr = step/subsamples;\n//get depth from depthmap\n//startp is apparently [-1,1]\n   vec2 tpos = startp.xy/2.0+0.5;\n   float depth = texture(depthmap, tpos).r;\n//compute vector between start and end\n   vec4 direction = maxpos-pos;\n   for( i = 0.0; i <= maxsteps; i++) {\n      vec4 pt = (pos+(i/maxsteps)*direction);\n      vec4 ppt = projectionMatrix*pt;\n      float ptdepth = ppt.z/ppt.w;\n      ptdepth = ((gl_DepthRange.diff * ptdepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\n      if(ptdepth > depth) break;\n      pt = textmat*pt;\n//       pt /= pt.w;\n      if(pt.x >= -0.01 && pt.y >= -0.01 && pt.z >= -0.01 && pt.x <= 1.01 && pt.y <= 1.01 && pt.z <= 1.01) {\n         seengood = true;\n      } else if(seengood) {\n         break;\n      }\n      if( pt.x < -0.01 || pt.x > 1.01 || pt.y < -0.01 || pt.y > 1.01 || pt.z < -0.01 || pt.z > 1.01  ){\n          color.a = 0.0;\n          continue;\n      }\n      else {\n         float val = texture(data, pt.zyx).r;\n         if(isinf(val)) continue; //masked out\n         float cval = (val-transfermin)/(transfermax-transfermin); //scale to texture 0-1 range\n         vec4 val_color = texture(colormap, vec2(cval,0.5));\n         color.rgb = color.rgb*color.a + (1.0-color.a)*val_color.a*val_color.rgb;\n         color.a += (1.0 - color.a) * val_color.a; \n         if(color.a > 0.0) color.rgb /= color.a;\n//          color = vec4(pt.x, pt.y, pt.z, 1.0);\n      }\n//       color = vec4(pt.x, pt.y, pt.z, 0.0)\n    }\n}\n\n        ";
            },
            /***/
            "./src/WebGL/shaders/lib/volumetric/volumetric.vert"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              const __WEBPACK_DEFAULT_EXPORT__ = "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\nin vec3 position;\nout vec4 mvPosition;\nvoid main() {\n\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix*mvPosition;\n}\n";
            },
            /***/
            "./src/WebGL/shaders/utils/clone.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                clone: () => (
                  /* binding */
                  clone
                )
                /* harmony export */
              });
              var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../../colors */
                "./src/colors.ts"
              );
              function clone(uniforms_src) {
                let uniforms_clone = {};
                for (const u in uniforms_src) {
                  uniforms_clone[u] = {};
                  uniforms_clone[u].type = uniforms_src[u].type;
                  var srcValue = uniforms_src[u].value;
                  if (srcValue instanceof _colors__WEBPACK_IMPORTED_MODULE_0__.Color)
                    uniforms_clone[u].value = srcValue.clone();
                  else if (typeof srcValue === "number")
                    uniforms_clone[u].value = srcValue;
                  else if (srcValue instanceof Array)
                    uniforms_clone[u].value = [];
                  else
                    console.error("Error copying shader uniforms from ShaderLib: unknown type for uniform");
                }
                return uniforms_clone;
              }
            },
            /***/
            "./src/WebGL/shaders/utils/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                ShaderUtils: () => (
                  /* binding */
                  ShaderUtils
                ),
                /* harmony export */
                clone: () => (
                  /* reexport safe */
                  _clone__WEBPACK_IMPORTED_MODULE_0__.clone
                )
                /* harmony export */
              });
              var _clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./clone */
                "./src/WebGL/shaders/utils/clone.ts"
              );
              const ShaderUtils = {
                clone: _clone__WEBPACK_IMPORTED_MODULE_0__.clone
              };
            },
            /***/
            "./src/WebGL/shapes/Cylinder.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Cylinder: () => (
                  /* binding */
                  Cylinder
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              let vector = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              class Cylinder {
                constructor(c1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), c2 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), radius = 0) {
                  this.c1 = c1;
                  this.c2 = c2;
                  this.radius = radius;
                  this.direction = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(this.c2, this.c1).normalize();
                }
                copy(cylinder) {
                  this.c1.copy(cylinder.c1);
                  this.c2.copy(cylinder.c2);
                  this.direction.copy(cylinder.direction);
                  this.radius = cylinder.radius;
                  return this;
                }
                lengthSq() {
                  return vector.subVectors(this.c2, this.c1).lengthSq();
                }
                applyMatrix4(matrix) {
                  this.direction.add(this.c1).applyMatrix4(matrix);
                  this.c1.applyMatrix4(matrix);
                  this.c2.applyMatrix4(matrix);
                  this.direction.sub(this.c1).normalize();
                  this.radius = this.radius * matrix.getMaxScaleOnAxis();
                  return this;
                }
              }
            },
            /***/
            "./src/WebGL/shapes/Sphere.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Sphere: () => (
                  /* binding */
                  Sphere
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              class Sphere {
                constructor(center = { x: 0, y: 0, z: 0 }, radius = 0) {
                  this.center = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(center.x, center.y, center.z);
                  this.radius = radius;
                }
                set(center, radius) {
                  this.center.copy(center);
                  this.radius = radius;
                  return this;
                }
                copy(sphere) {
                  this.center.copy(sphere.center);
                  this.radius = sphere.radius;
                  return this;
                }
                applyMatrix4(matrix) {
                  this.center.applyMatrix4(matrix);
                  this.radius = this.radius * matrix.getMaxScaleOnAxis();
                  return this;
                }
                translate(offset) {
                  this.center.add(offset);
                  return this;
                }
                equals(sphere) {
                  return sphere.center.equals(this.center) && sphere.radius === this.radius;
                }
                clone() {
                  return new Sphere().copy(this);
                }
              }
            },
            /***/
            "./src/WebGL/shapes/Triangle.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Triangle: () => (
                  /* binding */
                  Triangle
                )
                /* harmony export */
              });
              var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../math */
                "./src/WebGL/math/index.ts"
              );
              const v1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              class Triangle {
                constructor(a = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), b = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), c = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3()) {
                  this.a = a;
                  this.b = b;
                  this.c = c;
                }
                copy(triangle) {
                  this.a.copy(triangle.a);
                  this.b.copy(triangle.b);
                  this.c.copy(triangle.c);
                  return this;
                }
                applyMatrix4(matrix) {
                  this.a.applyMatrix4(matrix);
                  this.b.applyMatrix4(matrix);
                  this.c.applyMatrix4(matrix);
                  return this;
                }
                getNormal() {
                  var norm = this.a.clone();
                  norm.sub(this.b);
                  v1.subVectors(this.c, this.b);
                  norm.cross(v1);
                  norm.normalize();
                  return norm;
                }
              }
            },
            /***/
            "./src/WebGL/shapes/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Cylinder: () => (
                  /* reexport safe */
                  _Cylinder__WEBPACK_IMPORTED_MODULE_1__.Cylinder
                ),
                /* harmony export */
                Sphere: () => (
                  /* reexport safe */
                  _Sphere__WEBPACK_IMPORTED_MODULE_0__.Sphere
                ),
                /* harmony export */
                Triangle: () => (
                  /* reexport safe */
                  _Triangle__WEBPACK_IMPORTED_MODULE_2__.Triangle
                )
                /* harmony export */
              });
              var _Sphere__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./Sphere */
                "./src/WebGL/shapes/Sphere.ts"
              );
              var _Cylinder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./Cylinder */
                "./src/WebGL/shapes/Cylinder.ts"
              );
              var _Triangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./Triangle */
                "./src/WebGL/shapes/Triangle.ts"
              );
            },
            /***/
            "./src/autoload.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                autoinit: () => (
                  /* binding */
                  autoinit
                ),
                /* harmony export */
                autoload: () => (
                  /* binding */
                  autoload
                ),
                /* harmony export */
                processing_autoinit: () => (
                  /* binding */
                  processing_autoinit
                ),
                /* harmony export */
                viewers: () => (
                  /* binding */
                  viewers
                )
                /* harmony export */
              });
              var _GLViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./GLViewer */
                "./src/GLViewer.ts"
              );
              var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./ProteinSurface4 */
                "./src/ProteinSurface4.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var autoinit = false;
              var processing_autoinit = false;
              var viewers = {};
              function autoload(viewer, callback2) {
                var i, dataname, type;
                if (document.querySelector(".viewer_3Dmoljs") != null)
                  autoinit = true;
                if (autoinit) {
                  processing_autoinit = true;
                  viewer = viewer != void 0 ? viewer : null;
                  var nviewers = 0;
                  document.querySelectorAll(".viewer_3Dmoljs").forEach((viewerdiv) => {
                    var datauri = [];
                    var datatypes = [];
                    var uri = "";
                    if (viewerdiv.style.position == "static") {
                      viewerdiv.style.position = "relative";
                    }
                    var UI = null;
                    type = null;
                    if (viewerdiv.dataset.pdb) {
                      datauri.push("https://files.rcsb.org/view/" + viewerdiv.dataset.pdb + ".pdb");
                      datatypes.push("pdb");
                    } else if (viewerdiv.dataset.cid) {
                      datatypes.push("sdf");
                      datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + viewerdiv.dataset.cid + "/SDF?record_type=3d");
                    } else if (viewerdiv.dataset.href || viewerdiv.dataset.url) {
                      if (viewerdiv.dataset.href)
                        uri = viewerdiv.dataset.href;
                      else
                        uri = viewerdiv.dataset.url;
                      datauri.push(uri);
                      type = uri.substring(uri.lastIndexOf(".") + 1);
                      if (type == "gz") {
                        let pos = uri.substring(0, uri.lastIndexOf(".")).lastIndexOf(".");
                        type = uri.substring(pos + 1);
                      }
                      datatypes.push(type);
                      var molName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("."));
                      if (molName == "/")
                        molName = uri.substring(uri.lastIndexOf("/") + 1);
                      viewerdiv.dataset[datatypes[datatypes.length - 1]] = molName;
                    }
                    let divdata = viewerdiv.dataset;
                    for (i in divdata) {
                      if (i.substring(0, 3) === "pdb" && i !== "pdb") {
                        datauri.push("https://files.rcsb.org/view/" + divdata[i] + ".pdb");
                        datatypes.push("pdb");
                      } else if (i.substring(0, 4) === "href" && i !== "href") {
                        uri = divdata[i];
                        datauri.push(uri);
                        datatypes.push(uri.substring(uri.lastIndexOf(".") + 1));
                      } else if (i.substring(0, 3) === "cid" && i !== "cid") {
                        datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + divdata[i] + "/SDF?record_type=3d");
                        datatypes.push("sdf");
                      }
                    }
                    var options = {};
                    if (viewerdiv.dataset.options)
                      options = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.options);
                    var bgcolor = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(viewerdiv.dataset.backgroundcolor);
                    var bgalpha = viewerdiv.dataset.backgroundalpha;
                    bgalpha = bgalpha == void 0 ? 1 : parseFloat(bgalpha);
                    var style = { line: {} };
                    if (viewerdiv.dataset.style)
                      style = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.style);
                    var select = {};
                    if (viewerdiv.dataset.select)
                      select = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.select);
                    var selectstylelist = [];
                    var surfaces = [];
                    var labels = [];
                    var zoomto = {};
                    var spin = null;
                    var d = viewerdiv.dataset;
                    var stylere = /style(.+)/;
                    var surfre = /surface(.*)/;
                    var reslabre = /labelres(.*)/;
                    var keys = [];
                    for (dataname in d) {
                      if (Object.prototype.hasOwnProperty.call(d, dataname)) {
                        keys.push(dataname);
                      }
                    }
                    keys.sort();
                    for (i = 0; i < keys.length; i++) {
                      dataname = keys[i];
                      var m = stylere.exec(dataname);
                      var selname, newsel, styleobj;
                      if (m) {
                        selname = "select" + m[1];
                        newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]);
                        styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]);
                        selectstylelist.push([newsel, styleobj]);
                      }
                      m = surfre.exec(dataname);
                      if (m) {
                        selname = "select" + m[1];
                        newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]);
                        styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]);
                        surfaces.push([newsel, styleobj]);
                      }
                      m = reslabre.exec(dataname);
                      if (m) {
                        selname = "select" + m[1];
                        newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]);
                        styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]);
                        labels.push([newsel, styleobj]);
                      }
                      if (dataname == "zoomto") {
                        zoomto = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]);
                      }
                      if (dataname == "spin") {
                        spin = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]);
                      }
                    }
                    var applyStyles = function(glviewer2) {
                      glviewer2.setStyle(select, style);
                      if (UI) {
                        UI.createSelectionAndStyle(select, style);
                      }
                      for (i = 0; i < selectstylelist.length; i++) {
                        let sel = selectstylelist[i][0] || {};
                        let sty = selectstylelist[i][1] || { "line": {} };
                        glviewer2.setStyle(sel, sty);
                        if (UI) {
                          UI.createSelectionAndStyle(select, style);
                        }
                      }
                      for (i = 0; i < surfaces.length; i++) {
                        let sel = surfaces[i][0] || {};
                        let sty = surfaces[i][1] || {};
                        let viewer2 = glviewer2;
                        if (UI) {
                          viewer2.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, sty, sel, sel).then((surfid) => {
                            UI.loadSurface("VDW", sel, sty, surfid);
                          });
                        } else {
                          glviewer2.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, sty, sel, sel);
                        }
                      }
                      for (i = 0; i < labels.length; i++) {
                        let sel = labels[i][0] || {};
                        let sty = labels[i][1] || {};
                        glviewer2.addResLabels(sel, sty);
                      }
                      glviewer2.render();
                      glviewer2.zoomTo(zoomto);
                      if (spin) {
                        glviewer2.spin(spin.axis, spin.speed);
                      }
                    };
                    let glviewer = viewer;
                    try {
                      var config = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.config) || {};
                      if (config.backgroundColor === void 0)
                        config.backgroundColor = bgcolor;
                      if (config.backgroundAlpha === void 0)
                        config.backgroundAlpha = bgalpha;
                      if (glviewer == null) {
                        glviewer = viewers[viewerdiv.id || nviewers++] = (0, _GLViewer__WEBPACK_IMPORTED_MODULE_0__.createViewer)(viewerdiv, config);
                      } else {
                        glviewer.setBackgroundColor(bgcolor, bgalpha);
                        glviewer.setConfig(config);
                        if (UI)
                          UI.initiateUI();
                      }
                      if (viewerdiv.dataset.ui && $3Dmol.StateManager) {
                        UI = new $3Dmol.StateManager(glviewer);
                      }
                    } catch (error) {
                      console.log(error);
                      viewerdiv.textContent = "WebGL appears to be disabled.";
                    }
                    if (datauri.length != 0) {
                      let i2 = 0;
                      let process2 = /* @__PURE__ */ ((viewerdiv2, glviewer2) => function(moldata2) {
                        uri = datauri[i2];
                        var type2 = viewerdiv2.dataset.type || viewerdiv2.dataset.datatype || datatypes[i2];
                        glviewer2.addModel(moldata2, type2, options);
                        if (UI) {
                          var modelName = viewerdiv2.dataset[datatypes[i2]];
                          UI.setModelTitle(modelName);
                        }
                        i2 += 1;
                        if (i2 < datauri.length) {
                          (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[i2]).then(process2);
                        } else {
                          applyStyles(glviewer2);
                          if (viewerdiv2.dataset.callback) {
                            let runres = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.makeFunction)(viewerdiv2.dataset.callback);
                            runres(glviewer2);
                          }
                          processing_autoinit = false;
                          if (callback2)
                            callback2(glviewer2);
                        }
                      })(viewerdiv, glviewer);
                      if (type && type.endsWith("gz")) {
                        (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.getbin)(datauri[0]).then(process2);
                      } else {
                        (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[0]).then(process2);
                      }
                    } else {
                      if (viewerdiv.dataset.element) {
                        var moldataid = "#" + viewerdiv.dataset.element;
                        var molelem = document.querySelector(moldataid);
                        var moldata = molelem ? molelem.textContent : "";
                        type = viewerdiv.dataset.type || viewerdiv.dataset.datatype;
                        glviewer.addModel(moldata, type, options);
                      }
                      applyStyles(glviewer);
                      if (viewerdiv.dataset.callback) {
                        let runres = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.makeFunction)(viewerdiv.dataset.callback);
                        runres(glviewer);
                      }
                      processing_autoinit = false;
                      if (callback2)
                        callback2(glviewer);
                    }
                  });
                }
              }
              ;
              document.onreadystatechange = () => {
                if (document.readyState === "complete") {
                  autoload();
                }
              };
            },
            /***/
            "./src/colors.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CC: () => (
                  /* binding */
                  CC
                ),
                /* harmony export */
                Color: () => (
                  /* binding */
                  Color
                ),
                /* harmony export */
                builtinColorSchemes: () => (
                  /* binding */
                  builtinColorSchemes
                ),
                /* harmony export */
                chains: () => (
                  /* binding */
                  chains
                ),
                /* harmony export */
                elementColors: () => (
                  /* binding */
                  elementColors
                ),
                /* harmony export */
                htmlColors: () => (
                  /* binding */
                  htmlColors
                ),
                /* harmony export */
                residues: () => (
                  /* binding */
                  residues
                ),
                /* harmony export */
                ssColors: () => (
                  /* binding */
                  ssColors
                )
                /* harmony export */
              });
              class Color {
                constructor(r, g, b) {
                  this.r = 0;
                  this.g = 0;
                  this.b = 0;
                  if (arguments.length > 1 && typeof r === "number") {
                    this.r = r || 0;
                    this.g = g || 0;
                    this.b = b || 0;
                    return this;
                  }
                  return this.set(r || 0);
                }
                set(val) {
                  if (val instanceof Color)
                    return val.clone();
                  else if (typeof val === "number")
                    this.setHex(val);
                  else if (typeof val === "object") {
                    this.r = (val === null || val === void 0 ? void 0 : val.r) || 0;
                    this.g = (val === null || val === void 0 ? void 0 : val.g) || 0;
                    this.b = (val === null || val === void 0 ? void 0 : val.b) || 0;
                  }
                  return this;
                }
                setHex(hex) {
                  hex = Math.floor(hex);
                  this.r = (hex >> 16 & 255) / 255;
                  this.g = (hex >> 8 & 255) / 255;
                  this.b = (hex & 255) / 255;
                  return this;
                }
                getHex() {
                  var R = Math.round(this.r * 255);
                  var G = Math.round(this.g * 255);
                  var B = Math.round(this.b * 255);
                  return R << 16 | G << 8 | B;
                }
                clone() {
                  return new Color(this.r, this.g, this.b);
                }
                copy(color) {
                  this.r = color.r;
                  this.g = color.g;
                  this.b = color.b;
                  return this;
                }
                //return object that represents color components from 0 to 255
                scaled() {
                  var ret = {};
                  ret.r = Math.round(this.r * 255);
                  ret.g = Math.round(this.g * 255);
                  ret.b = Math.round(this.b * 255);
                  ret.a = 1;
                  return ret;
                }
              }
              class CC {
                static color(hex) {
                  if (!hex)
                    return CC.cache[0];
                  if (hex instanceof Color) {
                    return hex;
                  }
                  if (typeof hex === "number" && typeof CC.cache[hex] !== "undefined")
                    return CC.cache[hex];
                  if (hex && Array.isArray(hex))
                    return hex.map(CC.color);
                  let hexval = CC.getHex(hex);
                  let c = new Color(hexval);
                  CC.cache[hexval] = c;
                  return c;
                }
                static getHex(hex) {
                  if (Array.isArray(hex))
                    return hex.map(CC.getHex);
                  if (typeof hex === "string") {
                    let hexs = hex;
                    if (!isNaN(parseInt(hexs)))
                      return parseInt(hexs);
                    hexs = hexs.trim();
                    if (hexs.length == 4 && hexs[0] == "#") {
                      hexs = "#" + hexs[1] + hexs[1] + hexs[2] + hexs[2] + hexs[3] + hexs[3];
                    }
                    if (hexs.length == 7 && hexs[0] == "#") {
                      return parseInt(hexs.substring(1), 16);
                    }
                    let m = CC.rgbRegEx.exec(hexs);
                    if (m) {
                      if (m[1] != "") {
                        console.log("WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.");
                      }
                      let ret = 0;
                      for (let i = 2; i < 5; i++) {
                        ret *= 256;
                        let val2 = m[i].endsWith("%") ? 255 * parseFloat(m[i]) / 100 : parseFloat(m[i]);
                        ret += Math.round(val2);
                      }
                      return ret;
                    }
                    let val = htmlColors[hexs.toLowerCase()];
                    if (val !== void 0) {
                      return val;
                    } else {
                      console.error("color not found", hex.toLowerCase(), htmlColors);
                      return 0;
                    }
                  }
                  return hex;
                }
              }
              CC.rgbRegEx = /rgb(a?)\(\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)/i;
              CC.cache = { 0: new Color(0) };
              const htmlColors = {
                //htmlcolors
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgrey: 11119017,
                darkgreen: 25600,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                grey: 8421504,
                green: 32768,
                greenyellow: 11403055,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgrey: 13882323,
                lightgreen: 9498256,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074,
                //matplotlib single char colors
                "b": 255,
                // blue
                "g": 32768,
                // green
                "r": 16711680,
                // red
                "c": 49087,
                // cyan
                "m": 12517567,
                // magenta
                "y": 12566272,
                // yellow
                "k": 0,
                // black
                "w": 16777215
                // white  
              };
              const ssColors = {
                //names are in helix-sheet-coil order
                pyMol: { h: 16711680, s: 16776960, c: 65280 },
                Jmol: { h: 16711808, s: 16762880, c: 16777215 }
              };
              const rasmol = {
                H: 16777215,
                He: 16761035,
                HE: 16761035,
                Li: 11674146,
                LI: 11674146,
                B: 65280,
                C: 13158600,
                N: 9408511,
                O: 15728640,
                F: 14329120,
                Na: 255,
                NA: 255,
                Mg: 2263842,
                MG: 2263842,
                Al: 8421520,
                AL: 8421520,
                Si: 14329120,
                SI: 14329120,
                P: 16753920,
                S: 16762930,
                Cl: 65280,
                CL: 65280,
                Ca: 8421520,
                CA: 8421520,
                Ti: 8421520,
                TI: 8421520,
                Cr: 8421520,
                CR: 8421520,
                Mn: 8421520,
                MN: 8421520,
                Fe: 16753920,
                FE: 16753920,
                Ni: 10824234,
                NI: 10824234,
                Cu: 10824234,
                CU: 10824234,
                Zn: 10824234,
                ZN: 10824234,
                Br: 10824234,
                BR: 10824234,
                Ag: 8421520,
                AG: 8421520,
                I: 10494192,
                Ba: 16753920,
                BA: 16753920,
                Au: 14329120,
                AU: 14329120
              };
              const elementColors = {
                defaultColor: 16716947,
                /** Jmol-like element colors*/
                Jmol: {
                  H: 16777215,
                  He: 14286847,
                  HE: 14286847,
                  Li: 13402367,
                  LI: 13402367,
                  Be: 12779264,
                  BE: 12779264,
                  B: 16758197,
                  C: 9474192,
                  N: 3166456,
                  O: 16715021,
                  F: 9494608,
                  Ne: 11789301,
                  NE: 11789301,
                  Na: 11230450,
                  NA: 11230450,
                  Mg: 9109248,
                  MG: 9109248,
                  Al: 12560038,
                  AL: 12560038,
                  Si: 1578e4,
                  SI: 1578e4,
                  P: 16744448,
                  S: 16777008,
                  Cl: 2093087,
                  CL: 2093087,
                  Ar: 8442339,
                  AR: 8442339,
                  K: 9388244,
                  Ca: 4062976,
                  CA: 4062976,
                  Sc: 15132390,
                  SC: 15132390,
                  Ti: 12567239,
                  TI: 12567239,
                  V: 10921643,
                  Cr: 9083335,
                  CR: 9083335,
                  Mn: 10255047,
                  MN: 10255047,
                  Fe: 14706227,
                  FE: 14706227,
                  Co: 15765664,
                  CO: 15765664,
                  Ni: 5296208,
                  NI: 5296208,
                  Cu: 13140019,
                  CU: 13140019,
                  Zn: 8224944,
                  ZN: 8224944,
                  Ga: 12750735,
                  GA: 12750735,
                  Ge: 6721423,
                  GE: 6721423,
                  As: 12419299,
                  AS: 12419299,
                  Se: 16752896,
                  SE: 16752896,
                  Br: 10889513,
                  BR: 10889513,
                  Kr: 6076625,
                  KR: 6076625,
                  Rb: 7351984,
                  RB: 7351984,
                  Sr: 65280,
                  SR: 65280,
                  Y: 9764863,
                  Zr: 9756896,
                  ZR: 9756896,
                  Nb: 7586505,
                  NB: 7586505,
                  Mo: 5551541,
                  MO: 5551541,
                  Tc: 3907230,
                  TC: 3907230,
                  Ru: 2396047,
                  RU: 2396047,
                  Rh: 687500,
                  RH: 687500,
                  Pd: 27013,
                  PD: 27013,
                  Ag: 12632256,
                  AG: 12632256,
                  Cd: 16767375,
                  CD: 16767375,
                  In: 10909043,
                  IN: 10909043,
                  Sn: 6717568,
                  SN: 6717568,
                  Sb: 10380213,
                  SB: 10380213,
                  Te: 13924864,
                  TE: 13924864,
                  I: 9699476,
                  Xe: 4366e3,
                  XE: 4366e3,
                  Cs: 5707663,
                  CS: 5707663,
                  Ba: 51456,
                  BA: 51456,
                  La: 7394559,
                  LA: 7394559,
                  Ce: 16777159,
                  CE: 16777159,
                  Pr: 14286791,
                  PR: 14286791,
                  Nd: 13107143,
                  ND: 13107143,
                  Pm: 10747847,
                  PM: 10747847,
                  Sm: 9437127,
                  SM: 9437127,
                  Eu: 6422471,
                  EU: 6422471,
                  Gd: 4587463,
                  GD: 4587463,
                  Tb: 3211207,
                  TB: 3211207,
                  Dy: 2097095,
                  DY: 2097095,
                  Ho: 65436,
                  HO: 65436,
                  Er: 58997,
                  ER: 58997,
                  Tm: 54354,
                  TM: 54354,
                  Yb: 48952,
                  YB: 48952,
                  Lu: 43812,
                  LU: 43812,
                  Hf: 5096191,
                  HF: 5096191,
                  Ta: 5089023,
                  TA: 5089023,
                  W: 2200790,
                  Re: 2522539,
                  RE: 2522539,
                  Os: 2516630,
                  OS: 2516630,
                  Ir: 1528967,
                  IR: 1528967,
                  Pt: 13684960,
                  PT: 13684960,
                  Au: 16765219,
                  AU: 16765219,
                  Hg: 12105936,
                  HG: 12105936,
                  Tl: 10900557,
                  TL: 10900557,
                  Pb: 5724513,
                  PB: 5724513,
                  Bi: 10375093,
                  BI: 10375093,
                  Po: 11230208,
                  PO: 11230208,
                  At: 7688005,
                  AT: 7688005,
                  Rn: 4358806,
                  RN: 4358806,
                  Fr: 4325478,
                  FR: 4325478,
                  Ra: 32e3,
                  RA: 32e3,
                  Ac: 7384058,
                  AC: 7384058,
                  Th: 47871,
                  TH: 47871,
                  Pa: 41471,
                  PA: 41471,
                  U: 36863,
                  Np: 33023,
                  NP: 33023,
                  Pu: 27647,
                  PU: 27647,
                  Am: 5528818,
                  AM: 5528818,
                  Cm: 7888099,
                  CM: 7888099,
                  Bk: 9064419,
                  BK: 9064419,
                  Cf: 10565332,
                  CF: 10565332,
                  Es: 11739092,
                  ES: 11739092,
                  Fm: 11739066,
                  FM: 11739066,
                  Md: 11734438,
                  MD: 11734438,
                  No: 12389767,
                  NO: 12389767,
                  Lr: 13041766,
                  LR: 13041766,
                  Rf: 13369433,
                  RF: 13369433,
                  Db: 13697103,
                  DB: 13697103,
                  Sg: 14221381,
                  SG: 14221381,
                  Bh: 14680120,
                  BH: 14680120,
                  Hs: 15073326,
                  HS: 15073326,
                  Mt: 15400998,
                  MT: 15400998
                },
                /** rasmol-like element colors */
                rasmol,
                defaultColors: Object.assign({}, rasmol),
                greenCarbon: Object.assign(Object.assign({}, rasmol), { C: 65280 }),
                cyanCarbon: Object.assign(Object.assign({}, rasmol), { C: 65535 }),
                magentaCarbon: Object.assign(Object.assign({}, rasmol), { C: 16711935 }),
                yellowCarbon: Object.assign(Object.assign({}, rasmol), { C: 16776960 }),
                whiteCarbon: Object.assign(Object.assign({}, rasmol), { C: 16777215 }),
                orangeCarbon: Object.assign(Object.assign({}, rasmol), { C: 16753920 }),
                purpleCarbon: Object.assign(Object.assign({}, rasmol), { C: 8388736 }),
                blueCarbon: Object.assign(Object.assign({}, rasmol), { C: 255 })
              };
              const residues = {
                /** @property standard amino acid color scheme*/
                amino: {
                  ALA: 13158600,
                  ARG: 1334015,
                  ASN: 56540,
                  ASP: 15075850,
                  CYS: 15132160,
                  GLN: 56540,
                  GLU: 15075850,
                  GLY: 15461355,
                  HIS: 8553170,
                  ILE: 1016335,
                  LEU: 1016335,
                  LYS: 1334015,
                  MET: 15132160,
                  PHE: 3289770,
                  PRO: 14456450,
                  SER: 16422400,
                  THR: 16422400,
                  TRP: 11819700,
                  TYR: 3289770,
                  VAL: 1016335,
                  ASX: 16738740,
                  GLX: 16738740
                },
                /** @property shapely amino acid color scheme*/
                shapely: {
                  ALA: 9240460,
                  ARG: 124,
                  ASN: 16743536,
                  ASP: 10485826,
                  CYS: 16777072,
                  GLN: 16731212,
                  GLU: 6684672,
                  GLY: 16777215,
                  HIS: 7368959,
                  ILE: 19456,
                  LEU: 4546117,
                  LYS: 4671416,
                  MET: 12099650,
                  PHE: 5459026,
                  PRO: 5395026,
                  SER: 16740418,
                  THR: 12078080,
                  TRP: 5195264,
                  TYR: 9203788,
                  VAL: 16747775,
                  ASX: 16711935,
                  GLX: 16711935
                },
                /** @property nucleic acid color scheme*/
                nucleic: {
                  A: 10526975,
                  G: 16740464,
                  I: 8454143,
                  C: 16747595,
                  T: 10551200,
                  U: 16744576
                }
              };
              const chains = {
                /** @property chain based standard color scheme */
                atom: {
                  A: 12636415,
                  B: 11599792,
                  C: 16761032,
                  D: 16777088,
                  E: 16761087,
                  F: 11596016,
                  G: 16765040,
                  H: 15761536,
                  I: 16113331,
                  J: 49151,
                  K: 13458524,
                  L: 6737322,
                  M: 10145074,
                  N: 15631086,
                  O: 52945,
                  P: 65407,
                  Q: 3978097,
                  R: 139,
                  S: 12433259,
                  T: 25600,
                  U: 8388608,
                  V: 8421376,
                  W: 8388736,
                  X: 32896,
                  Y: 12092939,
                  Z: 11674146
                },
                /** @property hetatm color scheme */
                hetatm: {
                  A: 9478351,
                  B: 8441752,
                  C: 13602992,
                  D: 13619056,
                  E: 13603023,
                  F: 8437952,
                  G: 13607008,
                  H: 12603504,
                  I: 12955267,
                  J: 42959,
                  K: 11881548,
                  L: 5682578,
                  M: 9090346,
                  N: 12481214,
                  O: 46753,
                  P: 53103,
                  Q: 3447649,
                  R: 187,
                  S: 10854235,
                  T: 37888,
                  U: 11534336,
                  V: 11579392,
                  W: 11534512,
                  X: 45232,
                  Y: 15250963,
                  Z: 12726834
                }
              };
              const builtinColorSchemes = {
                /** secondary structure pymol */
                ssPyMol: { prop: "ss", map: ssColors.pyMol },
                ssJmol: { prop: "ss", map: ssColors.Jmol },
                Jmol: { prop: "elem", map: elementColors.Jmol },
                amino: { prop: "resn", map: residues.amino },
                shapely: { prop: "resn", map: residues.shapely },
                nucleic: { prop: "resn", map: residues.nucleic },
                chain: { prop: "chain", map: chains.atom },
                rasmol: { prop: "elem", map: elementColors.rasmol },
                default: { prop: "elem", map: elementColors.defaultColors },
                greenCarbon: { prop: "elem", map: elementColors.greenCarbon },
                chainHetatm: { prop: "chain", map: chains.hetatm },
                cyanCarbon: { prop: "elem", map: elementColors.cyanCarbon },
                magentaCarbon: { prop: "elem", map: elementColors.magentaCarbon },
                purpleCarbon: { prop: "elem", map: elementColors.purpleCarbon },
                whiteCarbon: { prop: "elem", map: elementColors.whiteCarbon },
                orangeCarbon: { prop: "elem", map: elementColors.orangeCarbon },
                yellowCarbon: { prop: "elem", map: elementColors.yellowCarbon },
                blueCarbon: { prop: "elem", map: elementColors.blueCarbon }
              };
            },
            /***/
            "./src/exporter.js"(module2) {
              if (typeof module2.exports === "object") {
                module2.exports = window.$3Dmol;
              }
            },
            /***/
            "./src/glcartoon.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                drawCartoon: () => (
                  /* binding */
                  drawCartoon
                ),
                /* harmony export */
                subdivide_spline: () => (
                  /* binding */
                  subdivide_spline
                )
                /* harmony export */
              });
              var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./WebGL/math */
                "./src/WebGL/math/index.ts"
              );
              var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./WebGL/shapes */
                "./src/WebGL/shapes/index.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./WebGL */
                "./src/WebGL/index.ts"
              );
              var _Gradient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./colors */
                "./src/colors.ts"
              );
              var _GLDraw__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./GLDraw */
                "./src/GLDraw.ts"
              );
              var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./utilities */
                "./src/utilities.ts"
              );
              ;
              function subdivide_spline(_points, DIV) {
                var ret = [];
                var points = _points;
                points = [];
                points.push(_points[0]);
                var i, lim, size;
                var p0, p1, p2, p3, v0, v1;
                for (i = 1, lim = _points.length - 1; i < lim; i++) {
                  p1 = _points[i];
                  p2 = _points[i + 1];
                  if (p1.smoothen) {
                    var np = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);
                    np.atom = p1.atom;
                    points.push(np);
                  } else
                    points.push(p1);
                }
                points.push(_points[_points.length - 1]);
                for (i = -1, size = points.length; i <= size - 3; i++) {
                  p0 = points[i === -1 ? 0 : i];
                  p1 = points[i + 1];
                  p2 = points[i + 2];
                  p3 = points[i === size - 3 ? size - 1 : i + 3];
                  v0 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(p2, p0).multiplyScalar(0.5);
                  v1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(p3, p1).multiplyScalar(0.5);
                  if (p2.skip)
                    continue;
                  for (var j = 0; j < DIV; j++) {
                    var t = 1 / DIV * j;
                    var x = p1.x + t * v0.x + t * t * (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x) + t * t * t * (2 * p1.x - 2 * p2.x + v0.x + v1.x);
                    var y = p1.y + t * v0.y + t * t * (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y) + t * t * t * (2 * p1.y - 2 * p2.y + v0.y + v1.y);
                    var z = p1.z + t * v0.z + t * t * (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z) + t * t * t * (2 * p1.z - 2 * p2.z + v0.z + v1.z);
                    var pt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);
                    if (j < DIV / 2) {
                      pt.atom = p1.atom;
                    } else {
                      pt.atom = p2.atom;
                    }
                    ret.push(pt);
                  }
                }
                ret.push(points[points.length - 1]);
                return ret;
              }
              ;
              const coilWidth = 0.5;
              const helixSheetWidth = 1.3;
              const nucleicAcidWidth = 0.8;
              const defaultThickness = 0.4;
              const baseThickness = 0.4;
              function drawThinStrip(geo, p1, p2, colors) {
                var offset, vertoffset;
                var color, colori;
                for (var i = 0, lim = p1.length; i < lim; i++) {
                  colori = Math.round(i * (colors.length - 1) / lim);
                  color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);
                  var geoGroup = geo.updateGeoGroup(2);
                  var vertexArray = geoGroup.vertexArray;
                  var colorArray = geoGroup.colorArray;
                  var faceArray = geoGroup.faceArray;
                  offset = geoGroup.vertices;
                  vertoffset = offset * 3;
                  vertexArray[vertoffset] = p1[i].x;
                  vertexArray[vertoffset + 1] = p1[i].y;
                  vertexArray[vertoffset + 2] = p1[i].z;
                  vertexArray[vertoffset + 3] = p2[i].x;
                  vertexArray[vertoffset + 4] = p2[i].y;
                  vertexArray[vertoffset + 5] = p2[i].z;
                  for (var j = 0; j < 6; ++j) {
                    colorArray[vertoffset + 3 * j] = color.r;
                    colorArray[vertoffset + 1 + 3 * j] = color.g;
                    colorArray[vertoffset + 2 + 3 * j] = color.b;
                  }
                  if (i > 0) {
                    var faces = [offset, offset + 1, offset - 1, offset - 2];
                    var faceoffset = geoGroup.faceidx;
                    faceArray[faceoffset] = faces[0];
                    faceArray[faceoffset + 1] = faces[1];
                    faceArray[faceoffset + 2] = faces[3];
                    faceArray[faceoffset + 3] = faces[1];
                    faceArray[faceoffset + 4] = faces[2];
                    faceArray[faceoffset + 5] = faces[3];
                    geoGroup.faceidx += 6;
                  }
                  geoGroup.vertices += 2;
                }
              }
              ;
              function drawShapeStrip(geo, points, colors, div, thickness, opacity, shape) {
                var i, j, num, len;
                num = points.length;
                if (num < 2 || points[0].length < 2)
                  return;
                for (i = 0; i < num; i++) {
                  points[i] = subdivide_spline(points[i], div);
                }
                len = points[0].length;
                if (!thickness)
                  return drawThinStrip(geo, points[0], points[num - 1], colors);
                var axis, cs_shape, cs_bottom, cs_top, last_cs_bottom, last_cs_top;
                var cs_ellipse = [], cs_rectangle = [], cs_parabola = [];
                for (j = 0; j < num; j++) {
                  cs_ellipse.push(0.25 + 1.5 * Math.sqrt((num - 1) * j - Math.pow(j, 2)) / (num - 1));
                  cs_rectangle.push(0.5);
                  cs_parabola.push(2 * (Math.pow(j / num, 2) - j / num) + 0.6);
                }
                var face_refs = [];
                for (j = 0; j < num * 2 - 1; j++) {
                  face_refs[j] = [j, j + 1, j + 1 - 2 * num, j - 2 * num];
                }
                face_refs[num * 2 - 1] = [
                  j,
                  j + 1 - 2 * num,
                  j + 1 - 4 * num,
                  j - 2 * num
                ];
                var v_offset, va_offset, f_offset;
                var currentAtom;
                var color, colori;
                var vertexArray, colorArray, faceArray, face;
                let geoGroup = geo.updateGeoGroup();
                for (i = 0; i < len; i++) {
                  let gnum = geo.groups;
                  let replicating = false;
                  geoGroup = geo.updateGeoGroup(2 * num);
                  if (gnum != geo.groups && i > 0) {
                    i = i - 1;
                    replicating = true;
                  }
                  colori = Math.round(i * (colors.length - 1) / len);
                  color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);
                  last_cs_bottom = cs_bottom;
                  last_cs_top = cs_top;
                  cs_bottom = [];
                  cs_top = [];
                  axis = [];
                  if (points[0][i].atom !== void 0) {
                    currentAtom = points[0][i].atom;
                    if (shape === "oval")
                      cs_shape = cs_ellipse;
                    else if (shape === "rectangle")
                      cs_shape = cs_rectangle;
                    else if (shape === "parabola")
                      cs_shape = cs_parabola;
                  }
                  if (!cs_shape)
                    cs_shape = cs_rectangle;
                  var toNext, toSide;
                  for (j = 0; j < num; j++) {
                    if (i < len - 1)
                      toNext = points[j][i + 1].clone().sub(points[j][i]);
                    else
                      toNext = points[j][i - 1].clone().sub(points[j][i]).negate();
                    if (j < num - 1)
                      toSide = points[j + 1][i].clone().sub(points[j][i]);
                    else
                      toSide = points[j - 1][i].clone().sub(points[j][i]).negate();
                    axis[j] = toSide.cross(toNext).normalize().multiplyScalar(thickness * cs_shape[j]);
                  }
                  for (j = 0; j < num; j++)
                    cs_bottom[j] = points[j][i].clone().add(axis[j].clone().negate());
                  for (j = 0; j < num; j++)
                    cs_top[j] = points[j][i].clone().add(axis[j]);
                  vertexArray = geoGroup.vertexArray;
                  colorArray = geoGroup.colorArray;
                  faceArray = geoGroup.faceArray;
                  v_offset = geoGroup.vertices;
                  va_offset = v_offset * 3;
                  for (j = 0; j < num; j++) {
                    vertexArray[va_offset + 3 * j + 0] = cs_bottom[j].x;
                    vertexArray[va_offset + 3 * j + 1] = cs_bottom[j].y;
                    vertexArray[va_offset + 3 * j + 2] = cs_bottom[j].z;
                  }
                  for (j = 0; j < num; j++) {
                    vertexArray[va_offset + 3 * j + 0 + 3 * num] = cs_top[num - 1 - j].x;
                    vertexArray[va_offset + 3 * j + 1 + 3 * num] = cs_top[num - 1 - j].y;
                    vertexArray[va_offset + 3 * j + 2 + 3 * num] = cs_top[num - 1 - j].z;
                  }
                  for (j = 0; j < 2 * num; ++j) {
                    colorArray[va_offset + 3 * j + 0] = color.r;
                    colorArray[va_offset + 3 * j + 1] = color.g;
                    colorArray[va_offset + 3 * j + 2] = color.b;
                  }
                  if (i > 0 && !replicating) {
                    for (j = 0; j < num * 2; j++) {
                      face = [
                        v_offset + face_refs[j][0],
                        v_offset + face_refs[j][1],
                        v_offset + face_refs[j][2],
                        v_offset + face_refs[j][3]
                      ];
                      f_offset = geoGroup.faceidx;
                      faceArray[f_offset] = face[0];
                      faceArray[f_offset + 1] = face[1];
                      faceArray[f_offset + 2] = face[3];
                      faceArray[f_offset + 3] = face[1];
                      faceArray[f_offset + 4] = face[2];
                      faceArray[f_offset + 5] = face[3];
                      geoGroup.faceidx += 6;
                    }
                    if (currentAtom.clickable || currentAtom.hoverable) {
                      var faces = [];
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[0], cs_bottom[0], cs_bottom[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[0], cs_bottom[num - 1], last_cs_bottom[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[num - 1], cs_bottom[num - 1], cs_top[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[num - 1], cs_top[num - 1], last_cs_top[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[0], last_cs_top[0], last_cs_top[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[num - 1], cs_top[0], last_cs_top[num - 1]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_bottom[0], last_cs_bottom[0], last_cs_top[0]));
                      faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[0], cs_bottom[0], last_cs_top[0]));
                      for (j in faces) {
                        currentAtom.intersectionShape.triangle.push(faces[j]);
                      }
                    }
                  }
                  geoGroup.vertices += 2 * num;
                }
                vertexArray = geoGroup.vertexArray;
                colorArray = geoGroup.colorArray;
                faceArray = geoGroup.faceArray;
                v_offset = geoGroup.vertices;
                va_offset = v_offset * 3;
                f_offset = geoGroup.faceidx;
                for (i = 0; i < num - 1; i++) {
                  face = [i, i + 1, 2 * num - 2 - i, 2 * num - 1 - i];
                  f_offset = geoGroup.faceidx;
                  faceArray[f_offset] = face[0];
                  faceArray[f_offset + 1] = face[1];
                  faceArray[f_offset + 2] = face[3];
                  faceArray[f_offset + 3] = face[1];
                  faceArray[f_offset + 4] = face[2];
                  faceArray[f_offset + 5] = face[3];
                  geoGroup.faceidx += 6;
                }
                for (i = 0; i < num - 1; i++) {
                  face = [
                    v_offset - 1 - i,
                    v_offset - 2 - i,
                    v_offset - 2 * num + i + 1,
                    v_offset - 2 * num + i
                  ];
                  f_offset = geoGroup.faceidx;
                  faceArray[f_offset] = face[0];
                  faceArray[f_offset + 1] = face[1];
                  faceArray[f_offset + 2] = face[3];
                  faceArray[f_offset + 3] = face[1];
                  faceArray[f_offset + 4] = face[2];
                  faceArray[f_offset + 5] = face[3];
                  geoGroup.faceidx += 6;
                }
              }
              ;
              function drawPlainStrip(geo, points, colors, div, thickness, opacity) {
                if (points.length < 2)
                  return;
                var p1, p2;
                p1 = points[0];
                p2 = points[points.length - 1];
                p1 = subdivide_spline(p1, div);
                p2 = subdivide_spline(p2, div);
                if (!thickness)
                  return drawThinStrip(geo, p1, p2, colors);
                var vs = [];
                var axis, p1v, p2v, a1v, a2v;
                var faces = [
                  [0, 2, -6, -8],
                  [-4, -2, 6, 4],
                  [7, -1, -5, 3],
                  [-3, 5, 1, -7]
                ];
                var offset, vertoffset, faceoffset;
                var color, colori;
                var currentAtom, lastAtom;
                var i, lim, j;
                var face1, face2, face3;
                var geoGroup, vertexArray, colorArray, faceArray;
                for (i = 0, lim = p1.length; i < lim; i++) {
                  colori = Math.round(i * (colors.length - 1) / lim);
                  color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);
                  vs.push(p1v = p1[i]);
                  vs.push(p1v);
                  vs.push(p2v = p2[i]);
                  vs.push(p2v);
                  if (i < lim - 1) {
                    var toNext = p1[i + 1].clone().sub(p1[i]);
                    var toSide = p2[i].clone().sub(p1[i]);
                    axis = toSide.cross(toNext).normalize().multiplyScalar(thickness);
                  }
                  vs.push(a1v = p1[i].clone().add(axis));
                  vs.push(a1v);
                  vs.push(a2v = p2[i].clone().add(axis));
                  vs.push(a2v);
                  if (p1v.atom !== void 0)
                    currentAtom = p1v.atom;
                  geoGroup = geo.updateGeoGroup(8);
                  vertexArray = geoGroup.vertexArray;
                  colorArray = geoGroup.colorArray;
                  faceArray = geoGroup.faceArray;
                  offset = geoGroup.vertices;
                  vertoffset = offset * 3;
                  vertexArray[vertoffset] = p1v.x;
                  vertexArray[vertoffset + 1] = p1v.y;
                  vertexArray[vertoffset + 2] = p1v.z;
                  vertexArray[vertoffset + 3] = p1v.x;
                  vertexArray[vertoffset + 4] = p1v.y;
                  vertexArray[vertoffset + 5] = p1v.z;
                  vertexArray[vertoffset + 6] = p2v.x;
                  vertexArray[vertoffset + 7] = p2v.y;
                  vertexArray[vertoffset + 8] = p2v.z;
                  vertexArray[vertoffset + 9] = p2v.x;
                  vertexArray[vertoffset + 10] = p2v.y;
                  vertexArray[vertoffset + 11] = p2v.z;
                  vertexArray[vertoffset + 12] = a1v.x;
                  vertexArray[vertoffset + 13] = a1v.y;
                  vertexArray[vertoffset + 14] = a1v.z;
                  vertexArray[vertoffset + 15] = a1v.x;
                  vertexArray[vertoffset + 16] = a1v.y;
                  vertexArray[vertoffset + 17] = a1v.z;
                  vertexArray[vertoffset + 18] = a2v.x;
                  vertexArray[vertoffset + 19] = a2v.y;
                  vertexArray[vertoffset + 20] = a2v.z;
                  vertexArray[vertoffset + 21] = a2v.x;
                  vertexArray[vertoffset + 22] = a2v.y;
                  vertexArray[vertoffset + 23] = a2v.z;
                  for (j = 0; j < 8; ++j) {
                    colorArray[vertoffset + 3 * j] = color.r;
                    colorArray[vertoffset + 1 + 3 * j] = color.g;
                    colorArray[vertoffset + 2 + 3 * j] = color.b;
                  }
                  if (i > 0) {
                    var diffAtoms = lastAtom !== void 0 && currentAtom !== void 0 && lastAtom.serial !== currentAtom.serial;
                    for (j = 0; j < 4; j++) {
                      var face = [
                        offset + faces[j][0],
                        offset + faces[j][1],
                        offset + faces[j][2],
                        offset + faces[j][3]
                      ];
                      faceoffset = geoGroup.faceidx;
                      faceArray[faceoffset] = face[0];
                      faceArray[faceoffset + 1] = face[1];
                      faceArray[faceoffset + 2] = face[3];
                      faceArray[faceoffset + 3] = face[1];
                      faceArray[faceoffset + 4] = face[2];
                      faceArray[faceoffset + 5] = face[3];
                      geoGroup.faceidx += 6;
                      if (currentAtom.clickable || lastAtom.clickable || currentAtom.hoverable || lastAtom.hoverable) {
                        var p1a = vs[face[3]].clone(), p1b = vs[face[0]].clone(), p2a = vs[face[2]].clone(), p2b = vs[face[1]].clone();
                        p1a.atom = vs[face[3]].atom || null;
                        p2a.atom = vs[face[2]].atom || null;
                        p1b.atom = vs[face[0]].atom || null;
                        p2b.atom = vs[face[1]].atom || null;
                        if (diffAtoms) {
                          var m1 = p1a.clone().add(p1b).multiplyScalar(0.5);
                          var m2 = p2a.clone().add(p2b).multiplyScalar(0.5);
                          var m = p1a.clone().add(p2b).multiplyScalar(0.5);
                          if (j % 2 === 0) {
                            if (lastAtom.clickable || lastAtom.hoverable) {
                              face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m1, m, p1a);
                              face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m2, p2a, m);
                              face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m, p2a, p1a);
                              lastAtom.intersectionShape.triangle.push(face1);
                              lastAtom.intersectionShape.triangle.push(face2);
                              lastAtom.intersectionShape.triangle.push(face3);
                            }
                            if (currentAtom.clickable || currentAtom.hoverable) {
                              face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, m);
                              face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, m2, m);
                              face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, m, m1);
                              currentAtom.intersectionShape.triangle.push(face1);
                              currentAtom.intersectionShape.triangle.push(face2);
                              currentAtom.intersectionShape.triangle.push(face3);
                            }
                          } else {
                            if (currentAtom.clickable || currentAtom.hoverable) {
                              face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m1, m, p1a);
                              face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m2, p2a, m);
                              face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m, p2a, p1a);
                              currentAtom.intersectionShape.triangle.push(face1);
                              currentAtom.intersectionShape.triangle.push(face2);
                              currentAtom.intersectionShape.triangle.push(face3);
                            }
                            if (lastAtom.clickable || lastAtom.hoverable) {
                              face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, m);
                              face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, m2, m);
                              face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, m, m1);
                              lastAtom.intersectionShape.triangle.push(face1);
                              lastAtom.intersectionShape.triangle.push(face2);
                              lastAtom.intersectionShape.triangle.push(face3);
                            }
                          }
                        } else if (currentAtom.clickable || currentAtom.hoverable) {
                          face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, p1a);
                          face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, p2a, p1a);
                          currentAtom.intersectionShape.triangle.push(face1);
                          currentAtom.intersectionShape.triangle.push(face2);
                        }
                      }
                    }
                  }
                  geoGroup.vertices += 8;
                  lastAtom = currentAtom;
                }
                var vsize = vs.length - 8;
                geoGroup = geo.updateGeoGroup(8);
                vertexArray = geoGroup.vertexArray;
                colorArray = geoGroup.colorArray;
                faceArray = geoGroup.faceArray;
                offset = geoGroup.vertices;
                vertoffset = offset * 3;
                faceoffset = geoGroup.faceidx;
                for (i = 0; i < 4; i++) {
                  vs.push(vs[i * 2]);
                  vs.push(vs[vsize + i * 2]);
                  var v1 = vs[i * 2], v2 = vs[vsize + i * 2];
                  vertexArray[vertoffset + 6 * i] = v1.x;
                  vertexArray[vertoffset + 1 + 6 * i] = v1.y;
                  vertexArray[vertoffset + 2 + 6 * i] = v1.z;
                  vertexArray[vertoffset + 3 + 6 * i] = v2.x;
                  vertexArray[vertoffset + 4 + 6 * i] = v2.y;
                  vertexArray[vertoffset + 5 + 6 * i] = v2.z;
                  colorArray[vertoffset + 6 * i] = color.r;
                  colorArray[vertoffset + 1 + 6 * i] = color.g;
                  colorArray[vertoffset + 2 + 6 * i] = color.b;
                  colorArray[vertoffset + 3 + 6 * i] = color.r;
                  colorArray[vertoffset + 4 + 6 * i] = color.g;
                  colorArray[vertoffset + 5 + 6 * i] = color.b;
                }
                vsize += 8;
                face1 = [offset, offset + 2, offset + 6, offset + 4];
                face2 = [offset + 1, offset + 5, offset + 7, offset + 3];
                faceArray[faceoffset] = face1[0];
                faceArray[faceoffset + 1] = face1[1];
                faceArray[faceoffset + 2] = face1[3];
                faceArray[faceoffset + 3] = face1[1];
                faceArray[faceoffset + 4] = face1[2];
                faceArray[faceoffset + 5] = face1[3];
                faceArray[faceoffset + 6] = face2[0];
                faceArray[faceoffset + 7] = face2[1];
                faceArray[faceoffset + 8] = face2[3];
                faceArray[faceoffset + 9] = face2[1];
                faceArray[faceoffset + 10] = face2[2];
                faceArray[faceoffset + 11] = face2[3];
                geoGroup.faceidx += 12;
                geoGroup.vertices += 8;
              }
              ;
              function drawStrip(geo, points, colors, div, thickness, opacity, shape) {
                if (!shape || shape === "default")
                  shape = "rectangle";
                if (shape === "edged")
                  drawPlainStrip(geo, points, colors, div, thickness, opacity);
                else if (shape === "rectangle" || shape === "oval" || shape === "parabola")
                  drawShapeStrip(geo, points, colors, div, thickness, opacity, shape);
              }
              ;
              function isAlphaCarbon(atom) {
                return atom && atom.elem === "C" && atom.atom === "CA";
              }
              ;
              function inConnectedResidues(a, b) {
                if (a && b && a.chain === b.chain) {
                  if (!a.hetflag && !b.hetflag && a.reschain === b.reschain && (a.resi === b.resi || a.resi === b.resi - 1))
                    return true;
                  if (a.resi < b.resi) {
                    var dx = a.x - b.x;
                    var dy = a.y - b.y;
                    var dz = a.z - b.z;
                    var dist = dx * dx + dy * dy + dz * dz;
                    if (a.atom == "CA" && b.atom == "CA" && dist < 16)
                      return true;
                    else if ((a.atom == "P" || b.atom == "P") && dist < 64)
                      return true;
                  }
                }
                return false;
              }
              ;
              function setGeo(group, geo, opacity, outline, setNormals) {
                if (geo == null || geo.vertices == 0)
                  return;
                if (setNormals) {
                  geo.initTypedArrays();
                  geo.setUpNormals();
                }
                var cartoonMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.MeshDoubleLambertMaterial();
                cartoonMaterial.vertexColors = _WebGL__WEBPACK_IMPORTED_MODULE_2__.Coloring.FaceColors;
                if (typeof opacity === "number" && opacity >= 0 && opacity < 1) {
                  cartoonMaterial.transparent = true;
                  cartoonMaterial.opacity = opacity;
                }
                cartoonMaterial.outline = outline;
                var cartoonMesh = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, cartoonMaterial);
                group.add(cartoonMesh);
              }
              ;
              function addBackbonePoints(points, num, smoothen, backbonePt, orientPt, prevOrientPt, backboneAtom, atoms, atomi) {
                var widthScalar, i, delta, v, addArrowPoints, testStyle;
                if (!backbonePt || !orientPt || !backboneAtom)
                  return;
                var sideVec = orientPt.sub(backbonePt);
                sideVec.normalize();
                var forwardVec = atoms[atomi];
                for (i = atomi + 1; i < atoms.length; i++) {
                  forwardVec = atoms[i];
                  if (forwardVec.atom == backboneAtom.atom)
                    break;
                }
                forwardVec = forwardVec ? new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(forwardVec.x, forwardVec.y, forwardVec.z) : new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
                forwardVec.sub(backbonePt);
                if (backboneAtom.ss === "arrow start") {
                  var adjustment = forwardVec.clone().multiplyScalar(0.3).cross(orientPt);
                  backbonePt.add(adjustment);
                  var upVec = forwardVec.clone().cross(sideVec).normalize();
                  sideVec.rotateAboutVector(upVec, 0.43);
                }
                if (backboneAtom.style.cartoon.ribbon) {
                  widthScalar = backboneAtom.style.cartoon.thickness || defaultThickness;
                } else {
                  if (!backboneAtom.style.cartoon.width) {
                    if (backboneAtom.ss === "c") {
                      if (backboneAtom.atom === "P")
                        widthScalar = nucleicAcidWidth;
                      else
                        widthScalar = coilWidth;
                    } else if (backboneAtom.ss === "arrow start") {
                      widthScalar = helixSheetWidth;
                      addArrowPoints = true;
                    } else if (backboneAtom.ss === "arrow end")
                      widthScalar = coilWidth;
                    else if (backboneAtom.ss === "h" && backboneAtom.style.cartoon.tubes || backboneAtom.ss === "tube start")
                      widthScalar = coilWidth;
                    else
                      widthScalar = helixSheetWidth;
                  } else
                    widthScalar = backboneAtom.style.cartoon.width;
                }
                if (prevOrientPt != null && sideVec.dot(prevOrientPt) < 0)
                  sideVec.negate();
                sideVec.multiplyScalar(widthScalar);
                for (i = 0; i < num; i++) {
                  delta = -1 + i * 2 / (num - 1);
                  v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(backbonePt.x + delta * sideVec.x, backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);
                  v.atom = backboneAtom;
                  if (smoothen && backboneAtom.ss === "s")
                    v.smoothen = true;
                  points[i].push(v);
                }
                if (addArrowPoints) {
                  sideVec.multiplyScalar(2);
                  for (i = 0; i < num; i++) {
                    delta = -1 + i * 2 / (num - 1);
                    v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(backbonePt.x + delta * sideVec.x, backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);
                    v.atom = backboneAtom;
                    v.smoothen = false;
                    v.skip = true;
                    points[i].push(v);
                  }
                }
                testStyle = backboneAtom.style.cartoon.style || "default";
                if (points.style) {
                  if (points.style != testStyle) {
                    console.log("Warning: a cartoon chain's strand-style is ambiguous");
                    points.style = "default";
                  }
                } else
                  points.style = testStyle;
                if (backboneAtom.ss === "arrow start" || backboneAtom.ss === "arrow end")
                  backboneAtom.ss = "s";
                return addArrowPoints;
              }
              ;
              const cartoonAtoms = {
                "C": true,
                "CA": true,
                "O": true,
                "P": true,
                "OP2": true,
                "O2P": true,
                "O5'": true,
                "O3'": true,
                "C5'": true,
                "C2'": true,
                "O5*": true,
                "O3*": true,
                "C5*": true,
                "C2*": true,
                "N1": true,
                "N3": true
              };
              const purResns = { "DA": true, "DG": true, "A": true, "G": true };
              const pyrResns = { "DT": true, "DC": true, "U": true, "C": true, "T": true };
              const naResns = { "DA": true, "DG": true, "A": true, "G": true, "DT": true, "DC": true, "U": true, "C": true, "T": true };
              function drawCartoon(group, atomList, gradientrange, quality = 10) {
                let num = quality;
                let div = quality;
                var cartoon, prev, curr, next, currColor, nextColor, thickness, i;
                var backbonePt, orientPt, prevOrientPt, terminalPt, termOrientPt, baseStartPt, baseEndPt;
                var tubeStart, tubeEnd, drawingTube;
                var shapeGeo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);
                var geo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);
                var colors = [];
                var points = [];
                var opacity = 1;
                var outline = false;
                var gradients = {};
                for (var g in _Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients) {
                  if (_Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients.hasOwnProperty(g)) {
                    gradients[g] = new _Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients[g](gradientrange[1], gradientrange[0]);
                  }
                }
                var cartoonColor = function(next2, cartoon2) {
                  if (gradientrange && cartoon2.color === "spectrum") {
                    if (cartoon2.colorscheme in gradients) {
                      return gradients[cartoon2.colorscheme].valueToHex(next2.resi);
                    } else {
                      return gradients.sinebow.valueToHex(next2.resi);
                    }
                  } else {
                    return (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(next2, cartoon2).getHex();
                  }
                };
                for (i = 0; i < num; i++)
                  points[i] = [];
                var inSheet = false;
                var inHelix = false;
                var atoms = [];
                for (i in atomList) {
                  next = atomList[i];
                  if (next.elem === "C" && next.atom === "CA") {
                    var connected = inConnectedResidues(curr, next);
                    if (connected && next.ss === "s") {
                      inSheet = true;
                    } else if (inSheet) {
                      if (curr && prev && curr.style.cartoon.arrows && prev.style.cartoon.arrows) {
                        curr.ss = "arrow end";
                        prev.ss = "arrow start";
                      }
                      inSheet = false;
                    }
                    if (connected && (curr.ss === "h" || curr.ss == "tube start") && curr.style.cartoon.tubes) {
                      if (!inHelix && curr.ss != "tube start" && next.style.cartoon.tubes) {
                        next.ss = "tube start";
                        inHelix = true;
                      }
                    } else if (inHelix) {
                      if (curr.ss === "tube start") {
                        curr.ss = "tube end";
                      } else if (prev && prev.style.cartoon.tubes) {
                        prev.ss = "tube end";
                      }
                      inHelix = false;
                    }
                    prev = curr;
                    curr = next;
                  }
                  if (next && next.atom in cartoonAtoms) {
                    atoms.push(next);
                  }
                }
                if (inHelix && curr.style.cartoon.tubes) {
                  curr.ss = "tube end";
                  inHelix = false;
                }
                var flushGeom = function(connect) {
                  if (points[0].length > 0) {
                    drawStrip(geo, points, colors, div, thickness, opacity, points.style);
                  }
                  var saved = [], savedc = null;
                  if (connect) {
                    for (i = 0; i < num; i++) {
                      saved[i] = points[i][points[i].length - 1];
                    }
                    savedc = colors[colors.length - 1];
                  }
                  points = [];
                  for (i = 0; i < num; i++)
                    points[i] = [];
                  colors = [];
                  if (connect) {
                    for (i = 0; i < num; i++) {
                      points[i].push(saved[i]);
                    }
                    colors.push(savedc);
                  }
                  setGeo(group, geo, opacity, outline, true);
                  setGeo(group, shapeGeo, opacity, outline, false);
                  geo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);
                  shapeGeo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);
                };
                curr = void 0;
                let disconnects = [];
                for (var a = 0; a < atoms.length; a++) {
                  next = atoms[a];
                  var nextresn = next.resn.trim();
                  var inNucleicAcid = nextresn in naResns;
                  opacity = 1;
                  cartoon = next.style.cartoon;
                  if (curr && curr.style.cartoon)
                    opacity = curr.style.cartoon.opacity;
                  if (curr && curr.style.cartoon && curr.style.cartoon.outline)
                    outline = curr.style.cartoon.outline;
                  if (curr && curr.style.cartoon && (!next.style.cartoon || curr.style.cartoon.opacity != next.style.cartoon.opacity)) {
                    flushGeom(curr.chain == next.chain);
                  }
                  if (curr && next && !inConnectedResidues(curr, next) && curr.chain && curr.chain == next.chain && !curr.hetflag && !next.hetflag && curr.reschain + 1 == next.reschain) {
                    disconnects.push([curr, next]);
                  }
                  if (cartoon.style === "trace") {
                    if (next.hetflag) {
                      ;
                    } else if (next.elem === "C" && next.atom === "CA" || inNucleicAcid && next.atom === "P" || next.atom === "BB") {
                      nextColor = cartoonColor(next, cartoon);
                      if ((0, _utilities__WEBPACK_IMPORTED_MODULE_6__.isNumeric)(cartoon.thickness))
                        thickness = cartoon.thickness;
                      else
                        thickness = defaultThickness;
                      if (inConnectedResidues(curr, next)) {
                        if (nextColor == currColor) {
                          var color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(nextColor);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, curr, next, thickness, color, 2, 2);
                        } else {
                          var midpoint = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, next).multiplyScalar(0.5);
                          var color1 = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor);
                          var color2 = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(nextColor);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, curr, midpoint, thickness, color1, 2, 0);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, midpoint, next, thickness, color2, 0, 2);
                        }
                      }
                      if ((next.clickable === true || next.hoverable) && next.intersectionShape !== void 0) {
                        var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                        next.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, thickness));
                      }
                      curr = next;
                      currColor = nextColor;
                    }
                  } else {
                    if (isAlphaCarbon(next) || inNucleicAcid && (next.atom === "P" || next.atom.indexOf("O5") == 0)) {
                      if (drawingTube) {
                        if (next.ss === "tube end") {
                          drawingTube = false;
                          tubeEnd = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, tubeStart, tubeEnd, 2, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor), 1, 1);
                          next.ss = "h";
                        } else if (curr.chain != next.chain || curr.ss === "tube end") {
                          drawingTube = false;
                          curr.ss = "h";
                          tubeEnd = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, tubeStart, tubeEnd, 2, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor), 1, 1);
                        } else
                          continue;
                      }
                      if (curr && (!inConnectedResidues(curr, next) || curr.ss === "tube start")) {
                        if (curr.ss === "tube start") {
                          drawingTube = true;
                          tubeStart = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);
                          curr.ss = "h";
                        }
                        if (baseEndPt) {
                          if (terminalPt)
                            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, terminalPt).multiplyScalar(0.5);
                          else
                            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(baseEndPt.color), 0, 2);
                          addBackbonePoints(points, num, true, terminalPt, termOrientPt, prevOrientPt, curr, atoms, a);
                          colors.push(nextColor);
                          baseStartPt = null;
                          baseEndPt = null;
                        }
                        if (points[0].length > 0)
                          drawStrip(geo, points, colors, div, thickness, opacity, points.style);
                        points = [];
                        for (i = 0; i < num; i++)
                          points[i] = [];
                        colors = [];
                      }
                      if (curr === void 0 || curr.rescode != next.rescode || curr.resi != next.resi) {
                        if (baseEndPt && curr != void 0) {
                          baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, next).multiplyScalar(0.5);
                          var startFix = baseStartPt.clone().sub(baseEndPt).multiplyScalar(0.02);
                          baseStartPt.add(startFix);
                          _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(baseEndPt.color), 0, 2);
                          baseStartPt = null;
                          baseEndPt = null;
                        }
                        nextColor = cartoonColor(next, cartoon);
                        colors.push(nextColor);
                        if ((0, _utilities__WEBPACK_IMPORTED_MODULE_6__.isNumeric)(cartoon.thickness))
                          thickness = cartoon.thickness;
                        else
                          thickness = defaultThickness;
                        curr = next;
                        backbonePt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);
                        backbonePt.resi = curr.resi;
                        currColor = nextColor;
                      }
                      if ((next.clickable === true || next.hoverable === true) && (next.intersectionShape === void 0 || next.intersectionShape.triangle === void 0))
                        next.intersectionShape = {
                          sphere: null,
                          cylinder: [],
                          line: [],
                          triangle: []
                        };
                    } else if (curr != void 0 && (isAlphaCarbon(curr) && next.atom === "O" || inNucleicAcid && curr.atom === "P" && (next.atom === "OP2" || next.atom === "O2P") || inNucleicAcid && curr.atom.indexOf("O5") == 0 && next.atom.indexOf("C5") == 0)) {
                      orientPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                      orientPt.resi = next.resi;
                      if (next.atom === "OP2" || next.atom === "O2P")
                        termOrientPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                    } else if (inNucleicAcid && next.atom.indexOf("O3") == 0) {
                      terminalPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                    } else if (next.atom === "N1" && nextresn in purResns || next.atom === "N3" && nextresn in pyrResns) {
                      baseEndPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);
                      baseEndPt.color = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(next, cartoon).getHex();
                    }
                    if (orientPt && backbonePt && orientPt.resi === backbonePt.resi) {
                      addBackbonePoints(points, num, true, backbonePt, orientPt, prevOrientPt, curr, atoms, a);
                      prevOrientPt = orientPt;
                      backbonePt = null;
                      orientPt = null;
                      colors.push(nextColor);
                    }
                  }
                }
                if (baseEndPt) {
                  if (terminalPt)
                    baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, terminalPt).multiplyScalar(0.5);
                  else
                    baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);
                  _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(baseEndPt.color), 0, 2);
                  addBackbonePoints(points, num, true, terminalPt, termOrientPt, prevOrientPt, curr, atoms, a);
                  colors.push(nextColor);
                }
                flushGeom(false);
                var drawGap = function(start, end) {
                  if (start.style.cartoon.gapcutoff && start.style.cartoon.gapcutoff == end.style.cartoon.gapcutoff) {
                    let cut = start.style.cartoon.gapcutoff;
                    let gap = end.resi - start.resi;
                    if (gap > 0 && gap < cut) {
                      let radius = 0.25;
                      let xdiff = end.x - start.x;
                      let ydiff = end.y - start.y;
                      let zdiff = end.z - start.z;
                      let gapLength = Math.sqrt(xdiff * xdiff + ydiff * ydiff + zdiff * zdiff);
                      let cylinderLength = gapLength / (2 * gap);
                      let new_start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(start.x, start.y, start.z);
                      let div2 = gapLength / cylinderLength;
                      let dashVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3((end.x - start.x) / div2, (end.y - start.y) / div2, (end.z - start.z) / div2);
                      new_start.add({ x: dashVector.x / 2, y: dashVector.y / 2, z: dashVector.z / 2 });
                      let new_end = new_start.clone().add(dashVector);
                      dashVector.multiplyScalar(2);
                      let fakeres = (0, _utilities__WEBPACK_IMPORTED_MODULE_6__.extend)({}, start);
                      for (var place = 0; place < gap; place++) {
                        fakeres.resi += 1;
                        let color3 = cartoonColor(fakeres, fakeres.style.cartoon);
                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, new_start, new_end, radius, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(color3), _GLDraw__WEBPACK_IMPORTED_MODULE_5__.CAP.FLAT, _GLDraw__WEBPACK_IMPORTED_MODULE_5__.CAP.FLAT);
                        new_start.add(dashVector);
                        new_end.add(dashVector);
                      }
                      flushGeom(false);
                    }
                  }
                };
                for (let pair of disconnects) {
                  drawGap(pair[0], pair[1]);
                }
              }
              ;
            },
            /***/
            "./src/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CAP: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.CAP
                ),
                /* harmony export */
                CC: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.CC
                ),
                /* harmony export */
                CONTEXTS_PER_VIEWPORT: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.CONTEXTS_PER_VIEWPORT
                ),
                /* harmony export */
                Color: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Color
                ),
                /* harmony export */
                CustomLinear: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.CustomLinear
                ),
                /* harmony export */
                Cylinder: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Cylinder
                ),
                /* harmony export */
                GLDraw: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GLDraw
                ),
                /* harmony export */
                GLModel: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GLModel
                ),
                /* harmony export */
                GLShape: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GLShape
                ),
                /* harmony export */
                GLViewer: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GLViewer
                ),
                /* harmony export */
                GLVolumetricRender: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GLVolumetricRender
                ),
                /* harmony export */
                Gradient: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Gradient
                ),
                /* harmony export */
                GradientType: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.GradientType
                ),
                /* harmony export */
                Label: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Label
                ),
                /* harmony export */
                LabelCount: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.LabelCount
                ),
                /* harmony export */
                MarchingCube: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.MarchingCube
                ),
                /* harmony export */
                MarchingCubeInitializer: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.MarchingCubeInitializer
                ),
                /* harmony export */
                Matrix3: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Matrix3
                ),
                /* harmony export */
                Matrix4: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Matrix4
                ),
                /* harmony export */
                Parsers: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Parsers
                ),
                /* harmony export */
                PausableTimer: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.PausableTimer
                ),
                /* harmony export */
                PointGrid: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.PointGrid
                ),
                /* harmony export */
                ProteinSurface: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.ProteinSurface
                ),
                /* harmony export */
                Quaternion: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Quaternion
                ),
                /* harmony export */
                ROYGB: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.ROYGB
                ),
                /* harmony export */
                RWB: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.RWB
                ),
                /* harmony export */
                Ray: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Ray
                ),
                /* harmony export */
                Sinebow: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Sinebow
                ),
                /* harmony export */
                Sphere: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Sphere
                ),
                /* harmony export */
                SurfaceType: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.SurfaceType
                ),
                /* harmony export */
                Triangle: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Triangle
                ),
                /* harmony export */
                Vector2: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Vector2
                ),
                /* harmony export */
                Vector3: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.Vector3
                ),
                /* harmony export */
                VolumeData: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.VolumeData
                ),
                /* harmony export */
                adjustVolumeStyle: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.adjustVolumeStyle
                ),
                /* harmony export */
                applyPartialCharges: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.applyPartialCharges
                ),
                /* harmony export */
                autoinit: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.autoinit
                ),
                /* harmony export */
                autoload: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.autoload
                ),
                /* harmony export */
                base64ToArray: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.base64ToArray
                ),
                /* harmony export */
                bondLength: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.bondLength
                ),
                /* harmony export */
                builtinColorSchemes: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.builtinColorSchemes
                ),
                /* harmony export */
                builtinGradients: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.builtinGradients
                ),
                /* harmony export */
                chains: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.chains
                ),
                /* harmony export */
                clamp: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.clamp
                ),
                /* harmony export */
                conversionMatrix3: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.conversionMatrix3
                ),
                /* harmony export */
                createStereoViewer: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.createStereoViewer
                ),
                /* harmony export */
                createViewer: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.createViewer
                ),
                /* harmony export */
                createViewerGrid: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.createViewerGrid
                ),
                /* harmony export */
                deepCopy: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.deepCopy
                ),
                /* harmony export */
                degToRad: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.degToRad
                ),
                /* harmony export */
                download: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.download
                ),
                /* harmony export */
                drawCartoon: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.drawCartoon
                ),
                /* harmony export */
                elementColors: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.elementColors
                ),
                /* harmony export */
                extend: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.extend
                ),
                /* harmony export */
                get: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.get
                ),
                /* harmony export */
                getAtomProperty: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getAtomProperty
                ),
                /* harmony export */
                getColorFromStyle: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getColorFromStyle
                ),
                /* harmony export */
                getElement: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getElement
                ),
                /* harmony export */
                getExtent: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getExtent
                ),
                /* harmony export */
                getGradient: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getGradient
                ),
                /* harmony export */
                getPropertyRange: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getPropertyRange
                ),
                /* harmony export */
                getbin: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.getbin
                ),
                /* harmony export */
                htmlColors: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.htmlColors
                ),
                /* harmony export */
                inflateString: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.inflateString
                ),
                /* harmony export */
                isEmptyObject: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject
                ),
                /* harmony export */
                isNumeric: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.isNumeric
                ),
                /* harmony export */
                makeFunction: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.makeFunction
                ),
                /* harmony export */
                mergeGeos: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.mergeGeos
                ),
                /* harmony export */
                normalizeValue: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.normalizeValue
                ),
                /* harmony export */
                partialCharges: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.partialCharges
                ),
                /* harmony export */
                processing_autoinit: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.processing_autoinit
                ),
                /* harmony export */
                residues: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.residues
                ),
                /* harmony export */
                setBondLength: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.setBondLength
                ),
                /* harmony export */
                setSyncSurface: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.setSyncSurface
                ),
                /* harmony export */
                specStringToObject: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.specStringToObject
                ),
                /* harmony export */
                splitMesh: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.splitMesh
                ),
                /* harmony export */
                ssColors: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.ssColors
                ),
                /* harmony export */
                subdivide_spline: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.subdivide_spline
                ),
                /* harmony export */
                syncSurface: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.syncSurface
                ),
                /* harmony export */
                viewers: () => (
                  /* reexport safe */
                  _3Dmol__WEBPACK_IMPORTED_MODULE_0__.viewers
                )
                /* harmony export */
              });
              var _3Dmol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./3Dmol */
                "./src/3Dmol.ts"
              );
              if (window) {
                window.$3Dmol = __webpack_exports__2;
              }
            },
            /***/
            "./src/parsers/BCIF.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                BCIF: () => (
                  /* binding */
                  BCIF
                )
                /* harmony export */
              });
              var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utilities */
                "./src/utilities.ts"
              );
              var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/computeSecondaryStructure */
                "./src/parsers/utils/computeSecondaryStructure.ts"
              );
              var _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./utils/processSymmetries */
                "./src/parsers/utils/processSymmetries.ts"
              );
              var _cifutils_category__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./cifutils/category */
                "./src/parsers/cifutils/category.ts"
              );
              var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./utils/assignPDBBonds */
                "./src/parsers/utils/assignPDBBonds.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_isEmpty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./utils/isEmpty */
                "./src/parsers/utils/isEmpty.ts"
              );
              var MMTF = __webpack_require__2(
                /*! ./src/vendor/mmtf.js */
                "./src/vendor/mmtf.js"
              );
              class Connectivity {
                constructor(comp_bond) {
                  this.C = {};
                  if (comp_bond) {
                    let ids = comp_bond.getField("comp_id");
                    let a1s = comp_bond.getField("atom_id_1");
                    let a2s = comp_bond.getField("atom_id_2");
                    let orders = comp_bond.getField("value_order");
                    for (let i = 0; i < ids.length; i++) {
                      let resn = ids[i];
                      let a1 = a1s[i];
                      let a2 = a2s[i];
                      let oname = orders[i];
                      let o = 1;
                      if (oname == "doub")
                        o = 2;
                      else if (oname == "trip")
                        o = 3;
                      if (this.C[resn] == void 0) {
                        this.C[resn] = {};
                      }
                      if (this.C[resn][a1] == void 0) {
                        this.C[resn][a1] = {};
                      }
                      if (this.C[resn][a2] == void 0) {
                        this.C[resn][a2] = {};
                      }
                      this.C[resn][a1][a2] = o;
                      this.C[resn][a2][a1] = o;
                    }
                  }
                }
                //returns bond order, zero if not connected
                order(resn, atom1, atom2) {
                  if (this.C[resn] !== void 0) {
                    if (this.C[resn][atom1] !== void 0) {
                      if (this.C[resn][atom1][atom2] !== void 0) {
                        return this.C[resn][atom1][atom2];
                      }
                    }
                  }
                  return 0;
                }
              }
              class StructConn {
                constructor(struct_conn) {
                  this.C = [];
                  if (struct_conn) {
                    let types = struct_conn.getField("conn_type_id");
                    let chain1 = struct_conn.getField("ptnr1_label_asym_id");
                    let resi1 = struct_conn.getField("ptnr1_label_seq_id");
                    let resn1 = struct_conn.getField("ptnr1_label_comp_id");
                    let a1 = struct_conn.getField("ptnr1_label_atom_id");
                    let chain2 = struct_conn.getField("ptnr2_label_asym_id");
                    let resi2 = struct_conn.getField("ptnr2_label_seq_id");
                    let resn2 = struct_conn.getField("ptnr2_label_comp_id");
                    let a2 = struct_conn.getField("ptnr2_label_atom_id");
                    let bo = struct_conn.getField("pdbx_value_order");
                    for (let i = 0; i < types.length; i++) {
                      if (types[i] == "disulf" || types[i] == "covale") {
                        let o = bo ? bo[i] == "" ? 1 : parseInt(bo[i]) : 1;
                        this.C.push([[chain1[i], resi1[i], resn1[i], a1[i]], [chain2[i], resi2[i], resn2[i], a2[i]], o]);
                      }
                    }
                  }
                }
              }
              class Residues {
                constructor() {
                  this.R = {};
                }
                add(a) {
                  if (this.R[a.lchain] == void 0)
                    this.R[a.lchain] = {};
                  if (this.R[a.lchain][a.lresi] == void 0)
                    this.R[a.lchain][a.lresi] = {};
                  if (this.R[a.lchain][a.lresi][a.lresn] == void 0)
                    this.R[a.lchain][a.lresi][a.lresn] = [];
                  this.R[a.lchain][a.lresi][a.lresn].push(a);
                  this.R[a.lchain][a.lresi][a.lresn][a.atom] = a;
                }
                geta([ch, resi, resn, aname]) {
                  if (this.R[ch] !== void 0 && this.R[ch][resi] !== void 0 && this.R[ch][resi][resn] !== void 0) {
                    return this.R[ch][resi][resn][aname];
                  }
                  return void 0;
                }
                setBonds(C, SC) {
                  for (let ch in this.R) {
                    for (let resi in this.R[ch]) {
                      for (let resn in this.R[ch][resi]) {
                        let atoms = this.R[ch][resi][resn];
                        for (let i = 0; i < atoms.length; i++) {
                          for (let j = i + 1; j < atoms.length; j++) {
                            let a1 = atoms[i];
                            let a2 = atoms[j];
                            let bo = C.order(resn, a1.atom, a2.atom);
                            if (a1.altLoc != a2.altLoc && a1.altLoc != "" && a2.altLoc != "") {
                              bo = 0;
                            }
                            if (bo > 0) {
                              a1.bonds.push(a2.index);
                              a2.bonds.push(a1.index);
                              a1.bondOrder.push(bo);
                              a2.bondOrder.push(bo);
                            }
                          }
                        }
                      }
                    }
                  }
                  for (let conn of SC.C) {
                    let a1 = conn[0];
                    let a2 = conn[1];
                    let bo = conn[2];
                    let atom1 = this.geta(a1);
                    let atom2 = this.geta(a2);
                    if (atom1 != void 0 && atom2 != void 0) {
                      atom1.bonds.push(atom2.index);
                      atom2.bonds.push(atom1.index);
                      atom1.bondOrder.push(bo);
                      atom2.bondOrder.push(bo);
                    }
                  }
                }
              }
              function BCIF(bindata, options) {
                var noH = !options.keepH;
                var selAltLoc = options.altLoc ? options.altLoc : "A";
                var computeStruct = !options.noComputeSecondaryStructure;
                const noAssembly = !options.doAssembly;
                const assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                if (typeof bindata == "string") {
                  try {
                    bindata = (0, _utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(bindata);
                  } catch (error) {
                    const encoder = new TextEncoder();
                    bindata = encoder.encode(bindata);
                  }
                } else {
                  bindata = new Uint8Array(bindata);
                }
                var bcifData = MMTF.decodeMsgpack(bindata);
                if (bcifData == 31) {
                  bindata = (0, _utilities__WEBPACK_IMPORTED_MODULE_0__.inflateString)(bindata, false);
                  bcifData = MMTF.decodeMsgpack(bindata);
                }
                var atoms = [];
                var modelData = atoms.modelData = [];
                var numModels = bcifData.dataBlocks.length;
                if (numModels == 0)
                  return atoms;
                if (!options.multimodel)
                  numModels = 1;
                for (let m = 0; m < numModels; m++) {
                  let startm = atoms.length;
                  const serialToIndex = [];
                  modelData.push({ symmetries: [] });
                  atoms.push([]);
                  const block = bcifData.dataBlocks[m];
                  const cats = /* @__PURE__ */ Object.create(null);
                  for (const cat of block.categories) {
                    cats[cat.name.substr(1)] = (0, _cifutils_category__WEBPACK_IMPORTED_MODULE_3__.Category)(cat);
                  }
                  let sslookup = {};
                  let sshelix = cats.struct_conf;
                  if (sshelix) {
                    let htypes = sshelix.getField("conf_type_id");
                    let hchain = sshelix.getField("beg_label_asym_id");
                    let hstart = sshelix.getField("beg_label_seq_id");
                    let hend = sshelix.getField("end_label_seq_id");
                    for (let i = 0; i < htypes.length; i++) {
                      if (htypes[i].startsWith("H")) {
                        let ch = hchain[i];
                        let startResi = hstart[i];
                        let endResi = hend[i];
                        if (!(ch in sslookup)) {
                          sslookup[ch] = {};
                        }
                        sslookup[ch][startResi] = "h1";
                        for (let res = startResi + 1; res < endResi; res++) {
                          sslookup[ch][res] = "h";
                        }
                        sslookup[ch][endResi] = "h2";
                      }
                    }
                  }
                  let sssheet = cats.struct_sheet_range;
                  if (sssheet) {
                    let sids = sssheet.getField("id");
                    let schain = sssheet.getField("beg_label_asym_id");
                    let sstart = sssheet.getField("beg_label_seq_id");
                    let send = sssheet.getField("end_label_seq_id");
                    for (let i = 0; i < sids.length; i++) {
                      let ch = schain[i];
                      let startResi = sstart[i];
                      let endResi = send[i];
                      if (!(ch in sslookup)) {
                        sslookup[ch] = {};
                      }
                      sslookup[ch][startResi] = "s1";
                      for (let res = startResi + 1; res < endResi; res++) {
                        sslookup[ch][res] = "s";
                      }
                      sslookup[ch][endResi] = "s2";
                    }
                  }
                  let structops = cats.pdbx_struct_oper_list;
                  let opids = structops.getField("id");
                  if (opids && !noAssembly) {
                    let matrix11 = structops.getField("matrix[1][1]");
                    let matrix12 = structops.getField("matrix[1][2]");
                    let matrix13 = structops.getField("matrix[1][3]");
                    let matrix21 = structops.getField("matrix[2][1]");
                    let matrix22 = structops.getField("matrix[2][2]");
                    let matrix23 = structops.getField("matrix[2][3]");
                    let matrix31 = structops.getField("matrix[3][1]");
                    let matrix32 = structops.getField("matrix[3][2]");
                    let matrix33 = structops.getField("matrix[3][3]");
                    let vector1 = structops.getField("vector[1]");
                    let vector2 = structops.getField("vector[2]");
                    let vector3 = structops.getField("vector[3]");
                    for (let i = 0; i < opids.length; i++) {
                      const matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_5__.Matrix4(matrix11[i], matrix12[i], matrix13[i], vector1[i], matrix21[i], matrix22[i], matrix23[i], vector2[i], matrix31[i], matrix32[i], matrix33[i], vector3[i]);
                      modelData[modelData.length - 1].symmetries.push(matrix);
                    }
                  }
                  let connect = new Connectivity(cats.chem_comp_bond);
                  let residues = new Residues();
                  let sconnect = new StructConn(cats.struct_conn);
                  let asites = cats.atom_site;
                  let atomCount = asites.rowCount;
                  let group_pdb = asites.getField("group_PDB");
                  let cartn_x = asites.getField("Cartn_x");
                  let cartn_y = asites.getField("Cartn_y");
                  let cartn_z = asites.getField("Cartn_z");
                  let auth_asym_id = asites.getField("auth_asym_id");
                  let label_asym_id = asites.getField("label_asym_id");
                  let auth_seq_id = asites.getField("auth_seq_id");
                  let label_seq_id = asites.getField("label_seq_id");
                  let auth_comp_id = asites.getField("auth_comp_id");
                  let label_comp_id = asites.getField("label_comp_id");
                  let auth_atom_id = asites.getField("auth_atom_id");
                  let label_atom_id = asites.getField("label_atom_id");
                  let type_symbol = asites.getField("type_symbol");
                  let bfactors = asites.getField("B_iso_or_equiv");
                  let serials = asites.getField("id");
                  let icodes = asites.getField("label_alt_id");
                  let modelnums = asites.getField("pdbx_PDB_model_num");
                  let curmodel = modelnums ? modelnums[0] : 0;
                  for (let i = 0; i < atomCount; i++) {
                    if (group_pdb !== void 0 && group_pdb[i] === "TER")
                      continue;
                    if (modelnums && modelnums[i] != curmodel) {
                      curmodel = modelnums[i];
                      if (options.multimodel) {
                        if (!options.onemol) {
                          atoms.push([]);
                          modelData.push(modelData[modelData.length - 1]);
                          curmodel = modelnums[i];
                          residues.setBonds(connect, sconnect);
                          residues = new Residues();
                        }
                      } else {
                        break;
                      }
                    }
                    const atom = {};
                    atom.x = cartn_x[i];
                    atom.y = cartn_y[i];
                    atom.z = cartn_z[i];
                    atom.chain = auth_asym_id ? auth_asym_id[i] : label_asym_id ? label_asym_id[i] : void 0;
                    atom.lchain = label_asym_id ? label_asym_id[i] : void 0;
                    atom.resi = auth_seq_id ? auth_seq_id[i] : label_seq_id ? label_seq_id[i] : void 0;
                    atom.lresi = label_seq_id ? label_seq_id[i] : void 0;
                    atom.resn = auth_comp_id ? auth_comp_id[i].trim() : label_comp_id ? label_comp_id[i].trim() : void 0;
                    atom.lresn = label_comp_id ? label_comp_id[i].trim() : void 0;
                    atom.atom = auth_atom_id ? auth_atom_id[i].replace(/"/gm, "") : label_atom_id ? label_atom_id[i].replace(/"/gm, "") : void 0;
                    atom.icode = icodes ? icodes[i] : void 0;
                    atom.altLoc = atom.icode;
                    atom.hetflag = !group_pdb || group_pdb[i] === "HETA" || group_pdb[i] === "HETATM";
                    let elem = "X";
                    if (type_symbol) {
                      elem = type_symbol[i].replace(/\(?\+?\d+.*/, "");
                    }
                    atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();
                    if (bfactors)
                      atom.b = bfactors[i];
                    if (noH && atom.elem == "H") {
                      continue;
                    }
                    if (atom.altLoc != "" && atom.altLoc != selAltLoc && selAltLoc != "*") {
                      continue;
                    }
                    atom.bonds = [];
                    atom.ss = "c";
                    atom.serial = serials[i];
                    atom.model = curmodel;
                    atom.bondOrder = [];
                    atom.properties = {};
                    atom.index = atoms[atoms.length - 1].length;
                    serialToIndex[atom.serial] = [atoms.length, atom.index];
                    atoms[atoms.length - 1].push(atom);
                    residues.add(atom);
                  }
                  residues.setBonds(connect, sconnect);
                  if (!(0, _utils_isEmpty__WEBPACK_IMPORTED_MODULE_6__.isEmpty)(sslookup)) {
                    for (let mi = startm; mi < atoms.length; mi++) {
                      let matoms = atoms[mi];
                      for (let i = 0; i < matoms.length; i++) {
                        const atom = matoms[i];
                        if (atom === void 0)
                          continue;
                        if (atom.lchain in sslookup && atom.lresi in sslookup[atom.lchain]) {
                          const code = sslookup[atom.lchain][atom.lresi];
                          atom.ss = code[0];
                          if (code.length > 1) {
                            if (code[1] == "1")
                              atom.ssbegin = true;
                            else if (code[1] == "2")
                              atom.ssend = true;
                          }
                        }
                      }
                    }
                  }
                  if (options.multimodel && m < numModels - 1) {
                    if (!options.onemol) {
                      atoms.push([]);
                      modelData.push({ symmetries: [] });
                    }
                  }
                }
                for (let i = 0; i < atoms.length; i++) {
                  if (assignbonds && !(options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms)) {
                    (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_4__.assignPDBBonds)(atoms[i], options);
                  }
                  if (computeStruct) {
                    (0, _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__.computeSecondaryStructure)(atoms[i], options.hbondCutoff);
                  }
                  (0, _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_2__.processSymmetries)(modelData[i].symmetries, atoms[i], options, modelData[i].cryst);
                  if (options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms && assignbonds)
                    (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_4__.assignPDBBonds)(atoms[i], options);
                }
                return atoms;
              }
              ;
            },
            /***/
            "./src/parsers/CDJSON.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CDJSON: () => (
                  /* binding */
                  CDJSON
                )
                /* harmony export */
              });
              function CDJSON(str, options) {
                var atoms = [[]];
                if (typeof str === "string") {
                  str = JSON.parse(str);
                }
                var molecules = str.m;
                var atomsInFile = molecules[0].a;
                var bondsInFile = molecules[0].b;
                var styles = molecules[0].s;
                var parseStyle = options !== void 0 && options.parseStyle !== void 0 ? options.parseStyle : styles !== void 0;
                var offset = atoms[atoms.length - 1].length;
                for (var i = 0; i < atomsInFile.length; i++) {
                  var currentAtom = atomsInFile[i];
                  var atom = {};
                  atom.id = currentAtom.i;
                  atom.x = currentAtom.x;
                  atom.y = currentAtom.y;
                  atom.z = currentAtom.z || 0;
                  atom.bonds = [];
                  atom.bondOrder = [];
                  var elem = currentAtom.l || "C";
                  atom.elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                  atom.serial = atoms[atoms.length - 1].length;
                  if (parseStyle) {
                    atom.style = styles[currentAtom.s || 0];
                  }
                  atoms[atoms.length - 1].push(atom);
                }
                for (let i2 = 0; i2 < bondsInFile.length; i2++) {
                  let currentBond = bondsInFile[i2];
                  let beginIndex = currentBond.b + offset;
                  let endIndex = currentBond.e + offset;
                  let bondOrder = currentBond.o || 1;
                  let firstAtom = atoms[atoms.length - 1][beginIndex];
                  let secondAtom = atoms[atoms.length - 1][endIndex];
                  firstAtom.bonds.push(endIndex);
                  firstAtom.bondOrder.push(bondOrder);
                  secondAtom.bonds.push(beginIndex);
                  secondAtom.bondOrder.push(bondOrder);
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/CIF.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CIF: () => (
                  /* binding */
                  CIF
                )
                /* harmony export */
              });
              var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/computeSecondaryStructure */
                "./src/parsers/utils/computeSecondaryStructure.ts"
              );
              var _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/processSymmetries */
                "./src/parsers/utils/processSymmetries.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./utils/assignPDBBonds */
                "./src/parsers/utils/assignPDBBonds.ts"
              );
              const fractionalToCartesian = function(cmat, x, y, z) {
                return new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z).applyMatrix3(cmat);
              };
              function CIF(str, options = {}) {
                const atoms = [];
                const noAssembly = !options.doAssembly;
                const modelData = atoms.modelData = [];
                const assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                function splitRespectingQuotes(string, separator) {
                  const sections = [];
                  let sectionStart = 0;
                  let sectionEnd = 0;
                  while (sectionEnd < string.length) {
                    while (string.substring(sectionEnd, sectionEnd + separator.length) !== separator && sectionEnd < string.length) {
                      if (string[sectionEnd] === "'") {
                        sectionEnd++;
                        while (sectionEnd < string.length && string[sectionEnd] !== "'") {
                          sectionEnd++;
                        }
                        while (string.substring(sectionEnd, sectionEnd + separator.length) !== separator && sectionEnd < string.length) {
                          sectionEnd++;
                        }
                      } else if (string[sectionEnd] === '"') {
                        sectionEnd++;
                        while (sectionEnd < string.length && string[sectionEnd] !== '"') {
                          sectionEnd++;
                        }
                        sectionEnd++;
                      } else {
                        sectionEnd++;
                      }
                    }
                    sections.push(string.substring(sectionStart, sectionEnd));
                    sectionStart = sectionEnd = sectionEnd + separator.length;
                  }
                  return sections;
                }
                const lines = str.split(/\r?\n|\r/);
                const linesFiltered = [];
                let trimDisabled = false;
                for (let lineNum2 = 0; lineNum2 < lines.length; lineNum2++) {
                  var line = lines[lineNum2].split("#")[0];
                  if (trimDisabled) {
                    if (line[0] === ";") {
                      trimDisabled = false;
                    }
                  } else {
                    if (line[0] === ";") {
                      trimDisabled = true;
                    }
                  }
                  if (trimDisabled || line !== "") {
                    if (!trimDisabled) {
                      line = line.trim();
                      if (line[0] === "_") {
                        const dot = line.split(/\s/)[0].indexOf(".");
                        if (dot > -1) {
                          let lineArr = line.split("");
                          lineArr[dot] = "_";
                          line = lineArr.join("");
                          line = line.substring(0, dot) + "_" + line.substring(dot + 1);
                        }
                      }
                    }
                    linesFiltered.push(line);
                  }
                }
                let lineNum = 0;
                while (lineNum < linesFiltered.length) {
                  while (!linesFiltered[lineNum].startsWith("data_") || linesFiltered[lineNum] === "data_global") {
                    lineNum++;
                  }
                  lineNum++;
                  const mmCIF = {};
                  while (lineNum < linesFiltered.length && !linesFiltered[lineNum].startsWith("data_")) {
                    if (linesFiltered[lineNum][0] === void 0) {
                      lineNum++;
                    } else if (linesFiltered[lineNum][0] === "_") {
                      const dataItemName = linesFiltered[lineNum].split(/\s/)[0].toLowerCase();
                      const dataItem = mmCIF[dataItemName] = mmCIF[dataItemName] || [];
                      const restOfLine = linesFiltered[lineNum].substring(linesFiltered[lineNum].indexOf(dataItemName) + dataItemName.length);
                      if (restOfLine === "") {
                        lineNum++;
                        if (linesFiltered[lineNum][0] === ";") {
                          let dataBlock = linesFiltered[lineNum].substring(1);
                          lineNum++;
                          while (linesFiltered[lineNum] !== ";") {
                            dataBlock = dataBlock + "\n" + linesFiltered[lineNum];
                            lineNum++;
                          }
                          dataItem.push(dataBlock);
                        } else {
                          dataItem.push(linesFiltered[lineNum]);
                        }
                      } else {
                        dataItem.push(restOfLine.trim());
                      }
                      lineNum++;
                    } else if (linesFiltered[lineNum].substring(0, 5) === "loop_") {
                      lineNum++;
                      const dataItems = [];
                      while (linesFiltered[lineNum] === "" || linesFiltered[lineNum][0] === "_") {
                        if (linesFiltered[lineNum] !== "") {
                          let dataItemName = linesFiltered[lineNum].split(/\s/)[0].toLowerCase();
                          let dataItem = mmCIF[dataItemName] = mmCIF[dataItemName] || [];
                          dataItems.push(dataItem);
                        }
                        lineNum++;
                      }
                      let currentDataItem = 0;
                      while (lineNum < linesFiltered.length && linesFiltered[lineNum][0] !== "_" && !linesFiltered[lineNum].startsWith("loop_") && !linesFiltered[lineNum].startsWith("data_")) {
                        let line2 = splitRespectingQuotes(linesFiltered[lineNum], " ");
                        for (let field = 0; field < line2.length; field++) {
                          if (line2[field] !== "") {
                            dataItems[currentDataItem].push(line2[field]);
                            currentDataItem = (currentDataItem + 1) % dataItems.length;
                          }
                        }
                        lineNum++;
                      }
                    } else {
                      lineNum++;
                    }
                  }
                  modelData.push({ symmetries: [] });
                  atoms.push([]);
                  const atomCount = mmCIF._atom_site_id !== void 0 ? mmCIF._atom_site_id.length : mmCIF._atom_site_label.length;
                  let conversionMatrix;
                  if (mmCIF._cell_length_a !== void 0) {
                    const a = parseFloat(mmCIF._cell_length_a);
                    const b = parseFloat(mmCIF._cell_length_b);
                    const c = parseFloat(mmCIF._cell_length_c);
                    const alpha_deg = parseFloat(mmCIF._cell_angle_alpha) || 90;
                    const beta_deg = parseFloat(mmCIF._cell_angle_beta) || 90;
                    const gamma_deg = parseFloat(mmCIF._cell_angle_gamma) || 90;
                    conversionMatrix = (0, _WebGL__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(a, b, c, alpha_deg, beta_deg, gamma_deg);
                    modelData[modelData.length - 1].cryst = {
                      a,
                      b,
                      c,
                      alpha: alpha_deg,
                      beta: beta_deg,
                      gamma: gamma_deg
                    };
                  }
                  for (let i = 0; i < atomCount; i++) {
                    if (mmCIF._atom_site_group_pdb !== void 0 && mmCIF._atom_site_group_pdb[i] === "TER")
                      continue;
                    const atom = {};
                    if (mmCIF._atom_site_cartn_x !== void 0) {
                      atom.x = parseFloat(mmCIF._atom_site_cartn_x[i]);
                      atom.y = parseFloat(mmCIF._atom_site_cartn_y[i]);
                      atom.z = parseFloat(mmCIF._atom_site_cartn_z[i]);
                    } else {
                      const coords = fractionalToCartesian(conversionMatrix, parseFloat(mmCIF._atom_site_fract_x[i]), parseFloat(mmCIF._atom_site_fract_y[i]), parseFloat(mmCIF._atom_site_fract_z[i]));
                      atom.x = coords.x;
                      atom.y = coords.y;
                      atom.z = coords.z;
                    }
                    atom.chain = mmCIF._atom_site_auth_asym_id ? mmCIF._atom_site_auth_asym_id[i] : mmCIF._atom_site_label_asym_id ? mmCIF._atom_site_label_asym_id[i] : void 0;
                    atom.lchain = mmCIF._atom_site_label_asym_id ? mmCIF._atom_site_label_asym_id[i] : void 0;
                    atom.resi = mmCIF._atom_site_auth_seq_id ? parseInt(mmCIF._atom_site_auth_seq_id[i]) : mmCIF._atom_site_label_seq_id ? mmCIF._atom_site_label_seq_id[i] : void 0;
                    atom.resn = mmCIF._atom_site_auth_comp_id ? mmCIF._atom_site_auth_comp_id[i].trim() : mmCIF._atom_site_label_comp_id ? mmCIF._atom_site_label_comp_id[i].trim() : void 0;
                    atom.atom = mmCIF._atom_site_auth_atom_id ? mmCIF._atom_site_auth_atom_id[i].replace(/"/gm, "") : mmCIF._atom_site_label_atom_id ? mmCIF._atom_site_label_atom_id[i].replace(/"/gm, "") : void 0;
                    atom.hetflag = !mmCIF._atom_site_group_pdb || mmCIF._atom_site_group_pdb[i] === "HETA" || mmCIF._atom_site_group_pdb[i] === "HETATM";
                    if (mmCIF._atom_site_b_iso_or_equiv) {
                      atom.b = parseFloat(mmCIF._atom_site_b_iso_or_equiv[i]);
                    }
                    let elem = "X";
                    if (mmCIF._atom_site_type_symbol) {
                      elem = mmCIF._atom_site_type_symbol[i].replace(/\(?\+?\d+.*/, "");
                    } else if (mmCIF._atom_site_label) {
                      elem = mmCIF._atom_site_label[i].split("_")[0].replace(/\(?\d+.*/, "");
                    }
                    atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();
                    atom.bonds = [];
                    atom.ss = "c";
                    atom.serial = i;
                    atom.bondOrder = [];
                    atom.properties = {};
                    atoms[atoms.length - 1].push(atom);
                  }
                  if (mmCIF._pdbx_struct_oper_list_id !== void 0 && !noAssembly) {
                    for (let i = 0; i < mmCIF._pdbx_struct_oper_list_id.length; i++) {
                      const matrix11 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[1][1]"][i]);
                      const matrix12 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[1][2]"][i]);
                      const matrix13 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[1][3]"][i]);
                      const vector1 = parseFloat(mmCIF["_pdbx_struct_oper_list_vector[1]"][i]);
                      const matrix21 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[2][1]"][i]);
                      const matrix22 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[2][2]"][i]);
                      const matrix23 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[2][3]"][i]);
                      const vector2 = parseFloat(mmCIF["_pdbx_struct_oper_list_vector[2]"][i]);
                      const matrix31 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[3][1]"][i]);
                      const matrix32 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[3][2]"][i]);
                      const matrix33 = parseFloat(mmCIF["_pdbx_struct_oper_list_matrix[3][3]"][i]);
                      const vector3 = parseFloat(mmCIF["_pdbx_struct_oper_list_vector[3]"][i]);
                      const matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4(matrix11, matrix12, matrix13, vector1, matrix21, matrix22, matrix23, vector2, matrix31, matrix32, matrix33, vector3);
                      modelData[modelData.length - 1].symmetries.push(matrix);
                    }
                  }
                  const parseTerm = function(term) {
                    const negative = term.match("-");
                    term = term.replace(/[-xyz]/g, "");
                    const fractionParts = term.split("/");
                    let numerator, denominator;
                    if (fractionParts[1] === void 0) {
                      denominator = 1;
                    } else {
                      denominator = parseInt(fractionParts[1]);
                    }
                    if (fractionParts[0] === "") {
                      numerator = 1;
                    } else {
                      numerator = parseInt(fractionParts[0]);
                    }
                    return numerator / denominator * (negative ? -1 : 1);
                  };
                  if (mmCIF._symmetry_equiv_pos_as_xyz !== void 0 && !noAssembly) {
                    for (let sym = 0; sym < mmCIF._symmetry_equiv_pos_as_xyz.length; sym++) {
                      const transform = mmCIF._symmetry_equiv_pos_as_xyz[sym].replace(/["' ]/g, "");
                      const componentStrings = transform.split(",").map(function(val) {
                        return val.replace(/-/g, "+-");
                      });
                      let matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
                      for (let coord = 0; coord < 3; coord++) {
                        const terms = componentStrings[coord].split("+");
                        for (let t = 0; t < terms.length; t++) {
                          const term = terms[t];
                          if (term === "")
                            continue;
                          const coefficient = parseTerm(term);
                          if (term.match("x")) {
                            matrix.elements[coord + 0] = coefficient;
                          } else if (term.match("y")) {
                            matrix.elements[coord + 4] = coefficient;
                          } else if (term.match("z")) {
                            matrix.elements[coord + 8] = coefficient;
                          } else {
                            matrix.elements[coord + 12] = coefficient;
                          }
                        }
                      }
                      const conversionMatrix4 = conversionMatrix.getMatrix4();
                      const conversionInverse = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().getInverse(conversionMatrix4, true);
                      matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(matrix, conversionInverse);
                      matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(conversionMatrix4, matrix);
                      modelData[modelData.length - 1].symmetries.push(matrix);
                    }
                  }
                }
                for (let i = 0; i < atoms.length; i++) {
                  if (assignbonds && !(options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms)) {
                    (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__.assignPDBBonds)(atoms[i], options);
                  }
                  (0, _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_0__.computeSecondaryStructure)(atoms[i], options.hbondCutoff);
                  (0, _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_1__.processSymmetries)(modelData[i].symmetries, atoms[i], options, modelData[i].cryst);
                  if (options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms && assignbonds)
                    (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__.assignPDBBonds)(atoms[i], options);
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/CUBE.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                CUBE: () => (
                  /* binding */
                  CUBE
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              var _utils_anumToSymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./utils/anumToSymbol */
                "./src/parsers/utils/anumToSymbol.ts"
              );
              function CUBE(str, options) {
                options = options || {};
                const atoms = [[]];
                let lines = str.split(/\r?\n/);
                const assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                if (lines.length < 6)
                  return atoms;
                let lineArr = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                const natoms = Math.abs(parseFloat(lineArr[0]));
                let cryst = {
                  origin: void 0,
                  size: void 0,
                  unit: void 0,
                  matrix4: void 0,
                  matrix: void 0
                };
                const origin = cryst.origin = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3]));
                lineArr = lines[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                lineArr = lines[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                const convFactor = lineArr[0] > 0 ? 0.529177 : 1;
                origin.multiplyScalar(convFactor);
                const nX = Math.abs(lineArr[0]);
                const xVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);
                lineArr = lines[4].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                const nY = Math.abs(lineArr[0]);
                const yVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);
                lineArr = lines[5].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                const nZ = Math.abs(lineArr[0]);
                const zVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);
                cryst.size = { x: nX, y: nY, z: nZ };
                cryst.unit = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(xVec.x, yVec.y, zVec.z);
                if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0 || zVec.y != 0) {
                  cryst.matrix4 = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0, 0, 0, 1);
                  let t = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(origin.x, origin.y, origin.z);
                  cryst.matrix4 = cryst.matrix4.multiplyMatrices(t, cryst.matrix4);
                  cryst.matrix = cryst.matrix4.matrix3FromTopLeft();
                  cryst.origin = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
                  cryst.unit = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);
                }
                atoms.modelData = [{ cryst }];
                lines = lines.splice(6, natoms);
                var start = atoms[atoms.length - 1].length;
                var end = start + lines.length;
                for (var i = start; i < end; ++i) {
                  var atom = {};
                  atom.serial = i;
                  var line = lines[i - start];
                  var tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  atom.elem = _utils_anumToSymbol__WEBPACK_IMPORTED_MODULE_2__.anumToSymbol[tokens[0]];
                  atom.x = parseFloat(tokens[2]) * convFactor;
                  atom.y = parseFloat(tokens[3]) * convFactor;
                  atom.z = parseFloat(tokens[4]) * convFactor;
                  atom.hetflag = true;
                  atom.bonds = [];
                  atom.bondOrder = [];
                  atom.properties = {};
                  atoms[atoms.length - 1].push(atom);
                }
                if (assignbonds) {
                  for (let i2 = 0; i2 < atoms.length; i2++)
                    (0, _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(atoms[i2], options);
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/GRO.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                GRO: () => (
                  /* binding */
                  GRO
                )
                /* harmony export */
              });
              var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/assignPDBBonds */
                "./src/parsers/utils/assignPDBBonds.ts"
              );
              var _utils_atomNameToElem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/atomNameToElem */
                "./src/parsers/utils/atomNameToElem.ts"
              );
              function GRO(str, options) {
                const allatoms = [];
                const lines = str.split(/\r?\n|\r/);
                while (lines.length > 0) {
                  const atomCount = parseInt(lines[1]);
                  const breakCondition = lines.length < 3 || isNaN(atomCount) || atomCount <= 0 || lines.length < atomCount + 3;
                  if (breakCondition)
                    break;
                  const atoms = [];
                  allatoms.push(atoms);
                  let offset = 2;
                  const start = atoms.length;
                  const end = start + atomCount;
                  for (let i = start; i < end; i++) {
                    const line = lines[offset++];
                    const atom = {};
                    atom.serial = i;
                    atom.atom = line.slice(10, 15).trim();
                    atom.elem = (0, _utils_atomNameToElem__WEBPACK_IMPORTED_MODULE_1__.atomNameToElem)(atom.atom, true);
                    atom.x = 10 * parseFloat(line.slice(20, 28));
                    atom.y = 10 * parseFloat(line.slice(28, 36));
                    atom.z = 10 * parseFloat(line.slice(36, 44));
                    atom.resi = parseInt(line.slice(0, 5));
                    atom.resn = line.slice(5, 10).trim();
                    atom.bonds = [];
                    atom.bondOrder = [];
                    atom.properties = {};
                    if (line.length > 44) {
                      atom.dx = 10 * parseFloat(line.slice(44, 52));
                      atom.dy = 10 * parseFloat(line.slice(52, 60));
                      atom.dz = 10 * parseFloat(line.slice(60, 68));
                    }
                    atoms[i] = atom;
                  }
                  if (lines.length <= offset + 3) {
                    const last = lines[offset++];
                    const box = last.trim().split(/\s+/);
                    if (box.length === 3) {
                      for (let b = 0; b < 3; b++) {
                        box[b] = (parseFloat(box[b]) * 10).toString();
                      }
                      allatoms.box = box;
                    }
                  }
                  lines.splice(0, ++offset);
                }
                for (let i = 0; i < allatoms.length; i++) {
                  (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__.assignPDBBonds)(allatoms[i], options);
                }
                return allatoms;
              }
            },
            /***/
            "./src/parsers/LAMMPSTRJ.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                LAMMPSTRJ: () => (
                  /* binding */
                  LAMMPSTRJ
                )
                /* harmony export */
              });
              var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              const dic = {
                id: "serial",
                type: "atom",
                element: "elem",
                q: "charge",
                radius: "radius",
                x: "x",
                xu: "x",
                xs: "x",
                xsu: "x",
                y: "y",
                yu: "y",
                ys: "y",
                ysu: "y",
                z: "z",
                zu: "z",
                zs: "z",
                zsu: "z"
              };
              function LAMMPSTRJ(str, options) {
                const atoms = [];
                const lines = str.split(/\r?\n|\r/);
                let offset = 0;
                let atomCount = 0;
                let start = 0;
                while (start < lines.length - 9) {
                  for (var j = start; j < lines.length; j++) {
                    if (lines[j].match(/ITEM: NUMBER OF ATOMS/))
                      atomCount = parseInt(lines[j + 1]);
                    if (lines[j].match(/ITEM: ATOMS/)) {
                      offset = j + 1;
                      break;
                    }
                  }
                  const types = lines[offset - 1].replace("ITEM: ATOMS ", "").split(" ");
                  atoms.push([]);
                  for (let j2 = offset; j2 < offset + atomCount; j2++) {
                    const atom = {};
                    const properties = {};
                    const tokens = lines[j2].split(" ");
                    for (let k = 0; k < tokens.length; k++) {
                      const prop = dic[types[k]];
                      if (prop !== void 0) {
                        if (prop === "serial")
                          atom[prop] = parseInt(tokens[k]);
                        else if (prop === "x" || prop === "y" || prop === "z")
                          atom[prop] = parseFloat(tokens[k]);
                        else if (prop === "charge" || prop === "radius")
                          properties[prop] = parseFloat(tokens[k]);
                        else
                          atom[prop] = tokens[k];
                      }
                      atom.properties = properties;
                      atom.bonds = [];
                      atom.bondOrder = [];
                    }
                    atoms[atoms.length - 1][j2 - offset] = atom;
                  }
                  start = offset + atomCount - 1;
                }
                if (options.assignBonds) {
                  for (let i = 0; i < atoms.length; i++)
                    (0, _utils_assignBonds__WEBPACK_IMPORTED_MODULE_0__.assignBonds)(atoms[i], options);
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/MMTF.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MMTFparser: () => (
                  /* binding */
                  MMTFparser
                )
                /* harmony export */
              });
              var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utilities */
                "./src/utilities.ts"
              );
              var _WebGL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./utils/computeSecondaryStructure */
                "./src/parsers/utils/computeSecondaryStructure.ts"
              );
              var _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./utils/processSymmetries */
                "./src/parsers/utils/processSymmetries.ts"
              );
              var MMTF = __webpack_require__2(
                /*! ./src/vendor/mmtf.js */
                "./src/vendor/mmtf.js"
              );
              var fromCharCode = function(charCodeArray) {
                return String.fromCharCode.apply(null, charCodeArray).replace(/\0/g, "");
              };
              var convertSS = function(val) {
                if (val == 0 || val == 2 || val == 4)
                  return "h";
                if (val == 3)
                  return "s";
                return "c";
              };
              let mmtfHETATMtypes = /* @__PURE__ */ new Set([
                "D-SACCHARIDE",
                "D-SACCHARIDE 1,4 AND 1,4 LINKING",
                "D-SACCHARIDE 1,4 AND 1,6 LINKING",
                "L-SACCHARIDE",
                "L-SACCHARIDE 1,4 AND 1,4 LINKING",
                "L-SACCHARIDE 1,4 AND 1,6 LINKING",
                "NON-POLYMER",
                "OTHER",
                "PEPTIDE-LIKE",
                "SACCHARIDE"
              ]);
              function MMTFparser(bindata, options) {
                var noH = !options.keepH;
                var selAltLoc = options.altLoc ? options.altLoc : "A";
                var ignoreStruct = !!options.noSecondaryStructure;
                var computeStruct = !options.noComputeSecondaryStructure;
                var noAssembly = !options.doAssembly;
                var assemblyIndex = options.assemblyIndex ? options.assemblyIndex : 0;
                if (typeof bindata == "string") {
                  bindata = (0, _utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(bindata);
                } else {
                  bindata = new Uint8Array(bindata);
                }
                var mmtfData = MMTF.decode(bindata);
                var atoms = [[]];
                var modelData = atoms.modelData = [];
                var chainIndex = 0;
                var groupIndex = 0;
                var atomIndex = 0;
                var secStructList = mmtfData.secStructList;
                var bFactorList = mmtfData.bFactorList;
                var altLocList = mmtfData.altLocList;
                var occupancyList = mmtfData.occupancyList;
                var bondAtomList = mmtfData.bondAtomList;
                var bondOrderList = mmtfData.bondOrderList;
                var numModels = mmtfData.numModels;
                if (numModels == 0)
                  return atoms;
                if (!options.multimodel)
                  numModels = 1;
                var i, j, k, kl, m, n;
                var symmetries = [];
                if (!noAssembly && mmtfData.bioAssemblyList && mmtfData.bioAssemblyList.length > 0) {
                  var transforms = mmtfData.bioAssemblyList[assemblyIndex].transformList;
                  for (i = 0, n = transforms.length; i < n; i++) {
                    var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_1__.Matrix4(transforms[i].matrix);
                    matrix.transpose();
                    symmetries.push(matrix);
                  }
                }
                var unitCell = null;
                if (mmtfData.unitCell) {
                  var u = mmtfData.unitCell;
                  unitCell = { "a": u[0], "b": u[1], "c": u[2], "alpha": u[3], "beta": u[4], "gamma": u[5] };
                }
                let chainIsPolymer = [];
                mmtfData.entityList.forEach((entity) => {
                  entity.chainIndexList.forEach((ch) => {
                    chainIsPolymer[ch] = entity.type == "polymer";
                  });
                });
                var bondAtomListStart = 0;
                for (m = 0; m < numModels; m++) {
                  var modelChainCount = mmtfData.chainsPerModel[m];
                  var matoms = atoms[atoms.length - 1];
                  var serialToIndex = [];
                  modelData.push({ symmetries, cryst: unitCell });
                  for (i = 0; i < modelChainCount; ++i) {
                    var chainGroupCount = mmtfData.groupsPerChain[chainIndex];
                    var chainId = fromCharCode(mmtfData.chainIdList.subarray(chainIndex * 4, chainIndex * 4 + 4));
                    if (mmtfData.chainNameList) {
                      chainId = fromCharCode(mmtfData.chainNameList.subarray(chainIndex * 4, chainIndex * 4 + 4));
                    }
                    var startGroup = groupIndex;
                    var prevSS = "";
                    for (j = 0; j < chainGroupCount; ++j) {
                      var groupData = mmtfData.groupList[mmtfData.groupTypeList[groupIndex]];
                      var groupAtomCount = groupData.atomNameList.length;
                      var secStruct = 0;
                      var secStructBegin = false;
                      var secStructEnd = false;
                      if (secStructList) {
                        secStruct = secStructList[groupIndex];
                        var sscode = convertSS(secStruct);
                        if (groupIndex == 0 || sscode != prevSS) {
                          secStructBegin = true;
                        }
                        prevSS = sscode;
                        var nextgroup = groupIndex + 1;
                        if (nextgroup >= secStructList.length || convertSS(secStructList[nextgroup] != sscode)) {
                          secStructEnd = true;
                        }
                      }
                      var groupId = mmtfData.groupIdList[groupIndex];
                      var groupName = groupData.groupName;
                      let groupType = groupData.chemCompType;
                      var startAtom = atomIndex;
                      let isHETATM = mmtfHETATMtypes.has(groupType) || !chainIsPolymer[chainIndex];
                      for (k = 0; k < groupAtomCount; ++k) {
                        var element = groupData.elementList[k];
                        if (noH && element == "H") {
                          atomIndex += 1;
                          continue;
                        }
                        var bFactor = "";
                        if (bFactorList) {
                          bFactor = bFactorList[atomIndex];
                        }
                        var altLoc = "";
                        if (altLocList && altLocList[atomIndex]) {
                          altLoc = String.fromCharCode(altLocList[atomIndex]);
                        }
                        var occupancy = "";
                        if (occupancyList) {
                          occupancy = occupancyList[atomIndex];
                        }
                        if (altLoc != "" && altLoc != selAltLoc && selAltLoc != "*") {
                          atomIndex += 1;
                          continue;
                        }
                        var atomId = mmtfData.atomIdList[atomIndex];
                        var atomName = groupData.atomNameList[k];
                        var atomCharge = 0;
                        if (groupData.atomChargeList)
                          atomCharge = groupData.atomChargeList[k];
                        var xCoord = mmtfData.xCoordList[atomIndex];
                        var yCoord = mmtfData.yCoordList[atomIndex];
                        var zCoord = mmtfData.zCoordList[atomIndex];
                        serialToIndex[atomIndex] = matoms.length;
                        matoms.push({
                          "resn": groupName,
                          "x": xCoord,
                          "y": yCoord,
                          "z": zCoord,
                          "elem": element,
                          "hetflag": isHETATM,
                          "chain": chainId,
                          "resi": groupId,
                          "icode": altLoc,
                          "rescode": groupId + (altLoc != " " ? "^" + altLoc : ""),
                          // combo
                          // resi
                          // and
                          // icode
                          "serial": atomId,
                          "altLoc": altLoc,
                          "index": atomIndex,
                          "atom": atomName,
                          "bonds": [],
                          "ss": convertSS(secStruct),
                          "ssbegin": secStructBegin,
                          "ssend": secStructEnd,
                          "bondOrder": [],
                          "properties": { charge: atomCharge, occupancy },
                          "b": bFactor
                        });
                        atomIndex += 1;
                      }
                      var groupBondAtomList = groupData.bondAtomList;
                      for (k = 0, kl = groupData.bondOrderList.length; k < kl; ++k) {
                        var atomIndex1 = startAtom + groupBondAtomList[k * 2];
                        var atomIndex2 = startAtom + groupBondAtomList[k * 2 + 1];
                        var bondOrder = groupData.bondOrderList[k];
                        var i1 = serialToIndex[atomIndex1];
                        var i2 = serialToIndex[atomIndex2];
                        var a1 = matoms[i1];
                        var a2 = matoms[i2];
                        if (a1 && a2) {
                          a1.bonds.push(i2);
                          a1.bondOrder.push(bondOrder);
                          a2.bonds.push(i1);
                          a2.bondOrder.push(bondOrder);
                        }
                      }
                      groupIndex += 1;
                    }
                    groupIndex = startGroup;
                    for (j = 0; j < chainGroupCount; ++j) {
                      groupIndex += 1;
                    }
                    chainIndex += 1;
                  }
                  if (bondAtomList) {
                    for (let k2 = bondAtomListStart, kl2 = bondAtomList.length; k2 < kl2; k2 += 2) {
                      let atomIndex12 = bondAtomList[k2];
                      let atomIndex22 = bondAtomList[k2 + 1];
                      let bondOrder2 = bondOrderList ? bondOrderList[k2 / 2] : 1;
                      if (atomIndex12 >= atomIndex) {
                        bondAtomListStart = k2;
                        break;
                      }
                      let i12 = serialToIndex[atomIndex12];
                      let i22 = serialToIndex[atomIndex22];
                      let a12 = matoms[i12];
                      let a22 = matoms[i22];
                      if (a12 && a22) {
                        a12.bonds.push(i22);
                        a12.bondOrder.push(bondOrder2);
                        a22.bonds.push(i12);
                        a22.bondOrder.push(bondOrder2);
                      }
                    }
                  }
                  if (options.multimodel) {
                    if (!options.onemol)
                      atoms.push([]);
                  }
                }
                if (!noAssembly) {
                  for (let n2 = 0; n2 < atoms.length; n2++) {
                    (0, _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_3__.processSymmetries)(modelData[n2].symmetries, atoms[n2], options, modelData[n2].cryst);
                  }
                }
                if (computeStruct && !ignoreStruct) {
                  (0, _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_2__.computeSecondaryStructure)(atoms, options.hbondCutoff);
                }
                return atoms;
              }
              ;
            },
            /***/
            "./src/parsers/MOL2.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                MOL2: () => (
                  /* binding */
                  MOL2
                )
                /* harmony export */
              });
              let SYBYLtoElem = {
                "C.1": "C",
                "C1": "C",
                "C.2": "C",
                "C2": "C",
                "C.3": "C",
                "C3": "C",
                "C.ar": "C",
                "Car": "C",
                "C.cat": "C",
                "Ccat": "C",
                "H.spc": "H",
                "Hspc": "H",
                "H.t3p": "H",
                "Ht3p": "H",
                "N.1": "N",
                "N1": "N",
                "N.2": "N",
                "N2": "N",
                "N.3": "N",
                "N3": "N",
                "N.4": "N",
                "N4": "N",
                "N.am": "N",
                "Nam": "N",
                "N.ar": "N",
                "Nar": "N",
                "N.p13": "N",
                "Np13": "N",
                "O.2": "O",
                "O2": "O",
                "O.3": "O",
                "O3": "O",
                "O.co2": "O",
                "Oco2": "O",
                "O.spc": "O",
                "Ospc": "O",
                "O.t3p": "O",
                "Ot3p": "O",
                "P.3": "P",
                "P3": "P",
                "S.2": "S",
                "S2": "S",
                "S.3": "S",
                "S3": "S",
                "S.o": "S",
                "So": "S",
                "S.o2": "S",
                "So2": "S"
              };
              function MOL2(str, options) {
                var atoms = [[]];
                var noH = false;
                if (typeof options.keepH !== "undefined")
                  noH = !options.keepH;
                var mol_pos = str.search(/@<TRIPOS>MOLECULE/);
                var atom_pos = str.search(/@<TRIPOS>ATOM/);
                if (mol_pos == -1 || atom_pos == -1)
                  return atoms;
                var lines = str.substring(mol_pos).split(/\r?\n|\r/);
                while (lines.length > 0) {
                  var serialToIndex = [];
                  var tokens = lines[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  var natoms = parseInt(tokens[0]);
                  var nbonds = 0;
                  if (tokens.length > 1)
                    nbonds = parseInt(tokens[1]);
                  var offset = 4;
                  var i;
                  for (i = 3; i < lines.length; i++) {
                    if (lines[i] == "@<TRIPOS>ATOM") {
                      offset = i + 1;
                      break;
                    }
                  }
                  var start = atoms[atoms.length - 1].length;
                  var end = start + natoms;
                  var line;
                  for (i = start; i < end; i++) {
                    line = lines[offset++];
                    tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                    var atom = {};
                    var elem = tokens[5];
                    if (SYBYLtoElem[elem] !== void 0) {
                      elem = SYBYLtoElem[elem];
                    } else {
                      elem = elem.split(".")[0];
                      elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                    }
                    atom.atom = tokens[1];
                    atom.elem = elem;
                    if (atom.elem == "H" && noH) {
                    } else {
                      var index = atoms[atoms.length - 1].length;
                      var serial = parseInt(tokens[0]);
                      atom.serial = serial;
                      atom.x = parseFloat(tokens[2]);
                      atom.y = parseFloat(tokens[3]);
                      atom.z = parseFloat(tokens[4]);
                      atom.atom = tokens[5];
                      var charge = parseFloat(tokens[8]);
                      atom.index = index;
                      atom.bonds = [];
                      atom.bondOrder = [];
                      atom.properties = {
                        charge,
                        partialCharge: charge
                      };
                      serialToIndex[serial] = index;
                      atoms[atoms.length - 1].push(atom);
                    }
                  }
                  var bonds_found = false;
                  while (offset < lines.length) {
                    if (lines[offset++] == "@<TRIPOS>BOND") {
                      bonds_found = true;
                      break;
                    }
                  }
                  if (bonds_found && nbonds) {
                    for (i = 0; i < nbonds; i++) {
                      line = lines[offset++];
                      tokens = line.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                      var from = parseInt(tokens[1]);
                      var fromAtom = atoms[atoms.length - 1][serialToIndex[from]];
                      var to = parseInt(tokens[2]);
                      var toAtom = atoms[atoms.length - 1][serialToIndex[to]];
                      var order = parseInt(tokens[3]);
                      if (isNaN(order))
                        order = 1;
                      if (fromAtom !== void 0 && toAtom !== void 0) {
                        fromAtom.bonds.push(serialToIndex[to]);
                        fromAtom.bondOrder.push(order);
                        toAtom.bonds.push(serialToIndex[from]);
                        toAtom.bondOrder.push(order);
                      }
                    }
                  }
                  if (options.multimodel) {
                    if (!options.onemol)
                      atoms.push([]);
                    lines.splice(0, offset);
                    str = lines.join("\n");
                    continue;
                  } else {
                    break;
                  }
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/PDB.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                PDB: () => (
                  /* binding */
                  PDB
                )
                /* harmony export */
              });
              var _utils_getSinglePDB__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/getSinglePDB */
                "./src/parsers/utils/getSinglePDB.ts"
              );
              function PDB(str, options) {
                options = options || {};
                var atoms = [];
                var sslookup = {};
                atoms.modelData = [];
                var lines = str.split(/\r?\n|\r/);
                while (lines.length > 0) {
                  var pdbinfo = (0, _utils_getSinglePDB__WEBPACK_IMPORTED_MODULE_0__.getSinglePDB)(lines, options, sslookup);
                  var modelatoms = pdbinfo[0];
                  var modelData = pdbinfo[1];
                  lines = pdbinfo[2];
                  if (modelatoms.length == 0) {
                    continue;
                  }
                  if (options.multimodel && options.onemol && atoms.length > 0) {
                    var inc = atoms[0].length;
                    for (var i = 0; i < modelatoms.length; i++) {
                      var atom = modelatoms[i];
                      atom.index = i;
                      for (var b = 0; b < atom.bonds.length; b++) {
                        atom.bonds[b] += inc;
                      }
                      atoms[0].push(atom);
                    }
                  } else {
                    atoms.modelData.push(modelData);
                    atoms.push(modelatoms);
                  }
                  if (!options.multimodel) {
                    break;
                  }
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/PQR.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                PQR: () => (
                  /* binding */
                  PQR
                )
                /* harmony export */
              });
              var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/assignPDBBonds */
                "./src/parsers/utils/assignPDBBonds.ts"
              );
              var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/computeSecondaryStructure */
                "./src/parsers/utils/computeSecondaryStructure.ts"
              );
              function PQR(str, options) {
                var atoms = [[]];
                var computeStruct = !options.noSecondaryStructure;
                atoms.modelData = [{ symmetries: [] }];
                var serialToIndex = [];
                var lines = str.split(/\r?\n|\r/);
                var line;
                for (let i = 0; i < lines.length; i++) {
                  line = lines[i].replace(/^\s*/, "");
                  var recordName = line.substring(0, 6);
                  if (recordName.indexOf("END") == 0) {
                    if (options.multimodel) {
                      if (!options.onemol)
                        atoms.push([]);
                      continue;
                    } else {
                      break;
                    }
                  } else if (recordName == "ATOM  " || recordName == "HETATM") {
                    var hetflag;
                    let serial = parseInt(line.substring(6, 11));
                    let atom = line.substring(12, 16).replace(/ /g, "");
                    let resn = line.substring(17, 20).trim();
                    let chain = line.substring(21, 22);
                    let resi = parseInt(line.substring(22, 26));
                    var vals = line.substring(30).trim().split(/\s+/);
                    var x = parseFloat(vals[0]);
                    var y = parseFloat(vals[1]);
                    var z = parseFloat(vals[2]);
                    var charge = parseFloat(vals[3]);
                    var radius = parseFloat(vals[4]);
                    var elem = atom[0];
                    if (atom.length > 1 && atom[1].toUpperCase() != atom[1]) {
                      elem = atom.substring(0, 2);
                    }
                    if (line[0] == "H")
                      hetflag = true;
                    else
                      hetflag = false;
                    serialToIndex[serial] = atoms[atoms.length - 1].length;
                    atoms[atoms.length - 1].push({
                      "resn": resn,
                      "x": x,
                      "y": y,
                      "z": z,
                      "elem": elem,
                      "hetflag": hetflag,
                      "chain": chain,
                      "resi": resi,
                      "serial": serial,
                      "atom": atom,
                      "bonds": [],
                      "ss": "c",
                      "bondOrder": [],
                      "properties": {
                        "charge": charge,
                        "partialCharge": charge,
                        "radius": radius
                      },
                      "pdbline": line
                    });
                  } else if (recordName == "CONECT") {
                    var from = parseInt(line.substring(6, 11));
                    var fromAtom = atoms[atoms.length - 1][serialToIndex[from]];
                    for (let j = 0; j < 4; j++) {
                      var to = parseInt(line.substring([11, 16, 21, 26][j], [11, 16, 21, 26][j] + 5));
                      var toAtom = atoms[atoms.length - 1][serialToIndex[to]];
                      if (fromAtom !== void 0 && toAtom !== void 0) {
                        fromAtom.bonds.push(serialToIndex[to]);
                        fromAtom.bondOrder.push(1);
                      }
                    }
                  }
                }
                for (let i = 0; i < atoms.length; i++) {
                  (0, _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__.assignPDBBonds)(atoms[i], options);
                  if (computeStruct)
                    (0, _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__.computeSecondaryStructure)(atoms[i], options.hbondCutoff);
                }
                return atoms;
              }
              ;
            },
            /***/
            "./src/parsers/PRMTOP.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                PRMTOP: () => (
                  /* binding */
                  PRMTOP
                )
                /* harmony export */
              });
              function PRMTOP(str) {
                var atoms = [];
                var atomIndex;
                var count = 0;
                var lines = str.split(/\r?\n|\r/);
                if (lines.length > 0 && lines[0].includes("VERSION")) {
                  var sectionList = lines.filter(function(line) {
                    return line.includes("POINTERS") || line.includes("ATOM_NAME") || line.includes("CHARGE") || line.includes("RADII") || line.includes("BONDS_INC_HYDROGEN") || line.includes("BONDS_WITHOUT_HYDROGEN") || line.includes("RESIDUE_LABEL") || line.includes("RESIDUE_POINTER");
                  });
                  var index = getIndex("POINTERS");
                  if (index == -1)
                    return [];
                  var col = getColEleSize(index);
                  var atomCount = parseInt(lines[index + 1].slice(0, col[1]));
                  let resCount = parseInt(lines[index + 2].slice(col[1], col[0] + col[1]));
                  if (isNaN(atomCount) || atomCount <= 0)
                    return [];
                  index = getIndex("ATOM_NAME");
                  if (index == -1)
                    return [];
                  col = getColEleSize(index);
                  var noOfCol = col[0];
                  for (let i = 0; i < atomCount / col[0]; i++) {
                    if (i == parseInt(atomCount / col[0]))
                      noOfCol = atomCount % col[0];
                    for (let j = 0; j < noOfCol; j++) {
                      let atom = {};
                      let properties = { charge: "", radii: "" };
                      atom.serial = count;
                      atom.x = 0;
                      atom.y = 0;
                      atom.z = 0;
                      atom.atom = lines[index + 1].slice(col[1] * j, col[1] * (j + 1)).trim();
                      atom.elem = lines[index + 1].slice(col[1] * j, col[1] * j + 1).trim();
                      atom.properties = properties;
                      atom.bonds = [];
                      atom.bondOrder = [];
                      atom.index = atoms.length;
                      atoms.push(atom);
                      count++;
                    }
                    index++;
                  }
                  index = getIndex("CHARGE");
                  if (index != -1) {
                    col = getColEleSize(index);
                    count = 0;
                    noOfCol = col[0];
                    for (let i = 0; i < atomCount / col[0]; i++) {
                      if (i == parseInt(atomCount / col[0]))
                        noOfCol = atomCount % col[0];
                      for (let j = 0; j < noOfCol; j++) {
                        atoms[count].properties.charge = parseFloat(lines[index + 1].slice(col[1] * j, col[1] * (j + 1)));
                        count++;
                      }
                      index++;
                    }
                  }
                  index = getIndex("RESIDUE_POINTER");
                  var resstarts = [];
                  if (index != -1) {
                    col = getColEleSize(index);
                    noOfCol = col[0];
                    index += 1;
                    for (let i = 0; i < resCount / col[0]; i++) {
                      if (i == parseInt(resCount / col[0]))
                        noOfCol = resCount % col[0];
                      for (let j = 0; j < noOfCol; j++) {
                        resstarts.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1))));
                      }
                      index++;
                    }
                    index = getIndex("RESIDUE_LABEL");
                    if (index != -1) {
                      let resnames = [];
                      col = getColEleSize(index);
                      noOfCol = col[0];
                      index += 1;
                      for (let i = 0; i < resCount / col[0]; i++) {
                        if (i == parseInt(resCount / col[0]))
                          noOfCol = resCount % col[0];
                        for (let j = 0; j < noOfCol; j++) {
                          resnames.push(lines[index].slice(col[1] * j, col[1] * (j + 1)).trim());
                        }
                        index++;
                      }
                      let curres = 0;
                      let resi = 0;
                      let resn = "";
                      resstarts.push(atoms.length + 1);
                      for (let i = 0; i < atoms.length; i++) {
                        if (i + 1 >= resstarts[curres]) {
                          resn = resnames[curres];
                          curres += 1;
                          resi += 1;
                        }
                        atoms[i].resi = resi;
                        atoms[i].resn = resn;
                      }
                    }
                  }
                  index = getIndex("RADII");
                  if (index != -1) {
                    col = getColEleSize(index);
                    count = 0;
                    noOfCol = col[0];
                    for (let i = 0; i < atomCount / col[0]; i++) {
                      if (i == parseInt(atomCount / col[0]))
                        noOfCol = atomCount % col[0];
                      for (let j = 0; j < noOfCol; j++) {
                        atoms[count].properties.radii = parseFloat(lines[index + 1].slice(col[1] * j, col[1] * (j + 1)));
                        count++;
                      }
                      index++;
                    }
                  }
                  index = getIndex("BONDS_WITHOUT_HYDROGEN");
                  if (index != -1) {
                    col = getColEleSize(index);
                    count = 0;
                    noOfCol = col[0];
                    index = index + 1;
                    while (!lines[index].match(/^%FLAG/)) {
                      if (lines[index + 1].match(/^%FLAG/))
                        noOfCol = atomCount % col[0];
                      for (let j = 0; j < noOfCol; j++) {
                        if (count % 3 == 0) {
                          atomIndex = parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3);
                        } else if (count % 3 == 1) {
                          atoms[atomIndex].bonds.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3));
                          atoms[atomIndex].bondOrder.push(1);
                        }
                        count++;
                      }
                      index++;
                    }
                  }
                  index = getIndex("BONDS_INC_HYDROGEN");
                  if (index != -1) {
                    col = getColEleSize(index);
                    count = 0;
                    noOfCol = col[0];
                    index = index + 1;
                    while (!lines[index].match(/^%FLAG/)) {
                      if (lines[index + 1].match(/^%FLAG/))
                        noOfCol = atomCount % col[0];
                      for (let j = 0; j < noOfCol; j++) {
                        if (count % 3 == 0) {
                          atomIndex = parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3);
                        } else if (count % 3 == 1) {
                          atoms[atomIndex].bonds.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3));
                          atoms[atomIndex].bonds.push(1);
                        }
                        count++;
                      }
                      index++;
                    }
                  }
                } else {
                  return [];
                }
                function getIndex(section) {
                  var index2 = lines.indexOf(sectionList.filter(function(line) {
                    return line.includes(section);
                  })[0]);
                  if (Number.isInteger(index2) && index2 > 0) {
                    while (!lines[index2].includes("FORMAT"))
                      index2++;
                    return index2;
                  } else {
                    return -1;
                  }
                }
                function getColEleSize(i) {
                  var numberOfCol = lines[i].match(/\((\d*)\S*/);
                  var elementSize = lines[i].match(/[a-zA-Z](\d*)\)\s*/);
                  if (elementSize == null) {
                    elementSize = lines[i].match(/[a-zA-Z](\d*)\.\d*\)\s*/);
                  }
                  return [parseInt(numberOfCol[1]), parseInt(elementSize[1])];
                }
                return [atoms];
              }
            },
            /***/
            "./src/parsers/SDF.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                SDF: () => (
                  /* binding */
                  SDF
                )
                /* harmony export */
              });
              var parseV2000 = function(lines, options) {
                var atoms = [[]];
                var noH = false;
                if (typeof options.keepH !== "undefined")
                  noH = !options.keepH;
                while (lines.length > 0) {
                  if (lines.length < 4)
                    break;
                  var atomCount = parseInt(lines[3].substring(0, 3));
                  if (isNaN(atomCount) || atomCount <= 0)
                    break;
                  var bondCount = parseInt(lines[3].substring(3, 6));
                  var offset = 4;
                  if (lines.length < 4 + atomCount + bondCount)
                    break;
                  var serialToIndex = [];
                  var start = atoms[atoms.length - 1].length;
                  var end = start + atomCount;
                  var i, line;
                  for (i = start; i < end; i++, offset++) {
                    line = lines[offset];
                    var atom = {};
                    var elem = line.substring(31, 34).replace(/ /g, "");
                    atom.atom = atom.elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                    if (atom.elem !== "H" || !noH) {
                      atom.serial = i;
                      serialToIndex[i] = atoms[atoms.length - 1].length;
                      atom.x = parseFloat(line.substring(0, 10));
                      atom.y = parseFloat(line.substring(10, 20));
                      atom.z = parseFloat(line.substring(20, 30));
                      atom.hetflag = true;
                      atom.bonds = [];
                      atom.bondOrder = [];
                      atom.properties = {};
                      atom.index = atoms[atoms.length - 1].length;
                      atoms[atoms.length - 1].push(atom);
                    }
                  }
                  for (i = 0; i < bondCount; i++, offset++) {
                    line = lines[offset];
                    var from = serialToIndex[parseInt(line.substring(0, 3)) - 1 + start];
                    var to = serialToIndex[parseInt(line.substring(3, 6)) - 1 + start];
                    var order = parseFloat(line.substring(6));
                    if (typeof from != "undefined" && typeof to != "undefined") {
                      atoms[atoms.length - 1][from].bonds.push(to);
                      atoms[atoms.length - 1][from].bondOrder.push(order);
                      atoms[atoms.length - 1][to].bonds.push(from);
                      atoms[atoms.length - 1][to].bondOrder.push(order);
                    }
                  }
                  if (options.multimodel) {
                    if (!options.onemol)
                      atoms.push([]);
                    while (lines[offset] !== "$$$$" && offset < lines.length)
                      offset++;
                    lines.splice(0, ++offset);
                  } else {
                    break;
                  }
                }
                return atoms;
              };
              var parseV3000 = function(lines, options) {
                var atoms = [[]];
                var noH = false;
                if (typeof options.keepH !== "undefined")
                  noH = !options.keepH;
                while (lines.length > 0) {
                  if (lines.length < 8)
                    break;
                  if (!lines[4].startsWith("M  V30 BEGIN CTAB"))
                    break;
                  if (!lines[5].startsWith("M  V30 COUNTS") || lines[5].length < 14)
                    break;
                  var counts = lines[5].substring(13).match(/\S+/g);
                  if (counts.length < 2)
                    break;
                  var atomCount = parseInt(counts[0]);
                  if (isNaN(atomCount) || atomCount <= 0)
                    break;
                  var bondCount = parseInt(counts[1]);
                  var offset = 7;
                  if (lines.length < 8 + atomCount + bondCount)
                    break;
                  var serialToIndex = [];
                  var start = atoms[atoms.length - 1].length;
                  var end = start + atomCount;
                  var i, line;
                  for (i = start; i < end; i++, offset++) {
                    line = lines[offset];
                    var atomParts = line.substring(6).match(/\S+/g);
                    if (atomParts.length > 4) {
                      var atom = {};
                      var elem = atomParts[1].replace(/ /g, "");
                      atom.atom = atom.elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                      if (atom.elem !== "H" || !noH) {
                        atom.serial = i;
                        serialToIndex[i] = atoms[atoms.length - 1].length;
                        atom.x = parseFloat(atomParts[2]);
                        atom.y = parseFloat(atomParts[3]);
                        atom.z = parseFloat(atomParts[4]);
                        atom.hetflag = true;
                        atom.bonds = [];
                        atom.bondOrder = [];
                        atom.properties = {};
                        atom.index = atoms[atoms.length - 1].length;
                        atoms[atoms.length - 1].push(atom);
                      }
                    }
                  }
                  if (lines[offset] === "M  V30 END ATOM")
                    offset++;
                  else
                    break;
                  if (bondCount !== 0 && lines[offset] === "M  V30 BEGIN BOND")
                    offset++;
                  else
                    break;
                  for (i = 0; i < bondCount; i++, offset++) {
                    line = lines[offset];
                    var bondParts = line.substring(6).match(/\S+/g);
                    if (bondParts.length > 3) {
                      var from = serialToIndex[parseInt(bondParts[2]) - 1 + start];
                      var to = serialToIndex[parseInt(bondParts[3]) - 1 + start];
                      var order = parseFloat(bondParts[1]);
                      if (typeof from != "undefined" && typeof to != "undefined") {
                        atoms[atoms.length - 1][from].bonds.push(to);
                        atoms[atoms.length - 1][from].bondOrder.push(order);
                        atoms[atoms.length - 1][to].bonds.push(from);
                        atoms[atoms.length - 1][to].bondOrder.push(order);
                      }
                    }
                  }
                  if (options.multimodel) {
                    if (!options.onemol) {
                      atoms.push([]);
                    }
                    while (lines[offset] !== "$$$$" && offset < lines.length) {
                      offset++;
                    }
                    lines.splice(0, ++offset);
                  } else {
                    break;
                  }
                }
                return atoms;
              };
              function SDF(str, options) {
                var molformat = "V2000";
                var lines = str.split(/\r?\n|\r/);
                if (lines.length > 3 && lines[3].length > 38) {
                  molformat = lines[3].substring(34, 39);
                }
                if (molformat === "V2000") {
                  return parseV2000(lines, options);
                } else if (molformat === "V3000") {
                  return parseV3000(lines, options);
                }
                return [[""]];
              }
            },
            /***/
            "./src/parsers/VASP.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                VASP: () => (
                  /* binding */
                  VASP
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              function VASP(str, options = {}) {
                var atoms = [[]];
                var lattice = {};
                const assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                var lines = str.replace(/^\s+/, "").split(/\r?\n/);
                if (lines.length < 3) {
                  return atoms;
                }
                if (lines[1].match(/\d+/)) {
                  lattice.length = parseFloat(lines[1]);
                } else {
                  console.log("Warning: second line of the vasp structure file must be a number");
                  return atoms;
                }
                if (lattice.length < 0) {
                  console.log("Warning: Vasp implementation for negative lattice lengths is not yet available");
                  return atoms;
                }
                lattice.xVec = new Float32Array(lines[2].replace(/^\s+/, "").split(/\s+/));
                lattice.yVec = new Float32Array(lines[3].replace(/^\s+/, "").split(/\s+/));
                lattice.zVec = new Float32Array(lines[4].replace(/^\s+/, "").split(/\s+/));
                var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3(lattice.xVec[0], lattice.xVec[1], lattice.xVec[2], lattice.yVec[0], lattice.yVec[1], lattice.yVec[2], lattice.zVec[0], lattice.zVec[1], lattice.zVec[2]);
                matrix.multiplyScalar(lattice.length);
                atoms.modelData = [{ symmetries: [], cryst: { matrix } }];
                var atomSymbols = lines[5].trim().split(/\s+/);
                var atomSpeciesNumber = new Int16Array(lines[6].trim().split(/\s+/));
                var vaspMode = lines[7].trim();
                var selective = false;
                if (vaspMode.match(/S/)) {
                  selective = true;
                  vaspMode = lines[8].trim();
                }
                if (vaspMode.toLowerCase()[0] == "c") {
                  vaspMode = "cartesian";
                } else if (vaspMode.toLowerCase()[0] == "d") {
                  vaspMode = "direct";
                } else {
                  console.log("Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)");
                  return atoms;
                }
                if (atomSymbols.length != atomSpeciesNumber.length) {
                  console.log("Warning: declaration of atomary species wrong:");
                  console.log(atomSymbols);
                  console.log(atomSpeciesNumber);
                  return atoms;
                }
                if (selective) {
                  lines.splice(0, 9);
                } else {
                  lines.splice(0, 8);
                }
                var atomCounter = 0;
                for (var i = 0, len = atomSymbols.length; i < len; i++) {
                  var atomSymbol = atomSymbols[i];
                  for (var j = 0, atomLen = atomSpeciesNumber[i]; j < atomLen; j++) {
                    var coords = new Float32Array(lines[atomCounter + j].trim().split(/\s+/));
                    var atom = {};
                    atom.elem = atomSymbol;
                    if (vaspMode == "cartesian") {
                      atom.x = lattice.length * coords[0];
                      atom.y = lattice.length * coords[1];
                      atom.z = lattice.length * coords[2];
                    } else {
                      atom.x = lattice.length * (coords[0] * lattice.xVec[0] + coords[1] * lattice.yVec[0] + coords[2] * lattice.zVec[0]);
                      atom.y = lattice.length * (coords[0] * lattice.xVec[1] + coords[1] * lattice.yVec[1] + coords[2] * lattice.zVec[1]);
                      atom.z = lattice.length * (coords[0] * lattice.xVec[2] + coords[1] * lattice.yVec[2] + coords[2] * lattice.zVec[2]);
                    }
                    atom.bonds = [];
                    atom.bondOrder = [];
                    atoms[0].push(atom);
                  }
                  atomCounter += atomSpeciesNumber[i];
                }
                if (assignbonds) {
                  for (let i2 = 0; i2 < atoms.length; i2++) {
                    (0, _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(atoms[i2], options);
                  }
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/XYZ.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                XYZ: () => (
                  /* binding */
                  XYZ
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../WebGL */
                "./src/WebGL/index.ts"
              );
              var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./utils/assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              function XYZ(str, options) {
                options = options || {};
                var atoms = [[]];
                var assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                var lines = str.trimStart().split(/\r?\n|\r/);
                while (lines.length > 0) {
                  if (lines.length < 3)
                    break;
                  var atomCount = parseInt(lines[0]);
                  if (isNaN(atomCount) || atomCount <= 0)
                    break;
                  if (lines.length < atomCount + 2)
                    break;
                  var lattice_re = /Lattice\s*=\s*["\{\}]([^"\{\}]+)["\{\}]\s*/gi;
                  var lattice_match = lattice_re.exec(lines[1]);
                  if (lattice_match != null && lattice_match.length > 1) {
                    var lattice = new Float32Array(lattice_match[1].split(/\s+/));
                    var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3(lattice[0], lattice[3], lattice[6], lattice[1], lattice[4], lattice[7], lattice[2], lattice[5], lattice[8]);
                    atoms.modelData = [{ cryst: { matrix } }];
                  }
                  var offset = 2;
                  var start = atoms[atoms.length - 1].length;
                  var end = start + atomCount;
                  for (var i = start; i < end; i++) {
                    var line = lines[offset++];
                    var tokens = line.trim().split(/\s+/);
                    var atom = {};
                    atom.serial = i;
                    var elem = tokens[0];
                    atom.atom = atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();
                    atom.x = parseFloat(tokens[1]);
                    atom.y = parseFloat(tokens[2]);
                    atom.z = parseFloat(tokens[3]);
                    atom.hetflag = true;
                    atom.bonds = [];
                    atom.bondOrder = [];
                    atom.properties = {};
                    atoms[atoms.length - 1][i] = atom;
                    if (tokens.length >= 7) {
                      atom.dx = parseFloat(tokens[4]);
                      atom.dy = parseFloat(tokens[5]);
                      atom.dz = parseFloat(tokens[6]);
                    }
                  }
                  if (options.multimodel) {
                    atoms.push([]);
                    lines.splice(0, offset);
                  } else {
                    break;
                  }
                }
                if (assignbonds) {
                  for (let i2 = 0; i2 < atoms.length; i2++) {
                    (0, _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(atoms[i2], options);
                  }
                }
                if (options.onemol) {
                  var temp = atoms;
                  atoms = [];
                  atoms.push(temp[0]);
                  for (let i2 = 1; i2 < temp.length; i2++) {
                    let offset2 = atoms[0].length;
                    for (let j = 0; j < temp[i2].length; j++) {
                      let a = temp[i2][j];
                      for (let k = 0; k < a.bonds.length; k++) {
                        a.bonds[k] = a.bonds[k] + offset2;
                      }
                      a.index = atoms[0].length;
                      a.serial = atoms[0].length;
                      atoms[0].push(a);
                    }
                  }
                }
                return atoms;
              }
            },
            /***/
            "./src/parsers/cifutils/category.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Category: () => (
                  /* binding */
                  Category
                )
                /* harmony export */
              });
              var _decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./decoder */
                "./src/parsers/cifutils/decoder.ts"
              );
              function Category(data) {
                const map = /* @__PURE__ */ Object.create(null);
                const cache = /* @__PURE__ */ Object.create(null);
                for (const col of data.columns)
                  map[col.name] = col;
                return {
                  rowCount: data.rowCount,
                  name: data.name.substring(1),
                  fieldNames: data.columns.map((c) => c.name),
                  getField(name) {
                    const col = map[name];
                    if (!col)
                      return void 0;
                    if (!!cache[name])
                      return cache[name];
                    cache[name] = (0, _decoder__WEBPACK_IMPORTED_MODULE_0__.decode)(col.data);
                    return cache[name];
                  }
                };
              }
            },
            /***/
            "./src/parsers/cifutils/decoder.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                decode: () => (
                  /* binding */
                  decode
                )
                /* harmony export */
              });
              var _encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./encoding */
                "./src/parsers/cifutils/encoding.ts"
              );
              const IsNativeEndianLittle = new Uint16Array(new Uint8Array([18, 52]).buffer)[0] === 13330;
              function flipByteOrder(data, bytes) {
                const buffer = new ArrayBuffer(data.length);
                const ret = new Uint8Array(buffer);
                for (let i = 0, n = data.length; i < n; i += bytes) {
                  for (let j = 0; j < bytes; j++) {
                    ret[i + bytes - j - 1] = data[i + j];
                  }
                }
                return buffer;
              }
              function decode(data) {
                let current = data.data;
                for (let i = data.encoding.length - 1; i >= 0; i--) {
                  current = decodeStep(current, data.encoding[i]);
                }
                return current;
              }
              function decodeStep(data, encoding) {
                switch (encoding.kind) {
                  case "ByteArray": {
                    switch (encoding.type) {
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint8:
                        return data;
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int8:
                        return int8(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int16:
                        return int16(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint16:
                        return uint16(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int32:
                        return int32(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint32:
                        return uint32(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.FloatDataType.Float32:
                        return float32(data);
                      case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.FloatDataType.Float64:
                        return float64(data);
                      default:
                        throw new Error("unreachable");
                    }
                  }
                  case "FixedPoint":
                    return fixedPoint(data, encoding);
                  case "IntervalQuantization":
                    return intervalQuantization(data, encoding);
                  case "RunLength":
                    return runLength(data, encoding);
                  case "Delta":
                    return delta(data, encoding);
                  case "IntegerPacking":
                    return integerPacking(data, encoding);
                  case "StringArray":
                    return stringArray(data, encoding);
                }
              }
              function getIntArray(type, size) {
                switch (type) {
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int8:
                    return new Int8Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int16:
                    return new Int16Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Int32:
                    return new Int32Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint8:
                    return new Uint8Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint16:
                    return new Uint16Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.IntDataType.Uint32:
                    return new Uint32Array(size);
                  default:
                    return new Int32Array(size);
                }
              }
              function getFloatArray(type, size) {
                switch (type) {
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.FloatDataType.Float32:
                    return new Float32Array(size);
                  case _encoding__WEBPACK_IMPORTED_MODULE_0__.Encoding.FloatDataType.Float64:
                    return new Float64Array(size);
                  default:
                    return new Float64Array(size);
                }
              }
              function int8(data) {
                return new Int8Array(data.buffer, data.byteOffset);
              }
              function view(data, byteSize, c) {
                if (data.byteOffset != 0 || data.byteLength != data.buffer.byteLength) {
                  data = new Uint8Array(data);
                }
                if (IsNativeEndianLittle)
                  return new c(data.buffer);
                return new c(flipByteOrder(data, byteSize));
              }
              function int16(data) {
                return view(data, 2, Int16Array);
              }
              function uint16(data) {
                return view(data, 2, Uint16Array);
              }
              function int32(data) {
                return view(data, 4, Int32Array);
              }
              function uint32(data) {
                return view(data, 4, Uint32Array);
              }
              function float32(data) {
                return view(data, 4, Float32Array);
              }
              function float64(data) {
                return view(data, 8, Float64Array);
              }
              function fixedPoint(data, encoding) {
                const n = data.length;
                const output = getFloatArray(encoding.srcType, n);
                const f = 1 / encoding.factor;
                for (let i = 0; i < n; i++) {
                  output[i] = f * data[i];
                }
                return output;
              }
              function intervalQuantization(data, encoding) {
                const n = data.length;
                const output = getFloatArray(encoding.srcType, n);
                const delta2 = (encoding.max - encoding.min) / (encoding.numSteps - 1);
                const min = encoding.min;
                for (let i = 0; i < n; i++) {
                  output[i] = min + delta2 * data[i];
                }
                return output;
              }
              function runLength(data, encoding) {
                const output = getIntArray(encoding.srcType, encoding.srcSize);
                let dataOffset = 0;
                for (let i = 0, il = data.length; i < il; i += 2) {
                  const value = data[i];
                  const length = data[i + 1];
                  for (let j = 0; j < length; ++j) {
                    output[dataOffset++] = value;
                  }
                }
                return output;
              }
              function delta(data, encoding) {
                const n = data.length;
                const output = getIntArray(encoding.srcType, n);
                if (!n)
                  return data;
                output[0] = data[0] + (encoding.origin | 0);
                for (let i = 1; i < n; ++i) {
                  output[i] = data[i] + output[i - 1];
                }
                return output;
              }
              function integerPackingSigned(data, encoding) {
                const upperLimit = encoding.byteCount === 1 ? 127 : 32767;
                const lowerLimit = -upperLimit - 1;
                const n = data.length;
                const output = new Int32Array(encoding.srcSize);
                let i = 0;
                let j = 0;
                while (i < n) {
                  let value = 0, t = data[i];
                  while (t === upperLimit || t === lowerLimit) {
                    value += t;
                    i++;
                    t = data[i];
                  }
                  value += t;
                  output[j] = value;
                  i++;
                  j++;
                }
                return output;
              }
              function integerPackingUnsigned(data, encoding) {
                const upperLimit = encoding.byteCount === 1 ? 255 : 65535;
                const n = data.length;
                const output = new Int32Array(encoding.srcSize);
                let i = 0;
                let j = 0;
                while (i < n) {
                  let value = 0, t = data[i];
                  while (t === upperLimit) {
                    value += t;
                    i++;
                    t = data[i];
                  }
                  value += t;
                  output[j] = value;
                  i++;
                  j++;
                }
                return output;
              }
              function integerPacking(data, encoding) {
                if (data.length === encoding.srcSize)
                  return data;
                return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);
              }
              function stringArray(data, encoding) {
                const offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });
                const indices = decode({ encoding: encoding.dataEncoding, data });
                const str = encoding.stringData;
                const strings = new Array(offsets.length);
                strings[0] = "";
                for (let i = 1, _i = offsets.length; i < _i; i++) {
                  strings[i] = str.substring(offsets[i - 1], offsets[i]);
                }
                let offset = 0;
                const result = new Array(indices.length);
                for (let i = 0, _i = indices.length; i < _i; i++) {
                  result[offset++] = strings[indices[i] + 1];
                }
                return result;
              }
            },
            /***/
            "./src/parsers/cifutils/encoding.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Encoding: () => (
                  /* binding */
                  Encoding
                ),
                /* harmony export */
                VERSION: () => (
                  /* binding */
                  VERSION
                )
                /* harmony export */
              });
              const VERSION = "0.3.0";
              var Encoding;
              (function(Encoding2) {
                let IntDataType;
                (function(IntDataType2) {
                  IntDataType2[IntDataType2["Int8"] = 1] = "Int8";
                  IntDataType2[IntDataType2["Int16"] = 2] = "Int16";
                  IntDataType2[IntDataType2["Int32"] = 3] = "Int32";
                  IntDataType2[IntDataType2["Uint8"] = 4] = "Uint8";
                  IntDataType2[IntDataType2["Uint16"] = 5] = "Uint16";
                  IntDataType2[IntDataType2["Uint32"] = 6] = "Uint32";
                })(IntDataType = Encoding2.IntDataType || (Encoding2.IntDataType = {}));
                let FloatDataType;
                (function(FloatDataType2) {
                  FloatDataType2[FloatDataType2["Float32"] = 32] = "Float32";
                  FloatDataType2[FloatDataType2["Float64"] = 33] = "Float64";
                })(FloatDataType = Encoding2.FloatDataType || (Encoding2.FloatDataType = {}));
                function getDataType(data) {
                  let srcType;
                  if (data instanceof Int8Array)
                    srcType = Encoding2.IntDataType.Int8;
                  else if (data instanceof Int16Array)
                    srcType = Encoding2.IntDataType.Int16;
                  else if (data instanceof Int32Array)
                    srcType = Encoding2.IntDataType.Int32;
                  else if (data instanceof Uint8Array)
                    srcType = Encoding2.IntDataType.Uint8;
                  else if (data instanceof Uint16Array)
                    srcType = Encoding2.IntDataType.Uint16;
                  else if (data instanceof Uint32Array)
                    srcType = Encoding2.IntDataType.Uint32;
                  else if (data instanceof Float32Array)
                    srcType = Encoding2.FloatDataType.Float32;
                  else if (data instanceof Float64Array)
                    srcType = Encoding2.FloatDataType.Float64;
                  else
                    srcType = Encoding2.IntDataType.Int32;
                  return srcType;
                }
                Encoding2.getDataType = getDataType;
                function isSignedIntegerDataType(data) {
                  if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array)
                    return true;
                  for (let i = 0, _i = data.length; i < _i; i++) {
                    if (i < 0)
                      return false;
                  }
                  return true;
                }
                Encoding2.isSignedIntegerDataType = isSignedIntegerDataType;
              })(Encoding || (Encoding = {}));
            },
            /***/
            "./src/parsers/index.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                Parsers: () => (
                  /* binding */
                  Parsers
                ),
                /* harmony export */
                bondLength: () => (
                  /* reexport safe */
                  _utils_bondLength__WEBPACK_IMPORTED_MODULE_14__.bondLength
                ),
                /* harmony export */
                setBondLength: () => (
                  /* reexport safe */
                  _utils_bondLength__WEBPACK_IMPORTED_MODULE_14__.setBondLength
                )
                /* harmony export */
              });
              var _VASP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./VASP */
                "./src/parsers/VASP.ts"
              );
              var _CUBE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./CUBE */
                "./src/parsers/CUBE.ts"
              );
              var _XYZ__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./XYZ */
                "./src/parsers/XYZ.ts"
              );
              var _SDF__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./SDF */
                "./src/parsers/SDF.ts"
              );
              var _CDJSON__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./CDJSON */
                "./src/parsers/CDJSON.ts"
              );
              var _CIF__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./CIF */
                "./src/parsers/CIF.ts"
              );
              var _MOL2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./MOL2 */
                "./src/parsers/MOL2.ts"
              );
              var _PDB__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./PDB */
                "./src/parsers/PDB.ts"
              );
              var _PQR__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./PQR */
                "./src/parsers/PQR.ts"
              );
              var _MMTF__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ./MMTF */
                "./src/parsers/MMTF.ts"
              );
              var _PRMTOP__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ./PRMTOP */
                "./src/parsers/PRMTOP.ts"
              );
              var _GRO__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                /*! ./GRO */
                "./src/parsers/GRO.ts"
              );
              var _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                /*! ./LAMMPSTRJ */
                "./src/parsers/LAMMPSTRJ.ts"
              );
              var _BCIF__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                /*! ./BCIF */
                "./src/parsers/BCIF.ts"
              );
              var _utils_bondLength__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                /*! ./utils/bondLength */
                "./src/parsers/utils/bondLength.ts"
              );
              const Parsers = {
                vasp: _VASP__WEBPACK_IMPORTED_MODULE_0__.VASP,
                VASP: _VASP__WEBPACK_IMPORTED_MODULE_0__.VASP,
                cube: _CUBE__WEBPACK_IMPORTED_MODULE_1__.CUBE,
                CUBE: _CUBE__WEBPACK_IMPORTED_MODULE_1__.CUBE,
                xyz: _XYZ__WEBPACK_IMPORTED_MODULE_2__.XYZ,
                XYZ: _XYZ__WEBPACK_IMPORTED_MODULE_2__.XYZ,
                sdf: _SDF__WEBPACK_IMPORTED_MODULE_3__.SDF,
                SDF: _SDF__WEBPACK_IMPORTED_MODULE_3__.SDF,
                json: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,
                cdjson: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,
                CDJSON: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,
                mcif: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,
                cif: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,
                CIF: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,
                mol2: _MOL2__WEBPACK_IMPORTED_MODULE_6__.MOL2,
                MOL2: _MOL2__WEBPACK_IMPORTED_MODULE_6__.MOL2,
                pdb: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,
                PDB: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,
                pdbqt: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,
                PDBQT: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,
                pqr: _PQR__WEBPACK_IMPORTED_MODULE_8__.PQR,
                PQR: _PQR__WEBPACK_IMPORTED_MODULE_8__.PQR,
                mmtf: _MMTF__WEBPACK_IMPORTED_MODULE_9__.MMTFparser,
                //need to avoid name collision
                MMTF: _MMTF__WEBPACK_IMPORTED_MODULE_9__.MMTFparser,
                prmtop: _PRMTOP__WEBPACK_IMPORTED_MODULE_10__.PRMTOP,
                PRMTOP: _PRMTOP__WEBPACK_IMPORTED_MODULE_10__.PRMTOP,
                gro: _GRO__WEBPACK_IMPORTED_MODULE_11__.GRO,
                GRO: _GRO__WEBPACK_IMPORTED_MODULE_11__.GRO,
                lammpstrj: _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__.LAMMPSTRJ,
                LAMMPSTRJ: _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__.LAMMPSTRJ,
                bcif: _BCIF__WEBPACK_IMPORTED_MODULE_13__.BCIF,
                BCIF: _BCIF__WEBPACK_IMPORTED_MODULE_13__.BCIF
              };
            },
            /***/
            "./src/parsers/utils/anumToSymbol.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                anumToSymbol: () => (
                  /* binding */
                  anumToSymbol
                )
                /* harmony export */
              });
              const anumToSymbol = {
                1: "H",
                2: "He",
                3: "Li",
                4: "Be",
                5: "B",
                6: "C",
                7: "N",
                8: "O",
                9: "F",
                10: "Ne",
                11: "Na",
                12: "Mg",
                13: "Al",
                14: "Si",
                15: "P",
                16: "S",
                17: "Cl",
                18: "Ar",
                19: "K",
                20: "Ca",
                21: "Sc",
                22: "Ti",
                23: "V",
                24: "Cr",
                25: "Mn",
                26: "Fe",
                27: "Co",
                28: "Ni",
                29: "Cu",
                30: "Zn",
                31: "Ga",
                32: "Ge",
                33: "As",
                34: "Se",
                35: "Br",
                36: "Kr",
                37: "Rb",
                38: "Sr",
                39: "Y",
                40: "Zr",
                41: "Nb",
                42: "Mo",
                43: "Tc",
                44: "Ru",
                45: "Rh",
                46: "Pd",
                47: "Ag",
                48: "Cd",
                49: "In",
                50: "Sn",
                51: "Sb",
                52: "Te",
                53: "I",
                54: "Xe",
                55: "Cs",
                56: "Ba",
                71: "Lu",
                72: "Hf",
                73: "Ta",
                74: "W",
                75: "Re",
                76: "Os",
                77: "Ir",
                78: "Pt",
                79: "Au",
                80: "Hg",
                81: "Tl",
                82: "Pb",
                83: "Bi",
                84: "Po",
                85: "At",
                86: "Rn",
                87: "Fr",
                88: "Ra",
                104: "Rf",
                105: "Db",
                106: "Sg",
                107: "Bh",
                108: "Hs",
                109: "Mt",
                110: "Ds",
                111: "Rg",
                112: "Cn",
                113: "Nh",
                114: "Fl",
                115: "Mc",
                116: "Lv",
                117: "Ts",
                118: "Og",
                57: "La",
                58: "Ce",
                59: "Pr",
                60: "Nd",
                61: "Pm",
                62: "Sm",
                63: "Eu",
                64: "Gd",
                65: "Tb",
                66: "Dy",
                67: "Ho",
                68: "Er",
                69: "Tm",
                70: "Yb",
                89: "Ac",
                90: "Th",
                91: "Pa",
                92: "U",
                93: "Np",
                94: "Pu",
                95: "Am",
                96: "Cm",
                97: "Bk",
                98: "Cf",
                99: "Es",
                100: "Fm",
                101: "Md",
                102: "No"
              };
            },
            /***/
            "./src/parsers/utils/areConnected.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                areConnected: () => (
                  /* binding */
                  areConnected
                )
                /* harmony export */
              });
              var _bondLength__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./bondLength */
                "./src/parsers/utils/bondLength.ts"
              );
              const cations = /* @__PURE__ */ new Set(["Na", "K", "Ca", "Mg", "Mn", "Sr"]);
              function areConnected(atom1, atom2, options) {
                if (options && options.unboundCations && (cations.has(atom1.elem) || cations.has(atom2.elem))) {
                  return false;
                }
                let maxsq = (0, _bondLength__WEBPACK_IMPORTED_MODULE_0__.bondLength)(atom1.elem) + (0, _bondLength__WEBPACK_IMPORTED_MODULE_0__.bondLength)(atom2.elem);
                maxsq += 0.25;
                maxsq *= maxsq;
                let xdiff = atom1.x - atom2.x;
                xdiff *= xdiff;
                if (xdiff > maxsq)
                  return false;
                let ydiff = atom1.y - atom2.y;
                ydiff *= ydiff;
                if (ydiff > maxsq)
                  return false;
                let zdiff = atom1.z - atom2.z;
                zdiff *= zdiff;
                if (zdiff > maxsq)
                  return false;
                const distSquared = xdiff + ydiff + zdiff;
                if (isNaN(distSquared) || distSquared < 0.5 || distSquared > maxsq || atom1.altLoc !== atom2.altLoc && atom1.altLoc.trim() !== "" && atom2.altLoc.trim() !== "")
                  return false;
                return true;
              }
            },
            /***/
            "./src/parsers/utils/assignBackboneHBonds.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                assignBackboneHBonds: () => (
                  /* binding */
                  assignBackboneHBonds
                )
                /* harmony export */
              });
              function assignBackboneHBonds(atomsarray, hbondCutoff) {
                const maxlength = hbondCutoff || 3.2;
                const maxlengthSq = maxlength * maxlength;
                const atoms = [];
                for (let i = 0, n = atomsarray.length; i < n; i++) {
                  atomsarray[i].index = i;
                  const atom = atomsarray[i];
                  if (!atom.hetflag && (atom.atom === "N" || atom.atom === "O")) {
                    atoms.push(atom);
                    atom.hbondOther = null;
                    atom.hbondDistanceSq = Number.POSITIVE_INFINITY;
                  }
                }
                atoms.sort(function(a, b) {
                  return a.z - b.z;
                });
                for (let i = 0, n = atoms.length; i < n; i++) {
                  const ai = atoms[i];
                  for (let j = i + 1; j < n; j++) {
                    const aj = atoms[j];
                    const zdiff = aj.z - ai.z;
                    if (zdiff > maxlength)
                      break;
                    if (aj.atom == ai.atom)
                      continue;
                    const ydiff = Math.abs(aj.y - ai.y);
                    if (ydiff > maxlength)
                      continue;
                    const xdiff = Math.abs(aj.x - ai.x);
                    if (xdiff > maxlength)
                      continue;
                    const dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                    if (dist > maxlengthSq)
                      continue;
                    if (aj.chain == ai.chain && Math.abs(aj.resi - ai.resi) < 4)
                      continue;
                    if (dist < ai.hbondDistanceSq) {
                      ai.hbondOther = aj;
                      ai.hbondDistanceSq = dist;
                    }
                    if (dist < aj.hbondDistanceSq) {
                      aj.hbondOther = ai;
                      aj.hbondDistanceSq = dist;
                    }
                  }
                }
              }
            },
            /***/
            "./src/parsers/utils/assignBonds.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                assignBonds: () => (
                  /* binding */
                  assignBonds
                )
                /* harmony export */
              });
              var _areConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./areConnected */
                "./src/parsers/utils/areConnected.ts"
              );
              const OFFSETS = [
                { x: 0, y: 0, z: 1 },
                { x: 0, y: 1, z: -1 },
                { x: 0, y: 1, z: 0 },
                { x: 0, y: 1, z: 1 },
                { x: 1, y: -1, z: -1 },
                { x: 1, y: -1, z: 0 },
                { x: 1, y: -1, z: 1 },
                { x: 1, y: 0, z: -1 },
                { x: 1, y: 0, z: 0 },
                { x: 1, y: 0, z: 1 },
                { x: 1, y: 1, z: -1 },
                { x: 1, y: 1, z: 0 },
                { x: 1, y: 1, z: 1 }
              ];
              const MAX_BOND_LENGTH = 4.95;
              function assignBonds(atoms, options) {
                for (let i = 0, n = atoms.length; i < n; i++) {
                  if (!atoms[i].index)
                    atoms[i].index = i;
                }
                const grid = {
                  x: {
                    y: {
                      z: []
                    }
                  }
                };
                for (let index = 0; index < atoms.length; index++) {
                  const atom = atoms[index];
                  const x = Math.floor(atom.x / MAX_BOND_LENGTH);
                  const y = Math.floor(atom.y / MAX_BOND_LENGTH);
                  const z = Math.floor(atom.z / MAX_BOND_LENGTH);
                  if (!grid[x]) {
                    grid[x] = {};
                  }
                  if (!grid[x][y]) {
                    grid[x][y] = {};
                  }
                  if (!grid[x][y][z]) {
                    grid[x][y][z] = [];
                  }
                  grid[x][y][z].push(atom);
                }
                function findConnections(points, otherPoints) {
                  for (let i = 0; i < points.length; i++) {
                    const atom1 = points[i];
                    for (let j = 0; j < otherPoints.length; j++) {
                      const atom2 = otherPoints[j];
                      if ((0, _areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(atom1, atom2, options)) {
                        const a2i = atom1.bonds.indexOf(atom2.index);
                        const a1i = atom2.bonds.indexOf(atom1.index);
                        if (a2i === -1 && a1i === -1) {
                          atom1.bonds.push(atom2.index);
                          atom1.bondOrder.push(1);
                          atom2.bonds.push(atom1.index);
                          atom2.bondOrder.push(1);
                        } else if (a2i === -1) {
                          atom1.bonds.push(atom2.index);
                          atom1.bondOrder.push(atom2.bondOrder[a1i]);
                        } else if (a1i === -1) {
                          atom2.bonds.push(atom1.index);
                          atom2.bondOrder.push(atom1.bondOrder[a2i]);
                        }
                      }
                    }
                  }
                }
                for (let xg in grid) {
                  const x = parseInt(xg);
                  for (let yg in grid[x]) {
                    const y = parseInt(yg);
                    for (let zg in grid[x][y]) {
                      const z = parseInt(zg);
                      const points = grid[x][y][z];
                      for (let i = 0; i < points.length; i++) {
                        const atom1 = points[i];
                        for (let j = i + 1; j < points.length; j++) {
                          const atom2 = points[j];
                          if ((0, _areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(atom1, atom2, options)) {
                            if (atom1.bonds.indexOf(atom2.index) == -1) {
                              atom1.bonds.push(atom2.index);
                              atom1.bondOrder.push(1);
                              atom2.bonds.push(atom1.index);
                              atom2.bondOrder.push(1);
                            }
                          }
                        }
                      }
                      for (let o = 0; o < OFFSETS.length; o++) {
                        const offset = OFFSETS[o];
                        if (!grid[x + offset.x] || !grid[x + offset.x][y + offset.y] || !grid[x + offset.x][y + offset.y][z + offset.z])
                          continue;
                        const otherPoints = grid[x + offset.x][y + offset.y][z + offset.z];
                        findConnections(points, otherPoints);
                      }
                    }
                  }
                }
              }
            },
            /***/
            "./src/parsers/utils/assignPDBBonds.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                assignPDBBonds: () => (
                  /* binding */
                  assignPDBBonds
                )
                /* harmony export */
              });
              var _areConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./areConnected */
                "./src/parsers/utils/areConnected.ts"
              );
              var _assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./assignBonds */
                "./src/parsers/utils/assignBonds.ts"
              );
              var _standardResidues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./standardResidues */
                "./src/parsers/utils/standardResidues.ts"
              );
              function assignPDBBonds(atomsarray, options) {
                const protatoms = [];
                const hetatoms = [];
                for (let i = 0, n = atomsarray.length; i < n; i++) {
                  const atom = atomsarray[i];
                  atom.index = i;
                  if (atom.hetflag || !_standardResidues__WEBPACK_IMPORTED_MODULE_2__.standardResidues.has(atom.resn))
                    hetatoms.push(atom);
                  else
                    protatoms.push(atom);
                }
                (0, _assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(hetatoms, options);
                protatoms.sort(function(a, b) {
                  if (a.chain !== b.chain)
                    return a.chain < b.chain ? -1 : 1;
                  return a.resi - b.resi;
                });
                let currentResi = -1;
                let reschain = -1;
                let lastResConnected;
                for (let i = 0, n = protatoms.length; i < n; i++) {
                  const ai = protatoms[i];
                  if (ai.resi !== currentResi) {
                    currentResi = ai.resi;
                    if (!lastResConnected)
                      reschain++;
                    lastResConnected = false;
                  }
                  ai.reschain = reschain;
                  for (let j = i + 1; j < protatoms.length; j++) {
                    const aj = protatoms[j];
                    if (aj.chain !== ai.chain || aj.resi - ai.resi > 1)
                      break;
                    if ((0, _areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(ai, aj, options)) {
                      if (ai.bonds.indexOf(aj.index) === -1) {
                        ai.bonds.push(aj.index);
                        ai.bondOrder.push(1);
                        aj.bonds.push(ai.index);
                        aj.bondOrder.push(1);
                      }
                      if (ai.resi !== aj.resi)
                        lastResConnected = true;
                    }
                  }
                }
              }
            },
            /***/
            "./src/parsers/utils/atomNameToElem.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                atomNameToElem: () => (
                  /* binding */
                  atomNameToElem
                )
                /* harmony export */
              });
              var _bondLength__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./bondLength */
                "./src/parsers/utils/bondLength.ts"
              );
              function atomNameToElem(name, nothetero) {
                let elem = name.replace(/ /g, "");
                if (elem.length > 0 && elem[0] === "H" && elem !== "Hg" && elem !== "He" && elem !== "Hf" && elem !== "Hs" && elem !== "Ho") {
                  elem = "H";
                }
                if (elem.length > 1) {
                  elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                  if (_bondLength__WEBPACK_IMPORTED_MODULE_0__.bondTable[elem] === void 0) {
                    elem = elem[0];
                  } else if (nothetero) {
                    if (elem === "Ca") {
                      elem = "C";
                    } else if (elem === "Cd") {
                      elem = "C";
                    }
                  }
                }
                return elem;
              }
            },
            /***/
            "./src/parsers/utils/bondLength.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                bondLength: () => (
                  /* binding */
                  bondLength
                ),
                /* harmony export */
                bondTable: () => (
                  /* binding */
                  bondTable
                ),
                /* harmony export */
                setBondLength: () => (
                  /* binding */
                  setBondLength
                )
                /* harmony export */
              });
              let bondTable = {
                H: 0.37,
                He: 0.32,
                Li: 1.34,
                Be: 0.9,
                B: 0.82,
                C: 0.77,
                N: 0.75,
                O: 0.73,
                F: 0.71,
                Ne: 0.69,
                Na: 1.54,
                Mg: 1.3,
                Al: 1.18,
                Si: 1.11,
                P: 1.06,
                S: 1.02,
                Cl: 0.99,
                Ar: 0.97,
                K: 1.96,
                Ca: 1.74,
                Sc: 1.44,
                Ti: 1.56,
                V: 1.25,
                /* Cr */
                Mn: 1.39,
                Fe: 1.25,
                Co: 1.26,
                Ni: 1.21,
                Cu: 1.38,
                Zn: 1.31,
                Ga: 1.26,
                Ge: 1.22,
                /* As */
                Se: 1.16,
                Br: 1.14,
                Kr: 1.1,
                Rb: 2.11,
                Sr: 1.92,
                Y: 1.62,
                Zr: 1.48,
                Nb: 1.37,
                Mo: 1.45,
                Tc: 1.56,
                Ru: 1.26,
                Rh: 1.35,
                Pd: 1.31,
                Ag: 1.53,
                Cd: 1.48,
                In: 1.44,
                Sn: 1.41,
                Sb: 1.38,
                Te: 1.35,
                I: 1.33,
                Xe: 1.3,
                Cs: 2.25,
                Ba: 1.98,
                Lu: 1.6,
                Hf: 1.5,
                Ta: 1.38,
                W: 1.46,
                Re: 1.59,
                Os: 1.44,
                Ir: 1.37,
                Pt: 1.28,
                Au: 1.44,
                Hg: 1.49,
                Tl: 1.48,
                Pb: 1.47,
                Bi: 1.46,
                /* Po */
                /* At */
                Rn: 1.45
                // None of the bottom row or any of the Lanthanides have bond lengths
              };
              function bondLength(elem) {
                return bondTable[elem] || 1.6;
              }
              function setBondLength(elem, radius) {
                if (radius < 0)
                  radius = 0;
                bondTable[elem] = radius;
              }
            },
            /***/
            "./src/parsers/utils/computeSecondaryStructure.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                computeSecondaryStructure: () => (
                  /* binding */
                  computeSecondaryStructure
                )
                /* harmony export */
              });
              var _assignBackboneHBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./assignBackboneHBonds */
                "./src/parsers/utils/assignBackboneHBonds.ts"
              );
              function computeSecondaryStructure(atomsarray, hbondCutoff) {
                (0, _assignBackboneHBonds__WEBPACK_IMPORTED_MODULE_0__.assignBackboneHBonds)(atomsarray, hbondCutoff);
                const chres = {};
                let i, il, c, r;
                let atom, val;
                for (i = 0, il = atomsarray.length; i < il; i++) {
                  atom = atomsarray[i];
                  if (chres[atom.chain] === void 0)
                    chres[atom.chain] = [];
                  if (isFinite(atom.hbondDistanceSq)) {
                    const other = atom.hbondOther;
                    if (chres[other.chain] === void 0)
                      chres[other.chain] = [];
                    if (Math.abs(other.resi - atom.resi) === 4) {
                      chres[atom.chain][atom.resi] = "h";
                    }
                  }
                }
                for (c in chres) {
                  for (r = 1; r < chres[c].length - 1; r++) {
                    const valbefore = chres[c][r - 1];
                    const valafter = chres[c][r + 1];
                    val = chres[c][r];
                    if (valbefore == "h" && valbefore == valafter && val != valbefore) {
                      chres[c][r] = valbefore;
                    }
                  }
                }
                for (i = 0, il = atomsarray.length; i < il; i++) {
                  atom = atomsarray[i];
                  if (isFinite(atom.hbondDistanceSq) && chres[atom.chain][atom.resi] != "h" && atom.ss !== "h") {
                    chres[atom.chain][atom.resi] = "maybesheet";
                  }
                }
                for (let i2 = 0, il2 = atomsarray.length; i2 < il2; i2++) {
                  atom = atomsarray[i2];
                  if (isFinite(atom.hbondDistanceSq) && chres[atom.chain][atom.resi] == "maybesheet") {
                    let other = atom.hbondOther;
                    let otherval = chres[other.chain][other.resi];
                    if (otherval == "maybesheet" || otherval == "s") {
                      chres[atom.chain][atom.resi] = "s";
                      chres[other.chain][other.resi] = "s";
                    }
                  }
                }
                for (let c2 in chres) {
                  for (let r2 = 1; r2 < chres[c2].length - 1; r2++) {
                    const valbefore = chres[c2][r2 - 1];
                    const valafter = chres[c2][r2 + 1];
                    val = chres[c2][r2];
                    if (valbefore == "s" && valbefore == valafter && val != valbefore) {
                      chres[c2][r2] = valbefore;
                    }
                  }
                  for (let r2 = 0; r2 < chres[c2].length; r2++) {
                    const val2 = chres[c2][r2];
                    if (val2 == "h" || val2 == "s") {
                      if (chres[c2][r2 - 1] != val2 && chres[c2][r2 + 1] != val2)
                        delete chres[c2][r2];
                    }
                  }
                }
                for (i = 0, il = atomsarray.length; i < il; i++) {
                  atom = atomsarray[i];
                  val = chres[atom.chain][atom.resi];
                  delete atom.hbondOther;
                  delete atom.hbondDistanceSq;
                  if (val === void 0 || val === "maybesheet")
                    continue;
                  atom.ss = val;
                  if (chres[atom.chain][atom.resi - 1] != val)
                    atom.ssbegin = true;
                  if (chres[atom.chain][atom.resi + 1] != val)
                    atom.ssend = true;
                }
              }
            },
            /***/
            "./src/parsers/utils/getSinglePDB.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                getSinglePDB: () => (
                  /* binding */
                  getSinglePDB
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../WebGL */
                "./src/WebGL/index.ts"
              );
              var _atomNameToElem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./atomNameToElem */
                "./src/parsers/utils/atomNameToElem.ts"
              );
              var _bondLength__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./bondLength */
                "./src/parsers/utils/bondLength.ts"
              );
              var _computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./computeSecondaryStructure */
                "./src/parsers/utils/computeSecondaryStructure.ts"
              );
              var _isEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./isEmpty */
                "./src/parsers/utils/isEmpty.ts"
              );
              var _processSymmetries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./processSymmetries */
                "./src/parsers/utils/processSymmetries.ts"
              );
              var _assignPDBBonds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./assignPDBBonds */
                "./src/parsers/utils/assignPDBBonds.ts"
              );
              var _validateBonds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./validateBonds */
                "./src/parsers/utils/validateBonds.ts"
              );
              function getSinglePDB(lines, options, sslookup) {
                const atoms = [];
                const assignbonds = options.assignBonds === void 0 ? true : options.assignBonds;
                const noH = !options.keepH;
                const ignoreStruct = !!options.noSecondaryStructure;
                const computeStruct = !options.noComputeSecondaryStructure;
                const noAssembly = !options.doAssembly;
                const selAltLoc = options.altLoc ? options.altLoc : "A";
                const modelData = { symmetries: [], cryst: void 0 };
                let atom;
                let remainingLines = [];
                const serialToIndex = [];
                let line;
                const seenbonds = {};
                for (let i = 0; i < lines.length; i++) {
                  line = lines[i].replace(/^\s*/, "");
                  const recordName = line.substring(0, 6);
                  let startChain, startResi, endResi;
                  if (recordName.indexOf("END") === 0) {
                    remainingLines = lines.slice(i + 1);
                    if (recordName === "END") {
                      for (const prop in sslookup) {
                        if (sslookup.hasOwnProperty(prop)) {
                          delete sslookup[prop];
                        }
                      }
                    }
                    break;
                  } else if (recordName === "ATOM  " || recordName === "HETATM") {
                    let resn, chain, resi, icode, x, y, z, hetflag, elem, serial, altLoc, b;
                    altLoc = line.substring(16, 17);
                    if (altLoc !== " " && altLoc !== selAltLoc && selAltLoc !== "*")
                      continue;
                    serial = parseInt(line.substring(6, 11));
                    atom = line.substring(12, 16).replace(/ /g, "");
                    resn = line.substring(17, 20).replace(/ /g, "");
                    chain = line.substring(21, 22);
                    resi = parseInt(line.substring(22, 26));
                    icode = line.substring(26, 27);
                    x = parseFloat(line.substring(30, 38));
                    y = parseFloat(line.substring(38, 46));
                    z = parseFloat(line.substring(46, 54));
                    b = parseFloat(line.substring(60, 68));
                    elem = line.substring(76, 78).replace(/ /g, "");
                    if (elem === "" || _bondLength__WEBPACK_IMPORTED_MODULE_2__.bondTable[elem] === void 0) {
                      elem = (0, _atomNameToElem__WEBPACK_IMPORTED_MODULE_1__.atomNameToElem)(line.substring(12, 14), line[0] == "A");
                    } else {
                      elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();
                    }
                    if (elem === "H" && noH)
                      continue;
                    if (recordName[0] == "H")
                      hetflag = true;
                    else
                      hetflag = false;
                    serialToIndex[serial] = atoms.length;
                    atoms.push({
                      resn,
                      x,
                      y,
                      z,
                      elem,
                      hetflag,
                      altLoc,
                      chain,
                      resi,
                      icode,
                      rescode: resi + (icode !== " " ? "^" + icode : ""),
                      // combo
                      // resi
                      // and
                      // icode
                      serial,
                      atom,
                      bonds: [],
                      ss: "c",
                      bondOrder: [],
                      properties: {},
                      b,
                      pdbline: line
                    });
                  } else if (recordName === "SHEET ") {
                    startChain = line.substring(21, 22);
                    startResi = parseInt(line.substring(22, 26));
                    endResi = parseInt(line.substring(33, 37));
                    if (!(startChain in sslookup)) {
                      sslookup[startChain] = {};
                    }
                    sslookup[startChain][startResi] = "s1";
                    for (let res = startResi + 1; res < endResi; res++) {
                      sslookup[startChain][res] = "s";
                    }
                    sslookup[startChain][endResi] = "s2";
                  } else if (recordName === "CONECT") {
                    const from = parseInt(line.substring(6, 11));
                    const fromindex = serialToIndex[from];
                    const fromAtom = atoms[fromindex];
                    const coffsets = [11, 16, 21, 26];
                    for (let j = 0; j < 4; j++) {
                      const to = parseInt(line.substring(coffsets[j], coffsets[j] + 5));
                      const toindex = serialToIndex[to];
                      let from_to = fromindex + ":" + toindex;
                      const toAtom = atoms[toindex];
                      if (fromAtom !== void 0 && toAtom !== void 0) {
                        if (!seenbonds[from_to]) {
                          seenbonds[from_to] = 1;
                          if (fromAtom.bonds.length == 0 || fromAtom.bonds[fromAtom.bonds.length - 1] !== toindex) {
                            fromAtom.bonds.push(toindex);
                            fromAtom.bondOrder.push(1);
                          }
                        } else {
                          seenbonds[from_to] += 1;
                          for (let bi = 0; bi < fromAtom.bonds.length; bi++) {
                            if (fromAtom.bonds[bi] == toindex) {
                              const newbo = seenbonds[from_to];
                              if (newbo >= 4) {
                                fromAtom.bondOrder[bi] = 1;
                              } else {
                                fromAtom.bondOrder[bi] = newbo;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else if (recordName === "HELIX ") {
                    startChain = line.substring(19, 20);
                    startResi = parseInt(line.substring(21, 25));
                    endResi = parseInt(line.substring(33, 37));
                    if (!(startChain in sslookup)) {
                      sslookup[startChain] = {};
                    }
                    sslookup[startChain][startResi] = "h1";
                    for (let res = startResi + 1; res < endResi; res++) {
                      sslookup[startChain][res] = "h";
                    }
                    sslookup[startChain][endResi] = "h2";
                  } else if (!noAssembly && recordName === "REMARK" && line.substring(13, 18) === "BIOMT") {
                    let n;
                    let matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                    for (n = 1; n <= 3; n++) {
                      line = lines[i].replace(/^\s*/, "");
                      if (parseInt(line.substring(18, 19)) == n) {
                        matrix.elements[n - 1] = parseFloat(line.substring(23, 33));
                        matrix.elements[n - 1 + 4] = parseFloat(line.substring(33, 43));
                        matrix.elements[n - 1 + 8] = parseFloat(line.substring(43, 53));
                        matrix.elements[n - 1 + 12] = parseFloat(line.substring(53));
                        i++;
                      } else {
                        while (line.substring(13, 18) === "BIOMT") {
                          i++;
                          line = lines[i].replace(/^\s*/, "");
                        }
                      }
                    }
                    matrix.elements[3] = 0;
                    matrix.elements[7] = 0;
                    matrix.elements[11] = 0;
                    matrix.elements[15] = 1;
                    modelData.symmetries.push(matrix);
                    i--;
                  } else if (recordName === "CRYST1") {
                    let a, b, c, alpha, beta, gamma;
                    a = parseFloat(line.substring(7, 15));
                    b = parseFloat(line.substring(16, 24));
                    c = parseFloat(line.substring(25, 33));
                    alpha = parseFloat(line.substring(34, 40));
                    beta = parseFloat(line.substring(41, 47));
                    gamma = parseFloat(line.substring(48, 54));
                    modelData.cryst = {
                      a,
                      b,
                      c,
                      alpha,
                      beta,
                      gamma
                    };
                  } else if (recordName === "ANISOU") {
                    const serial = parseInt(line.substring(6, 11));
                    const anisouAtomIndex = serialToIndex[serial];
                    const anisouAtom = atoms[anisouAtomIndex];
                    if (anisouAtom) {
                      const vals = line.substring(30).trim().split(/\s+/);
                      const uMat = {
                        u11: parseInt(vals[0]),
                        u22: parseInt(vals[1]),
                        u33: parseInt(vals[2]),
                        u12: parseInt(vals[3]),
                        u13: parseInt(vals[4]),
                        u23: parseInt(vals[5])
                      };
                      anisouAtom.uMat = uMat;
                    }
                  }
                }
                (0, _validateBonds__WEBPACK_IMPORTED_MODULE_7__.validateBonds)(atoms, serialToIndex);
                if (assignbonds)
                  (0, _assignPDBBonds__WEBPACK_IMPORTED_MODULE_6__.assignPDBBonds)(atoms, options);
                if (!noAssembly)
                  (0, _processSymmetries__WEBPACK_IMPORTED_MODULE_5__.processSymmetries)(modelData.symmetries, atoms, options, modelData.cryst);
                if (computeStruct && !ignoreStruct) {
                  (0, _computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_3__.computeSecondaryStructure)(atoms, options.hbondCutoff);
                }
                if (!(0, _isEmpty__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(sslookup)) {
                  for (let i = 0; i < atoms.length; i++) {
                    const atom2 = atoms[i];
                    if (atom2 === void 0)
                      continue;
                    if (atom2.chain in sslookup && atom2.resi in sslookup[atom2.chain]) {
                      const code = sslookup[atom2.chain][atom2.resi];
                      atom2.ss = code[0];
                      if (code.length > 1) {
                        if (code[1] == "1")
                          atom2.ssbegin = true;
                        else if (code[1] == "2")
                          atom2.ssend = true;
                      }
                    }
                  }
                }
                return [atoms, modelData, remainingLines];
              }
            },
            /***/
            "./src/parsers/utils/isEmpty.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                isEmpty: () => (
                  /* binding */
                  isEmpty
                )
                /* harmony export */
              });
              function isEmpty(obj) {
                for (const _ in obj) {
                  return false;
                }
                return true;
              }
            },
            /***/
            "./src/parsers/utils/processSymmetries.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                processSymmetries: () => (
                  /* binding */
                  processSymmetries
                )
                /* harmony export */
              });
              var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../../WebGL */
                "./src/WebGL/index.ts"
              );
              function processSymmetries(copyMatrices, atoms, options, cryst) {
                const dontDuplicate = !options.duplicateAssemblyAtoms;
                const end = atoms.length;
                let offset = end;
                let modifiedIdentity = -1;
                let conversionMatrix = null;
                let toFrac = null;
                if ((options.normalizeAssembly || options.wrapAtoms) && cryst) {
                  conversionMatrix = (0, _WebGL__WEBPACK_IMPORTED_MODULE_0__.conversionMatrix3)(cryst.a, cryst.b, cryst.c, cryst.alpha, cryst.beta, cryst.gamma);
                  toFrac = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3();
                  toFrac.getInverse3(conversionMatrix);
                }
                let getAdjustment = function(v) {
                  let c = v.clone().applyMatrix3(toFrac);
                  const coord = [c.x, c.y, c.z];
                  const adjustment = [0, 0, 0];
                  for (let i = 0; i < 3; i++) {
                    while (coord[i] < -1e-3) {
                      coord[i] += 1;
                      adjustment[i] += 1;
                    }
                    while (coord[i] > 1.001) {
                      coord[i] -= 1;
                      adjustment[i] -= 1;
                    }
                  }
                  const adjustmentVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(adjustment[0], adjustment[1], adjustment[2]);
                  adjustmentVec.applyMatrix3(conversionMatrix);
                  return adjustmentVec;
                };
                if (options.normalizeAssembly && cryst) {
                  for (let t = 0; t < copyMatrices.length; t++) {
                    const center = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
                    for (let n = 0; n < end; n++) {
                      const xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(atoms[n].x, atoms[n].y, atoms[n].z);
                      xyz.applyMatrix4(copyMatrices[t]);
                      center.add(xyz);
                    }
                    center.divideScalar(end);
                    const adjustmentVec = getAdjustment(center);
                    if (copyMatrices[t].isNearlyIdentity() && adjustmentVec.lengthSq() > 1e-3) {
                      modifiedIdentity = t;
                    }
                    copyMatrices[t].translate(adjustmentVec);
                  }
                }
                if (!dontDuplicate) {
                  for (let n = 0; n < end; n++) {
                    atoms[n].sym = -1;
                  }
                  for (let t = 0; t < copyMatrices.length; t++) {
                    if (!copyMatrices[t].isNearlyIdentity() && modifiedIdentity != t) {
                      let xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                      for (let n = 0; n < end; n++) {
                        const bondsArr = [];
                        for (let l = 0; l < atoms[n].bonds.length; l++) {
                          bondsArr.push(atoms[n].bonds[l] + offset);
                        }
                        xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);
                        xyz.applyMatrix4(copyMatrices[t]);
                        if (options.wrapAtoms && cryst) {
                          let adjustment = getAdjustment(xyz);
                          xyz.add(adjustment);
                        }
                        const newAtom = {};
                        for (const i in atoms[n]) {
                          newAtom[i] = atoms[n][i];
                        }
                        newAtom.x = xyz.x;
                        newAtom.y = xyz.y;
                        newAtom.z = xyz.z;
                        newAtom.bonds = bondsArr;
                        newAtom.sym = t;
                        newAtom.index = atoms.length;
                        atoms.push(newAtom);
                      }
                      offset = atoms.length;
                    } else {
                      for (let n = 0; n < end; n++) {
                        atoms[n].sym = t;
                      }
                    }
                  }
                  if (options.wrapAtoms && cryst) {
                    let xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    for (let n = 0; n < end; n++) {
                      xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);
                      let adjustment = getAdjustment(xyz);
                      xyz.add(adjustment);
                      atoms[n].x = xyz.x;
                      atoms[n].y = xyz.y;
                      atoms[n].z = xyz.z;
                    }
                  }
                  if (modifiedIdentity >= 0) {
                    const xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    for (let n = 0; n < end; n++) {
                      xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);
                      xyz.applyMatrix4(copyMatrices[modifiedIdentity]);
                      atoms[n].x = xyz.x;
                      atoms[n].y = xyz.y;
                      atoms[n].z = xyz.z;
                    }
                  }
                  copyMatrices.length = 0;
                } else if (copyMatrices.length > 1) {
                  for (let t = 0; t < atoms.length; t++) {
                    var symmetries = [];
                    for (let l = 0; l < copyMatrices.length; l++) {
                      if (!copyMatrices[l].isNearlyIdentity()) {
                        var newXYZ = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        newXYZ.set(atoms[t].x, atoms[t].y, atoms[t].z);
                        newXYZ.applyMatrix4(copyMatrices[l]);
                        symmetries.push(newXYZ);
                      }
                    }
                    atoms[t].symmetries = symmetries;
                  }
                }
              }
            },
            /***/
            "./src/parsers/utils/standardResidues.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                standardResidues: () => (
                  /* binding */
                  standardResidues
                )
                /* harmony export */
              });
              const standardResidues = /* @__PURE__ */ new Set([
                "ABU",
                "ACD",
                "ALA",
                "ALB",
                "ALI",
                "ARG",
                "AR0",
                "ASN",
                "ASP",
                "ASX",
                "BAS",
                "CYS",
                "CYH",
                "CYX",
                "CSS",
                "CSH",
                "GLN",
                "GLU",
                "GLX",
                "GLY",
                "HIS",
                "HIE",
                "HID",
                "HIP",
                "HYP",
                "ILE",
                "ILU",
                "LEU",
                "LYS",
                "MET",
                "PCA",
                "PGA",
                "PHE",
                "PR0",
                "PRO",
                "PRZ",
                "SER",
                "THR",
                "TRP",
                "TYR",
                "VAL",
                "A",
                "1MA",
                "C",
                "5MC",
                "OMC",
                "G",
                "1MG",
                "2MG",
                "M2G",
                "7MG",
                "OMG",
                "YG",
                "I",
                "T",
                "U",
                "+U",
                "H2U",
                "5MU",
                "PSU",
                "ACE",
                "F0R",
                "H2O",
                "HOH",
                "WAT"
              ]);
            },
            /***/
            "./src/parsers/utils/validateBonds.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                validateBonds: () => (
                  /* binding */
                  validateBonds
                )
                /* harmony export */
              });
              function validateBonds(atomsarray, serialToIndex) {
                for (let i = 0, n = atomsarray.length; i < n; i++) {
                  const atom = atomsarray[i];
                  for (let b = 0; b < atom.bonds.length; b++) {
                    const a2i = atom.bonds[b];
                    const atom2 = atomsarray[a2i];
                    const atomi = serialToIndex[atom.serial];
                    if (atom2 && atomi) {
                      const a1i = atom2.bonds.indexOf(atomi);
                      if (a1i < 0) {
                        atom2.bonds.push(atomi);
                        atom2.bondOrder.push(atom.bondOrder[b]);
                      }
                    }
                  }
                }
              }
            },
            /***/
            "./src/partialCharges.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                applyPartialCharges: () => (
                  /* binding */
                  applyPartialCharges
                ),
                /* harmony export */
                partialCharges: () => (
                  /* binding */
                  partialCharges
                )
                /* harmony export */
              });
              const partialCharges = {
                "ALA:N": -0.15,
                "ALA:CA": 0.1,
                "ALA:CB": 0,
                "ALA:C": 0.6,
                "ALA:O": -0.55,
                "ARG:N": -0.15,
                "ARG:CA": 0.1,
                "ARG:CB": 0,
                "ARG:CG": 0,
                "ARG:CD": 0.1,
                "ARG:NE": -0.1,
                "ARG:CZ": 0.5,
                "ARG:NH1": 0.25,
                "ARG:NH2": 0.25,
                "ARG:C": 0.6,
                "ARG:O": -0.55,
                "ASN:N": -0.15,
                "ASN:CA": 0.1,
                "ASN:CB": 0,
                "ASN:CG": 0.55,
                "ASN:OD1": -0.55,
                "ASN:ND2": 0,
                "ASN:C": 0.6,
                "ASN:O": -0.55,
                "ASP:N": -0.15,
                "ASP:CA": 0.1,
                "ASP:CB": 0,
                "ASP:CG": 0.14,
                "ASP:OD1": -0.57,
                "ASP:OD2": -0.57,
                "ASP:C": 0.6,
                "ASP:O": -0.55,
                "CYS:N": -0.15,
                "CYS:CA": 0.1,
                "CYS:CB": 0.19,
                "CYS:SG": -0.19,
                "CYS:C": 0.6,
                "CYS:O": -0.55,
                "GLN:N": -0.15,
                "GLN:CA": 0.1,
                "GLN:CB": 0,
                "GLN:CG": 0,
                "GLN:CD": 0.55,
                "GLN:OE1": -0.55,
                "GLN:NE2": 0,
                "GLN:C": 0.6,
                "GLN:O": -0.55,
                "GLU:N": -0.15,
                "GLU:CA": 0.1,
                "GLU:CB": 0,
                "GLU:CG": 0,
                "GLU:CD": 0.14,
                "GLU:OE1": -0.57,
                "GLU:OE2": -0.57,
                "GLU:C": 0.6,
                "GLU:O": -0.55,
                "GLY:N": -0.15,
                "GLY:CA": 0.1,
                "GLY:C": 0.6,
                "GLY:O": -0.55,
                "HIS:N": -0.15,
                "HIS:CA": 0.1,
                "HIS:CB": 0,
                "HIS:CG": 0.1,
                "HIS:ND1": -0.1,
                "HIS:CD2": 0.1,
                "HIS:NE2": -0.4,
                "HIS:CE1": 0.3,
                "HIS:C": 0.6,
                "HIS:O": -0.55,
                "ILE:N": -0.15,
                "ILE:CA": 0.1,
                "ILE:CB": 0,
                "ILE:CG2": 0,
                "ILE:CG1": 0,
                "ILE:CD": 0,
                "ILE:C": 0.6,
                "ILE:O": -0.55,
                "LEU:N": -0.15,
                "LEU:CA": 0.1,
                "LEU:CB": 0,
                "LEU:CG": 0,
                "LEU:CD1": 0,
                "LEU:CD2": 0,
                "LEU:C": 0.6,
                "LEU:O": -0.55,
                "LYS:N": -0.15,
                "LYS:CA": 0.1,
                "LYS:CB": 0,
                "LYS:CG": 0,
                "LYS:CD": 0,
                "LYS:CE": 0.25,
                "LYS:NZ": 0.75,
                "LYS:C": 0.6,
                "LYS:O": -0.55,
                "MET:N": -0.15,
                "MET:CA": 0.1,
                "MET:CB": 0,
                "MET:CG": 0.06,
                "MET:SD": -0.12,
                "MET:CE": 0.06,
                "MET:C": 0.6,
                "MET:O": -0.55,
                "PHE:N": -0.15,
                "PHE:CA": 0.1,
                "PHE:CB": 0,
                "PHE:CG": 0,
                "PHE:CD1": 0,
                "PHE:CD2": 0,
                "PHE:CE1": 0,
                "PHE:CE2": 0,
                "PHE:CZ": 0,
                "PHE:C": 0.6,
                "PHE:O": -0.55,
                "PRO:N": -0.25,
                "PRO:CD": 0.1,
                "PRO:CA": 0.1,
                "PRO:CB": 0,
                "PRO:CG": 0,
                "PRO:C": 0.6,
                "PRO:O": -0.55,
                "SER:N": -0.15,
                "SER:CA": 0.1,
                "SER:CB": 0.25,
                "SER:OG": -0.25,
                "SER:C": 0.6,
                "SER:O": -0.55,
                "THR:N": -0.15,
                "THR:CA": 0.1,
                "THR:CB": 0.25,
                "THR:OG1": -0.25,
                "THR:CG2": 0,
                "THR:C": 0.6,
                "THR:O": -0.55,
                "TRP:N": -0.15,
                "TRP:CA": 0.1,
                "TRP:CB": 0,
                "TRP:CG": -0.03,
                "TRP:CD2": 0.1,
                "TRP:CE2": -0.04,
                "TRP:CE3": -0.03,
                "TRP:CD1": 0.06,
                "TRP:NE1": -0.06,
                "TRP:CZ2": 0,
                "TRP:CZ3": 0,
                "TRP:CH2": 0,
                "TRP:C": 0.6,
                "TRP:O": -0.55,
                "TYR:N": -0.15,
                "TYR:CA": 0.1,
                "TYR:CB": 0,
                "TYR:CG": 0,
                "TYR:CD1": 0,
                "TYR:CE1": 0,
                "TYR:CD2": 0,
                "TYR:CE2": 0,
                "TYR:CZ": 0.25,
                "TYR:OH": -0.25,
                "TYR:C": 0.6,
                "TYR:O": -0.55,
                "VAL:N": -0.15,
                "VAL:CA": 0.1,
                "VAL:CB": 0,
                "VAL:CG1": 0,
                "VAL:CG2": 0,
                "VAL:C": 0.6,
                "VAL:O": -0.55
              };
              function applyPartialCharges(atom, keepexisting) {
                if (!keepexisting || typeof atom.partialCharge === "undefined") {
                  if (atom.resn && atom.atom) {
                    var key = atom.resn + ":" + atom.atom;
                    atom.properties.partialCharge = partialCharges[key];
                  }
                }
              }
              ;
            },
            /***/
            "./src/specs.ts"(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
            },
            /***/
            "./src/utilities.ts"(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, {
                /* harmony export */
                PausableTimer: () => (
                  /* binding */
                  PausableTimer
                ),
                /* harmony export */
                adjustVolumeStyle: () => (
                  /* binding */
                  adjustVolumeStyle
                ),
                /* harmony export */
                base64ToArray: () => (
                  /* binding */
                  base64ToArray
                ),
                /* harmony export */
                deepCopy: () => (
                  /* binding */
                  deepCopy
                ),
                /* harmony export */
                download: () => (
                  /* binding */
                  download
                ),
                /* harmony export */
                extend: () => (
                  /* binding */
                  extend
                ),
                /* harmony export */
                get: () => (
                  /* binding */
                  get
                ),
                /* harmony export */
                getAtomProperty: () => (
                  /* binding */
                  getAtomProperty
                ),
                /* harmony export */
                getColorFromStyle: () => (
                  /* binding */
                  getColorFromStyle
                ),
                /* harmony export */
                getElement: () => (
                  /* binding */
                  getElement
                ),
                /* harmony export */
                getExtent: () => (
                  /* binding */
                  getExtent
                ),
                /* harmony export */
                getPropertyRange: () => (
                  /* binding */
                  getPropertyRange
                ),
                /* harmony export */
                getbin: () => (
                  /* binding */
                  getbin
                ),
                /* harmony export */
                inflateString: () => (
                  /* binding */
                  inflateString
                ),
                /* harmony export */
                isEmptyObject: () => (
                  /* binding */
                  isEmptyObject
                ),
                /* harmony export */
                isNumeric: () => (
                  /* binding */
                  isNumeric
                ),
                /* harmony export */
                makeFunction: () => (
                  /* binding */
                  makeFunction
                ),
                /* harmony export */
                mergeGeos: () => (
                  /* binding */
                  mergeGeos
                ),
                /* harmony export */
                specStringToObject: () => (
                  /* binding */
                  specStringToObject
                )
                /* harmony export */
              });
              var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ./Gradient */
                "./src/Gradient.ts"
              );
              var _VolumeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ./VolumeData */
                "./src/VolumeData.ts"
              );
              var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
                /*! ./colors */
                "./src/colors.ts"
              );
              var pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
                /*! pako */
                "./node_modules/pako/dist/pako.esm.mjs"
              );
              function extend(obj1, src1) {
                for (var key in src1) {
                  if (src1.hasOwnProperty(key) && src1[key] !== void 0) {
                    obj1[key] = src1[key];
                  }
                }
                return obj1;
              }
              ;
              function deepCopy(inObject) {
                let outObject, value, key;
                if (inObject == void 0) {
                  return {};
                }
                if (typeof inObject !== "object" || inObject === null) {
                  return inObject;
                }
                outObject = Array.isArray(inObject) ? [] : {};
                for (key in inObject) {
                  value = inObject[key];
                  outObject[key] = deepCopy(value);
                }
                return outObject;
              }
              ;
              function isNumeric(obj) {
                var type = typeof obj;
                return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
              }
              ;
              function isEmptyObject(obj) {
                return Object.keys(obj).length === 0;
              }
              ;
              function makeFunction(callback) {
                if (callback && typeof callback === "string") {
                  callback = eval("(" + callback + ")");
                }
                if (callback && typeof callback != "function") {
                  console.warn("Invalid callback provided.");
                  return () => {
                  };
                }
                return callback;
              }
              ;
              function adjustVolumeStyle(style) {
                if (style) {
                  if (style.volformat && !(style.voldata instanceof _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData)) {
                    style.voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData(style.voldata, style.volformat);
                  }
                  if (style.volscheme) {
                    style.volscheme = _Gradient__WEBPACK_IMPORTED_MODULE_0__.Gradient.getGradient(style.volscheme);
                  }
                }
              }
              ;
              function getExtent(atomlist, ignoreSymmetries) {
                var xmin, ymin, zmin, xmax, ymax, zmax, xsum, ysum, zsum, cnt;
                var includeSym = !ignoreSymmetries;
                xmin = ymin = zmin = 9999;
                xmax = ymax = zmax = -9999;
                xsum = ysum = zsum = cnt = 0;
                if (atomlist.length === 0)
                  return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
                for (var i = 0; i < atomlist.length; i++) {
                  var atom = atomlist[i];
                  if (typeof atom === "undefined" || !isFinite(atom.x) || !isFinite(atom.y) || !isFinite(atom.z))
                    continue;
                  cnt++;
                  xsum += atom.x;
                  ysum += atom.y;
                  zsum += atom.z;
                  xmin = xmin < atom.x ? xmin : atom.x;
                  ymin = ymin < atom.y ? ymin : atom.y;
                  zmin = zmin < atom.z ? zmin : atom.z;
                  xmax = xmax > atom.x ? xmax : atom.x;
                  ymax = ymax > atom.y ? ymax : atom.y;
                  zmax = zmax > atom.z ? zmax : atom.z;
                  if (atom.symmetries && includeSym) {
                    for (var n = 0; n < atom.symmetries.length; n++) {
                      cnt++;
                      xsum += atom.symmetries[n].x;
                      ysum += atom.symmetries[n].y;
                      zsum += atom.symmetries[n].z;
                      xmin = xmin < atom.symmetries[n].x ? xmin : atom.symmetries[n].x;
                      ymin = ymin < atom.symmetries[n].y ? ymin : atom.symmetries[n].y;
                      zmin = zmin < atom.symmetries[n].z ? zmin : atom.symmetries[n].z;
                      xmax = xmax > atom.symmetries[n].x ? xmax : atom.symmetries[n].x;
                      ymax = ymax > atom.symmetries[n].y ? ymax : atom.symmetries[n].y;
                      zmax = zmax > atom.symmetries[n].z ? zmax : atom.symmetries[n].z;
                    }
                  }
                }
                return [
                  [xmin, ymin, zmin],
                  [xmax, ymax, zmax],
                  [xsum / cnt, ysum / cnt, zsum / cnt]
                ];
              }
              ;
              function getPropertyRange(atomlist, prop) {
                var min = Number.POSITIVE_INFINITY;
                var max = Number.NEGATIVE_INFINITY;
                for (var i = 0, n = atomlist.length; i < n; i++) {
                  var atom = atomlist[i];
                  var val = getAtomProperty(atom, prop);
                  if (val != null) {
                    if (val < min)
                      min = val;
                    if (val > max)
                      max = val;
                  }
                }
                if (!isFinite(min) && !isFinite(max))
                  min = max = 0;
                else if (!isFinite(min))
                  min = max;
                else if (!isFinite(max))
                  max = min;
                return [min, max];
              }
              ;
              class PausableTimer {
                constructor(fn, countdown, arg) {
                  this.total_time_run = 0;
                  this.fn = fn;
                  this.arg = arg;
                  this.countdown = countdown;
                  this.start_time = (/* @__PURE__ */ new Date()).getTime();
                  this.ident = setTimeout(fn, countdown, arg);
                }
                cancel() {
                  clearTimeout(this.ident);
                }
                pause() {
                  clearTimeout(this.ident);
                  this.total_time_run = (/* @__PURE__ */ new Date()).getTime() - this.start_time;
                }
                resume() {
                  this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);
                }
              }
              ;
              function base64ToArray(base64) {
                var binary_string = window.atob(base64);
                var len = binary_string.length;
                var bytes = new Uint8Array(len);
                for (var i = 0; i < len; i++) {
                  bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes;
              }
              ;
              function getAtomProperty(atom, prop) {
                var val = null;
                if (atom.properties && typeof atom.properties[prop] != "undefined") {
                  val = atom.properties[prop];
                } else if (typeof atom[prop] != "undefined") {
                  val = atom[prop];
                }
                return val;
              }
              ;
              function mergeGeos(geometry, mesh) {
                var meshGeo = mesh.geometry;
                if (meshGeo === void 0)
                  return;
                geometry.geometryGroups.push(meshGeo.geometryGroups[0]);
              }
              ;
              function specStringToObject(str) {
                if (typeof str === "object") {
                  return str;
                } else if (typeof str === "undefined" || str == null) {
                  return str;
                }
                try {
                  let parsed = JSON.parse(str);
                  return parsed;
                } catch (error) {
                }
                str = str.replace(/%7E/g, "~");
                var massage = function(val2) {
                  if (isNumeric(val2)) {
                    if (Math.floor(parseFloat(val2)) == parseInt(val2)) {
                      return parseFloat(val2);
                    } else if (val2.indexOf(".") >= 0) {
                      return parseFloat(val2);
                    } else {
                      return parseInt(val2);
                    }
                  } else if (val2 === "true") {
                    return true;
                  } else if (val2 === "false") {
                    return false;
                  }
                  return val2;
                };
                var ret = {};
                if (str === "all")
                  return ret;
                var fields = str.split(";");
                for (var i = 0; i < fields.length; i++) {
                  var fv = fields[i].split(":");
                  var f = fv[0];
                  var val = {};
                  var vstr = fv[1];
                  if (vstr) {
                    vstr = vstr.replace(/~/g, "=");
                    if (vstr.indexOf("=") !== -1) {
                      var kvs = vstr.split(",");
                      for (var j = 0; j < kvs.length; j++) {
                        var kv = kvs[j].split("=", 2);
                        val[kv[0]] = massage(kv[1]);
                      }
                    } else if (vstr.indexOf(",") !== -1) {
                      val = vstr.split(",");
                    } else {
                      val = massage(vstr);
                    }
                  }
                  ret[f] = val;
                }
                return ret;
              }
              ;
              function checkStatus(response) {
                if (!response.ok) {
                  throw new Error(`HTTP ${response.status} - ${response.statusText}`);
                }
                return response;
              }
              function get(uri, callback2) {
                var promise = fetch(uri).then(checkStatus).then((response) => response.text());
                if (callback2)
                  return promise.then(callback2);
                else
                  return promise;
              }
              function getbin(uri, callback2, request, postdata) {
                var promise;
                if (request == "POST") {
                  promise = fetch(uri, { method: "POST", body: postdata }).then((response) => checkStatus(response)).then((response) => response.arrayBuffer());
                } else {
                  promise = fetch(uri).then((response) => checkStatus(response)).then((response) => response.arrayBuffer());
                }
                if (callback2)
                  return promise.then(callback2);
                else
                  return promise;
              }
              ;
              function download(query, viewer, options, callback2) {
                var type = "";
                var pdbUri = "";
                var uri = "";
                var promise = null;
                var m = viewer.addModel();
                if (query.indexOf(":") < 0) {
                  if (query.length == 4) {
                    query = "pdb:" + query;
                  } else if (!isNaN(query)) {
                    query = "cid:" + query;
                  } else {
                    query = "url:" + query;
                  }
                }
                if (query.substring(0, 5) == "mmtf:") {
                  console.warn("WARNING: MMTF now deprecated.  Reverting to bcif.");
                  query = "bcif:" + query.slice(5);
                }
                if (query.substring(0, 5) === "bcif:") {
                  query = query.substring(5).toUpperCase();
                  uri = "https://models.rcsb.org/" + query + ".bcif.gz";
                  if (options && typeof options.noComputeSecondaryStructure === "undefined") {
                    options.noComputeSecondaryStructure = true;
                  }
                  promise = new Promise(function(resolve) {
                    getbin(uri).then(function(ret) {
                      m.addMolData(ret, "bcif.gz", options);
                      viewer.zoomTo();
                      viewer.render();
                      resolve(m);
                    }, function() {
                      console.error("fetch of " + uri + " failed.");
                    });
                  });
                } else {
                  if (query.substring(0, 4) === "pdb:") {
                    type = "bcif";
                    if (options && options.format) {
                      type = options.format;
                    }
                    if (options && typeof options.noComputeSecondaryStructure === "undefined") {
                      options.noComputeSecondaryStructure = true;
                    }
                    query = query.substring(4).toUpperCase();
                    if (!query.match(/^[1-9][A-Za-z0-9]{3}$/)) {
                      alert("Wrong PDB ID");
                      return;
                    }
                    if (type == "bcif") {
                      uri = "https://models.rcsb.org/" + query.toUpperCase() + ".bcif.gz";
                    } else {
                      pdbUri = options && options.pdbUri ? options.pdbUri : "https://files.rcsb.org/view/";
                      uri = pdbUri + query + "." + type;
                    }
                  } else if (query.substring(0, 4) == "cid:") {
                    type = "sdf";
                    query = query.substring(4);
                    if (!query.match(/^[0-9]+$/)) {
                      alert("Wrong Compound ID");
                      return;
                    }
                    uri = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + query + "/SDF?record_type=3d";
                  } else if (query.substring(0, 4) == "url:") {
                    uri = query.substring(4);
                    type = uri;
                  }
                  var handler = function(ret) {
                    m.addMolData(ret, type, options);
                    viewer.zoomTo();
                    viewer.render();
                  };
                  promise = new Promise(function(resolve) {
                    if (type == "bcif") {
                      getbin(uri).then(function(ret) {
                        handler(ret);
                        resolve(m);
                      }).catch(function() {
                        pdbUri = options && options.pdbUri ? options.pdbUri : "https://files.rcsb.org/view/";
                        uri = pdbUri + query + ".pdb";
                        type = "pdb";
                        console.warn("falling back to pdb format");
                        get(uri).then(function(data) {
                          handler(data);
                          resolve(m);
                        }).catch(function(e) {
                          handler("");
                          resolve(m);
                          console.error("fetch of " + uri + " failed: " + e.statusText);
                        });
                      });
                    } else {
                      get(uri).then(function(data) {
                        handler(data);
                        resolve(m);
                      }).catch(function(e) {
                        handler("");
                        resolve(m);
                        console.error("fetch of " + uri + " failed: " + e.statusText);
                      });
                    }
                  });
                }
                if (callback2) {
                  promise.then(function(m2) {
                    callback2(m2);
                  });
                  return m;
                } else
                  return promise;
              }
              ;
              function getColorFromStyle(atom, style) {
                let scheme = style.colorscheme;
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme] != "undefined") {
                  scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme];
                } else if (typeof scheme == "string" && scheme.endsWith("Carbon")) {
                  let ccolor = scheme.substring(0, scheme.lastIndexOf("Carbon")).toLowerCase();
                  if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[ccolor] != "undefined") {
                    let newscheme = Object.assign({}, _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors);
                    newscheme.C = _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[ccolor];
                    _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme] = { prop: "elem", map: newscheme };
                    scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme];
                  }
                }
                let color = atom.color;
                if (typeof style.color != "undefined" && style.color != "spectrum")
                  color = style.color;
                if (typeof scheme != "undefined") {
                  let prop, val;
                  if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[scheme] != "undefined") {
                    scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[scheme];
                    if (typeof scheme[atom[scheme.prop]] != "undefined") {
                      color = scheme.map[atom[scheme.prop]];
                    }
                  } else if (typeof scheme[atom[scheme.prop]] != "undefined") {
                    color = scheme.map[atom[scheme.prop]];
                  } else if (typeof scheme.prop != "undefined" && typeof scheme.gradient != "undefined") {
                    prop = scheme.prop;
                    var grad = scheme.gradient;
                    if (!(grad instanceof _Gradient__WEBPACK_IMPORTED_MODULE_0__.GradientType)) {
                      grad = (0, _Gradient__WEBPACK_IMPORTED_MODULE_0__.getGradient)(scheme);
                    }
                    let range = grad.range() || [-1, 1];
                    val = getAtomProperty(atom, prop);
                    if (val != null) {
                      color = grad.valueToHex(val, range);
                    }
                  } else if (typeof scheme.prop != "undefined" && typeof scheme.map != "undefined") {
                    prop = scheme.prop;
                    val = getAtomProperty(atom, prop);
                    if (typeof scheme.map[val] != "undefined") {
                      color = scheme.map[val];
                    }
                  } else if (typeof style.colorscheme[atom.elem] != "undefined") {
                    color = style.colorscheme[atom.elem];
                  } else {
                    console.warn("Could not interpret colorscheme " + scheme);
                  }
                } else if (typeof style.colorfunc != "undefined") {
                  color = style.colorfunc(atom);
                }
                let C = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(color);
                return C;
              }
              ;
              function getElement(element) {
                let ret = element;
                if (typeof element === "string") {
                  ret = document.querySelector("#" + element);
                } else if (typeof element === "object" && element.get) {
                  ret = element.get(0);
                }
                return ret;
              }
              function inflateString(str, tostring = true) {
                let data;
                if (typeof str === "string") {
                  const encoder = new TextEncoder();
                  data = encoder.encode(str);
                } else {
                  data = new Uint8Array(str);
                }
                const inflatedData = (0, pako__WEBPACK_IMPORTED_MODULE_3__.inflate)(data, {
                  to: tostring ? "string" : null
                });
                return inflatedData;
              }
            },
            /***/
            "./src/vendor/mmtf.js"(__unused_webpack_module2, exports2) {
              !(function(r, t) {
                true ? t(exports2) : 0;
              })(this, function(r) {
                "use strict";
                function t(r2, t2, n2) {
                  for (var e2 = (r2.byteLength, 0), i2 = n2.length; i2 > e2; e2++) {
                    var o2 = n2.charCodeAt(e2);
                    if (128 > o2) r2.setUint8(t2++, o2 >>> 0 & 127 | 0);
                    else if (2048 > o2) r2.setUint8(t2++, o2 >>> 6 & 31 | 192), r2.setUint8(t2++, o2 >>> 0 & 63 | 128);
                    else if (65536 > o2) r2.setUint8(t2++, o2 >>> 12 & 15 | 224), r2.setUint8(t2++, o2 >>> 6 & 63 | 128), r2.setUint8(t2++, o2 >>> 0 & 63 | 128);
                    else {
                      if (!(1114112 > o2)) throw new Error("bad codepoint " + o2);
                      r2.setUint8(t2++, o2 >>> 18 & 7 | 240), r2.setUint8(t2++, o2 >>> 12 & 63 | 128), r2.setUint8(t2++, o2 >>> 6 & 63 | 128), r2.setUint8(t2++, o2 >>> 0 & 63 | 128);
                    }
                  }
                }
                function n(r2) {
                  for (var t2 = 0, n2 = 0, e2 = r2.length; e2 > n2; n2++) {
                    var i2 = r2.charCodeAt(n2);
                    if (128 > i2) t2 += 1;
                    else if (2048 > i2) t2 += 2;
                    else if (65536 > i2) t2 += 3;
                    else {
                      if (!(1114112 > i2)) throw new Error("bad codepoint " + i2);
                      t2 += 4;
                    }
                  }
                  return t2;
                }
                function e(r2, i2, o2) {
                  var a2 = typeof r2;
                  if ("string" === a2) {
                    var u2 = n(r2);
                    if (32 > u2) return i2.setUint8(o2, 160 | u2), t(i2, o2 + 1, r2), 1 + u2;
                    if (256 > u2) return i2.setUint8(o2, 217), i2.setUint8(o2 + 1, u2), t(i2, o2 + 2, r2), 2 + u2;
                    if (65536 > u2) return i2.setUint8(o2, 218), i2.setUint16(o2 + 1, u2), t(i2, o2 + 3, r2), 3 + u2;
                    if (4294967296 > u2) return i2.setUint8(o2, 219), i2.setUint32(o2 + 1, u2), t(i2, o2 + 5, r2), 5 + u2;
                  }
                  if (r2 instanceof Uint8Array) {
                    var u2 = r2.byteLength, s2 = new Uint8Array(i2.buffer);
                    if (256 > u2) return i2.setUint8(o2, 196), i2.setUint8(o2 + 1, u2), s2.set(r2, o2 + 2), 2 + u2;
                    if (65536 > u2) return i2.setUint8(o2, 197), i2.setUint16(o2 + 1, u2), s2.set(r2, o2 + 3), 3 + u2;
                    if (4294967296 > u2) return i2.setUint8(o2, 198), i2.setUint32(o2 + 1, u2), s2.set(r2, o2 + 5), 5 + u2;
                  }
                  if ("number" === a2) {
                    if (!isFinite(r2)) throw new Error("Number not finite: " + r2);
                    if (Math.floor(r2) !== r2) return i2.setUint8(o2, 203), i2.setFloat64(o2 + 1, r2), 9;
                    if (r2 >= 0) {
                      if (128 > r2) return i2.setUint8(o2, r2), 1;
                      if (256 > r2) return i2.setUint8(o2, 204), i2.setUint8(o2 + 1, r2), 2;
                      if (65536 > r2) return i2.setUint8(o2, 205), i2.setUint16(o2 + 1, r2), 3;
                      if (4294967296 > r2) return i2.setUint8(o2, 206), i2.setUint32(o2 + 1, r2), 5;
                      throw new Error("Number too big 0x" + r2.toString(16));
                    }
                    if (r2 >= -32) return i2.setInt8(o2, r2), 1;
                    if (r2 >= -128) return i2.setUint8(o2, 208), i2.setInt8(o2 + 1, r2), 2;
                    if (r2 >= -32768) return i2.setUint8(o2, 209), i2.setInt16(o2 + 1, r2), 3;
                    if (r2 >= -2147483648) return i2.setUint8(o2, 210), i2.setInt32(o2 + 1, r2), 5;
                    throw new Error("Number too small -0x" + (-r2).toString(16).substr(1));
                  }
                  if (null === r2) return i2.setUint8(o2, 192), 1;
                  if ("boolean" === a2) return i2.setUint8(o2, r2 ? 195 : 194), 1;
                  if ("object" === a2) {
                    var u2, f2 = 0, c2 = Array.isArray(r2);
                    if (c2) u2 = r2.length;
                    else {
                      var d2 = Object.keys(r2);
                      u2 = d2.length;
                    }
                    var f2;
                    if (16 > u2 ? (i2.setUint8(o2, u2 | (c2 ? 144 : 128)), f2 = 1) : 65536 > u2 ? (i2.setUint8(o2, c2 ? 220 : 222), i2.setUint16(o2 + 1, u2), f2 = 3) : 4294967296 > u2 && (i2.setUint8(o2, c2 ? 221 : 223), i2.setUint32(o2 + 1, u2), f2 = 5), c2) for (var l2 = 0; u2 > l2; l2++) f2 += e(r2[l2], i2, o2 + f2);
                    else for (var l2 = 0; u2 > l2; l2++) {
                      var g2 = d2[l2];
                      f2 += e(g2, i2, o2 + f2), f2 += e(r2[g2], i2, o2 + f2);
                    }
                    return f2;
                  }
                  throw new Error("Unknown type " + a2);
                }
                function i(r2) {
                  var t2 = typeof r2;
                  if ("string" === t2) {
                    var e2 = n(r2);
                    if (32 > e2) return 1 + e2;
                    if (256 > e2) return 2 + e2;
                    if (65536 > e2) return 3 + e2;
                    if (4294967296 > e2) return 5 + e2;
                  }
                  if (r2 instanceof Uint8Array) {
                    var e2 = r2.byteLength;
                    if (256 > e2) return 2 + e2;
                    if (65536 > e2) return 3 + e2;
                    if (4294967296 > e2) return 5 + e2;
                  }
                  if ("number" === t2) {
                    if (Math.floor(r2) !== r2) return 9;
                    if (r2 >= 0) {
                      if (128 > r2) return 1;
                      if (256 > r2) return 2;
                      if (65536 > r2) return 3;
                      if (4294967296 > r2) return 5;
                      throw new Error("Number too big 0x" + r2.toString(16));
                    }
                    if (r2 >= -32) return 1;
                    if (r2 >= -128) return 2;
                    if (r2 >= -32768) return 3;
                    if (r2 >= -2147483648) return 5;
                    throw new Error("Number too small -0x" + r2.toString(16).substr(1));
                  }
                  if ("boolean" === t2 || null === r2) return 1;
                  if ("object" === t2) {
                    var e2, o2 = 0;
                    if (Array.isArray(r2)) {
                      e2 = r2.length;
                      for (var a2 = 0; e2 > a2; a2++) o2 += i(r2[a2]);
                    } else {
                      var u2 = Object.keys(r2);
                      e2 = u2.length;
                      for (var a2 = 0; e2 > a2; a2++) {
                        var s2 = u2[a2];
                        o2 += i(s2) + i(r2[s2]);
                      }
                    }
                    if (16 > e2) return 1 + o2;
                    if (65536 > e2) return 3 + o2;
                    if (4294967296 > e2) return 5 + o2;
                    throw new Error("Array or object too long 0x" + e2.toString(16));
                  }
                  throw new Error("Unknown type " + t2);
                }
                function o(r2) {
                  var t2 = new ArrayBuffer(i(r2)), n2 = new DataView(t2);
                  return e(r2, n2, 0), new Uint8Array(t2);
                }
                function a(r2, t2, n2) {
                  return t2 ? new r2(t2.buffer, t2.byteOffset, t2.byteLength / (n2 || 1)) : void 0;
                }
                function u(r2) {
                  return a(DataView, r2);
                }
                function s(r2) {
                  return a(Uint8Array, r2);
                }
                function f(r2) {
                  return a(Int8Array, r2);
                }
                function c(r2) {
                  return a(Int32Array, r2, 4);
                }
                function d(r2) {
                  return a(Float32Array, r2, 4);
                }
                function l(r2, t2) {
                  var n2 = r2.length / 2;
                  t2 || (t2 = new Int16Array(n2));
                  for (var e2 = 0, i2 = 0; n2 > e2; ++e2, i2 += 2) t2[e2] = r2[i2] << 8 ^ r2[i2 + 1] << 0;
                  return t2;
                }
                function g(r2, t2) {
                  var n2 = r2.length;
                  t2 || (t2 = new Uint8Array(2 * n2));
                  for (var e2 = u(t2), i2 = 0; n2 > i2; ++i2) e2.setInt16(2 * i2, r2[i2]);
                  return s(t2);
                }
                function v(r2, t2) {
                  var n2 = r2.length / 4;
                  t2 || (t2 = new Int32Array(n2));
                  for (var e2 = 0, i2 = 0; n2 > e2; ++e2, i2 += 4) t2[e2] = r2[i2] << 24 ^ r2[i2 + 1] << 16 ^ r2[i2 + 2] << 8 ^ r2[i2 + 3] << 0;
                  return t2;
                }
                function L(r2, t2) {
                  var n2 = r2.length;
                  t2 || (t2 = new Uint8Array(4 * n2));
                  for (var e2 = u(t2), i2 = 0; n2 > i2; ++i2) e2.setInt32(4 * i2, r2[i2]);
                  return s(t2);
                }
                function h(r2, t2) {
                  var n2 = r2.length;
                  t2 || (t2 = new Float32Array(n2 / 4));
                  for (var e2 = u(t2), i2 = u(r2), o2 = 0, a2 = 0, s2 = n2 / 4; s2 > o2; ++o2, a2 += 4) e2.setFloat32(a2, i2.getFloat32(a2), true);
                  return t2;
                }
                function y(r2, t2, n2) {
                  var e2 = r2.length, i2 = 1 / t2;
                  n2 || (n2 = new Float32Array(e2));
                  for (var o2 = 0; e2 > o2; ++o2) n2[o2] = r2[o2] * i2;
                  return n2;
                }
                function m(r2, t2, n2) {
                  var e2 = r2.length;
                  n2 || (n2 = new Int32Array(e2));
                  for (var i2 = 0; e2 > i2; ++i2) n2[i2] = Math.round(r2[i2] * t2);
                  return n2;
                }
                function p(r2, t2) {
                  var n2, e2;
                  if (!t2) {
                    var i2 = 0;
                    for (n2 = 0, e2 = r2.length; e2 > n2; n2 += 2) i2 += r2[n2 + 1];
                    t2 = new r2.constructor(i2);
                  }
                  var o2 = 0;
                  for (n2 = 0, e2 = r2.length; e2 > n2; n2 += 2) for (var a2 = r2[n2], u2 = r2[n2 + 1], s2 = 0; u2 > s2; ++s2) t2[o2] = a2, ++o2;
                  return t2;
                }
                function U(r2) {
                  if (0 === r2.length) return new Int32Array();
                  var t2, n2, e2 = 2;
                  for (t2 = 1, n2 = r2.length; n2 > t2; ++t2) r2[t2 - 1] !== r2[t2] && (e2 += 2);
                  var i2 = new Int32Array(e2), o2 = 0, a2 = 1;
                  for (t2 = 1, n2 = r2.length; n2 > t2; ++t2) r2[t2 - 1] !== r2[t2] ? (i2[o2] = r2[t2 - 1], i2[o2 + 1] = a2, a2 = 1, o2 += 2) : ++a2;
                  return i2[o2] = r2[r2.length - 1], i2[o2 + 1] = a2, i2;
                }
                function b(r2, t2) {
                  var n2 = r2.length;
                  t2 || (t2 = new r2.constructor(n2)), n2 && (t2[0] = r2[0]);
                  for (var e2 = 1; n2 > e2; ++e2) t2[e2] = r2[e2] + t2[e2 - 1];
                  return t2;
                }
                function I(r2, t2) {
                  var n2 = r2.length;
                  t2 || (t2 = new r2.constructor(n2)), t2[0] = r2[0];
                  for (var e2 = 1; n2 > e2; ++e2) t2[e2] = r2[e2] - r2[e2 - 1];
                  return t2;
                }
                function w(r2, t2) {
                  var n2, e2, i2 = r2 instanceof Int8Array ? 127 : 32767, o2 = -i2 - 1, a2 = r2.length;
                  if (!t2) {
                    var u2 = 0;
                    for (n2 = 0; a2 > n2; ++n2) r2[n2] < i2 && r2[n2] > o2 && ++u2;
                    t2 = new Int32Array(u2);
                  }
                  for (n2 = 0, e2 = 0; a2 > n2; ) {
                    for (var s2 = 0; r2[n2] === i2 || r2[n2] === o2; ) s2 += r2[n2], ++n2;
                    s2 += r2[n2], ++n2, t2[e2] = s2, ++e2;
                  }
                  return t2;
                }
                function C(r2, t2) {
                  var n2, e2 = t2 ? 127 : 32767, i2 = -e2 - 1, o2 = r2.length, a2 = 0;
                  for (n2 = 0; o2 > n2; ++n2) {
                    var u2 = r2[n2];
                    0 === u2 ? ++a2 : u2 > 0 ? (a2 += Math.ceil(u2 / e2), u2 % e2 === 0 && (a2 += 1)) : (a2 += Math.ceil(u2 / i2), u2 % i2 === 0 && (a2 += 1));
                  }
                  var s2 = t2 ? new Int8Array(a2) : new Int16Array(a2), f2 = 0;
                  for (n2 = 0; o2 > n2; ++n2) {
                    var u2 = r2[n2];
                    if (u2 >= 0) for (; u2 >= e2; ) s2[f2] = e2, ++f2, u2 -= e2;
                    else for (; i2 >= u2; ) s2[f2] = i2, ++f2, u2 -= i2;
                    s2[f2] = u2, ++f2;
                  }
                  return s2;
                }
                function A(r2, t2) {
                  return b(p(r2), t2);
                }
                function x(r2) {
                  return U(I(r2));
                }
                function M(r2, t2, n2) {
                  return y(p(r2, c(n2)), t2, n2);
                }
                function F(r2, t2) {
                  return U(m(r2, t2));
                }
                function S(r2, t2, n2) {
                  return y(b(r2, c(n2)), t2, n2);
                }
                function E(r2, t2, n2) {
                  return I(m(r2, t2), n2);
                }
                function N(r2, t2, n2) {
                  return y(w(r2, c(n2)), t2, n2);
                }
                function O(r2, t2, n2) {
                  var e2 = w(r2, c(n2));
                  return S(e2, t2, d(e2));
                }
                function T(r2, t2, n2) {
                  return C(E(r2, t2), n2);
                }
                function k(r2) {
                  var t2 = u(r2), n2 = t2.getInt32(0), e2 = t2.getInt32(4), i2 = r2.subarray(8, 12), r2 = r2.subarray(12);
                  return [n2, r2, e2, i2];
                }
                function j(r2, t2, n2, e2) {
                  var i2 = new ArrayBuffer(12 + e2.byteLength), o2 = new Uint8Array(i2), a2 = new DataView(i2);
                  return a2.setInt32(0, r2), a2.setInt32(4, t2), n2 && o2.set(n2, 8), o2.set(e2, 12), o2;
                }
                function q(r2) {
                  var t2 = r2.length, n2 = s(r2);
                  return j(2, t2, void 0, n2);
                }
                function D(r2) {
                  var t2 = r2.length, n2 = L(r2);
                  return j(4, t2, void 0, n2);
                }
                function P(r2, t2) {
                  var n2 = r2.length / t2, e2 = L([t2]), i2 = s(r2);
                  return j(5, n2, e2, i2);
                }
                function z(r2) {
                  var t2 = r2.length, n2 = L(U(r2));
                  return j(6, t2, void 0, n2);
                }
                function B(r2) {
                  var t2 = r2.length, n2 = L(x(r2));
                  return j(8, t2, void 0, n2);
                }
                function V(r2, t2) {
                  var n2 = r2.length, e2 = L([t2]), i2 = L(F(r2, t2));
                  return j(9, n2, e2, i2);
                }
                function G(r2, t2) {
                  var n2 = r2.length, e2 = L([t2]), i2 = g(T(r2, t2));
                  return j(10, n2, e2, i2);
                }
                function R(r2) {
                  var t2 = {};
                  return rr.forEach(function(n2) {
                    void 0 !== r2[n2] && (t2[n2] = r2[n2]);
                  }), r2.bondAtomList && (t2.bondAtomList = D(r2.bondAtomList)), r2.bondOrderList && (t2.bondOrderList = q(r2.bondOrderList)), t2.xCoordList = G(r2.xCoordList, 1e3), t2.yCoordList = G(r2.yCoordList, 1e3), t2.zCoordList = G(r2.zCoordList, 1e3), r2.bFactorList && (t2.bFactorList = G(r2.bFactorList, 100)), r2.atomIdList && (t2.atomIdList = B(r2.atomIdList)), r2.altLocList && (t2.altLocList = z(r2.altLocList)), r2.occupancyList && (t2.occupancyList = V(r2.occupancyList, 100)), t2.groupIdList = B(r2.groupIdList), t2.groupTypeList = D(r2.groupTypeList), r2.secStructList && (t2.secStructList = q(r2.secStructList)), r2.insCodeList && (t2.insCodeList = z(r2.insCodeList)), r2.sequenceIndexList && (t2.sequenceIndexList = B(r2.sequenceIndexList)), t2.chainIdList = P(r2.chainIdList, 4), r2.chainNameList && (t2.chainNameList = P(r2.chainNameList, 4)), t2;
                }
                function H(r2) {
                  function t2(r3) {
                    for (var t3 = {}, n3 = 0; r3 > n3; n3++) {
                      var e3 = o2();
                      t3[e3] = o2();
                    }
                    return t3;
                  }
                  function n2(t3) {
                    var n3 = r2.subarray(a2, a2 + t3);
                    return a2 += t3, n3;
                  }
                  function e2(t3) {
                    var n3 = r2.subarray(a2, a2 + t3);
                    a2 += t3;
                    var e3 = 65535;
                    if (t3 > e3) {
                      for (var i3 = [], o3 = 0; o3 < n3.length; o3 += e3) i3.push(String.fromCharCode.apply(null, n3.subarray(o3, o3 + e3)));
                      return i3.join("");
                    }
                    return String.fromCharCode.apply(null, n3);
                  }
                  function i2(r3) {
                    for (var t3 = new Array(r3), n3 = 0; r3 > n3; n3++) t3[n3] = o2();
                    return t3;
                  }
                  function o2() {
                    var o3, s2, f2 = r2[a2];
                    if (0 === (128 & f2)) return a2++, f2;
                    if (128 === (240 & f2)) return s2 = 15 & f2, a2++, t2(s2);
                    if (144 === (240 & f2)) return s2 = 15 & f2, a2++, i2(s2);
                    if (160 === (224 & f2)) return s2 = 31 & f2, a2++, e2(s2);
                    if (224 === (224 & f2)) return o3 = u2.getInt8(a2), a2++, o3;
                    switch (f2) {
                      case 192:
                        return a2++, null;
                      case 194:
                        return a2++, false;
                      case 195:
                        return a2++, true;
                      case 196:
                        return s2 = u2.getUint8(a2 + 1), a2 += 2, n2(s2);
                      case 197:
                        return s2 = u2.getUint16(a2 + 1), a2 += 3, n2(s2);
                      case 198:
                        return s2 = u2.getUint32(a2 + 1), a2 += 5, n2(s2);
                      case 202:
                        return o3 = u2.getFloat32(a2 + 1), a2 += 5, o3;
                      case 203:
                        return o3 = u2.getFloat64(a2 + 1), a2 += 9, o3;
                      case 204:
                        return o3 = r2[a2 + 1], a2 += 2, o3;
                      case 205:
                        return o3 = u2.getUint16(a2 + 1), a2 += 3, o3;
                      case 206:
                        return o3 = u2.getUint32(a2 + 1), a2 += 5, o3;
                      case 208:
                        return o3 = u2.getInt8(a2 + 1), a2 += 2, o3;
                      case 209:
                        return o3 = u2.getInt16(a2 + 1), a2 += 3, o3;
                      case 210:
                        return o3 = u2.getInt32(a2 + 1), a2 += 5, o3;
                      case 217:
                        return s2 = u2.getUint8(a2 + 1), a2 += 2, e2(s2);
                      case 218:
                        return s2 = u2.getUint16(a2 + 1), a2 += 3, e2(s2);
                      case 219:
                        return s2 = u2.getUint32(a2 + 1), a2 += 5, e2(s2);
                      case 220:
                        return s2 = u2.getUint16(a2 + 1), a2 += 3, i2(s2);
                      case 221:
                        return s2 = u2.getUint32(a2 + 1), a2 += 5, i2(s2);
                      case 222:
                        return s2 = u2.getUint16(a2 + 1), a2 += 3, t2(s2);
                      case 223:
                        return s2 = u2.getUint32(a2 + 1), a2 += 5, t2(s2);
                    }
                    throw new Error("Unknown type 0x" + f2.toString(16));
                  }
                  var a2 = 0, u2 = new DataView(r2.buffer);
                  return o2();
                }
                function W(r2, t2, n2, e2) {
                  switch (r2) {
                    case 1:
                      return h(t2);
                    case 2:
                      return f(t2);
                    case 3:
                      return l(t2);
                    case 4:
                      return v(t2);
                    case 5:
                      return s(t2);
                    case 6:
                      return p(v(t2), new Uint8Array(n2));
                    case 7:
                      return p(v(t2));
                    case 8:
                      return A(v(t2));
                    case 9:
                      return M(v(t2), v(e2)[0]);
                    case 10:
                      return O(l(t2), v(e2)[0]);
                    case 11:
                      return y(l(t2), v(e2)[0]);
                    case 12:
                      return N(l(t2), v(e2)[0]);
                    case 13:
                      return N(f(t2), v(e2)[0]);
                    case 14:
                      return w(l(t2));
                    case 15:
                      return w(f(t2));
                  }
                }
                function X(r2, t2) {
                  t2 = t2 || {};
                  var n2 = t2.ignoreFields, e2 = {};
                  return nr.forEach(function(t3) {
                    var i2 = n2 ? -1 !== n2.indexOf(t3) : false, o2 = r2[t3];
                    i2 || void 0 === o2 || (o2 instanceof Uint8Array ? e2[t3] = W.apply(null, k(o2)) : e2[t3] = o2);
                  }), e2;
                }
                function J(r2) {
                  return String.fromCharCode.apply(null, r2).replace(/\0/g, "");
                }
                function K(r2, t2, n2) {
                  n2 = n2 || {};
                  var e2, i2, o2, a2, u2, s2, f2 = n2.firstModelOnly, c2 = t2.onModel, d2 = t2.onChain, l2 = t2.onGroup, g2 = t2.onAtom, v2 = t2.onBond, L2 = 0, h2 = 0, y2 = 0, m2 = 0, p2 = 0, U2 = -1, b2 = r2.chainNameList, I2 = r2.secStructList, w2 = r2.insCodeList, C2 = r2.sequenceIndexList, A2 = r2.atomIdList, x2 = r2.bFactorList, M2 = r2.altLocList, F2 = r2.occupancyList, S2 = r2.bondAtomList, E2 = r2.bondOrderList;
                  for (e2 = 0, i2 = r2.chainsPerModel.length; i2 > e2 && !(f2 && L2 > 0); ++e2) {
                    var N2 = r2.chainsPerModel[L2];
                    for (c2 && c2({ chainCount: N2, modelIndex: L2 }), o2 = 0; N2 > o2; ++o2) {
                      var O2 = r2.groupsPerChain[h2];
                      if (d2) {
                        var T2 = J(r2.chainIdList.subarray(4 * h2, 4 * h2 + 4)), k2 = null;
                        b2 && (k2 = J(b2.subarray(4 * h2, 4 * h2 + 4))), d2({ groupCount: O2, chainIndex: h2, modelIndex: L2, chainId: T2, chainName: k2 });
                      }
                      for (a2 = 0; O2 > a2; ++a2) {
                        var j2 = r2.groupList[r2.groupTypeList[y2]], q2 = j2.atomNameList.length;
                        if (l2) {
                          var D2 = null;
                          I2 && (D2 = I2[y2]);
                          var P2 = null;
                          r2.insCodeList && (P2 = String.fromCharCode(w2[y2]));
                          var z2 = null;
                          C2 && (z2 = C2[y2]), l2({ atomCount: q2, groupIndex: y2, chainIndex: h2, modelIndex: L2, groupId: r2.groupIdList[y2], groupType: r2.groupTypeList[y2], groupName: j2.groupName, singleLetterCode: j2.singleLetterCode, chemCompType: j2.chemCompType, secStruct: D2, insCode: P2, sequenceIndex: z2 });
                        }
                        for (u2 = 0; q2 > u2; ++u2) {
                          if (g2) {
                            var B2 = null;
                            A2 && (B2 = A2[m2]);
                            var V2 = null;
                            x2 && (V2 = x2[m2]);
                            var G2 = null;
                            M2 && (G2 = String.fromCharCode(M2[m2]));
                            var R2 = null;
                            F2 && (R2 = F2[m2]), g2({ atomIndex: m2, groupIndex: y2, chainIndex: h2, modelIndex: L2, atomId: B2, element: j2.elementList[u2], atomName: j2.atomNameList[u2], formalCharge: j2.formalChargeList[u2], xCoord: r2.xCoordList[m2], yCoord: r2.yCoordList[m2], zCoord: r2.zCoordList[m2], bFactor: V2, altLoc: G2, occupancy: R2 });
                          }
                          m2 += 1;
                        }
                        if (v2) {
                          var H2 = j2.bondAtomList;
                          for (u2 = 0, s2 = j2.bondOrderList.length; s2 > u2; ++u2) v2({ atomIndex1: m2 - q2 + H2[2 * u2], atomIndex2: m2 - q2 + H2[2 * u2 + 1], bondOrder: j2.bondOrderList[u2] });
                        }
                        y2 += 1;
                      }
                      h2 += 1;
                    }
                    if (p2 = U2 + 1, U2 = m2 - 1, v2 && S2) for (u2 = 0, s2 = S2.length; s2 > u2; u2 += 2) {
                      var W2 = S2[u2], X2 = S2[u2 + 1];
                      (W2 >= p2 && U2 >= W2 || X2 >= p2 && U2 >= X2) && v2({ atomIndex1: W2, atomIndex2: X2, bondOrder: E2 ? E2[u2 / 2] : null });
                    }
                    L2 += 1;
                  }
                }
                function Q(r2) {
                  return o(R(r2));
                }
                function Y(r2, t2) {
                  r2 instanceof ArrayBuffer && (r2 = new Uint8Array(r2));
                  var n2;
                  return n2 = r2 instanceof Uint8Array ? H(r2) : r2, X(n2, t2);
                }
                function Z(r2, t2, n2, e2) {
                  function i2() {
                    try {
                      var r3 = Y(o2.response);
                      n2(r3);
                    } catch (t3) {
                      e2(t3);
                    }
                  }
                  var o2 = new XMLHttpRequest();
                  o2.addEventListener("load", i2, true), o2.addEventListener("error", e2, true), o2.responseType = "arraybuffer", o2.open("GET", t2 + r2.toUpperCase()), o2.send();
                }
                function $(r2, t2, n2) {
                  Z(r2, or, t2, n2);
                }
                function _(r2, t2, n2) {
                  Z(r2, ar, t2, n2);
                }
                var rr = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], tr = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], nr = rr.concat(tr), er = "v1.0.1", ir = "//mmtf.rcsb.org/v1.0/", or = ir + "full/", ar = ir + "reduced/";
                r.encode = Q, r.decode = Y, r.traverse = K, r.fetch = $, r.fetchReduced = _, r.version = er, r.fetchUrl = or, r.fetchReducedUrl = ar, r.encodeMsgpack = o, r.encodeMmtf = R, r.decodeMsgpack = H, r.decodeMmtf = X;
              });
            }
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            if (__webpack_modules__[moduleId] === void 0) {
              var e = new Error("Cannot find module '" + moduleId + "'");
              e.code = "MODULE_NOT_FOUND";
              throw e;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          __webpack_require__("./src/index.ts");
          __webpack_require__("./src/SurfaceWorker.js");
          var __webpack_exports__ = __webpack_require__("./src/exporter.js");
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_Dmol();
//# sourceMappingURL=3dmol.js.map
