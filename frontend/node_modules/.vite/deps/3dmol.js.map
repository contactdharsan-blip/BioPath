{
  "version": 3,
  "sources": ["webpack://3dmol/webpack/universalModuleDefinition", "webpack://3dmol/node_modules/iobuffer/lib-esm/IOBuffer.js", "webpack://3dmol/node_modules/iobuffer/lib-esm/text.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/data.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/header.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/index.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/parser.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/toString.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/types.js", "webpack://3dmol/node_modules/netcdfjs/lib-esm/utils.js", "webpack://3dmol/node_modules/pako/dist/pako.esm.mjs", "webpack://3dmol/node_modules/upng-js/UPNG.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/index.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/deflate.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/inflate.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/utils/common.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/utils/strings.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/constants.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/messages.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/trees.js", "webpack://3dmol/node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js", "webpack://3dmol/src/3Dmol.ts", "webpack://3dmol/src/GLDraw.ts", "webpack://3dmol/src/GLModel.ts", "webpack://3dmol/src/GLShape.ts", "webpack://3dmol/src/GLViewer.ts", "webpack://3dmol/src/Gradient.ts", "webpack://3dmol/src/Label.ts", "webpack://3dmol/src/ProteinSurface4.ts", "webpack://3dmol/src/SurfaceWorker.js", "webpack://3dmol/src/VolumeData.ts", "webpack://3dmol/src/VolumetricRender.ts", "webpack://3dmol/src/WebGL/Camera.ts", "webpack://3dmol/src/WebGL/Fog.ts", "webpack://3dmol/src/WebGL/Renderer.ts", "webpack://3dmol/src/WebGL/SpritePlugin.ts", "webpack://3dmol/src/WebGL/constants/Coloring.ts", "webpack://3dmol/src/WebGL/constants/Shading.ts", "webpack://3dmol/src/WebGL/constants/Sides.ts", "webpack://3dmol/src/WebGL/constants/SpriteAlignment.ts", "webpack://3dmol/src/WebGL/constants/TextureConstants.ts", "webpack://3dmol/src/WebGL/constants/TextureOperations.ts", "webpack://3dmol/src/WebGL/constants/index.ts", "webpack://3dmol/src/WebGL/core/EventDispatcher.ts", "webpack://3dmol/src/WebGL/core/Geometry.ts", "webpack://3dmol/src/WebGL/core/Object3D.ts", "webpack://3dmol/src/WebGL/core/Projector.ts", "webpack://3dmol/src/WebGL/core/Raycaster.ts", "webpack://3dmol/src/WebGL/core/Texture.ts", "webpack://3dmol/src/WebGL/core/UVMapping.ts", "webpack://3dmol/src/WebGL/core/index.ts", "webpack://3dmol/src/WebGL/index.ts", "webpack://3dmol/src/WebGL/materials/ImposterMaterial.ts", "webpack://3dmol/src/WebGL/materials/InstancedMaterial.ts", "webpack://3dmol/src/WebGL/materials/LineBasicMaterial.ts", "webpack://3dmol/src/WebGL/materials/Material.ts", "webpack://3dmol/src/WebGL/materials/MeshDoubleLambertMaterial.ts", "webpack://3dmol/src/WebGL/materials/MeshLambertMaterial.ts", "webpack://3dmol/src/WebGL/materials/MeshOutlineMaterial.ts", "webpack://3dmol/src/WebGL/materials/SphereImposterMaterial.ts", "webpack://3dmol/src/WebGL/materials/SphereImposterOutlineMaterial.ts", "webpack://3dmol/src/WebGL/materials/SpriteMaterial.ts", "webpack://3dmol/src/WebGL/materials/StickImposterMaterial.ts", "webpack://3dmol/src/WebGL/materials/StickImposterOutlineMaterial.ts", "webpack://3dmol/src/WebGL/materials/VolumetricMaterial.ts", "webpack://3dmol/src/WebGL/materials/index.ts", "webpack://3dmol/src/WebGL/math/Quaternion.ts", "webpack://3dmol/src/WebGL/math/Vector2.ts", "webpack://3dmol/src/WebGL/math/index.ts", "webpack://3dmol/src/WebGL/math/math.ts", "webpack://3dmol/src/WebGL/math/utils/clamp.ts", "webpack://3dmol/src/WebGL/math/utils/conversionMatrix3.ts", "webpack://3dmol/src/WebGL/math/utils/degToRad.ts", "webpack://3dmol/src/WebGL/objects/Line.ts", "webpack://3dmol/src/WebGL/objects/Mesh.ts", "webpack://3dmol/src/WebGL/objects/Sprite.ts", "webpack://3dmol/src/WebGL/objects/index.ts", "webpack://3dmol/src/WebGL/shaders/ShaderType.ts", "webpack://3dmol/src/WebGL/shaders/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/basic/basic.frag", "webpack://3dmol/src/WebGL/shaders/lib/basic/basic.vert", "webpack://3dmol/src/WebGL/shaders/lib/basic/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/basic/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/blur/blur.frag", "webpack://3dmol/src/WebGL/shaders/lib/blur/blur.vert", "webpack://3dmol/src/WebGL/shaders/lib/blur/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/blur/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/instanced/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/instanced/instanced.frag", "webpack://3dmol/src/WebGL/shaders/lib/instanced/instanced.vert", "webpack://3dmol/src/WebGL/shaders/lib/instanced/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/lambert/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/lambert/lambert.frag", "webpack://3dmol/src/WebGL/shaders/lib/lambert/lambert.vert", "webpack://3dmol/src/WebGL/shaders/lib/lambert/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/lambertdouble/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag", "webpack://3dmol/src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert", "webpack://3dmol/src/WebGL/shaders/lib/lambertdouble/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/outline/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/outline/outline.frag", "webpack://3dmol/src/WebGL/shaders/lib/outline/outline.vert", "webpack://3dmol/src/WebGL/shaders/lib/outline/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/screen/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/screen/screen.frag", "webpack://3dmol/src/WebGL/shaders/lib/screen/screen.vert", "webpack://3dmol/src/WebGL/shaders/lib/screen/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/screenaa/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/screenaa/screenaa.frag", "webpack://3dmol/src/WebGL/shaders/lib/screenaa/screenaa.vert", "webpack://3dmol/src/WebGL/shaders/lib/screenaa/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposter/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposter/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposteroutline/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert", "webpack://3dmol/src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/sprite/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/sprite/sprite.frag", "webpack://3dmol/src/WebGL/shaders/lib/sprite/sprite.vert", "webpack://3dmol/src/WebGL/shaders/lib/sprite/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/ssao/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/ssao/ssao.frag", "webpack://3dmol/src/WebGL/shaders/lib/ssao/ssao.vert", "webpack://3dmol/src/WebGL/shaders/lib/ssao/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/stickimposter/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag", "webpack://3dmol/src/WebGL/shaders/lib/stickimposter/stickimposter.vert", "webpack://3dmol/src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag", "webpack://3dmol/src/WebGL/shaders/lib/stickimposter/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/stickimposteroutline/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.partial.frag", "webpack://3dmol/src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert", "webpack://3dmol/src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/volumetric/index.ts", "webpack://3dmol/src/WebGL/shaders/lib/volumetric/uniforms.ts", "webpack://3dmol/src/WebGL/shaders/lib/volumetric/volumetric.frag", "webpack://3dmol/src/WebGL/shaders/lib/volumetric/volumetric.vert", "webpack://3dmol/src/WebGL/shaders/utils/clone.ts", "webpack://3dmol/src/WebGL/shaders/utils/index.ts", "webpack://3dmol/src/WebGL/shapes/Cylinder.ts", "webpack://3dmol/src/WebGL/shapes/Sphere.ts", "webpack://3dmol/src/WebGL/shapes/Triangle.ts", "webpack://3dmol/src/WebGL/shapes/index.ts", "webpack://3dmol/src/autoload.ts", "webpack://3dmol/src/colors.ts", "webpack://3dmol/src/exporter.js", "webpack://3dmol/src/glcartoon.ts", "webpack://3dmol/src/index.ts", "webpack://3dmol/src/parsers/BCIF.ts", "webpack://3dmol/src/parsers/CDJSON.ts", "webpack://3dmol/src/parsers/CIF.ts", "webpack://3dmol/src/parsers/CUBE.ts", "webpack://3dmol/src/parsers/GRO.ts", "webpack://3dmol/src/parsers/LAMMPSTRJ.ts", "webpack://3dmol/src/parsers/MMTF.ts", "webpack://3dmol/src/parsers/MOL2.ts", "webpack://3dmol/src/parsers/PDB.ts", "webpack://3dmol/src/parsers/PQR.ts", "webpack://3dmol/src/parsers/PRMTOP.ts", "webpack://3dmol/src/parsers/SDF.ts", "webpack://3dmol/src/parsers/VASP.ts", "webpack://3dmol/src/parsers/XYZ.ts", "webpack://3dmol/src/parsers/cifutils/category.ts", "webpack://3dmol/src/parsers/cifutils/decoder.ts", "webpack://3dmol/src/parsers/cifutils/encoding.ts", "webpack://3dmol/src/parsers/index.ts", "webpack://3dmol/src/parsers/utils/anumToSymbol.ts", "webpack://3dmol/src/parsers/utils/areConnected.ts", "webpack://3dmol/src/parsers/utils/assignBackboneHBonds.ts", "webpack://3dmol/src/parsers/utils/assignBonds.ts", "webpack://3dmol/src/parsers/utils/assignPDBBonds.ts", "webpack://3dmol/src/parsers/utils/atomNameToElem.ts", "webpack://3dmol/src/parsers/utils/bondLength.ts", "webpack://3dmol/src/parsers/utils/computeSecondaryStructure.ts", "webpack://3dmol/src/parsers/utils/getSinglePDB.ts", "webpack://3dmol/src/parsers/utils/isEmpty.ts", "webpack://3dmol/src/parsers/utils/processSymmetries.ts", "webpack://3dmol/src/parsers/utils/standardResidues.ts", "webpack://3dmol/src/parsers/utils/validateBonds.ts", "webpack://3dmol/src/partialCharges.ts", "webpack://3dmol/src/specs.ts", "webpack://3dmol/src/utilities.ts", "webpack://3dmol/src/vendor/mmtf.js", "webpack://3dmol/webpack/bootstrap", "webpack://3dmol/webpack/runtime/compat%20get%20default%20export", "webpack://3dmol/webpack/runtime/define%20property%20getters", "webpack://3dmol/webpack/runtime/hasOwnProperty%20shorthand", "webpack://3dmol/webpack/runtime/make%20namespace%20object", "webpack://3dmol/webpack/before-startup", "webpack://3dmol/webpack/startup", "webpack://3dmol/webpack/after-startup"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"3Dmol\"] = factory();\n\telse\n\t\troot[\"3Dmol\"] = factory();\n})(this, () => {\nreturn ", "import { decode, encode } from './text';\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n    const array = new Uint8Array(4);\n    const view = new Uint32Array(array.buffer);\n    return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n    int8: globalThis.Int8Array,\n    uint8: globalThis.Uint8Array,\n    int16: globalThis.Int16Array,\n    uint16: globalThis.Uint16Array,\n    int32: globalThis.Int32Array,\n    uint32: globalThis.Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    int64: globalThis.BigInt64Array,\n    float32: globalThis.Float32Array,\n    float64: globalThis.Float64Array,\n};\nexport class IOBuffer {\n    /**\n     * Reference to the internal ArrayBuffer object.\n     */\n    buffer;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    byteLength;\n    /**\n     * Byte offset of the internal ArrayBuffer.\n     */\n    byteOffset;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    length;\n    /**\n     * The current offset of the buffer's pointer.\n     */\n    offset;\n    lastWrittenByte;\n    littleEndian;\n    _data;\n    _mark;\n    _marks;\n    /**\n     * Create a new IOBuffer.\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options - An object for the options.\n     * @returns A new IOBuffer instance.\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     * @returns This.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes backward.\n     * @param n - Number of bytes to move back.\n     * @returns This.\n     */\n    back(n = 1) {\n        this.offset -= n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset - The offset to move to.\n     * @returns This.\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     * @returns This.\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     * @returns This.\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     * @returns This.\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     * @returns This.\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     * @returns This.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength - The needed memory in bytes.\n     * @returns This.\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = newLength;\n            this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     * @returns The read boolean.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     * @returns The read byte.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The read bytes.\n     */\n    readBytes(n = 1) {\n        return this.readArray(n, 'uint8');\n    }\n    /**\n     * Creates an array of corresponding to the type `type` and size `size`.\n     * For example type `uint8` will create a `Uint8Array`.\n     * @param size - size of the resulting array\n     * @param type - number type of elements to read\n     * @returns The read array.\n     */\n    readArray(size, type) {\n        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n        const offset = this.byteOffset + this.offset;\n        const slice = this.buffer.slice(offset, offset + bytes);\n        if (this.littleEndian === hostBigEndian &&\n            type !== 'uint8' &&\n            type !== 'int8') {\n            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n            slice.reverse();\n            const returnArray = new typedArrays[type](slice.buffer);\n            this.offset += bytes;\n            returnArray.reverse();\n            return returnArray;\n        }\n        const returnArray = new typedArrays[type](slice);\n        this.offset += bytes;\n        return returnArray;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     * @returns The read character.\n     */\n    readChar() {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     * @param n - Number of characters to read.\n     * @returns The read characters.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The decoded string.\n     */\n    readUtf8(n = 1) {\n        return decode(this.readBytes(n));\n    }\n    /**\n     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n     * forward by `n` bytes.\n     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n     * @param n - Number of bytes to read.\n     * @param encoding - The encoding to use. Default is 'utf8'.\n     * @returns The decoded string.\n     */\n    decodeText(n = 1, encoding = 'utf8') {\n        return decode(this.readBytes(n), encoding);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     * @param bytes - The array of bytes to write.\n     * @returns This.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     * @param str - The character to write.\n     * @returns This.\n     */\n    writeChar(str) {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     * @param str - The characters to write.\n     * @returns This.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            // eslint-disable-next-line unicorn/prefer-code-point\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     * @param str - The string to write.\n     * @returns This.\n     */\n    writeUtf8(str) {\n        return this.writeBytes(encode(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     * @returns A new Uint8Array view.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     *  Get the total number of bytes written so far, regardless of the current offset.\n     * @returns - Total number of bytes.\n     */\n    getWrittenByteLength() {\n        return this.lastWrittenByte - this.byteOffset;\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map", "export function decode(bytes, encoding = 'utf8') {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\nexport function encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=text.js.map", "import { num2bytes, str2num, readType } from './types';\n// const STREAMING = 4294967295;\n/**\n * Read data for the given non-record variable\n * @param buffer - Buffer for the file data\n * @param variable - Variable metadata\n * @return - Data of the element\n */\nexport function nonRecord(buffer, variable) {\n    // variable type\n    const type = str2num(variable.type);\n    // size of the data\n    const size = variable.size / num2bytes(type);\n    // iterates over the data\n    const data = new Array(size);\n    for (let i = 0; i < size; i++) {\n        data[i] = readType(buffer, type, 1);\n    }\n    return data;\n}\n/**\n * Read data for the given record variable\n * @param buffer - Buffer for the file data\n * @param variable - Variable metadata\n * @param recordDimension - Record dimension metadata\n * @return - Data of the element\n */\nexport function record(buffer, variable, recordDimension) {\n    // variable type\n    const type = str2num(variable.type);\n    const width = variable.size ? variable.size / num2bytes(type) : 1;\n    // size of the data\n    // TODO streaming data\n    const size = recordDimension.length;\n    // iterates over the data\n    const data = new Array(size);\n    const step = recordDimension.recordStep;\n    if (step) {\n        for (let i = 0; i < size; i++) {\n            const currentOffset = buffer.offset;\n            data[i] = readType(buffer, type, width);\n            buffer.seek(currentOffset + step);\n        }\n    }\n    else {\n        throw new Error('recordDimension.recordStep is undefined');\n    }\n    return data;\n}\n//# sourceMappingURL=data.js.map", "import { num2str, readType } from './types';\nimport { padding, notNetcdf, readName } from './utils';\n// Grammar constants\nconst ZERO = 0;\nconst NC_DIMENSION = 10;\nconst NC_VARIABLE = 11;\nconst NC_ATTRIBUTE = 12;\nconst NC_UNLIMITED = 0;\n/**\n * Reads the file header as @see {@link Header}\n * @param buffer - Buffer for the file data\n * @param version - Version of the file\n * @returns\n */\nexport function header(buffer, version) {\n    const header = { version };\n    const recordDimension = {\n        length: buffer.readUint32(),\n    };\n    const dimList = dimensionsList(buffer);\n    if (!Array.isArray(dimList)) {\n        recordDimension.id = dimList.recordId;\n        recordDimension.name = dimList.recordName;\n        header.dimensions = dimList.dimensions;\n    }\n    header.globalAttributes = attributesList(buffer);\n    const variables = variablesList(buffer, recordDimension?.id, version);\n    if (!Array.isArray(variables)) {\n        header.variables = variables.variables;\n        recordDimension.recordStep = variables.recordStep;\n    }\n    header.recordDimension = recordDimension;\n    return header;\n}\n/**\n * List of dimensions\n * @param buffer - Buffer for the file data\n * @return List of dimensions\n */\nfunction dimensionsList(buffer) {\n    const result = {};\n    let recordId, recordName;\n    const dimList = buffer.readUint32();\n    let dimensions;\n    if (dimList === ZERO) {\n        notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of dimensions');\n        return [];\n    }\n    else {\n        notNetcdf(dimList !== NC_DIMENSION, 'wrong tag for list of dimensions');\n        // Length of dimensions\n        const dimensionSize = buffer.readUint32();\n        dimensions = new Array(dimensionSize);\n        //populate `name` and `size` for each dimension\n        for (let dim = 0; dim < dimensionSize; dim++) {\n            // Read name\n            const name = readName(buffer);\n            // Read dimension size\n            const size = buffer.readUint32();\n            if (size === NC_UNLIMITED) {\n                // in netcdf 3 one field can be of size unlimited\n                recordId = dim;\n                recordName = name;\n            }\n            dimensions[dim] = {\n                name,\n                size,\n            };\n        }\n    }\n    if (recordId !== undefined) {\n        result.recordId = recordId;\n    }\n    if (recordName !== undefined) {\n        result.recordName = recordName;\n    }\n    result.dimensions = dimensions;\n    return result;\n}\n/**\n * List of attributes\n * @param buffer - Buffer for the file data\n * @return - List of attributes with:\n */\nfunction attributesList(buffer) {\n    const gAttList = buffer.readUint32();\n    let attributes;\n    if (gAttList === ZERO) {\n        notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of attributes');\n        return [];\n    }\n    else {\n        notNetcdf(gAttList !== NC_ATTRIBUTE, 'wrong tag for list of attributes');\n        // Length of attributes\n        const attributeSize = buffer.readUint32();\n        attributes = new Array(attributeSize);\n        // Populate `name`, `type` and `value` for each attribute\n        for (let gAtt = 0; gAtt < attributeSize; gAtt++) {\n            // Read name\n            const name = readName(buffer);\n            // Read type\n            const type = buffer.readUint32();\n            notNetcdf(type < 1 || type > 6, `non valid type ${type}`);\n            // Read attribute\n            const size = buffer.readUint32();\n            const value = readType(buffer, type, size);\n            // Apply padding\n            padding(buffer);\n            attributes[gAtt] = {\n                name,\n                type: num2str(type),\n                value,\n            };\n        }\n    }\n    return attributes;\n}\n/**\n * @param buffer - Buffer for the file data\n * @param recordId - Id of the unlimited dimension (also called record dimension)\n * This value may be undefined if there is no unlimited dimension\n * @param version - Version of the file\n * @return - Number of recordStep and list of variables @see {@link Variables}\n */\nfunction variablesList(buffer, recordId, version) {\n    const varList = buffer.readUint32();\n    let recordStep = 0;\n    let variables;\n    if (varList === ZERO) {\n        notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of variables');\n        return [];\n    }\n    else {\n        notNetcdf(varList !== NC_VARIABLE, 'wrong tag for list of variables');\n        // Length of variables\n        const variableSize = buffer.readUint32();\n        variables = new Array(variableSize);\n        for (let v = 0; v < variableSize; v++) {\n            // Read name\n            const name = readName(buffer);\n            // Read dimensionality of the variable\n            const dimensionality = buffer.readUint32();\n            // Index into the list of dimensions\n            const dimensionsIds = new Array(dimensionality);\n            for (let dim = 0; dim < dimensionality; dim++) {\n                dimensionsIds[dim] = buffer.readUint32();\n            }\n            // Read variables size\n            const attributes = attributesList(buffer);\n            // Read type\n            const type = buffer.readUint32();\n            notNetcdf(type < 1 && type > 6, `non valid type ${type}`);\n            // Read variable size\n            // The 32-bit varSize field is not large enough to contain the size of variables that require\n            // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n            const varSize = buffer.readUint32();\n            // Read offset\n            let offset = buffer.readUint32();\n            if (version === 2) {\n                notNetcdf(offset > 0, 'offsets larger than 4GB not supported');\n                offset = buffer.readUint32();\n            }\n            let record = false;\n            // Count amount of record variables\n            if (typeof recordId !== 'undefined' && dimensionsIds[0] === recordId) {\n                recordStep += varSize;\n                record = true;\n            }\n            variables[v] = {\n                name,\n                dimensions: dimensionsIds,\n                attributes,\n                type: num2str(type),\n                size: varSize,\n                offset,\n                record,\n            };\n        }\n    }\n    return {\n        variables,\n        recordStep,\n    };\n}\n//# sourceMappingURL=header.js.map", "export * from './parser';\n//# sourceMappingURL=index.js.map", "import { IOBuffer } from 'iobuffer';\nimport { record, nonRecord } from './data';\nimport { header } from './header';\nimport { toString } from './toString';\nimport { notNetcdf } from './utils';\n/**\n * Reads a NetCDF v3.x file\n * [See specification](https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html)\n * @param data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nexport class NetCDFReader {\n    constructor(data) {\n        this.toString = toString;\n        const buffer = new IOBuffer(data);\n        buffer.setBigEndian();\n        // Validate that it's a NetCDF file\n        notNetcdf(buffer.readChars(3) !== 'CDF', 'should start with CDF');\n        // Check the NetCDF format\n        const version = buffer.readByte();\n        notNetcdf(version > 2, 'unknown version');\n        // Read the header\n        this.header = header(buffer, version);\n        this.buffer = buffer;\n    }\n    /**\n     * @return - Version for the NetCDF format\n     */\n    get version() {\n        if (this.header.version === 1) {\n            return 'classic format';\n        }\n        else {\n            return '64-bit offset format';\n        }\n    }\n    /**\n     * @return {object} - Metadata for the record dimension\n     *  * `length`: Number of elements in the record dimension\n     *  * `id`: Id number in the list of dimensions for the record dimension\n     *  * `name`: String with the name of the record dimension\n     *  * `recordStep`: Number with the record variables step size\n     */\n    get recordDimension() {\n        return this.header.recordDimension;\n    }\n    /**\n     * @return - Array - List of dimensions with:\n     *  * `name`: String with the name of the dimension\n     *  * `size`: Number with the size of the dimension\n     */\n    get dimensions() {\n        return this.header.dimensions;\n    }\n    /**\n     * @return - Array - List of global attributes with:\n     *  * `name`: String with the name of the attribute\n     *  * `type`: String with the type of the attribute\n     *  * `value`: A number or string with the value of the attribute\n     */\n    get globalAttributes() {\n        return this.header.globalAttributes;\n    }\n    /**\n     * Returns the value of an attribute\n     * @param - AttributeName\n     * @return - Value of the attributeName or null\n     */\n    getAttribute(attributeName) {\n        const attribute = this.globalAttributes.find((val) => val.name === attributeName);\n        if (attribute)\n            return attribute.value;\n        return null;\n    }\n    /**\n     * Returns the value of a variable as a string\n     * @param - variableName\n     * @return - Value of the variable as a string or null\n     */\n    getDataVariableAsString(variableName) {\n        const variable = this.getDataVariable(variableName);\n        if (variable)\n            return variable.join('');\n        return null;\n    }\n    get variables() {\n        return this.header.variables;\n    }\n    /**\n     * Retrieves the data for a given variable\n     * @param variableName - Name of the variable to search or variable object\n     * @return The variable values\n     */\n    getDataVariable(variableName) {\n        let variable;\n        if (typeof variableName === 'string') {\n            // search the variable\n            variable = this.header.variables.find((val) => {\n                return val.name === variableName;\n            });\n        }\n        else {\n            variable = variableName;\n        }\n        // throws if variable not found\n        if (variable === undefined) {\n            throw new Error('Not a valid NetCDF v3.x file: variable not found');\n        }\n        // go to the offset position\n        this.buffer.seek(variable.offset);\n        if (variable.record) {\n            // record variable case\n            return record(this.buffer, variable, this.header.recordDimension);\n        }\n        else {\n            // non-record variable case\n            return nonRecord(this.buffer, variable);\n        }\n    }\n    /**\n     * Check if a dataVariable exists\n     * @param variableName - Name of the variable to find\n     * @return boolean\n     */\n    dataVariableExists(variableName) {\n        const variable = this.header.variables.find((val) => {\n            return val.name === variableName;\n        });\n        return variable !== undefined;\n    }\n    /**\n     * Check if an attribute exists\n     * @param attributeName - Name of the attribute to find\n     * @return boolean\n     */\n    attributeExists(attributeName) {\n        const attribute = this.globalAttributes.find((val) => val.name === attributeName);\n        return attribute !== undefined;\n    }\n}\n//# sourceMappingURL=parser.js.map", "export function toString() {\n    const result = [];\n    result.push('DIMENSIONS');\n    for (const dimension of this.dimensions) {\n        result.push(`  ${dimension.name.padEnd(30)} = size: ${dimension.size}`);\n    }\n    result.push('');\n    result.push('GLOBAL ATTRIBUTES');\n    for (const attribute of this.globalAttributes) {\n        result.push(`  ${attribute.name.padEnd(30)} = ${attribute.value}`);\n    }\n    const variables = JSON.parse(JSON.stringify(this.variables));\n    result.push('');\n    result.push('VARIABLES:');\n    for (const variable of variables) {\n        variable.value = this.getDataVariable(variable);\n        let stringify = JSON.stringify(variable.value);\n        if (stringify.length > 50)\n            stringify = stringify.substring(0, 50);\n        if (!isNaN(variable.value.length)) {\n            stringify += ` (length: ${variable.value.length})`;\n        }\n        result.push(`  ${variable.name.padEnd(30)} = ${stringify}`);\n    }\n    return result.join('\\n');\n}\n//# sourceMappingURL=toString.js.map", "const types = {\n    BYTE: 1,\n    CHAR: 2,\n    SHORT: 3,\n    INT: 4,\n    FLOAT: 5,\n    DOUBLE: 6,\n};\n/**\n * Parse a number into their respective type\n * @param type - integer that represents the type\n * @return - parsed value of the type\n */\nexport function num2str(type) {\n    switch (Number(type)) {\n        case types.BYTE:\n            return 'byte';\n        case types.CHAR:\n            return 'char';\n        case types.SHORT:\n            return 'short';\n        case types.INT:\n            return 'int';\n        case types.FLOAT:\n            return 'float';\n        case types.DOUBLE:\n            return 'double';\n        default:\n            return 'undefined';\n    }\n}\n/**\n * Parse a number type identifier to his size in bytes\n * @param type - integer that represents the type\n * @return size of the type\n */\nexport function num2bytes(type) {\n    switch (Number(type)) {\n        case types.BYTE:\n            return 1;\n        case types.CHAR:\n            return 1;\n        case types.SHORT:\n            return 2;\n        case types.INT:\n            return 4;\n        case types.FLOAT:\n            return 4;\n        case types.DOUBLE:\n            return 8;\n        default:\n            return -1;\n    }\n}\n/**\n * Reverse search of num2str\n * @param type - string that represents the type\n * @return parsed value of the type\n */\nexport function str2num(type) {\n    switch (String(type)) {\n        case 'byte':\n            return types.BYTE;\n        case 'char':\n            return types.CHAR;\n        case 'short':\n            return types.SHORT;\n        case 'int':\n            return types.INT;\n        case 'float':\n            return types.FLOAT;\n        case 'double':\n            return types.DOUBLE;\n        /* istanbul ignore next */\n        default:\n            return -1;\n    }\n}\n/**\n * Auxiliary function to read numeric data\n * @param size - Size of the element to read\n * @param bufferReader - Function to read next value\n * @return\n */\nfunction readNumber(size, bufferReader) {\n    if (size !== 1) {\n        const numbers = new Array(size);\n        for (let i = 0; i < size; i++) {\n            numbers[i] = bufferReader();\n        }\n        return numbers;\n    }\n    else {\n        return bufferReader();\n    }\n}\n/**\n * Given a type and a size reads the next element\n * @param buffer - Buffer for the file data\n * @param type - Type of the data to read\n * @param size - Size of the element to read\n * @return\n */\nexport function readType(buffer, type, size) {\n    switch (type) {\n        case types.BYTE:\n            return Array.from(buffer.readBytes(size));\n        case types.CHAR:\n            return trimNull(buffer.readChars(size));\n        case types.SHORT:\n            return readNumber(size, buffer.readInt16.bind(buffer));\n        case types.INT:\n            return readNumber(size, buffer.readInt32.bind(buffer));\n        case types.FLOAT:\n            return readNumber(size, buffer.readFloat32.bind(buffer));\n        case types.DOUBLE:\n            return readNumber(size, buffer.readFloat64.bind(buffer));\n        default:\n            throw new Error(`non valid type ${type}`);\n    }\n}\n/**\n * Removes null terminate value\n * @param value - String to trim\n * @return - Trimmed string\n */\nfunction trimNull(value) {\n    if (value.charCodeAt(value.length - 1) === 0) {\n        return value.substring(0, value.length - 1);\n    }\n    return value;\n}\n//# sourceMappingURL=types.js.map", "/**\n * Throws a non-valid NetCDF exception if the statement it's true\n * @ignore\n * @param statement - Throws if true\n * @param reason - Reason to throw\n */\nexport function notNetcdf(statement, reason) {\n    if (statement) {\n        throw new TypeError(`Not a valid NetCDF v3.x file: ${reason}`);\n    }\n}\n/**\n * Moves 1, 2, or 3 bytes to next 4-byte boundary\n * @param buffer - Buffer for the file data\n */\nexport function padding(buffer) {\n    if (buffer.offset % 4 !== 0) {\n        buffer.skip(4 - (buffer.offset % 4));\n    }\n}\n/**\n * Reads the name\n * @param buffer - Buffer for the file data\n * @return Name\n */\nexport function readName(buffer) {\n    // Read name\n    const nameLength = buffer.readUint32();\n    const name = buffer.readChars(nameLength);\n    // validate name\n    // TODO\n    // Apply padding\n    padding(buffer);\n    return name;\n}\n//# sourceMappingURL=utils.js.map", "\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\nexport { Deflate_1 as Deflate, Inflate_1 as Inflate, constants_1 as constants, pako as default, deflate_1 as deflate, deflateRaw_1 as deflateRaw, gzip_1 as gzip, inflate_1 as inflate, inflateRaw_1 as inflateRaw, ungzip_1 as ungzip };\n", "\n;(function(){\nvar UPNG = {};\n\n// Make available for import by `require()`\nvar pako;\nif (typeof module == \"object\") {module.exports = UPNG;}  else {window.UPNG = UPNG;}\nif (typeof require == \"function\") {pako = require(\"pako\");}  else {pako = window.pako;}\nfunction log() { if (typeof process==\"undefined\" || process.env.NODE_ENV==\"development\") console.log.apply(console, arguments);  }\n(function(UPNG, pako){\n\n\t\n\n\t\n\nUPNG.toRGBA8 = function(out)\n{\n\tvar w = out.width, h = out.height;\n\tif(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n\t\n\tvar frms = [];\n\tif(out.frames[0].data==null) out.frames[0].data = out.data;\n\t\n\tvar img, empty = new Uint8Array(w*h*4);\n\tfor(var i=0; i<out.frames.length; i++)\n\t{\n\t\tvar frm = out.frames[i];\n\t\tvar fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n\t\tvar fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);\n\t\t\n\t\tif(i==0) img = fdata;\n\t\telse if(frm.blend  ==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.blend  ==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\t\t\n\t\tfrms.push(img.buffer);  img = img.slice(0);\n\t\t\n\t\tif     (frm.dispose==0) {}\n\t\telse if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.dispose==2) {\n\t\t\tvar pi = i-1;\n\t\t\twhile(out.frames[pi].dispose==2) pi--;\n\t\t\timg = new Uint8Array(frms[pi]).slice(0);\n\t\t}\n\t}\n\treturn frms;\n}\nUPNG.toRGBA8.decodeImage = function(data, w, h, out)\n{\n\tvar area = w*h, bpp = UPNG.decode._getBPP(out);\n\tvar bpl = Math.ceil(w*bpp/8);\t// bytes per line\n\n\tvar bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);\n\tvar ctype = out.ctype, depth = out.depth;\n\tvar rs = UPNG._bin.readUshort;\n\t\n\t//console.log(ctype, depth);\n\n\tif     (ctype==6) { // RGB + alpha\n\t\tvar qarea = area<<2;\n\t\tif(depth== 8) for(var i=0; i<qarea;i++) {  bf[i] = data[i];  /*if((i&3)==3 && data[i]!=0) bf[i]=255;*/ }\n\t\tif(depth==16) for(var i=0; i<qarea;i++) {  bf[i] = data[i<<1];  }\n\t}\n\telse if(ctype==2) {\t// RGB\n\t\tvar ts=out.tabs[\"tRNS\"], tr=-1, tg=-1, tb=-1;\n\t\tif(ts) {  tr=ts[0];  tg=ts[1];  tb=ts[2];  }\n\t\tif(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf[qi] = data[ti];  bf[qi+1] = data[ti+1];  bf[qi+2] = data[ti+2];  bf[qi+3] = 255;\n\t\t\tif(tr!=-1 && data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }\n\t\tif(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf[qi] = data[ti];  bf[qi+1] = data[ti+2];  bf[qi+2] = data[ti+4];  bf[qi+3] = 255;\n\t\t\tif(tr!=-1 && rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }\n\t}\n\telse if(ctype==3) {\t// palette\n\t\tvar p=out.tabs[\"PLTE\"], ap=out.tabs[\"tRNS\"], tl=ap?ap.length:0;\n\t\t//console.log(p, ap);\n\t\tif(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t}\n\telse if(ctype==4) {\t// gray + alpha\n\t\tif(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }\n\t\tif(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }\n\t}\n\telse if(ctype==0) {\t// gray\n\t\tvar tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n\t\tif(depth== 1) for(var i=0; i<area; i++) {  var gr=255*((data[i>>3]>>(7 -((i&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 2) for(var i=0; i<area; i++) {  var gr= 85*((data[i>>2]>>(6 -((i&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 4) for(var i=0; i<area; i++) {  var gr= 17*((data[i>>1]>>(4 -((i&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 8) for(var i=0; i<area; i++) {  var gr=data[i  ] , al=(gr           ==tr)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth==16) for(var i=0; i<area; i++) {  var gr=data[i<<1], al=(rs(data,i<<1)==tr)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t}\n\treturn bf;\n}\n\n\n\nUPNG.decode = function(buff)\n{\n\tvar data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n\tvar out = {tabs:{}, frames:[]};\n\tvar dd = new Uint8Array(data.length), doff = 0;\t // put all IDAT data into it\n\tvar fd, foff = 0;\t// frames\n\t\n\tvar mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw \"The input is not a PNG file!\";\n\n\twhile(offset<data.length)\n\t{\n\t\tvar len  = bin.readUint(data, offset);  offset += 4;\n\t\tvar type = bin.readASCII(data, offset, 4);  offset += 4;\n\t\t//log(type,len);\n\t\t\n\t\tif     (type==\"IHDR\")  {  UPNG.decode._IHDR(data, offset, out);  }\n\t\telse if(type==\"IDAT\") {\n\t\t\tfor(var i=0; i<len; i++) dd[doff+i] = data[offset+i];\n\t\t\tdoff += len;\n\t\t}\n\t\telse if(type==\"acTL\")  {\n\t\t\tout.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };\n\t\t\tfd = new Uint8Array(data.length);\n\t\t}\n\t\telse if(type==\"fcTL\")  {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\n\t\t\tvar rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};\n\t\t\tvar del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);\n\t\t\tvar frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};\n\t\t\t//console.log(frm);\n\t\t\tout.frames.push(frm);\n\t\t}\n\t\telse if(type==\"fdAT\") {\n\t\t\tfor(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];\n\t\t\tfoff += len-4;\n\t\t}\n\t\telse if(type==\"pHYs\") {\n\t\t\tout.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];\n\t\t}\n\t\telse if(type==\"cHRM\") {\n\t\t\tout.tabs[type] = [];\n\t\t\tfor(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));\n\t\t}\n\t\telse if(type==\"tEXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = bin.nextZero(data, offset);\n\t\t\tvar keyw = bin.readASCII(data, offset, nz-offset);\n\t\t\tvar text = bin.readASCII(data, nz+1, offset+len-nz-1);\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"iTXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = 0, off = offset;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tvar cflag = data[off], cmeth = data[off+1];  off+=2;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;\n\t\t\tvar text  = bin.readUTF8(data, off, len-(off-offset));\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"PLTE\") {\n\t\t\tout.tabs[type] = bin.readBytes(data, offset, len);\n\t\t}\n\t\telse if(type==\"hIST\") {\n\t\t\tvar pl = out.tabs[\"PLTE\"].length/3;\n\t\t\tout.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));\n\t\t}\n\t\telse if(type==\"tRNS\") {\n\t\t\tif     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);\n\t\t\telse if(out.ctype==0) out.tabs[type] = rUs(data, offset);\n\t\t\telse if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];\n\t\t\t//else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n\t\t}\n\t\telse if(type==\"gAMA\") out.tabs[type] = bin.readUint(data, offset)/100000;\n\t\telse if(type==\"sRGB\") out.tabs[type] = data[offset];\n\t\telse if(type==\"bKGD\")\n\t\t{\n\t\t\tif     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];\n\t\t\telse if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];\n\t\t\telse if(out.ctype==3) out.tabs[type] = data[offset];\n\t\t}\n\t\telse if(type==\"IEND\") {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\t\n\t\t\tout.data = UPNG.decode._decompress(out, dd, out.width, out.height);  break;\n\t\t}\n\t\t//else {  log(\"unknown chunk type\", type, len);  }\n\t\toffset += len;\n\t\tvar crc = bin.readUint(data, offset);  offset += 4;\n\t}\n\tdelete out.compress;  delete out.interlace;  delete out.filter;\n\treturn out;\n}\n\nUPNG.decode._decompress = function(out, dd, w, h) {\n\tif(out.compress ==0) dd = UPNG.decode._inflate(dd);\n\n\tif     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n\telse if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);\n\treturn dd;\n}\n\nUPNG.decode._inflate = function(data) {  return pako[\"inflate\"](data);  }\n\nUPNG.decode._readInterlace = function(data, out)\n{\n\tvar w = out.width, h = out.height;\n\tvar bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);\n\tvar img = new Uint8Array( h * bpl );\n\tvar di = 0;\n\n\tvar starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];\n\tvar starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];\n\tvar row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];\n\tvar col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];\n\n\tvar pass=0;\n\twhile(pass<7)\n\t{\n\t\tvar ri = row_increment[pass], ci = col_increment[pass];\n\t\tvar sw = 0, sh = 0;\n\t\tvar cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }\n\t\tvar cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }\n\t\tvar bpll = Math.ceil(sw*bpp/8);\n\t\tUPNG.decode._filterZero(data, out, di, sw, sh);\n\n\t\tvar y=0, row = starting_row[pass];\n\t\twhile(row<h)\n\t\t{\n\t\t\tvar col = starting_col[pass];\n\t\t\tvar cdi = (di+y*bpll)<<3;\n\n\t\t\twhile(col<w)\n\t\t\t{\n\t\t\t\tif(bpp==1) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;\n\t\t\t\t\timg[row*bpl + (col>>3)] |= (val << (7-((col&3)<<0)));\n\t\t\t\t}\n\t\t\t\tif(bpp==2) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;\n\t\t\t\t\timg[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));\n\t\t\t\t}\n\t\t\t\tif(bpp==4) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;\n\t\t\t\t\timg[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));\n\t\t\t\t}\n\t\t\t\tif(bpp>=8) {\n\t\t\t\t\tvar ii = row*bpl+col*cbpp;\n\t\t\t\t\tfor(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];\n\t\t\t\t}\n\t\t\t\tcdi+=bpp;  col+=ci;\n\t\t\t}\n\t\t\ty++;  row += ri;\n\t\t}\n\t\tif(sw*sh!=0) di += sh * (1 + bpll);\n\t\tpass = pass + 1;\n\t}\n\treturn img;\n}\n\nUPNG.decode._getBPP = function(out) {\n\tvar noc = [1,null,3,1,2,null,4][out.ctype];\n\treturn noc * out.depth;\n}\n\nUPNG.decode._filterZero = function(data, out, off, w, h)\n{\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;\n\tbpp = Math.ceil(bpp/8);\n\n\tfor(var y=0; y<h; y++)  {\n\t\tvar i = off+y*bpl, di = i+y+1;\n\t\tvar type = data[di-1];\n\n\t\tif     (type==0) for(var x=  0; x<bpl; x++) data[i+x] = data[di+x];\n\t\telse if(type==1) {\n\t\t\tfor(var x=  0; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\tfor(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp])&255;\n\t\t}\n\t\telse if(y==0) {\n\t\t\tfor(var x=  0; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x])&255;\n\t\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + (data[i+x-bpp]>>1) )&255;\n\t\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], 0, 0) )&255;\n\t\t}\n\t\telse {\n\t\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl])&255;  }\n\n\t\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[i+x] = (data[di+x] + (data[i+x-bpl]>>1))&255;\n\t\t\t              for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>1) )&255;  }\n\n\t\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0))&255;\n\t\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) )&255;  }\n\t\t}\n\t}\n\treturn data;\n}\n\nUPNG.decode._paeth = function(a,b,c)\n{\n\tvar p = a+b-c, pa = Math.abs(p-a), pb = Math.abs(p-b), pc = Math.abs(p-c);\n\tif (pa <= pb && pa <= pc)  return a;\n\telse if (pb <= pc)  return b;\n\treturn c;\n}\n\nUPNG.decode._IHDR = function(data, offset, out)\n{\n\tvar bin = UPNG._bin;\n\tout.width  = bin.readUint(data, offset);  offset += 4;\n\tout.height = bin.readUint(data, offset);  offset += 4;\n\tout.depth     = data[offset];  offset++;\n\tout.ctype     = data[offset];  offset++;\n\tout.compress  = data[offset];  offset++;\n\tout.filter    = data[offset];  offset++;\n\tout.interlace = data[offset];  offset++;\n}\n\nUPNG._bin = {\n\tnextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },\n\treadUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },\n\twriteUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },\n\treadUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },\n\twriteUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\n\treadBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\n\treadUTF8 : function(buff, p, l) {\n\t\tvar s = \"\", ns;\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UPNG._bin.pad(buff[p+i].toString(16));\n\t\ttry {  ns = decodeURIComponent(s); }\n\t\tcatch(e) {  return UPNG._bin.readASCII(buff, p, l);  }\n\t\treturn  ns;\n\t}\n}\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)\n{\n\tvar w = Math.min(sw,tw), h = Math.min(sh,th);\n\tvar si=0, ti=0;\n\tfor(var y=0; y<h; y++)\n\t\tfor(var x=0; x<w; x++)\n\t\t{\n\t\t\tif(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }\n\t\t\telse                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }\n\t\t\t\n\t\t\tif     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }\n\t\t\telse if(mode==1) {\n\t\t\t\tvar fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa; \n\t\t\t\tvar ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba; \n\t\t\t\t\n\t\t\t\tvar ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);\n\t\t\t\ttb[ti+3] = 255*oa;  \n\t\t\t\ttb[ti+0] = (fr+br*ifa)*ioa;  \n\t\t\t\ttb[ti+1] = (fg+bg*ifa)*ioa;   \n\t\t\t\ttb[ti+2] = (fb+bb*ifa)*ioa;  \n\t\t\t}\n\t\t\telse if(mode==2){\t// copy only differences, otherwise zero\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }\n\t\t\t\telse {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }\n\t\t\t}\n\t\t\telse if(mode==3){\t// check if can be blended\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) continue;\n\t\t\t\t//if(fa!=255 && ba!=0) return false;\n\t\t\t\tif(fa<220 && ba>20) return false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\n\n\nUPNG.encode = function(bufs, w, h, ps, dels, forbidPlte)\n{\n\tif(ps==null) ps=0;\n\tif(forbidPlte==null) forbidPlte = false;\n\tvar data = new Uint8Array(bufs[0].byteLength*bufs.length+100);\n\tvar wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) data[i]=wr[i];\n\tvar offset = 8,  bin = UPNG._bin, crc = UPNG.crc.crc, wUi = bin.writeUint, wUs = bin.writeUshort, wAs = bin.writeASCII;\n\n\tvar nimg = UPNG.encode.compressPNG(bufs, w, h, ps, forbidPlte);\n\n\twUi(data,offset, 13);     offset+=4;\n\twAs(data,offset,\"IHDR\");  offset+=4;\n\twUi(data,offset,w);  offset+=4;\n\twUi(data,offset,h);  offset+=4;\n\tdata[offset] = nimg.depth;  offset++;  // depth\n\tdata[offset] = nimg.ctype;  offset++;  // ctype\n\tdata[offset] = 0;  offset++;  // compress\n\tdata[offset] = 0;  offset++;  // filter\n\tdata[offset] = 0;  offset++;  // interlace\n\twUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc\n\n\t// 9 bytes to say, that it is sRGB\n\twUi(data,offset, 1);      offset+=4;\n\twAs(data,offset,\"sRGB\");  offset+=4;\n\tdata[offset] = 1;  offset++;\n\twUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc\n\n\tvar anim = bufs.length>1;\n\tif(anim) {\n\t\twUi(data,offset, 8);      offset+=4;\n\t\twAs(data,offset,\"acTL\");  offset+=4;\n\t\twUi(data,offset, bufs.length);      offset+=4;\n\t\twUi(data,offset, 0);      offset+=4;\n\t\twUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc\n\t}\n\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\twUi(data,offset, dl*3);  offset+=4;\n\t\twAs(data,offset,\"PLTE\");  offset+=4;\n\t\tfor(var i=0; i<dl; i++){\n\t\t\tvar ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>8)&255, b=(c>>16)&255;\n\t\t\tdata[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;\n\t\t}\n\t\toffset+=dl*3;\n\t\twUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc\n\n\t\tif(nimg.gotAlpha) {\n\t\t\twUi(data,offset, dl);  offset+=4;\n\t\t\twAs(data,offset,\"tRNS\");  offset+=4;\n\t\t\tfor(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>24)&255;\n\t\t\toffset+=dl;\n\t\t\twUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc\n\t\t}\n\t}\n\t\n\tvar fi = 0;\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) {\n\t\t\twUi(data,offset, 26);     offset+=4;\n\t\t\twAs(data,offset,\"fcTL\");  offset+=4;\n\t\t\twUi(data, offset, fi++);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.width );   offset+=4;\n\t\t\twUi(data, offset, fr.rect.height);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.x);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.y);   offset+=4;\n\t\t\twUs(data, offset, dels[j]);   offset+=2;\n\t\t\twUs(data, offset,  1000);   offset+=2;\n\t\t\tdata[offset] = fr.dispose;  offset++;\t// dispose\n\t\t\tdata[offset] = fr.blend  ;  offset++;\t// blend\n\t\t\twUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc\n\t\t}\n\t\t\t\t\n\t\tvar imgd = fr.cimg, dl = imgd.length;\n\t\twUi(data,offset, dl+(j==0?0:4));     offset+=4;\n\t\tvar ioff = offset;\n\t\twAs(data,offset,(j==0)?\"IDAT\":\"fdAT\");  offset+=4;\n\t\tif(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }\n\t\tfor(var i=0; i<dl; i++) data[offset+i] = imgd[i];\n\t\toffset += dl;\n\t\twUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc\n\t}\n\n\twUi(data,offset, 0);     offset+=4;\n\twAs(data,offset,\"IEND\");  offset+=4;\n\twUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc\n\n\treturn data.buffer.slice(0,offset);\n}\n\nUPNG.encode.compressPNG = function(bufs, w, h, ps, forbidPlte)\n{\n\tvar out = UPNG.encode.compress(bufs, w, h, ps, false, forbidPlte);\n\tfor(var i=0; i<bufs.length; i++) {\n\t\tvar frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height, bpl=frm.bpl, bpp=frm.bpp;\n\t\tvar fdata = new Uint8Array(nh*bpl+nh);\n\t\tfrm.cimg = UPNG.encode._filterZero(frm.img,nh,bpp,bpl,fdata);\n\t}\t\n\treturn out;\n}\n\nUPNG.encode.compress = function(bufs, w, h, ps, forGIF, forbidPlte)\n{\n\tif(forbidPlte==null) forbidPlte = false;\n\t\n\tvar ctype = 6, depth = 8, bpp = 4, alphaAnd=255\n\t\n\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\tvar img = new Uint8Array(bufs[j]), ilen = img.length;\n\t\tfor(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];\n\t}\n\tvar gotAlpha = (alphaAnd)!=255;\n\t\n\tvar cmap={}, plte=[];  if(bufs.length!=0) {  cmap[0]=0;  plte.push(0);  if(ps!=0) ps--;  } \n\t\n\t\n\tif(ps!=0) {\n\t\tvar qres = UPNG.quantize(bufs, ps, forGIF);  bufs = qres.bufs;\n\t\tfor(var i=0; i<qres.plte.length; i++) {  var c=qres.plte[i].est.rgba;  if(cmap[c]==null) {  cmap[c]=plte.length;  plte.push(c);  }     }\n\t}\n\telse {\n\t\t// what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n\t\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\t\tvar img32 = new Uint32Array(bufs[j]), ilen = img32.length;\n\t\t\tfor(var i=0; i<ilen; i++) {\n\t\t\t\tvar c = img32[i];\n\t\t\t\tif((i<w || (c!=img32[i-1] && c!=img32[i-w])) && cmap[c]==null) {  cmap[c]=plte.length;  plte.push(c);  if(plte.length>=300) break;  }\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar brute = gotAlpha ? forGIF : false;\t\t// brute : frames can only be copied, not \"blended\"\n\tvar cc=plte.length;  //console.log(cc);\n\tif(cc<=256 && forbidPlte==false) {\n\t\tif(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;\n\t\tif(forGIF) depth=8;\n\t\tgotAlpha = true;\n\t}\n\t\n\t\n\tvar frms = [];\n\tfor(var j=0; j<bufs.length; j++)\n\t{\n\t\tvar cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n\t\t\n\t\tvar nx=0, ny=0, nw=w, nh=h, blend=0;\n\t\tif(j!=0 && !brute) {\n\t\t\tvar tlim = (forGIF || j==1 || frms[frms.length-2].dispose==2)?1:2, tstp = 0, tarea = 1e9;\n\t\t\tfor(var it=0; it<tlim; it++)\n\t\t\t{\n\t\t\t\tvar pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);\n\t\t\t\tvar mix=w,miy=h,max=-1,may=-1;\n\t\t\t\tfor(var y=0; y<h; y++) for(var x=0; x<w; x++) {\n\t\t\t\t\tvar i = y*w+x;\n\t\t\t\t\tif(cimg32[i]!=p32[i]) {\n\t\t\t\t\t\tif(x<mix) mix=x;  if(x>max) max=x;\n\t\t\t\t\t\tif(y<miy) miy=y;  if(y>may) may=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar sarea = (max==-1) ? 1 : (max-mix+1)*(may-miy+1);\n\t\t\t\tif(sarea<tarea) {\n\t\t\t\t\ttarea = sarea;  tstp = it;  \n\t\t\t\t\tif(max==-1) {  nx=ny=0;  nw=nh=1;  }\n\t\t\t\t\telse {  nx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;  }\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar pimg = new Uint8Array(bufs[j-1-tstp]);\n\t\t\tif(tstp==1) frms[frms.length-1].dispose = 2;\n\t\t\t\n\t\t\tvar nimg = new Uint8Array(nw*nh*4), nimg32 = new Uint32Array(nimg.buffer);\n\t\t\tUPNG.   _copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\tif(UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3)) {\n\t\t\t\tUPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 2);  blend = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);  blend = 0;\n\t\t\t}\n\t\t\tcimg = nimg;  cimg32 = new Uint32Array(cimg.buffer);\n\t\t}\n\t\tvar bpl = 4*nw;\n\t\tif(cc<=256 && forbidPlte==false) {\n\t\t\tbpl = Math.ceil(depth*nw/8);\n\t\t\tvar nimg = new Uint8Array(bpl*nh);\n\t\t\tfor(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;\n\t\t\t\tif     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (cmap[cimg32[ii+x]]             );\n\t\t\t\telse if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (cmap[cimg32[ii+x]]<<(4-(x&1)*4));\n\t\t\t\telse if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (cmap[cimg32[ii+x]]<<(6-(x&3)*2));\n\t\t\t\telse if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (cmap[cimg32[ii+x]]<<(7-(x&7)*1));\n\t\t\t}\n\t\t\tcimg=nimg;  ctype=3;  bpp=1;\n\t\t}\n\t\telse if(gotAlpha==false && bufs.length==1) {\t// some next \"reduced\" frames may contain alpha for blending\n\t\t\tvar nimg = new Uint8Array(nw*nh*3), area=nw*nh;\n\t\t\tfor(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }\n\t\t\tcimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;\n\t\t}\n\t\tfrms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:cimg, bpl:bpl, bpp:bpp, blend:blend, dispose:brute?1:0});\n\t}\n\treturn {ctype:ctype, depth:depth, plte:plte, gotAlpha:gotAlpha, frames:frms  };\n}\n\nUPNG.encode._filterZero = function(img,h,bpp,bpl,data)\n{\n\tvar fls = [];\n\tfor(var t=0; t<5; t++) {  if(h*bpl>500000 && (t==2 || t==3 || t==4)) continue;\n\t\tfor(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, t);\n\t\tfls.push(pako[\"deflate\"](data));  if(bpp==1) break;\n\t}\n\tvar ti, tsize=1e9;\n\tfor(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }\n\treturn fls[ti];\n}\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)\n{\n\tvar i = y*bpl, di = i+y, paeth = UPNG.decode._paeth\n\tdata[di]=type;  di++;\n\n\tif(type==0) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];\n\telse if(type==1) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];\n\t\tfor(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;\n\t}\n\telse if(y==0) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] = img[i+x];\n\n\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];\n\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;\n\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;\n\t}\n\telse {\n\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }\n\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }\n\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }\n\t}\n}\n\nUPNG.crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }\n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n}\n\n\nUPNG.quantize = function(bufs, ps, roundAlpha)\n{\t\n\tvar imgs = [], totl = 0;\n\tfor(var i=0; i<bufs.length; i++) {  imgs.push(UPNG.encode.alphaMul(new Uint8Array(bufs[i]), roundAlpha));  totl+=bufs[i].byteLength;  }\n\t\n\tvar nimg = new Uint8Array(totl), nimg32 = new Uint32Array(nimg.buffer), noff=0;\n\tfor(var i=0; i<imgs.length; i++) {\n\t\tvar img = imgs[i], il = img.length;\n\t\tfor(var j=0; j<il; j++) nimg[noff+j] = img[j];\n\t\tnoff += il;\n\t}\n\t\n\tvar root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic\n\troot.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );\n\tvar leafs = [root];\n\t\n\twhile(leafs.length<ps)\n\t{\n\t\tvar maxL = 0, mi=0;\n\t\tfor(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }\n\t\tif(maxL<1e-3) break;\n\t\tvar node = leafs[mi];\n\t\t\n\t\tvar s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n\t\t\n\t\tvar ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );  \n\t\tln.est = UPNG.quantize.estats( ln.bst );\n\t\tvar rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};\n\t\tfor(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];\n\t\tfor(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];\n\t\trn.est = UPNG.quantize.estats( rn.bst );\n\t\t\n\t\tnode.left = ln;  node.right = rn;\n\t\tleafs[mi]=ln;  leafs.push(rn);\n\t}\n\tleafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });\n\t\n\tfor(var ii=0; ii<imgs.length; ii++) {\n\t\tvar planeDst = UPNG.quantize.planeDst;\n\t\tvar sb = new Uint8Array(imgs[ii].buffer), tb = new Uint32Array(imgs[ii].buffer), len = sb.length;\n\t\t\n\t\tvar stack = [], si=0;\n\t\tfor(var i=0; i<len; i+=4) {\n\t\t\tvar r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\n\t\t\t\n\t\t\t//  exact, but too slow :(\n\t\t\t//var nd = UPNG.quantize.getNearest(root, r, g, b, a);\n\t\t\tvar nd = root;\n\t\t\twhile(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n\t\t\t\n\t\t\ttb[i>>2] = nd.est.rgba;\n\t\t}\n\t\timgs[ii]=tb.buffer;\n\t}\n\treturn {  bufs:imgs, plte:leafs  };\n}\nUPNG.quantize.getNearest = function(nd, r,g,b,a)\n{\n\tif(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }\n\tvar planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);\n\t\n\tvar node0 = nd.left, node1 = nd.right;\n\tif(planeDst>0) {  node0=nd.right;  node1=nd.left;  }\n\t\n\tvar ln = UPNG.quantize.getNearest(node0, r,g,b,a);\n\tif(ln.tdst<=planeDst*planeDst) return ln;\n\tvar rn = UPNG.quantize.getNearest(node1, r,g,b,a);\n\treturn rn.tdst<ln.tdst ? rn : ln;\n}\nUPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }\nUPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }\n\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)\n{\n\tvar vecDot = UPNG.quantize.vecDot;\n\ti1-=4;\n\tvar shfs = 0;\n\twhile(i0<i1)\n\t{\n\t\twhile(vecDot(nimg, i0, e)<=eMq) i0+=4;\n\t\twhile(vecDot(nimg, i1, e)> eMq) i1-=4;\n\t\tif(i0>=i1) break;\n\t\t\n\t\tvar t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;\n\t\t\n\t\ti0+=4;  i1-=4;\n\t}\n\twhile(vecDot(nimg, i0, e)>eMq) i0-=4;\n\treturn i0+4;\n}\nUPNG.quantize.vecDot = function(nimg, i, e)\n{\n\treturn nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];\n}\nUPNG.quantize.stats = function(nimg, i0, i1){\n\tvar R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];\n\tvar m = [0,0,0,0];\n\tvar N = (i1-i0)>>2;\n\tfor(var i=i0; i<i1; i+=4)\n\t{\n\t\tvar r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);\n\t\t//var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n\t\tm[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;\n\t\t\n\t\tR[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;  \n\t\t               R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a; \n\t\t                              R[10] += b*b;  R[11] += b*a;  \n\t\t                                             R[15] += a*a;  \n\t}\n\tR[4]=R[1];  R[8]=R[2];  R[12]=R[3];  R[9]=R[6];  R[13]=R[7];  R[14]=R[11];\n\t\n\treturn {R:R, m:m, N:N};\n}\nUPNG.quantize.estats = function(stats){\n\tvar R = stats.R, m = stats.m, N = stats.N;\n\t\n\tvar m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);\n\tvar Rj = [\n\t\tR[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,  \n\t\tR[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,\n\t\tR[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,  \n\t\tR[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN \n\t];\n\t\n\tvar A = Rj, M = UPNG.M4;\n\tvar b = [0.5,0.5,0.5,0.5], mi = 0, tmi = 0;\n\t\n\tif(N!=0)\n\tfor(var i=0; i<10; i++) {\n\t\tb = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);\n\t\tif(Math.abs(tmi-mi)<1e-9) break;  mi = tmi;\n\t}\t\n\t//b = [0,0,1,0];  mi=N;\n\tvar q = [m0*iN, m1*iN, m2*iN, m3*iN];\n\tvar eMq255 = M.dot(M.sml(255,q),b);\n\t\n\tvar ia = (q[3]<0.001) ? 0 : 1/q[3];\n\t\n\treturn {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),\n\t\t\t\trgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2]*ia)<<16) |  (Math.round(255*q[1]*ia)<<8) | (Math.round(255*q[0]*ia)<<0))>>>0)  };\n}\nUPNG.M4 = {\n\tmultVec : function(m,v) {\n\t\t\treturn [\n\t\t\t\tm[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],\n\t\t\t\tm[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],\n\t\t\t\tm[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],\n\t\t\t\tm[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]\n\t\t\t];\n\t},\n\tdot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },\n\tsml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }\n}\n\nUPNG.encode.alphaMul = function(img, roundA) {\n\tvar nimg = new Uint8Array(img.length), area = img.length>>2; \n\tfor(var i=0; i<area; i++) {\n\t\tvar qi=i<<2, ia=img[qi+3];   \n\t\tif(roundA) ia = ((ia<128))?0:255;\n\t\tvar a = ia*(1/255);\n\t\tnimg[qi+0] = img[qi+0]*a;  nimg[qi+1] = img[qi+1]*a;  nimg[qi+2] = img[qi+2]*a;  nimg[qi+3] = ia;\n\t}\n\treturn nimg;\n}\n\n\t\n\t\n\t\n\t\n\t\n\n\n})(UPNG, pako);\n})();\n\n", "// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n", "'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n", "'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n", "'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n", "// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n", "'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n", "'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n", "'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n", "export * from \"./autoload\";\nexport * from \"./colors\";\nexport * from \"./glcartoon\";\nexport * from \"./GLDraw\";\nexport * from \"./GLModel\";\nexport * from \"./GLShape\";\nexport * from \"./GLViewer\";\nexport * from \"./Gradient\";\nexport * from \"./Label\";\nexport * from \"./parsers\";\nexport * from \"./partialCharges\";\nexport * from \"./ProteinSurface4\";\nexport * from \"./specs\";\nexport * from \"./utilities\";\nexport * from \"./VolumeData\";\nexport * from \"./VolumetricRender\";\nexport * from \"./WebGL/math\";\nexport * from \"./WebGL/shapes\";\n", "import { Vector3 } from \"./WebGL/math\";\nimport { Geometry } from \"./WebGL\";\nimport { Color, Colored } from \"colors\";\n\n\n//define enum values\n/**\n * Enum for cylinder cap styles.\n * @readonly\n * @enum \n * @property NONE\n * @property FLAT\n * @property ROUND\n */\nexport enum CAP {\n    NONE = 0,\n    FLAT = 1,\n    ROUND = 2\n};\n\nexport interface Point {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * Lower level utilities for creating WebGL shape geometries.\n * These are not intended for general consumption.\n * @namespace \n  */\nexport namespace GLDraw {\n\n    // Rotation matrix around z and x axis -\n    // according to y basis vector\n    // TODO: Try to optimize this (square roots?)\n    function getRotationMatrix(dx: number, dy: number, dz: number) {\n        var dxy = Math.hypot(dx, dy);\n        var dyz;\n\n        var sinA, cosA, sinB, cosB;\n\n        // about z axis - Phi\n        if (dxy < 0.0001) {\n            sinA = 0;\n            cosA = 1;\n        }\n\n        else {\n            sinA = -dx / dxy;\n            cosA = dy / dxy;\n        }\n\n        // recast dy in terms of new axes - z is the same\n\n        dy = -sinA * dx + cosA * dy;\n        dyz = Math.hypot(dy, dz);\n\n        // about new x axis - Theta\n\n        if (dyz < 0.0001) {\n            sinB = 0;\n            cosB = 1;\n        }\n\n        else {\n            sinB = dz / dyz;\n            cosB = dy / dyz;\n        }\n\n        var rot = new Float32Array(9);\n        rot[0] = cosA;\n        rot[1] = sinA;\n        rot[2] = 0;\n        rot[3] = -sinA * cosB;\n        rot[4] = cosA * cosB;\n        rot[5] = sinB;\n        rot[6] = sinA * sinB;\n        rot[7] = -cosA * sinB;\n        rot[8] = cosB;\n\n        return rot;\n\n    };\n\n\n    // memoize capped cylinder for given radius cylVertexCache\n    class CylVertexCache {\n\n        // memoize both rounded and flat caps (hemisphere and circle)\n        cache: any = {};\n\n\n        // Ortho normal vectors for cylinder radius/ sphere cap equator and cones\n        // Direction is j basis (0,1,0)\n        basisVectors: any;\n\n        constructor() {\n\n            //initialize basisVectors\n            let nvecs = [];\n\n            let subdivisions = 4; // including the initial 2, eg. 4 => 16 subintervals\n            let N = Math.pow(2, subdivisions);  // eg. 2**4 = 16 subintervals in total\n            let i = 2;  // start with 2 subdivisions already done\n            let M = Math.pow(2, i); // 4\n            let spacing = N / M;  // 16/4 = 4; if there were 5 subdivs, then 32/4 = 8.\n            let j: number;\n\n            nvecs[0] = new Vector3(-1, 0, 0);\n            nvecs[spacing] = new Vector3(0, 0, 1);\n            nvecs[spacing * 2] = new Vector3(1, 0, 0);\n            nvecs[spacing * 3] = new Vector3(0, 0, -1);\n\n            for (i = 3; i <= subdivisions; i++) {\n                // eg. i=3, we need to add 2**(3-1) = 4 new vecs. Call it M.\n                // their spacing is N/M, eg. N=16, M=4, N/M=4; M=8, N/M=2.\n                // they start off at half this spacing\n                // and are equal to the average of the two vectors on either side\n                M = Math.pow(2, (i - 1));\n                spacing = N / M;\n                for (j = 0; j < (M - 1); j++) {\n                    nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[(j + 1) * spacing]).normalize();\n                }\n                // treat the last one specially so it wraps around to zero\n                j = M - 1;\n                nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[0]).normalize();\n            }\n\n            this.basisVectors = nvecs;\n        };\n\n        getVerticesForRadius(radius: any, cap: CAP, capType: any) {\n            if (typeof (this.cache) !== \"undefined\" && this.cache[radius] !== undefined)\n                if (this.cache[radius][cap + capType] !== undefined)\n                    return this.cache[radius][cap + capType];\n\n            var w = this.basisVectors.length;\n            var nvecs = [], norms = [];\n            var n;\n\n            for (var i = 0; i < w; i++) {\n                // bottom\n                nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));\n                // top\n                nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));\n\n                // NOTE: this normal is used for constructing sphere caps -\n                // cylinder normals taken care of in drawCylinder\n                n = this.basisVectors[i].clone().normalize();\n                norms.push(n);\n                norms.push(n);\n            }\n\n            // norms[0]\n\n            var verticesRows = [];\n\n            // Require that heightSegments is even and >= 2\n            // Equator points at h/2 (theta = pi/2)\n            // (repeated) polar points at 0 and h (theta = 0 and pi)\n            var heightSegments = 10, widthSegments = w; // 16 or however many\n            // basis vectors for\n            // cylinder\n\n            if (heightSegments % 2 !== 0 || !heightSegments) {\n                console.error(\"heightSegments must be even\");\n                return null;\n            }\n\n            var phiStart = 0;\n            var phiLength = Math.PI * 2;\n\n            var thetaStart = 0;\n            var thetaLength = Math.PI;\n\n            var x: number, y:number;\n            var polar = false, equator = false;\n\n            for (y = 0; y <= heightSegments; y++) {\n\n                polar = (y === 0 || y === heightSegments) ? true : false;\n                equator = (y === heightSegments / 2) ? true : false;\n\n                var verticesRow = [], toRow = [];\n\n                for (x = 0; x <= widthSegments; x++) {\n\n                    // Two vertices rows for equator pointing to previously\n                    // constructed cyl points\n                    if (equator) {\n                        var xi = (x < widthSegments) ? 2 * x : 0;\n                        toRow.push(xi + 1);\n                        verticesRow.push(xi);\n\n                        continue;\n                    }\n\n                    var u = x / widthSegments;\n                    var v = y / heightSegments;\n\n                    // Only push first polar point\n\n                    if (!polar || x === 0) {\n\n                        if (x < widthSegments) {\n                            var vertex = new Vector3();\n                            vertex.x = -radius *\n                                Math.cos(phiStart + u * phiLength) *\n                                Math.sin(thetaStart + v * thetaLength);\n                            if (cap == 1)\n                                vertex.y = 0;\n                            else\n                                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n\n                            vertex.z = radius *\n                                Math.sin(phiStart + u * phiLength) *\n                                Math.sin(thetaStart + v * thetaLength);\n\n                            if (Math.abs(vertex.x) < 1e-5)\n                                vertex.x = 0;\n                            if (Math.abs(vertex.y) < 1e-5)\n                                vertex.y = 0;\n                            if (Math.abs(vertex.z) < 1e-5)\n                                vertex.z = 0;\n\n                            if (cap == CAP.FLAT) {\n                                n = new Vector3(0, Math.cos(thetaStart + v * thetaLength), 0);\n                                n.normalize();\n                            }\n                            else {\n                                n = new Vector3(vertex.x, vertex.y, vertex.z);\n                                n.normalize();\n                            }\n\n                            nvecs.push(vertex);\n                            norms.push(n);\n\n                            verticesRow.push(nvecs.length - 1);\n                        }\n\n                        // last point is just the first point for this row\n                        else {\n                            verticesRow.push(nvecs.length - widthSegments);\n                        }\n\n                    }\n\n                    // x > 0; index to already added point\n                    else if (polar)\n                        verticesRow.push(nvecs.length - 1);\n\n                }\n\n                // extra equator row\n                if (equator)\n                    verticesRows.push(toRow);\n\n                verticesRows.push(verticesRow);\n\n            }\n\n            var obj = {\n                vertices: nvecs,\n                normals: norms,\n                verticesRows: verticesRows,\n                w: widthSegments,\n                h: heightSegments\n            };\n\n            if (!(radius in this.cache)) this.cache[radius] = {};\n            this.cache[radius][cap + capType] = obj;\n\n            return obj;\n\n        }\n    };\n\n    var cylVertexCache = new CylVertexCache();\n\n    /** \n     * Create a cylinder \n     * @memberof GLDraw \n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            from\n     * @param {Point}\n     *            to\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     * @param {CAP} fromCap - 0 for none, 1 for flat, 2 for round\n     * @param {CAP} toCap = 0 for none, 1 for flat, 2 for round\n     *            \n     * */\n    export function drawCylinder(geo: Geometry, from: any, to: any, radius: number, color: Color | Color[], fromCap:CAP|string = 0, toCap:CAP|string = 0) {\n        if (!from || !to)\n            return;\n\n        let getcap = function(c: CAP|string): CAP {\n            if(typeof c === \"string\") {\n                let s = <string>c;\n                if(s.toLowerCase() == 'flat') {\n                    return CAP.FLAT;\n                } else if(s.toLowerCase() == 'round') {\n                    return CAP.ROUND;\n                } else {\n                    return CAP.NONE;\n                }\n            } else {\n                return <CAP>c;\n            }\n        }\n        fromCap = getcap(fromCap);\n        toCap = getcap(toCap);\n        \n        // vertices\n        var drawcaps = toCap || fromCap;\n        color = color || ({ r: 0, g: 0, b: 0 } as Color);\n\n        var e = getRotationMatrix(to.x-from.x, to.y-from.y, to.z-from.z);\n        // get orthonormal vectors from cache\n        // TODO: Will have orient with model view matrix according to direction\n\n        var vobj = cylVertexCache.getVerticesForRadius(radius, toCap, \"to\");\n        // w (n) corresponds to the number of orthonormal vectors for cylinder\n        // (default 16)\n        var n = vobj.w, h = vobj.h;\n\n        // get orthonormal vector\n        var n_verts = (drawcaps) ? h * n + 2 : 2 * n;\n\n        var geoGroup = geo.updateGeoGroup(n_verts);\n\n        var vertices = vobj.vertices, normals = vobj.normals, verticesRows = vobj.verticesRows;\n        var toRow = verticesRows[h / 2], fromRow = verticesRows[h / 2 + 1];\n\n        var start = geoGroup.vertices;\n        var offset, faceoffset;\n        var i, x, y, z;\n\n        var vertexArray = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        // add vertices, opposing vertices paired together\n        for (i = 0; i < n; ++i) {\n\n            var vi = 2 * i;\n\n            x = e[0] * vertices[vi].x + e[3] * vertices[vi].y + e[6] * vertices[vi].z;\n            y = e[1] * vertices[vi].x + e[4] * vertices[vi].y + e[7] * vertices[vi].z;\n            z = e[5] * vertices[vi].y + e[8] * vertices[vi].z;\n\n            // var xn = x/radius, yn = y/radius, zn = z/radius;\n\n            offset = 3 * (start + vi);\n            faceoffset = geoGroup.faceidx;\n\n            // from\n            vertexArray[offset] = x + from.x;\n            vertexArray[offset + 1] = y + from.y;\n            vertexArray[offset + 2] = z + from.z;\n            // to\n            vertexArray[offset + 3] = x + to.x;\n            vertexArray[offset + 4] = y + to.y;\n            vertexArray[offset + 5] = z + to.z;\n\n            // normals\n            normalArray[offset] = x;\n            normalArray[offset + 3] = x;\n            normalArray[offset + 1] = y;\n            normalArray[offset + 4] = y;\n            normalArray[offset + 2] = z;\n            normalArray[offset + 5] = z;\n\n            // colors\n            colorArray[offset] = (color as Color).r;\n            colorArray[offset + 3] = (color as Color).r;\n            colorArray[offset + 1] = (color as Color).g;\n            colorArray[offset + 4] = (color as Color).g;\n            colorArray[offset + 2] = (color as Color).b;\n            colorArray[offset + 5] = (color as Color).b;\n\n            // faces\n            // 0 - 2 - 1\n            faceArray[faceoffset] = fromRow[i] + start;\n            faceArray[faceoffset + 1] = fromRow[i + 1] + start;\n            faceArray[faceoffset + 2] = toRow[i] + start;\n            // 1 - 2 - 3\n            faceArray[faceoffset + 3] = toRow[i] + start;\n            faceArray[faceoffset + 4] = fromRow[i + 1] + start;\n            faceArray[faceoffset + 5] = toRow[i + 1] + start;\n\n            geoGroup.faceidx += 6;\n\n        }\n\n        // SPHERE CAPS\n        if (drawcaps) {\n            // h - sphere rows, verticesRows.length - 2\n\n            var ystart = (toCap) ? 0 : h / 2;\n            var yend = (fromCap) ? h + 1 : h / 2 + 1;\n            var v1, v2, v3, v4, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, nx1, nx2, nx3, nx4, ny1, ny2, ny3, ny4, nz1, nz2, nz3, nz4, v1offset, v2offset, v3offset, v4offset;\n\n            for (y = ystart; y < yend; y++) {\n                if (y === h / 2)\n                    continue;\n                // n number of points for each level (verticesRows[i].length -\n                // 1)\n                var cap = (y <= h / 2) ? to : from;\n                var toObj = cylVertexCache.getVerticesForRadius(radius, toCap, \"to\");\n                var fromObj = cylVertexCache.getVerticesForRadius(radius, fromCap, \"from\");\n                if (cap === to) {\n                    vertices = toObj.vertices;\n                    normals = toObj.normals;\n                    verticesRows = toObj.verticesRows;\n                } else if (cap == from) {\n                    vertices = fromObj.vertices;\n                    normals = fromObj.normals;\n                    verticesRows = fromObj.verticesRows;\n                }\n                for (x = 0; x < n; x++) {\n\n                    faceoffset = geoGroup.faceidx;\n\n                    v1 = verticesRows[y][x + 1];\n                    v1offset = (v1 + start) * 3;\n                    v2 = verticesRows[y][x];\n                    v2offset = (v2 + start) * 3;\n                    v3 = verticesRows[y + 1][x];\n                    v3offset = (v3 + start) * 3;\n                    v4 = verticesRows[y + 1][x + 1];\n                    v4offset = (v4 + start) * 3;\n\n                    // rotate sphere vectors\n                    x1 = e[0] * vertices[v1].x + e[3] * vertices[v1].y + e[6] * vertices[v1].z;\n                    x2 = e[0] * vertices[v2].x + e[3] * vertices[v2].y + e[6] * vertices[v2].z;\n                    x3 = e[0] * vertices[v3].x + e[3] * vertices[v3].y + e[6] * vertices[v3].z;\n                    x4 = e[0] * vertices[v4].x + e[3] * vertices[v4].y + e[6] * vertices[v4].z;\n\n                    y1 = e[1] * vertices[v1].x + e[4] * vertices[v1].y + e[7] * vertices[v1].z;\n                    y2 = e[1] * vertices[v2].x + e[4] * vertices[v2].y + e[7] * vertices[v2].z;\n                    y3 = e[1] * vertices[v3].x + e[4] * vertices[v3].y + e[7] * vertices[v3].z;\n                    y4 = e[1] * vertices[v4].x + e[4] * vertices[v4].y + e[7] * vertices[v4].z;\n\n                    z1 = e[5] * vertices[v1].y + e[8] * vertices[v1].z;\n                    z2 = e[5] * vertices[v2].y + e[8] * vertices[v2].z;\n                    z3 = e[5] * vertices[v3].y + e[8] * vertices[v3].z;\n                    z4 = e[5] * vertices[v4].y + e[8] * vertices[v4].z;\n\n                    vertexArray[v1offset] = x1 + cap.x;\n                    vertexArray[v2offset] = x2 + cap.x;\n                    vertexArray[v3offset] = x3 + cap.x;\n                    vertexArray[v4offset] = x4 + cap.x;\n\n                    vertexArray[v1offset + 1] = y1 + cap.y;\n                    vertexArray[v2offset + 1] = y2 + cap.y;\n                    vertexArray[v3offset + 1] = y3 + cap.y;\n                    vertexArray[v4offset + 1] = y4 + cap.y;\n\n                    vertexArray[v1offset + 2] = z1 + cap.z;\n                    vertexArray[v2offset + 2] = z2 + cap.z;\n                    vertexArray[v3offset + 2] = z3 + cap.z;\n                    vertexArray[v4offset + 2] = z4 + cap.z;\n\n                    colorArray[v1offset] = (color as Color).r;\n                    colorArray[v2offset] = (color as Color).r;\n                    colorArray[v3offset] = (color as Color).r;\n                    colorArray[v4offset] = (color as Color).r;\n\n                    colorArray[v1offset + 1] = (color as Color).g;\n                    colorArray[v2offset + 1] = (color as Color).g;\n                    colorArray[v3offset + 1] = (color as Color).g;\n                    colorArray[v4offset + 1] = (color as Color).g;\n\n                    colorArray[v1offset + 2] = (color as Color).b;\n                    colorArray[v2offset + 2] = (color as Color).b;\n                    colorArray[v3offset + 2] = (color as Color).b;\n                    colorArray[v4offset + 2] = (color as Color).b;\n\n                    nx1 = e[0] * normals[v1].x + e[3] * normals[v1].y + e[6] * normals[v1].z;\n                    nx2 = e[0] * normals[v2].x + e[3] * normals[v2].y + e[6] * normals[v2].z;\n                    nx3 = e[0] * normals[v3].x + e[3] * normals[v3].y + e[6] * normals[v3].z;\n                    nx4 = e[0] * normals[v4].x + e[3] * normals[v4].y + e[6] * normals[v4].z;\n\n                    ny1 = e[1] * normals[v1].x + e[4] * normals[v1].y + e[7] * normals[v1].z;\n                    ny2 = e[1] * normals[v2].x + e[4] * normals[v2].y + e[7] * normals[v2].z;\n                    ny3 = e[1] * normals[v3].x + e[4] * normals[v3].y + e[7] * normals[v3].z;\n                    ny4 = e[1] * normals[v4].x + e[4] * normals[v4].y + e[7] * normals[v4].z;\n\n                    nz1 = e[5] * normals[v1].y + e[8] * normals[v1].z;\n                    nz2 = e[5] * normals[v2].y + e[8] * normals[v2].z;\n                    nz3 = e[5] * normals[v3].y + e[8] * normals[v3].z;\n                    nz4 = e[5] * normals[v4].y + e[8] * normals[v4].z;\n\n                    // if (Math.abs(vobj.sphereVertices[v1].y) === radius) {\n\n                    if (y === 0) {//to center circle\n                        // face = [v1, v3, v4];\n                        // norm = [n1, n3, n4];\n\n                        normalArray[v1offset] = nx1;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v3offset + 2] = nz3;\n                        normalArray[v4offset + 2] = nz4;\n\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v3 + start;\n                        faceArray[faceoffset + 2] = v4 + start;\n\n                        geoGroup.faceidx += 3;\n\n                    }\n\n                    // else if (Math.abs(vobj.sphereVertices[v3].y) === radius)\n                    // {\n                    else if (y === yend - 1) {//from end center circle\n                        // face = [v1, v2, v3];\n                        // norm = [n1, n2, n3];\n\n                        normalArray[v1offset] = nx1;\n                        normalArray[v2offset] = nx2;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v3offset + 2] = nz3;\n\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v2 + start;\n                        faceArray[faceoffset + 2] = v3 + start;\n\n                        geoGroup.faceidx += 3;\n\n                    }\n\n                    else { // the rest of the circles\n                        // face = [v1, v2, v3, v4];\n                        // norm = [n1, n2, n3, n4];\n\n                        normalArray[v1offset] = nx1;\n                        normalArray[v2offset] = nx2;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v4offset + 2] = nz4;\n\n                        normalArray[v2offset] = nx2;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v3offset + 2] = nz3;\n                        normalArray[v4offset + 2] = nz4;\n\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v2 + start;\n                        faceArray[faceoffset + 2] = v4 + start;\n\n                        faceArray[faceoffset + 3] = v2 + start;\n                        faceArray[faceoffset + 4] = v3 + start;\n                        faceArray[faceoffset + 5] = v4 + start;\n\n                        geoGroup.faceidx += 6;\n                    }\n\n                }\n            }\n\n        }\n\n        geoGroup.vertices += n_verts;\n    };\n\n\n    /** Create a cone \n     * @memberof GLDraw\n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            from\n     * @param {Point}\n     *            to\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     *            */\n    export function drawCone (geo: Geometry, from: any, to: any, radius: number, color?: Color) {\n        if (!from || !to)\n            return;\n\n        // TODO: check if from and to do not contain x,y,z and if  so generate a center based on the passed selections\n\n        color = color || ({ r: 0, g: 0, b: 0 } as Color);\n\n        let ndir = new Vector3(to.x-from.x, to.y-from.y, to.z-from.z);\n        var e = getRotationMatrix(ndir.x, ndir.y, ndir.z);\n        ndir = ndir.normalize();\n\n        // n vertices around bottom plust the two points\n        var n = cylVertexCache.basisVectors.length;\n        var basis = cylVertexCache.basisVectors;\n        var n_verts = n + 2;\n\n        //setup geo structures\n        var geoGroup = geo.updateGeoGroup(n_verts);\n        var start = geoGroup.vertices;\n        var offset, faceoffset;\n        var i, x, y, z;\n        var vertexArray = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n\n        offset = start * 3;\n        //base point first vertex\n        vertexArray[offset] = from.x;\n        vertexArray[offset + 1] = from.y;\n        vertexArray[offset + 2] = from.z;\n        normalArray[offset] = -ndir.x;\n        normalArray[offset + 1] = -ndir.y;\n        normalArray[offset + 2] = -ndir.z;\n        colorArray[offset] = color.r;\n        colorArray[offset + 1] = color.g;\n        colorArray[offset + 2] = color.b;\n\n        //second vertex top\n        vertexArray[offset + 3] = to.x;\n        vertexArray[offset + 4] = to.y;\n        vertexArray[offset + 5] = to.z;\n\n        normalArray[offset + 3] = ndir.x;\n        normalArray[offset + 4] = ndir.y;\n        normalArray[offset + 5] = ndir.z;\n        colorArray[offset + 3] = color.r;\n        colorArray[offset + 4] = color.g;\n        colorArray[offset + 5] = color.b;\n\n        offset += 6;\n\n        // add circle vertices\n        for (i = 0; i < n; ++i) {\n            var vec = basis[i].clone();\n            vec.multiplyScalar(radius);\n            x = e[0] * vec.x + e[3] * vec.y + e[6] * vec.z;\n            y = e[1] * vec.x + e[4] * vec.y + e[7] * vec.z;\n            z = e[5] * vec.y + e[8] * vec.z;\n\n            // from\n            vertexArray[offset] = x + from.x;\n            vertexArray[offset + 1] = y + from.y;\n            vertexArray[offset + 2] = z + from.z;\n\n            // normals\n            normalArray[offset] = x;\n            normalArray[offset + 1] = y;\n            normalArray[offset + 2] = z;\n\n            // colors\n            colorArray[offset] = color.r;\n            colorArray[offset + 1] = color.g;\n            colorArray[offset + 2] = color.b;\n\n            offset += 3;\n\n        }\n        geoGroup.vertices += (n + 2);\n        //faces\n        faceoffset = geoGroup.faceidx;\n        for (i = 0; i < n; i++) {\n            //two neighboring circle vertices\n            var v1 = start + 2 + i;\n            var v2 = start + 2 + ((i + 1) % n);\n\n            faceArray[faceoffset] = v1;\n            faceArray[faceoffset + 1] = v2;\n            faceArray[faceoffset + 2] = start;\n            faceoffset += 3;\n            faceArray[faceoffset] = v1;\n            faceArray[faceoffset + 1] = v2;\n            faceArray[faceoffset + 2] = start + 1;\n            faceoffset += 3;\n        }\n        geoGroup.faceidx += 6 * n;\n    };\n\n    interface MyObject {\n        vertices: any[];\n        verticesRows: any[][];\n        normals: any[];\n     }\n\n    // Sphere component sphereVertexCache\n    class  SphereVertexCache {\n        private cache = new Map<number, Map<number, any>>(); //sphereQuality then radius\n        constructor() {}\n\n        getVerticesForRadius(radius: number, sphereQuality: any) {\n            sphereQuality = sphereQuality || 2;\n\n            if (!this.cache.has(sphereQuality))  {\n                this.cache.set(sphereQuality, new Map<number,any>());\n            }\n            let radiusCache = this.cache.get(sphereQuality);\n            if (radiusCache.has(radius))\n                return radiusCache.get(radius);\n\n            var obj: MyObject = {\n                vertices: [],\n                verticesRows: [],\n                normals: []\n            };\n            // scale quality with radius heuristically\n            var widthSegments = 16 * sphereQuality;\n            var heightSegments = 10 * sphereQuality;\n            if (radius < 1) {\n                widthSegments = 10 * sphereQuality;\n                heightSegments = 8 * sphereQuality;\n            }\n\n            var phiStart = 0;\n            var phiLength = Math.PI * 2;\n\n            var thetaStart = 0;\n            var thetaLength = Math.PI;\n\n            var x, y;\n\n            for (y = 0; y <= heightSegments; y++) {\n\n                let verticesRow = [];\n                for (x = 0; x <= widthSegments; x++) {\n\n                    let u = x / widthSegments;\n                    let v = y / heightSegments;\n\n                    let vx = -radius * Math.cos(phiStart + u * phiLength) *\n                        Math.sin(thetaStart + v * thetaLength);\n                    let vy = radius * Math.cos(thetaStart + v * thetaLength);\n                    let vz = radius * Math.sin(phiStart + u * phiLength) *\n                        Math.sin(thetaStart + v * thetaLength);\n\n                    var n = new Vector3(vx, vy, vz);\n                    n.normalize();\n\n                    obj.vertices.push({x: vx, y: vy, z: vz});\n                    obj.normals.push(n);\n\n                    verticesRow.push(obj.vertices.length - 1);\n\n                }\n\n                obj.verticesRows.push(verticesRow);\n\n            }\n\n            radiusCache.set(radius, obj);\n            return obj;\n        }\n\n    };\n    var sphereVertexCache = new SphereVertexCache();\n\n    /** Create a sphere.\n     * @memberof GLDraw\n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            pos\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     * @param {number} \n     *            sphereQuality - Quality of sphere (default 2, higher increases number of triangles)\n     */\n    export function drawSphere(geo:Geometry, pos: any, radius: number, color: Colored, sphereQuality?: number) {\n\n        var vobj = sphereVertexCache.getVerticesForRadius(radius, sphereQuality);\n\n        var vertices = vobj.vertices;\n        var normals = vobj.normals;\n\n        var geoGroup = geo.updateGeoGroup(vertices.length);\n\n        var start = geoGroup.vertices;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        var lineArray = geoGroup.lineArray;\n        var normalArray = geoGroup.normalArray;\n\n        for (let i = 0, il = vertices.length; i < il; ++i) {\n            let offset = 3 * (start + i);\n            let v = vertices[i];\n\n            vertexArray[offset] = (v.x + pos.x);\n            vertexArray[offset + 1] = (v.y + pos.y);\n            vertexArray[offset + 2] = (v.z + pos.z);\n\n            colorArray[offset] = (color as Colored).r;\n            colorArray[offset + 1] = (color as Colored).g;\n            colorArray[offset + 2] = (color as Colored).b;\n\n        }\n\n        geoGroup.vertices += vertices.length;\n\n        let verticesRows = vobj.verticesRows;\n        let h = verticesRows.length - 1;\n\n        for (let y = 0; y < h; y++) {\n            let w = verticesRows[y].length - 1;\n            for (let x = 0; x < w; x++) {\n\n                let faceoffset = geoGroup.faceidx, lineoffset = geoGroup.lineidx;\n\n                let v1 = verticesRows[y][x + 1] + start, v1offset = v1 * 3;\n                let v2 = verticesRows[y][x] + start, v2offset = v2 * 3;\n                let v3 = verticesRows[y + 1][x] + start, v3offset = v3 * 3;\n                let v4 = verticesRows[y + 1][x + 1] + start, v4offset = v4 * 3;\n\n                let n1 = normals[v1 - start];\n                let n2 = normals[v2 - start];\n                let n3 = normals[v3 - start];\n                let n4 = normals[v4 - start];\n\n                if (Math.abs(vertices[v1 - start].y) === radius) {\n                    // face = [v1, v3, v4];\n                    // norm = [n1, n3, n4];\n\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v3offset + 2] = n3.z;\n                    normalArray[v4offset + 2] = n4.z;\n\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v3;\n                    faceArray[faceoffset + 2] = v4;\n\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v3;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v4;\n                    lineArray[lineoffset + 4] = v3;\n                    lineArray[lineoffset + 5] = v4;\n\n                    geoGroup.faceidx += 3;\n                    geoGroup.lineidx += 6;\n\n                } else if (Math.abs(vertices[v3 - start].y) === radius) {\n                    // face = [v1, v2, v3];\n                    // norm = [n1, n2, n3];\n\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v3offset + 2] = n3.z;\n\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v2;\n                    faceArray[faceoffset + 2] = v3;\n\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v2;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v3;\n                    lineArray[lineoffset + 4] = v2;\n                    lineArray[lineoffset + 5] = v3;\n\n                    geoGroup.faceidx += 3;\n                    geoGroup.lineidx += 6;\n\n                } else {\n                    // face = [v1, v2, v3, v4];\n                    // norm = [n1, n2, n3, n4];\n\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v4offset + 2] = n4.z;\n\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v3offset + 2] = n3.z;\n                    normalArray[v4offset + 2] = n4.z;\n\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v2;\n                    faceArray[faceoffset + 2] = v4;\n\n                    faceArray[faceoffset + 3] = v2;\n                    faceArray[faceoffset + 4] = v3;\n                    faceArray[faceoffset + 5] = v4;\n\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v2;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v4;\n\n                    lineArray[lineoffset + 4] = v2;\n                    lineArray[lineoffset + 5] = v3;\n                    lineArray[lineoffset + 6] = v3;\n                    lineArray[lineoffset + 7] = v4;\n\n                    geoGroup.faceidx += 6;\n                    geoGroup.lineidx += 8;\n\n                }\n\n            }\n        }\n\n    };\n\n}\n", "// A model is a collection of related atoms.  Bonds are only allowed between\n//atoms in the same model.  An atom is uniquely specified by its model id and\n//its serial number.\n//A glmodel knows how to apply the styles on each atom to create a gl object\nimport { Geometry, Material, StickImposterMaterial } from \"./WebGL\";\nimport { Sphere, Cylinder } from \"./WebGL/shapes\";\nimport { Vector3, Matrix4, conversionMatrix3, Matrix3, XYZ } from \"./WebGL/math\";\nimport { Color, CC, ColorschemeSpec, ColorSpec } from \"./colors\";\nimport { InstancedMaterial, SphereImposterMaterial, MeshLambertMaterial, Object3D, Mesh, LineBasicMaterial, Line, LineStyle } from \"./WebGL\";\nimport { CAP, GLDraw } from \"./GLDraw\"\nimport { CartoonStyleSpec, drawCartoon } from \"./glcartoon\";\nimport { elementColors } from \"./colors\";\nimport { get, deepCopy, extend, getExtent, getAtomProperty, makeFunction, getPropertyRange, specStringToObject, getbin, getColorFromStyle, inflateString } from \"./utilities\";\nimport { Gradient } from \"./Gradient\";\nimport { Parsers } from \"./parsers\";\nimport { NetCDFReader } from \"netcdfjs\"\nimport { AtomSelectionSpec, AtomSpec } from \"./specs\";\nimport { GLViewer } from \"GLViewer\";\nimport { ArrowSpec } from \"GLShape\";\nimport { ParserOptionsSpec } from \"./parsers/ParserOptionsSpec\";\nimport { LabelSpec } from \"Label\";\nimport { assignBonds } from \"./parsers/utils/assignBonds\";\n\n/**\n * GLModel represents a group of related atoms\n * @class\n */\nexport class GLModel {\n\n    // class variables go here\n    static defaultAtomStyle: AtomStyleSpec = {\n        line: {}\n    };\n\n    static defaultlineWidth = 1.0;\n\n    // Reference: A. Bondi, J. Phys. Chem., 1964, 68, 441.\n    // https://en.wikipedia.org/wiki/Van_der_Waals_radius\n    static vdwRadii = {\n        \"H\": 1.2,\n        \"He\": 1.4,\n        \"Li\": 1.82,\n        \"Be\": 1.53,\n        \"B\": 1.92,\n        \"C\": 1.7,\n        \"N\": 1.55,\n        \"O\": 1.52,\n        \"F\": 1.47,\n        \"Ne\": 1.54,\n        \"Na\": 2.27,\n        \"Mg\": 1.73,\n        \"Al\": 1.84,\n        \"Si\": 2.1,\n        \"P\": 1.8,\n        \"S\": 1.8,\n        \"Cl\": 1.75,\n        \"Ar\": 1.88,\n        \"K\": 2.75,\n        \"Ca\": 2.31,\n        \"Ni\": 1.63,\n        \"Cu\": 1.4,\n        \"Zn\": 1.39,\n        \"Ga\": 1.87,\n        \"Ge\": 2.11,\n        \"As\": 1.85,\n        \"Se\": 1.9,\n        \"Br\": 1.85,\n        \"Kr\": 2.02,\n        \"Rb\": 3.03,\n        \"Sr\": 2.49,\n        \"Pd\": 1.63,\n        \"Ag\": 1.72,\n        \"Cd\": 1.58,\n        \"In\": 1.93,\n        \"Sn\": 2.17,\n        \"Sb\": 2.06,\n        \"Te\": 2.06,\n        \"I\": 1.98,\n        \"Xe\": 2.16,\n        \"Cs\": 3.43,\n        \"Ba\": 2.68,\n        \"Pt\": 1.75,\n        \"Au\": 1.66,\n        \"Hg\": 1.55,\n        \"Tl\": 1.96,\n        \"Pb\": 2.02,\n        \"Bi\": 2.07,\n        \"Po\": 1.97,\n        \"At\": 2.02,\n        \"Rn\": 2.20,\n        \"Fr\": 3.48,\n        \"Ra\": 2.83,\n        \"U\": 1.86\n    };\n\n    // class functions\n    // return true if a and b represent the same style\n    static sameObj(a, b) {\n        if (a && b)\n            return JSON.stringify(a) == JSON.stringify(b);\n        else\n            return a == b;\n    };\n\n    public unitCellObjects: any;\n\n    // private variables\n    private atoms: AtomSpec[] = [];\n    private frames: any = [];\n    private box: any = null;\n    private atomdfs: any = null; //depth first search over connected components\n    private id = 0;\n    private hidden: any = false;\n    private molObj: any = null;\n    private renderedMolObj: any = null;\n    private lastColors: any = null;\n    private modelData: any = {};\n    private modelDatas: any = null; //if there is different modelData per frame\n    private idMatrix = new Matrix4();\n    private dontDuplicateAtoms = true;\n    private defaultColor = elementColors.defaultColor;\n\n    private options: any;\n    private ElementColors: any;\n\n    private viewer: GLViewer;\n\n    private readonly defaultSphereRadius: number;\n    private readonly defaultCartoonQuality: number;\n    // bonds as cylinders\n    private readonly defaultStickRadius = 0.25;\n\n    constructor(mid, options?, viewer?) {\n\n        this.options = options || {};\n        this.viewer = viewer;\n        this.ElementColors = (this.options.defaultcolors) ? this.options.defaultcolors : elementColors.defaultColors;\n\n        this.defaultSphereRadius = (this.options.defaultSphereRadius) ? this.options.defaultSphereRadius : 1.5;\n        this.defaultCartoonQuality = (this.options.cartoonQuality) ? this.options.cartoonQuality : 10;\n        this.id = mid;\n    }\n    // return proper radius for atom given style\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {atomstyle} style\n     * @return {number}\n     *\n     */\n    private getRadiusFromStyle(atom: AtomSpec, style: SphereStyleSpec | ClickSphereStyleSpec | CrossStyleSpec) {\n        var r = this.defaultSphereRadius;\n        if (typeof (style.radius) != \"undefined\")\n            r = style.radius;\n        else if (GLModel.vdwRadii[atom.elem])\n            r = GLModel.vdwRadii[atom.elem];\n        else if (atom.elem.length > 1) { //see if adjusting case helps\n            let e: string = atom.elem;\n            e = e[0].toUpperCase() + e[1].toLowerCase();\n            if (GLModel.vdwRadii[e])\n                r = GLModel.vdwRadii[e];\n        }\n\n        if (typeof (style.scale) != \"undefined\")\n            r *= style.scale;\n        return r;\n    };\n\n    // cross drawing\n\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {Record<number, Geometry>} geos\n     */\n    private drawAtomCross(atom: AtomSpec, geos: Record<number, Geometry>) {\n        if (!atom.style.cross)\n            return;\n        var style = atom.style.cross;\n        if (style.hidden)\n            return;\n        var linewidth = (style.linewidth || GLModel.defaultlineWidth);\n        if (!geos[linewidth])\n            geos[linewidth] = new Geometry();\n\n        var geoGroup = geos[linewidth].updateGeoGroup(6);\n\n        var delta = this.getRadiusFromStyle(atom, style);\n\n        var points = [[delta, 0, 0], [-delta, 0, 0], [0, delta, 0],\n        [0, -delta, 0], [0, 0, delta], [0, 0, -delta]];\n\n        var clickable = atom.clickable || atom.hoverable;\n        if (clickable && atom.intersectionShape === undefined)\n            atom.intersectionShape = { sphere: [], cylinder: [], line: [] };\n\n        var c = getColorFromStyle(atom, style);\n\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n\n        for (var j = 0; j < 6; j++) {\n\n            var offset = geoGroup.vertices * 3;\n\n            geoGroup.vertices++;\n            vertexArray[offset] = atom.x + points[j][0];\n            vertexArray[offset + 1] = atom.y + points[j][1];\n            vertexArray[offset + 2] = atom.z + points[j][2];\n            colorArray[offset] = c.r;\n            colorArray[offset + 1] = c.g;\n            colorArray[offset + 2] = c.b;\n\n            if (clickable) {\n                var point = new Vector3(points[j][0], points[j][1], points[j][2]);\n\n                //decrease cross size for selection to prevent misselection from atom overlap\n                point.multiplyScalar(0.1);\n                point.set(point.x + atom.x, point.y + atom.y, point.z + atom.z);\n                atom.intersectionShape.line.push(point);\n            }\n\n        }\n\n    };\n\n    private getGoodCross(atom: AtomSpec, atom2: AtomSpec, p1, dir) {\n        // get vector 2 different neighboring atom\n        //find most divergent neighbor\n        var bestv = null;\n        var bestlen = -1;\n        for (var j = 0, n = atom.bonds.length; j < n; j++) {\n            if (atom.bonds[j] != atom2.index) {\n                let j2 = atom.bonds[j];\n                let atom3 = this.atoms[j2];\n                let p3 = new Vector3(atom3.x, atom3.y, atom3.z);\n\n                let dir2 = p3.clone();\n                dir2.sub(p1);\n\n                let v = dir2.clone();\n                v.cross(dir);\n                var l = v.lengthSq();\n                if (l > bestlen) {\n                    bestlen = l;\n                    bestv = v;\n                    if (bestlen > 0.1) {\n                        return bestv;\n                    }\n                }\n            }\n        }\n        return bestv;\n    };\n\n\n    //from atom, return a normalized vector v that is orthogonal and along which\n    //it is appropraite to draw multiple bonds\n    private getSideBondV(atom: AtomSpec, atom2: AtomSpec, i: number) {\n\n        var i2, j2, atom3, p3, dir2;\n        var p1 = new Vector3(atom.x, atom.y, atom.z);\n        var p2 = new Vector3(atom2.x, atom2.y, atom2.z);\n        var dir = p2.clone();\n        var v = null;\n        dir.sub(p1);\n\n\n        if (atom.bonds.length === 1) {\n            if (atom2.bonds.length === 1) {\n                v = dir.clone();\n                if (Math.abs(v.x) > 0.0001)\n                    v.y += 1;\n                else\n                    v.x += 1;\n            } else {\n                // pick a distinct neighbor of atom2 (not atom) to define an offset direction\n                atom3 = null;\n                for (i2 = 0; i2 < atom2.bonds.length; i2++) {\n                    j2 = atom2.bonds[i2];\n                    if (j2 !== atom.index) {\n                        atom3 = this.atoms[j2];\n                        break;\n                    }\n                }\n                if (!atom3) {\n                    // degenerate case: no distinct neighbor found\n                    v = dir.clone();\n                    v.x += 1;\n                } else {\n                    p3 = new Vector3(atom3.x, atom3.y, atom3.z);\n                    dir2 = p3.clone();\n                    dir2.sub(p1);\n                    v = dir2.clone();\n                    v.cross(dir);\n                }\n            }\n        } else {\n            v = this.getGoodCross(atom, atom2, p1, dir);\n\n            if (v.lengthSq() < 0.01) {\n                var v2 = this.getGoodCross(atom2, atom, p1, dir);\n                if (v2 != null) v = v2; //can be null if no other neighbors\n            }\n        }\n\n        // especially for C#C (triple bond) dir and dir2\n        // may be opposites resulting in a zero v\n        if (v.lengthSq() < 0.01) {\n            v = dir.clone();\n            if (Math.abs(v.x) > 0.0001)\n                v.y += 1;\n            else\n                v.x += 1;\n        }\n\n        v.cross(dir);\n        v.normalize();\n\n        return v;\n    };\n\n    private addLine(vertexArray, colorArray, offset, p1: Vector3, p2: Vector3, c1: Color) {\n        //make line from p1 to p2, does not incremeant counts\n        vertexArray[offset] = p1.x; vertexArray[offset + 1] = p1.y; vertexArray[offset + 2] = p1.z;\n        colorArray[offset] = c1.r; colorArray[offset + 1] = c1.g; colorArray[offset + 2] = c1.b;\n        vertexArray[offset + 3] = p2.x; vertexArray[offset + 4] = p2.y; vertexArray[offset + 5] = p2.z;\n        colorArray[offset + 3] = c1.r; colorArray[offset + 4] = c1.g; colorArray[offset + 5] = c1.b;\n    };\n\n\n    // bonds - both atoms must match bond style\n    // standardize on only drawing for lowest to highest\n    /**\n     *\n     * @param {AtomSpec}\n     *            atom\n     * @param {AtomSpec[]} atoms\n     * @param {Record<number,Geometry>} geos\n     */\n    private drawBondLines(atom: AtomSpec, atoms: AtomSpec[], geos: Record<number, Geometry>) {\n        if (!atom.style.line)\n            return;\n        var style = atom.style.line;\n        if (style.hidden)\n            return;\n        var p1a, p1b, p2a, p2b;\n        // have a separate geometry for each linewidth\n        var linewidth = (style.linewidth || GLModel.defaultlineWidth);\n\n        if (!geos[linewidth])\n            geos[linewidth] = new Geometry();\n        /** @type {geometryGroup} */\n        var geoGroup = geos[linewidth].updateGeoGroup(6 * atom.bonds.length); //reserve enough space even for triple bonds\n\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n\n        for (var i = 0; i < atom.bonds.length; i++) {\n            var j = atom.bonds[i]; // our neighbor\n\n            var atom2 = atoms[j];\n            if (!atom2.style.line)\n                continue; // don't sweat the details\n\n            if (atom.index >= atom2.index) // only draw if less, this way we can do multi bonds correctly\n                continue;\n            var p1 = new Vector3(atom.x, atom.y, atom.z);\n            var p2 = new Vector3(atom2.x, atom2.y, atom2.z);\n            var mp = p1.clone().add(p2).multiplyScalar(0.5);\n            var singleBond = false;\n\n            var atomneedsi = atom.clickable || atom.hoverable;\n            var atom2needsi = atom2.clickable || atom2.hoverable;\n\n            if (atomneedsi || atom2needsi) {\n                if (atomneedsi) {\n                    if (atom.intersectionShape === undefined)\n                        atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                    atom.intersectionShape.line.push(p1);\n                    atom.intersectionShape.line.push(mp);\n                }\n                if (atom2needsi) {\n                    if (atom2.intersectionShape === undefined)\n                        atom2.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                    atom2.intersectionShape.line.push(mp);\n                    atom2.intersectionShape.line.push(p2);\n                }\n            }\n            var c1 = getColorFromStyle(atom, atom.style.line);\n            var c2 = getColorFromStyle(atom2, atom2.style.line);\n\n            if (atom.bondStyles && atom.bondStyles[i]) {\n                var bstyle = atom.bondStyles[i];\n                if (!bstyle.iswire) {\n                    continue;\n                }\n                if (bstyle.singleBond) singleBond = true;\n                if (typeof (bstyle.color1) != \"undefined\") {\n                    c1 = CC.color(bstyle.color1) as Color;\n                }\n                if (typeof (bstyle.color2) != \"undefined\") {\n                    c2 = CC.color(bstyle.color2) as Color;\n                }\n            }\n\n            var offset = geoGroup.vertices * 3;\n            var mpa, mpb;\n\n            if (atom.bondOrder[i] > 1 && atom.bondOrder[i] < 4 && !singleBond) {\n                var v = this.getSideBondV(atom, atom2, i);\n                var dir = p2.clone();\n                dir.sub(p1);\n\n                if (atom.bondOrder[i] == 2) { //double\n\n                    v.multiplyScalar(0.1);\n                    p1a = p1.clone();\n                    p1a.add(v);\n                    p1b = p1.clone();\n                    p1b.sub(v);\n\n                    p2a = p1a.clone();\n                    p2a.add(dir);\n                    p2b = p1b.clone();\n                    p2b.add(dir);\n\n                    if (c1 == c2) {\n                        geoGroup.vertices += 4;\n                        this.addLine(vertexArray, colorArray, offset, p1a, p2a, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, p1b, p2b, c1);\n                    }\n                    else {\n                        geoGroup.vertices += 8;\n                        dir.multiplyScalar(0.5);\n                        mpa = p1a.clone();\n                        mpa.add(dir);\n                        mpb = p1b.clone();\n                        mpb.add(dir);\n\n                        this.addLine(vertexArray, colorArray, offset, p1a, mpa, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, mpa, p2a, c2);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1b, mpb, c1);\n                        this.addLine(vertexArray, colorArray, offset + 18, mpb, p2b, c2);\n                    }\n                }\n                else if (atom.bondOrder[i] == 3) { //triple\n\n                    v.multiplyScalar(0.1);\n                    p1a = p1.clone();\n                    p1a.add(v);\n                    p1b = p1.clone();\n                    p1b.sub(v);\n\n                    p2a = p1a.clone();\n                    p2a.add(dir);\n                    p2b = p1b.clone();\n                    p2b.add(dir);\n\n                    if (c1 == c2) {\n                        geoGroup.vertices += 6;\n                        this.addLine(vertexArray, colorArray, offset, p1, p2, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, p1a, p2a, c1);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1b, p2b, c1);\n                    }\n                    else {\n                        geoGroup.vertices += 12;\n                        dir.multiplyScalar(0.5);\n                        mpa = p1a.clone();\n                        mpa.add(dir);\n                        mpb = p1b.clone();\n                        mpb.add(dir);\n\n                        this.addLine(vertexArray, colorArray, offset, p1, mp, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1a, mpa, c1);\n                        this.addLine(vertexArray, colorArray, offset + 18, mpa, p2a, c2);\n                        this.addLine(vertexArray, colorArray, offset + 24, p1b, mpb, c1);\n                        this.addLine(vertexArray, colorArray, offset + 30, mpb, p2b, c2);\n                    }\n                }\n            }\n            else { //single bond\n                if (c1 == c2) {\n                    geoGroup.vertices += 2;\n                    this.addLine(vertexArray, colorArray, offset, p1, p2, c1);\n                } else {\n                    geoGroup.vertices += 4;\n                    this.addLine(vertexArray, colorArray, offset, p1, mp, c1);\n                    this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);\n                }\n\n            }\n        }\n\n    };\n\n    //sphere drawing\n    //See also: drawCylinder\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {Geometry} geo\n     */\n    private drawAtomSphere(atom: AtomSpec, geo: Geometry) {\n\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n\n        var C = getColorFromStyle(atom, style);\n\n        var radius = this.getRadiusFromStyle(atom, style);\n\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new Sphere(center, radius));\n        }\n\n        GLDraw.drawSphere(geo, atom, radius, C);\n    };\n\n    /** Register atom shaped click handlers */\n    private drawAtomClickSphere(atom: AtomSpec) {\n\n        if (!atom.style.clicksphere)\n            return;\n        var style = atom.style.clicksphere;\n        if (style.hidden)\n            return;\n\n        var radius = this.getRadiusFromStyle(atom, style);\n\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new Sphere(center, radius));\n        }\n    };\n\n    private drawAtomInstanced(atom: AtomSpec, geo: Geometry) {\n\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n\n        var radius = this.getRadiusFromStyle(atom, style);\n        var C = getColorFromStyle(atom, style);\n\n        var geoGroup = geo.updateGeoGroup(1);\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var radiusArray = geoGroup.radiusArray;\n\n        vertexArray[start] = atom.x;\n        vertexArray[start + 1] = atom.y;\n        vertexArray[start + 2] = atom.z;\n\n        colorArray[start] = C.r;\n        colorArray[start + 1] = C.g;\n        colorArray[start + 2] = C.b;\n\n        radiusArray[startv] = radius;\n\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new Sphere(center, radius));\n        }\n\n        geoGroup.vertices += 1;\n\n    };\n\n    private drawSphereImposter(geo: Geometry, center: XYZ, radius: number, C: Color) {\n        //create flat square\n        var geoGroup = geo.updateGeoGroup(4);\n        var i;\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n\n        //use center point for each vertex\n        for (i = 0; i < 4; i++) {\n            vertexArray[start + 3 * i] = center.x;\n            vertexArray[start + 3 * i + 1] = center.y;\n            vertexArray[start + 3 * i + 2] = center.z;\n        }\n\n\n        //same colors for all 4 vertices\n        var normalArray = geoGroup.normalArray;\n        for (i = 0; i < 4; i++) {\n            colorArray[start + 3 * i] = C.r;\n            colorArray[start + 3 * i + 1] = C.g;\n            colorArray[start + 3 * i + 2] = C.b;\n        }\n\n        normalArray[start + 0] = -radius;\n        normalArray[start + 1] = radius;\n        normalArray[start + 2] = 0;\n\n        normalArray[start + 3] = -radius;\n        normalArray[start + 4] = -radius;\n        normalArray[start + 5] = 0;\n\n        normalArray[start + 6] = radius;\n        normalArray[start + 7] = -radius;\n        normalArray[start + 8] = 0;\n\n        normalArray[start + 9] = radius;\n        normalArray[start + 10] = radius;\n        normalArray[start + 11] = 0;\n\n        geoGroup.vertices += 4;\n\n        //two faces\n        var faceArray = geoGroup.faceArray;\n        var faceoffset = geoGroup.faceidx; //not number faces, but index\n        faceArray[faceoffset + 0] = startv;\n        faceArray[faceoffset + 1] = startv + 1;\n        faceArray[faceoffset + 2] = startv + 2;\n        faceArray[faceoffset + 3] = startv + 2;\n        faceArray[faceoffset + 4] = startv + 3;\n        faceArray[faceoffset + 5] = startv;\n        geoGroup.faceidx += 6;\n    };\n\n    //dkoes -  code for sphere imposters\n    private drawAtomImposter(atom: AtomSpec, geo: Geometry) {\n\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n\n        var radius = this.getRadiusFromStyle(atom, style);\n        var C = getColorFromStyle(atom, style);\n\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new Sphere(center, radius));\n        }\n\n        this.drawSphereImposter(geo, atom as XYZ, radius, C);\n    };\n\n    // Calculate dashes with color support for two-color bonds\n    private calculateDashes(from: XYZ, to: XYZ, radius: number, dashLength: number, gapLength: number, colors?: Color[]) {\n        // Calculate the length of a cylinder defined by two points 'from' and 'to'.\n        var cylinderLength = Math.sqrt(\n            Math.pow((from.x - to.x), 2) +\n            Math.pow((from.y - to.y), 2) +\n            Math.pow((from.z - to.z), 2)\n        );\n\n        // Ensure non-negative values for radius, dashLength, and gapLength.\n        // Adjust gapLength to include the radius of the cylinder.\n        radius = Math.max(radius, 0);\n        gapLength = Math.max(gapLength, 0) + 2 * radius;\n        dashLength = Math.max(dashLength, 0.001);\n\n        // Handle cases where the combined length of dash and gap exceeds the cylinder's length.\n        // In such cases, use a single dash to represent the entire cylinder with no gaps.\n        if (dashLength + gapLength > cylinderLength) {\n            // avoid gapLength=0 causing divide-by-zero in gapVector\n            var segmentColor = (colors && colors.length > 0) ? colors[0] : null;\n            return [{\n                from: new Vector3(from.x, from.y, from.z),\n                to: new Vector3(to.x, to.y, to.z),\n                color: segmentColor\n            }];\n        }\n\n        // Calculate the total number of dash-gap segments that can fit within the cylinder.\n        var totalSegments = Math.floor((cylinderLength - dashLength) / (dashLength + gapLength)) + 1;\n\n        // Compute the total length covered by dashes.\n        var totalDashLength = totalSegments * dashLength;\n\n        // Recalculate gap length to evenly distribute remaining space among gaps.\n        // This ensures dashes and gaps are evenly spaced within the cylinder.\n        gapLength = (cylinderLength - totalDashLength) / totalSegments;\n\n        var new_to;\n        var new_from = new Vector3(from.x, from.y, from.z);\n\n        var gapVector = new Vector3(\n            (to.x - from.x) / (cylinderLength / gapLength),\n            (to.y - from.y) / (cylinderLength / gapLength),\n            (to.z - from.z) / (cylinderLength / gapLength)\n        );\n        var dashVector = new Vector3(\n            (to.x - from.x) / (cylinderLength / dashLength),\n            (to.y - from.y) / (cylinderLength / dashLength),\n            (to.z - from.z) / (cylinderLength / dashLength)\n        );\n\n        var segments = [];\n        for (var place = 0; place < totalSegments; place++) {\n            new_to = new Vector3(new_from.x + dashVector.x, new_from.y + dashVector.y, new_from.z + dashVector.z);\n            // Color interpolation: first half uses colors[0], second half uses colors[1]\n            var segmentColor = (colors && colors.length > 1 && place >= totalSegments / 2) ? colors[1] : (colors ? colors[0] : null);\n            segments.push({ from: new_from, to: new_to, color: segmentColor });\n            new_from = new Vector3(new_to.x + gapVector.x, new_to.y + gapVector.y, new_to.z + gapVector.z);\n        }\n\n        return segments;\n    }\n\n    // Calculate segments for solid two-color bonds (split at midpoint)\n    private calculateTwoColorSegments(from: XYZ, to: XYZ, colors: Color[]) {\n        var segments = [];\n        if (colors.length <= 1) {\n            segments.push({ from: new Vector3(from.x, from.y, from.z), to: new Vector3(to.x, to.y, to.z), color: colors[0] });\n        } else {\n            var mp = new Vector3((from.x + to.x) / 2, (from.y + to.y) / 2, (from.z + to.z) / 2);\n            segments.push({ from: new Vector3(from.x, from.y, from.z), to: mp, color: colors[0] });\n            segments.push({ from: mp, to: new Vector3(to.x, to.y, to.z), color: colors[1] });\n        }\n        return segments;\n    }\n\n    // Determine which side of a multi-bond should have the dashed line.\n    // Returns true if dashed should be on the +v side (toward ring interior).\n    private chooseDashedPlusV(atom: AtomSpec, atom2: AtomSpec, p1: Vector3, p2: Vector3, v: Vector3) {\n        var center = new Vector3(0, 0, 0);\n        var totalWeight = 0;\n\n        // Check if any non-terminal neighbors exist (ring atoms vs hydrogens)\n        var hasNonTerminal = false;\n        for (var idx = 0; idx < atom.bonds.length; idx++) {\n            if (atom.bonds[idx] === atom2.index) continue;\n            var a3 = this.atoms[atom.bonds[idx]];\n            if (a3 && a3.bonds && a3.bonds.length > 1) {\n                hasNonTerminal = true;\n                break;\n            }\n        }\n        if (!hasNonTerminal) {\n            for (var idx = 0; idx < atom2.bonds.length; idx++) {\n                if (atom2.bonds[idx] === atom.index) continue;\n                var a3 = this.atoms[atom2.bonds[idx]];\n                if (a3 && a3.bonds && a3.bonds.length > 1) {\n                    hasNonTerminal = true;\n                    break;\n                }\n            }\n        }\n\n        // Accumulate weighted centroid of neighbors\n        var addNeighbors = (sourceAtom: AtomSpec, excludeIdx: number) => {\n            for (var idx = 0; idx < sourceAtom.bonds.length; idx++) {\n                if (sourceAtom.bonds[idx] === excludeIdx) continue;\n                var a3 = this.atoms[sourceAtom.bonds[idx]];\n                if (!a3) continue;\n\n                // Terminal atoms (like H) get lower weight when non-terminals exist\n                var isTerminal = !a3.bonds || a3.bonds.length <= 1;\n                var weight = (hasNonTerminal && isTerminal) ? 0.25 : 1.0;\n\n                center.x += a3.x * weight;\n                center.y += a3.y * weight;\n                center.z += a3.z * weight;\n                totalWeight += weight;\n            }\n        };\n\n        addNeighbors(atom, atom2.index);\n        addNeighbors(atom2, atom.index);\n\n        if (totalWeight < 1e-8) return false;\n        center.multiplyScalar(1.0 / totalWeight);\n\n        var mid = new Vector3().addVectors(p1, p2).multiplyScalar(0.5);\n        var plus = mid.clone().add(v);\n        var minus = mid.clone().sub(v);\n\n        // Dashed line goes toward the centroid (ring interior)\n        return plus.distanceToSquared(center) < minus.distanceToSquared(center);\n    }\n\n    static drawStickImposter(geo: Geometry, from: XYZ, to: XYZ, radius: number, color: Color, fromCap: CAP = 0, toCap: CAP = 0) {\n        //we need the four corners - two have from coord, two have to coord, the normal\n        //is the opposing point, from which we can get the normal and length\n        //also need the radius\n        var geoGroup = geo.updateGeoGroup(4);\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var radiusArray = geoGroup.radiusArray;\n        var normalArray = geoGroup.normalArray;\n        //encode extra bits of information in the color\n        var r = color.r;\n        var g = color.g;\n        var b = color.b;\n\n        var negateColor = function (c) {\n            //set sign bit\n            var n = -c;\n            if (n == 0) n = -0.0001;\n            return n;\n        };\n\n        /* for sticks, always draw caps, but we could in theory set caps in color */\n\n        //4 vertices, distinguish between p1 and p2 with neg blue\n        var pos = start;\n        for (var i = 0; i < 4; i++) {\n            vertexArray[pos] = from.x;\n            normalArray[pos] = to.x;\n            colorArray[pos] = r;\n            pos++;\n            vertexArray[pos] = from.y;\n            normalArray[pos] = to.y;\n            colorArray[pos] = g;\n            pos++;\n            vertexArray[pos] = from.z;\n            normalArray[pos] = to.z;\n            if (i < 2)\n                colorArray[pos] = b;\n            else\n                colorArray[pos] = negateColor(b);\n            pos++;\n        }\n\n        geoGroup.vertices += 4;\n\n        radiusArray[startv] = -radius;\n        radiusArray[startv + 1] = radius;\n        radiusArray[startv + 2] = -radius;\n        radiusArray[startv + 3] = radius;\n\n        //two faces\n        var faceArray = geoGroup.faceArray;\n        var faceoffset = geoGroup.faceidx; //not number faces, but index\n        faceArray[faceoffset + 0] = startv;\n        faceArray[faceoffset + 1] = startv + 1;\n        faceArray[faceoffset + 2] = startv + 2;\n        faceArray[faceoffset + 3] = startv + 2;\n        faceArray[faceoffset + 4] = startv + 3;\n        faceArray[faceoffset + 5] = startv;\n        geoGroup.faceidx += 6;\n    };\n\n    // draws cylinders and small spheres (at bond radius)\n    private drawBondSticks(atom: AtomSpec, atoms: AtomSpec[], geo: Geometry) {\n        if (!atom.style.stick)\n            return;\n        var style = atom.style.stick;\n        if (style.hidden)\n            return;\n\n        var atomBondR = style.radius || this.defaultStickRadius;\n        var doubleBondScale = style.doubleBondScaling || 0.4;\n        var tripleBondScale = style.tripleBondScaling || 0.25;\n\n        var bondDashLength = style.dashedBondConfig?.dashLength || 0.1;\n        var bondGapLength = style.dashedBondConfig?.gapLength || 0.25;\n\n        var bondR = atomBondR;\n        var atomSingleBond = style.singleBonds || false;\n        var atomDashedBonds = style.dashedBonds || false;\n        var fromCap = 0, toCap = 0;\n        var atomneedsi, atom2needsi, i, singleBond, bstyle;\n        var cylinder1a, cylinder1b, cylinder1c, cylinder2a, cylinder2b, cylinder2c;\n\n        var C1 = getColorFromStyle(atom, style);\n\n        var mp, mp2, mp3;\n\n        if (!atom.capDrawn && atom.bonds.length < 4)\n            fromCap = 2;\n\n        // Get custom colors from dashedBondConfig if specified\n        var solidColor = style.dashedBondConfig?.solidColor ? CC.color(style.dashedBondConfig.solidColor) as Color : null;\n        var dashedColor = style.dashedBondConfig?.dashedColor ? CC.color(style.dashedBondConfig.dashedColor) as Color : null;\n\n        var self = this;\n        var selectCylDrawMethod = (bondOrder) => {\n            var drawMethod = geo.imposter ? GLModel.drawStickImposter : GLDraw.drawCylinder;\n\n            if (!atomDashedBonds && bondOrder % 1 === 0) {\n                // Integer bond order - solid\n                return (geo, from, to, radius, color1, color2, fromCap = 0, toCap = 0) => {\n                    if (!color2 || color1 === color2) {\n                        drawMethod(geo, from, to, radius, color1, fromCap, toCap);\n                    } else {\n                        var segments = self.calculateTwoColorSegments(from, to, [color1, color2]);\n                        for (var si = 0; si < segments.length; si++) {\n                            var seg = segments[si];\n                            var fc = (si === 0) ? fromCap : 0;\n                            var tc = (si === segments.length - 1) ? toCap : 0;\n                            drawMethod(geo, seg.from, seg.to, radius, seg.color, fc, tc);\n                        }\n                    }\n                };\n            }\n\n            // Fractional bond order - dashed\n            return (geo, from, to, radius, color1, color2, fromCap = 0, toCap = 0) => {\n                var colors = color2 ? [color1, color2] : [color1];\n                var segments = self.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);\n                segments.forEach(segment => {\n                    drawMethod(geo, segment.from, segment.to, radius, segment.color, fromCap, toCap);\n                });\n            };\n        };\n\n        for (i = 0; i < atom.bonds.length; i++) {\n            // Treat aromatic bond type (4) as 1.5 for rendering\n            var rawBondOrder = atom.bondOrder[i];\n            var renderBondOrder = (rawBondOrder === 4) ? 1.5 : rawBondOrder;\n\n            var drawCyl = selectCylDrawMethod(renderBondOrder);\n            var j = atom.bonds[i]; // our neighbor\n            var atom2 = atoms[j]; //parsePDB, etc should only add defined bonds\n            mp = mp2 = mp3 = null;\n            if (atom.index < atom2.index) {// only draw if less, this\n                // lets us combine\n                // cylinders of the same\n                // color\n                toCap = 0;\n                var style2 = atom2.style;\n                if (!style2.stick || style2.stick.hidden)\n                    continue; // don't sweat the details\n\n                var C2 = getColorFromStyle(atom2, style2.stick);\n\n                //support bond specific styles\n                bondR = atomBondR;\n                singleBond = atomSingleBond;\n                if (atom.bondStyles && atom.bondStyles[i]) {\n                    bstyle = atom.bondStyles[i];\n                    if (bstyle.iswire) {\n                        continue;\n                    }\n                    if (bstyle.radius) bondR = bstyle.radius;\n                    if (bstyle.singleBond) singleBond = true;\n                    if (typeof (bstyle.color1) != \"undefined\") {\n                        C1 = CC.color(bstyle.color1) as Color;\n                    }\n                    if (typeof (bstyle.color2) != \"undefined\") {\n                        C2 = CC.color(bstyle.color2) as Color;\n                    }\n                }\n                var p1 = new Vector3(atom.x, atom.y, atom.z);\n                var p2 = new Vector3(atom2.x, atom2.y, atom2.z);\n\n                // Determine colors for solid and dashed portions\n                var solid1 = solidColor || C1;\n                var solid2 = solidColor || C2;\n                var dashed1 = dashedColor || C1;\n                var dashed2 = dashedColor || C2;\n\n                // draw cylinders\n                if (renderBondOrder <= 1 || singleBond || renderBondOrder > 3) {\n\n                    if (renderBondOrder < 1) bondR *= renderBondOrder;\n                    if (!atom2.capDrawn && atom2.bonds.length < 4)\n                        toCap = 2;\n\n                    const isDashed = atomDashedBonds || (renderBondOrder % 1 !== 0);\n                    const colA = isDashed ? dashed1 : C1;\n                    const colB = isDashed ? dashed2 : C2;\n\n                    drawCyl(geo, p1, p2, bondR, colA, colB, fromCap, toCap);\n\n                    atomneedsi = atom.clickable || atom.hoverable;\n                    atom2needsi = atom2.clickable || atom2.hoverable;\n\n                    if (atomneedsi || atom2needsi) {\n                        if (!mp) mp = new Vector3().addVectors(p1, p2).multiplyScalar(0.5);\n                        if (atomneedsi) {\n                            var cylinder1 = new Cylinder(p1, mp, bondR);\n                            var sphere1 = new Sphere(p1, bondR);\n                            atom.intersectionShape.cylinder.push(cylinder1);\n                            atom.intersectionShape.sphere.push(sphere1);\n                        }\n                        if (atom2needsi) {\n                            var cylinder2 = new Cylinder(p2, mp, bondR);\n                            var sphere2 = new Sphere(p2, bondR);\n                            atom2.intersectionShape.cylinder.push(cylinder2);\n                            atom2.intersectionShape.sphere.push(sphere2);\n                        }\n                    }\n                }\n                else if (renderBondOrder > 1) {\n                    //multi bond caps\n                    var mfromCap = 0;\n                    var mtoCap = 0;\n\n                    if (bondR != atomBondR) {\n                        //assume jmol style multiple bonds - the radius doesn't fit within atom sphere\n                        mfromCap = 2;\n                        mtoCap = 2;\n                    }\n\n                    var dir = p2.clone();\n                    var v = null;\n                    dir.sub(p1);\n\n                    var r, r2, p1a, p1b, p2a, p2b;\n                    v = this.getSideBondV(atom, atom2, i);\n\n                    // Determine dashed bond placement for fractional orders (aromatic)\n                    var isDashedBondFlipped = false;\n                    if (renderBondOrder % 1 !== 0) {\n                        isDashedBondFlipped = this.chooseDashedPlusV(atom, atom2, p1, p2, v);\n                    }\n\n                    if (renderBondOrder > 1 && renderBondOrder <= 2) {\n                        // Fractional double bond (aromatic, 1.5, etc)\n                        r = bondR * doubleBondScale;\n                        r2 = r * (renderBondOrder - 1); // dashed bond is thinner\n\n                        v.multiplyScalar(r * 1.5);\n                        p1a = p1.clone();\n                        p1a.add(v);\n                        p1b = p1.clone();\n                        p1b.sub(v);\n\n                        p2a = p1a.clone();\n                        p2a.add(dir);\n                        p2b = p1b.clone();\n                        p2b.add(dir);\n\n                        // Determine colors for solid and dashed portions\n                        var solid1 = solidColor || C1;\n                        var solid2 = solidColor || C2;\n                        var dashed1 = dashedColor || C1;\n                        var dashed2 = dashedColor || C2;\n\n                        var drawMethod = geo.imposter ? GLModel.drawStickImposter : GLDraw.drawCylinder;\n\n                        // Draw solid bond\n                        var drawSolid = (from, to, radius, c1, c2, fc, tc) => {\n                            if (c1 != c2) {\n                                var m = new Vector3().addVectors(from, to).multiplyScalar(0.5);\n                                drawMethod(geo, from, m, radius, c1, fc, 0);\n                                drawMethod(geo, m, to, radius, c2, 0, tc);\n                            } else {\n                                drawMethod(geo, from, to, radius, c1, fc, tc);\n                            }\n                        };\n\n                        // Draw dashed bond\n                        var drawDashed = (from, to, radius, c1, c2, fc, tc) => {\n                            var colors = (c1 != c2) ? [c1, c2] : [c1];\n                            var segments = self.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);\n                            segments.forEach(segment => {\n                                drawMethod(geo, segment.from, segment.to, radius, segment.color || c1, fc, tc);\n                            });\n                        };\n\n                        if (renderBondOrder == 2) {\n                            // Integer double bond - both solid\n                            drawSolid(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);\n                            drawSolid(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);\n                        } else {\n                            // Fractional double bond (1.x) - one solid, one dashed\n                            if (!isDashedBondFlipped) {\n                                drawSolid(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);\n                                drawDashed(p1b, p2b, r2, dashed1, dashed2, mfromCap, mtoCap);\n                            } else {\n                                drawDashed(p1a, p2a, r2, dashed1, dashed2, mfromCap, mtoCap);\n                                drawSolid(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);\n                            }\n                        }\n\n                        atomneedsi = atom.clickable || atom.hoverable;\n                        atom2needsi = atom2.clickable || atom2.hoverable;\n\n                        if (atomneedsi || atom2needsi) {\n                            if (!mp) mp = new Vector3().addVectors(p1a, p2a)\n                                .multiplyScalar(0.5);\n                            if (!mp2) mp2 = new Vector3().addVectors(p1b, p2b)\n                                .multiplyScalar(0.5);\n\n                            // Account for flip - dashed bond has radius r2\n                            var raRadius = (renderBondOrder == 2) ? r : (isDashedBondFlipped ? r2 : r);\n                            var rbRadius = (renderBondOrder == 2) ? r : (isDashedBondFlipped ? r : r2);\n\n                            if (atomneedsi) {\n                                cylinder1a = new Cylinder(p1a, mp, raRadius);\n                                cylinder1b = new Cylinder(p1b, mp2, rbRadius);\n                                atom.intersectionShape.cylinder.push(cylinder1a);\n                                atom.intersectionShape.cylinder.push(cylinder1b);\n                            }\n                            if (atom2needsi) {\n                                cylinder2a = new Cylinder(p2a, mp, raRadius);\n                                cylinder2b = new Cylinder(p2b, mp2, rbRadius);\n                                atom2.intersectionShape.cylinder.push(cylinder2a);\n                                atom2.intersectionShape.cylinder.push(cylinder2b);\n                            }\n                        }\n                    }\n                    else if (renderBondOrder > 2 && renderBondOrder <= 3) {\n                        r = bondR * tripleBondScale;\n                        var r3 = r * (renderBondOrder - 2); // dashed bond thinner for fractional\n                        v.cross(dir);\n                        v.normalize();\n                        v.multiplyScalar(r * 3);\n\n                        p1a = p1.clone();\n                        p1a.add(v);\n                        p1b = p1.clone();\n                        p1b.sub(v);\n\n                        p2a = p1a.clone();\n                        p2a.add(dir);\n                        p2b = p1b.clone();\n                        p2b.add(dir);\n\n                        var drawMethod = geo.imposter ? GLModel.drawStickImposter : GLDraw.drawCylinder;\n\n                        // Draw solid bond helper\n                        var drawSolidTriple = (from, to, radius, c1, c2, fc, tc) => {\n                            if (c1 != c2) {\n                                var m = new Vector3().addVectors(from, to).multiplyScalar(0.5);\n                                drawMethod(geo, from, m, radius, c1, fc, 0);\n                                drawMethod(geo, m, to, radius, c2, 0, tc);\n                            } else {\n                                drawMethod(geo, from, to, radius, c1, fc, tc);\n                            }\n                        };\n\n                        // Draw dashed bond helper\n                        var drawDashedTriple = (from, to, radius, c1, c2, fc, tc) => {\n                            var colors = (c1 != c2) ? [c1, c2] : [c1];\n                            var segments = self.calculateDashes(from, to, radius, bondDashLength, bondGapLength, colors);\n                            segments.forEach(segment => {\n                                drawMethod(geo, segment.from, segment.to, radius, segment.color || c1, fc, tc);\n                            });\n                        };\n\n                        if (renderBondOrder == 3) {\n                            // Integer triple bond - all solid\n                            drawSolidTriple(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);\n                            drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);\n                            drawSolidTriple(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);\n                        } else {\n                            // Fractional triple bond (2.x) - one dashed\n                            if (!isDashedBondFlipped) {\n                                drawSolidTriple(p1a, p2a, r, solid1, solid2, mfromCap, mtoCap);\n                                drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);\n                                drawDashedTriple(p1b, p2b, r3, dashed1, dashed2, mfromCap, mtoCap);\n                            } else {\n                                drawDashedTriple(p1a, p2a, r3, dashed1, dashed2, mfromCap, mtoCap);\n                                drawSolidTriple(p1, p2, r, solid1, solid2, fromCap, toCap);\n                                drawSolidTriple(p1b, p2b, r, solid1, solid2, mfromCap, mtoCap);\n                            }\n                        }\n\n                        atomneedsi = atom.clickable || atom.hoverable;\n                        atom2needsi = atom2.clickable || atom2.hoverable;\n\n                        if (atomneedsi || atom2needsi) {\n                            if (!mp) mp = new Vector3().addVectors(p1a, p2a)\n                                .multiplyScalar(0.5);\n                            if (!mp2) mp2 = new Vector3().addVectors(p1b, p2b)\n                                .multiplyScalar(0.5);\n                            if (!mp3) mp3 = new Vector3().addVectors(p1, p2)\n                                .multiplyScalar(0.5);\n\n                            // Account for flip - dashed bond has radius r3\n                            var raRadius = (renderBondOrder == 3) ? r : (isDashedBondFlipped ? r3 : r);\n                            var rbRadius = (renderBondOrder == 3) ? r : (isDashedBondFlipped ? r : r3);\n\n                            if (atomneedsi) {\n                                cylinder1a = new Cylinder(p1a.clone(), mp.clone(), raRadius);\n                                cylinder1b = new Cylinder(p1b.clone(), mp2.clone(), rbRadius);\n                                cylinder1c = new Cylinder(p1.clone(), mp3.clone(), r);\n                                atom.intersectionShape.cylinder.push(cylinder1a);\n                                atom.intersectionShape.cylinder.push(cylinder1b);\n                                atom.intersectionShape.cylinder.push(cylinder1c);\n                            }\n                            if (atom2needsi) {\n                                cylinder2a = new Cylinder(p2a.clone(), mp.clone(), raRadius);\n                                cylinder2b = new Cylinder(p2b.clone(), mp2.clone(), rbRadius);\n                                cylinder2c = new Cylinder(p2.clone(), mp3.clone(), r);\n                                atom2.intersectionShape.cylinder.push(cylinder2a);\n                                atom2.intersectionShape.cylinder.push(cylinder2b);\n                                atom2.intersectionShape.cylinder.push(cylinder2c);\n                            }\n                        }\n                    }\n                }\n\n            }\n\n        }\n\n        // draw non bonded heteroatoms as spheres\n        var drawSphere = false;\n        var numsinglebonds = 0;\n        var differentradii = false;\n        //also, if any bonds were drawn as multiples, need sphere\n        for (i = 0; i < atom.bonds.length; i++) {\n            singleBond = atomSingleBond;\n            if (atom.bondStyles && atom.bondStyles[i]) {\n                bstyle = atom.bondStyles[i];\n                if (bstyle.singleBond) singleBond = true;\n                if (bstyle.radius && bstyle.radius != atomBondR) {\n                    differentradii = true;\n                }\n            }\n            if (singleBond || atom.bondOrder[i] == 1) {\n                numsinglebonds++;\n            }\n        }\n\n        if (differentradii) { //jmol style double/triple bonds - no sphere\n            if (numsinglebonds > 0) drawSphere = true; //unless needed as a cap\n        }\n        else if (numsinglebonds == 0 && (atom.bonds.length > 0 || style.showNonBonded)) {\n            drawSphere = true;\n        }\n\n        if (drawSphere) {\n            bondR = atomBondR;\n            //do not use bond style as this can be variable, particularly\n            //with jmol export of double/triple bonds\n            if (geo.imposter) {\n                this.drawSphereImposter(geo.sphereGeometry, atom as XYZ, bondR, C1);\n            }\n            else {\n                GLDraw.drawSphere(geo, atom, bondR, C1);\n            }\n        }\n\n    };\n\n\n\n    // go through all the atoms and regenerate their geometries\n    // we try to have one geometry for each style since this is much much\n    // faster\n    // at some point we should optimize this to avoid unnecessary\n    // recalculation\n    /** param {AtomSpec[]} atoms */\n    private createMolObj(atoms: AtomSpec[], options?) {\n\n        options = options || {};\n\n        var ret = new Object3D();\n        var cartoonAtoms = [];\n        var lineGeometries: Record<number, Geometry> = {};\n        var crossGeometries: Record<number, Geometry> = {};\n\n        var drawSphereFunc = this.drawAtomSphere;\n        var sphereGeometry: Geometry = null;\n        var stickGeometry: Geometry = null;\n        if (options.supportsImposters) {\n            drawSphereFunc = this.drawAtomImposter;\n            sphereGeometry = new Geometry(true);\n            sphereGeometry.imposter = true;\n            stickGeometry = new Geometry(true, true);\n            stickGeometry.imposter = true;\n            stickGeometry.sphereGeometry = new Geometry(true); //for caps\n            stickGeometry.sphereGeometry.imposter = true;\n            stickGeometry.drawnCaps = {};\n        }\n        else if (options.supportsAIA) {\n            drawSphereFunc = this.drawAtomInstanced;\n            sphereGeometry = new Geometry(false, true, true);\n            sphereGeometry.instanced = true;\n            stickGeometry = new Geometry(true); //don't actually have instanced sticks\n        } else {\n            sphereGeometry = new Geometry(true);\n            stickGeometry = new Geometry(true);\n        }\n\n        var i, j, n, testOpacities;\n        var opacities: any = {};\n        var range = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n        for (i = 0, n = atoms.length; i < n; i++) {\n            var atom = atoms[i];\n            // recreate gl info for each atom as necessary\n            // set up appropriate intersection spheres for clickable atoms\n\n            if (atom && atom.style) {\n\n                if ((atom.clickable || atom.hoverable) && atom.intersectionShape === undefined)\n                    atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n\n                testOpacities = { line: undefined, cross: undefined, stick: undefined, sphere: undefined };\n                for (j in testOpacities) {\n                    if (atom.style[j]) {\n                        if (atom.style[j].opacity)\n                            testOpacities[j] = parseFloat(atom.style[j].opacity);\n                        else\n                            testOpacities[j] = 1;\n\n                    } else testOpacities[j] = undefined;\n\n                    if (opacities[j]) {\n                        if (testOpacities[j] != undefined && opacities[j] != testOpacities[j]) {\n                            console.log(\"Warning: \" + j + \" opacity is ambiguous\");\n                            opacities[j] = 1;\n                        }\n\n                    } else opacities[j] = testOpacities[j];\n                }\n\n                drawSphereFunc.call(this, atom, sphereGeometry);\n                this.drawAtomClickSphere(atom);\n                this.drawAtomCross(atom, crossGeometries);\n                this.drawBondLines(atom, atoms, lineGeometries);\n                this.drawBondSticks(atom, atoms, stickGeometry);\n\n                if (typeof (atom.style.cartoon) !== \"undefined\" && !atom.style.cartoon.hidden) {\n                    //gradient color scheme range\n                    if (atom.style.cartoon.color === \"spectrum\" && typeof (atom.resi) === \"number\" && !atom.hetflag) {\n                        if (atom.resi < range[0])\n                            range[0] = atom.resi;\n                        if (atom.resi > range[1])\n                            range[1] = atom.resi;\n                    }\n\n                    cartoonAtoms.push(atom);\n                }\n            }\n        }\n        // create cartoon if needed - this is a whole model analysis\n        if (cartoonAtoms.length > 0) {\n            drawCartoon(ret, cartoonAtoms, range, this.defaultCartoonQuality);\n        }\n\n        // add sphere geometry\n        if (sphereGeometry && sphereGeometry.vertices > 0) {\n            //Initialize buffers in geometry\n            sphereGeometry.initTypedArrays();\n            var sphereMaterial = null;\n            var sphere = null;\n\n            //create appropriate material\n            if (sphereGeometry.imposter) {\n                sphereMaterial = new SphereImposterMaterial({\n                    ambient: 0x000000,\n                    vertexColors: true,\n                    reflectivity: 0\n                });\n            }\n            else if (sphereGeometry.instanced) {\n                sphere = new Geometry(true);\n                GLDraw.drawSphere(sphere, { x: 0, y: 0, z: 0 }, 1, new Color(0.5, 0.5, 0.5));\n                sphere.initTypedArrays();\n                sphereMaterial = new InstancedMaterial({\n                    sphereMaterial: new MeshLambertMaterial({\n                        ambient: 0x000000,\n                        vertexColors: true,\n                        reflectivity: 0,\n                    }),\n                    sphere: sphere\n                });\n            }\n            else { //regular mesh\n                sphereMaterial = new MeshLambertMaterial({\n                    ambient: 0x000000,\n                    vertexColors: true,\n                    reflectivity: 0,\n                });\n            }\n            if (opacities.sphere < 1 && opacities.sphere >= 0) {\n                sphereMaterial.transparent = true;\n                sphereMaterial.opacity = opacities.sphere;\n            }\n\n            sphere = new Mesh(sphereGeometry, sphereMaterial);\n            ret.add(sphere);\n        }\n\n        // add stick geometry\n        if (stickGeometry.vertices > 0) {\n\n            var stickMaterial = null;\n            var ballMaterial = null;\n            var balls = stickGeometry.sphereGeometry;\n            if (!balls || typeof (balls.vertices) === 'undefined' || balls.vertices == 0) balls = null; //no balls\n\n            //Initialize buffers in geometry\n            stickGeometry.initTypedArrays();\n            if (balls) balls.initTypedArrays();\n\n            //create material\n            var matvals = { ambient: 0x000000, vertexColors: true, reflectivity: 0 };\n\n            if (stickGeometry.imposter) {\n                stickMaterial = new StickImposterMaterial(matvals);\n                ballMaterial = new SphereImposterMaterial(matvals);\n            } else {\n                stickMaterial = new MeshLambertMaterial(matvals);\n                ballMaterial = new MeshLambertMaterial(matvals);\n\n                if (stickMaterial.wireframe) {\n                    stickGeometry.setUpWireframe();\n                    if (balls) balls.setUpWireframe();\n                }\n            }\n\n            if (opacities.stick < 1 && opacities.stick >= 0) {\n                stickMaterial.transparent = true;\n                stickMaterial.opacity = opacities.stick;\n                ballMaterial.transparent = true;\n                ballMaterial.opacity = opacities.stick;\n            }\n            var sticks = new Mesh(stickGeometry, stickMaterial);\n            ret.add(sticks);\n\n            if (balls) {\n                var stickspheres = new Mesh(balls, ballMaterial);\n                ret.add(stickspheres);\n            }\n        }\n\n        //var linewidth;\n        // add any line geometries, distinguished by line width\n        var linewidth;\n        for (i in lineGeometries) {\n            if (lineGeometries.hasOwnProperty(i)) {\n                linewidth = i;\n                var lineMaterial = new LineBasicMaterial({\n                    linewidth: linewidth,\n                    vertexColors: true\n                });\n                if (opacities.line < 1 && opacities.line >= 0) {\n                    lineMaterial.transparent = true;\n                    lineMaterial.opacity = opacities.line;\n                }\n\n                lineGeometries[i].initTypedArrays();\n\n                var line = new Line(lineGeometries[i], lineMaterial as Material, LineStyle.LinePieces);\n\n                ret.add(line);\n            }\n        }\n\n        // add any cross geometries\n        for (i in crossGeometries) {\n            if (crossGeometries.hasOwnProperty(i)) {\n                linewidth = i;\n                var crossMaterial = new LineBasicMaterial({\n                    linewidth: linewidth,\n                    vertexColors: true\n                });\n                if (opacities.cross < 1 && opacities.cross >= 0) {\n                    crossMaterial.transparent = true;\n                    crossMaterial.opacity = opacities.cross;\n                }\n\n                crossGeometries[i].initTypedArrays();\n\n                var cross = new Line(crossGeometries[i], crossMaterial as Material, LineStyle.LinePieces);\n\n                ret.add(cross);\n            }\n        }\n\n\n        //for BIOMT assembly\n        if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {\n            var finalRet = new Object3D();\n            var t;\n            for (t = 0; t < this.modelData.symmetries.length; t++) {\n                var transformedRet = new Object3D();\n                transformedRet = ret.clone();\n                transformedRet.matrix.copy(this.modelData.symmetries[t]);\n                transformedRet.matrixAutoUpdate = false;\n                finalRet.add(transformedRet);\n            }\n            return finalRet;\n        }\n\n        return ret;\n    };\n\n    /**\n     * Return viewer associated with this model.\n     * @returns GLViewer\n     */\n    public getViewer() {\n        return this.viewer;\n    }\n\n    /**\n     * Return object representing internal state of\n     * the model appropriate for passing to setInternalState\n     *\n    */\n    public getInternalState() {\n        return {\n            'atoms': this.atoms,\n            'frames': this.frames\n        };\n    };\n\n    /**\n     * Overwrite the internal model state with the passed state.\n     *\n    */\n    public setInternalState(state) {\n        this.atoms = state.atoms;\n        this.frames = state.frames;\n        this.molObj = null;\n    };\n\n    /**\n     * Returns crystallographic information if present.\n     *\n     *\n     */\n    public getCrystData() {\n        if (this.modelData.cryst) {\n            // add the matrix if it is missing\n            if (!this.modelData.cryst.matrix) {\n                const cryst = this.modelData.cryst;\n                this.modelData.cryst.matrix = conversionMatrix3(\n                    cryst.a, cryst.b, cryst.c,\n                    cryst.alpha, cryst.beta, cryst.gamma\n                );\n            }\n            return this.modelData.cryst;\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * Set crystallographic information using three angles and three lengths\n     *\n     * @param {number} a - length of unit cell side\n     * @param {number} b - length of unit cell side\n     * @param {number} c - length of unit cell side\n     * @param {number} alpha - unit cell angle in degrees (default 90)\n     * @param {number} beta - unit cell angle in degrees (default 90)\n     * @param {number} gamma - unit cell angle in degrees (default 90)\n\n     */\n    public setCrystData(a?: number, b?: number, c?: number, alpha?: number, beta?: number, gamma?: number) {\n        //I am assuming these\n        a = a || 1.0;\n        b = b || 1.0;\n        c = c || 1.0;\n        alpha = alpha || 90;\n        beta = beta || 90;\n        gamma = gamma || 90;\n\n        const matrix = conversionMatrix3(a, b, c, alpha, beta, gamma);\n        this.modelData.cryst = {\n            'a': a, 'b': b, 'c': c,\n            'alpha': alpha, 'beta': beta, 'gamma': gamma,\n            'matrix': matrix\n        };\n    };\n\n    /**\n     * Set the crystallographic matrix to the given matrix.\n     *\n     * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from\n     * the crystal data.\n     *\n     * @param {Matrix3} matrix - unit cell matrix\n     */\n    public setCrystMatrix(matrix: Matrix3) {\n        matrix = matrix || new Matrix3(\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        );\n\n        this.modelData.cryst = {\n            'matrix': matrix\n        };\n    };\n\n    /**\n     * Returns list of rotational/translational matrices if there is BIOMT data\n     * Otherwise returns a list of just the ID matrix\n     *\n     * @return {Array<Matrix4>}\n     *\n     */\n    public getSymmetries() {\n\n        if (typeof (this.modelData.symmetries) == 'undefined') {\n            this.modelData.symmetries = [this.idMatrix];\n        }\n        return this.modelData.symmetries;\n    };\n\n    /**\n     * Sets symmetries based on specified matrices in list\n     *\n     * @param {Array<Matrix4>} list\n     *\n     */\n    public setSymmetries(list) {\n        if (typeof (list) == \"undefined\") { //delete sym data\n            this.modelData.symmetries = [this.idMatrix];\n        }\n        else {\n            this.modelData.symmetries = list;\n            this.molObj = null;\n        }\n    };\n\n    /**\n     * Returns model id number\n     *\n     * @return {number} Model ID\n     */\n    public getID() {\n        return this.id;\n    };\n\n    /**\n     * Returns model's frames property, a list of atom lists\n     *\n     * @return {number}\n     */\n    public getNumFrames() {\n        return (this.frames.numFrames != undefined) ? this.frames.numFrames : this.frames.length;\n    };\n\n    private adjustCoord(x1: number, x2: number, margin: number, adjust: number) {\n        //return new value of x2 that isn't more than margin away\n        var dist = x2 - x1;\n        if (dist < -margin) {\n            return x2 + adjust;\n        } else if (dist > margin) {\n            return x2 - adjust;\n        }\n        return x2;\n    };\n    //go over current atoms in depth first order and ensure that connected\n    //attoms aren't split across the box\n    private adjustCoordinatesToBox() {\n        if (!this.box) return;\n        if (!this.atomdfs) return;\n        var bx = this.box[0];\n        var by = this.box[1];\n        var bz = this.box[2];\n        var mx = bx * 0.9;\n        var my = by * 0.9;\n        var mz = bz * 0.9;\n\n        for (var c = 0; c < this.atomdfs.length; c++) {\n            //for each connected component\n            var component = this.atomdfs[c];\n            for (var i = 1; i < component.length; i++) {\n                //compare each atom to its previous and prevent coordinates from wrapping\n                var atom = this.atoms[component[i][0]];\n                var prev = this.atoms[component[i][1]];\n                atom.x = this.adjustCoord(prev.x, atom.x, mx, bx);\n                atom.y = this.adjustCoord(prev.y, atom.y, my, by);\n                atom.z = this.adjustCoord(prev.z, atom.z, mz, bz);\n            }\n        }\n    };\n\n    /**\n     * Sets model's atomlist to specified frame\n     * Sets to last frame if framenum out of range\n     *\n     * @param {number} framenum - model's atoms are set to this index in frames list\n     * @return {Promise}\n     */\n    public setFrame(framenum: number) {\n        var numFrames = this.getNumFrames();\n        let model = this;\n        let viewer = this.viewer;\n        return new Promise<void>(function (resolve, reject) {\n            if (numFrames == 0) {\n                //return;\n                resolve();\n            }\n            if (framenum < 0 || framenum >= numFrames) {\n                framenum = numFrames - 1;\n            }\n            if (model.frames.url != undefined) {\n                var url = model.frames.url;\n                getbin(url + \"/traj/frame/\" + framenum + \"/\" + model.frames.path, undefined, 'POST', undefined).then(function (buffer) {\n                    var values = new Float32Array(buffer, 44);\n                    var count = 0;\n                    for (var i = 0; i < model.atoms.length; i++) {\n                        model.atoms[i].x = values[count++];\n                        model.atoms[i].y = values[count++];\n                        model.atoms[i].z = values[count++];\n                    }\n                    //if a box was provided, check to see if we need to wrap connected components\n                    if (model.box && model.atomdfs) {\n                        model.adjustCoordinatesToBox();\n                    }\n                    resolve();\n                }).catch(reject);\n            }\n            else {\n                model.atoms = model.frames[framenum];\n                resolve();\n            }\n            model.molObj = null;\n            if (model.modelDatas && framenum < model.modelDatas.length) {\n                model.modelData = model.modelDatas[framenum];\n                if (model.unitCellObjects && viewer) {\n                    viewer.removeUnitCell(model);\n                    viewer.addUnitCell(model);\n                }\n            }\n        });\n    };\n\n    /**\n     * Add atoms as frames of model\n     *\n     * @param {AtomSpec[]} atoms - atoms to be added\n     */\n    public addFrame(atoms: AtomSpec[]) {\n        this.frames.push(atoms);\n    };\n\n\n    /**\n     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.\n     * Model can then be animated\n     *\n     * @param {number} numFrames - number of frames to be created, default to 10\n     * @param {number} amplitude - amplitude of distortion, default to 1 (full)\n     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames\n     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.\n     *@example\n\n      $3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.vibrate(10, 1);\n        viewer.animate({loop: \"forward\",reps: 1});\n\n        viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    public vibrate(numFrames: number = 10, amplitude: number = 1, bothWays: boolean = false, arrowSpec?: ArrowSpec) {\n        var start = 0;\n        var end = numFrames;\n        let viewer = this.viewer;\n        if (bothWays) {\n            start = -numFrames;\n            end = numFrames;\n        }\n\n        //to enable multiple setting of vibrate with bothWays, must record original position\n        if (this.frames !== undefined && this.frames.origIndex !== undefined) {\n            this.setFrame(this.frames.origIndex);\n        } else {\n            this.setFrame(0);\n        }\n\n        if (start < end) this.frames = []; //clear\n        if (bothWays) this.frames.origIndex = numFrames;\n\n        for (var i = start; i < end; i++) {\n            var newAtoms = [];\n            var currframe = this.frames.length;\n            if (i == 0 && !arrowSpec) { //still need to calculate if drawing arrows\n                this.frames.push(this.atoms);\n                continue;\n            }\n            for (var j = 0; j < this.atoms.length; j++) {\n                var dx = getAtomProperty(this.atoms[j], 'dx');\n                var dy = getAtomProperty(this.atoms[j], 'dy');\n                var dz = getAtomProperty(this.atoms[j], 'dz');\n                var newVector = new Vector3(dx, dy, dz);\n                var starting = new Vector3(this.atoms[j].x, this.atoms[j].y, this.atoms[j].z);\n                var mult = (i * amplitude) / numFrames;\n                newVector.multiplyScalar(mult);\n                starting.add(newVector);\n                var newAtom: any = {};\n                for (var k in this.atoms[j]) {\n                    newAtom[k] = this.atoms[j][k];\n                }\n                newAtom.x = starting.x;\n                newAtom.y = starting.y;\n                newAtom.z = starting.z;\n                newAtoms.push(newAtom);\n                if (viewer && arrowSpec) {\n                    var spec = extend({}, arrowSpec);\n                    var arrowend = new Vector3(dx, dy, dz);\n                    arrowend.multiplyScalar(amplitude);\n                    arrowend.add(starting);\n\n                    spec.start = starting;\n                    spec.end = arrowend;\n                    spec.frame = currframe;\n                    if (!spec.color) {\n                        var s = newAtom.style.sphere;\n                        if (!s) s = newAtom.style.stick;\n                        if (!s) s = newAtom.style.line;\n                        spec.color = getColorFromStyle(newAtom, s);\n                    }\n                    viewer.addArrow(spec);\n                }\n            }\n            this.frames.push(newAtoms);\n        }\n    };\n\n    // set default style and colors for atoms\n    public setAtomDefaults(atoms: AtomSpec[]) {\n        for (let i = 0; i < atoms.length; i++) {\n            let atom = atoms[i];\n            if (atom) {\n                atom.style = atom.style || deepCopy(GLModel.defaultAtomStyle);\n                atom.color = atom.color || this.ElementColors[atom.elem] || this.defaultColor;\n                atom.model = this.id;\n                if (atom.clickable || atom.hoverable)\n                    atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            }\n        }\n    };\n\n    /** add atoms to this model from molecular data string\n     *\n     * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer\n     * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)\n     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format\n     */\n    public addMolData(data: string | ArrayBuffer, format: string, options: ParserOptionsSpec = {}) {\n        var parsedAtoms = GLModel.parseMolData(data, format, options);\n        this.dontDuplicateAtoms = !options.duplicateAssemblyAtoms;\n        var mData = parsedAtoms.modelData;\n        if (mData) {\n            if (Array.isArray(mData)) {\n                this.modelData = mData[0];\n                if (options.frames) {\n                    this.modelDatas = mData;\n                }\n            } else {\n                this.modelData = mData;\n            }\n        }\n\n        if (parsedAtoms.box) {\n            this.box = parsedAtoms.box;\n        } else {\n            this.box = null;\n        }\n\n        if (this.frames.length == 0) { //first call\n            for (let i = 0; i < parsedAtoms.length; i++) {\n                if (parsedAtoms[i].length != 0)\n                    this.frames.push(parsedAtoms[i]);\n            }\n            if (this.frames[0])\n                this.atoms = this.frames[0];\n        }\n\n        else { //subsequent calls\n            if (options.frames) { //add to new frame\n                for (let i = 0; i < parsedAtoms.length; i++) {\n                    this.frames.push(parsedAtoms[i]);\n                }\n            }\n            else { //add atoms to current frame\n                for (var i = 0; i < parsedAtoms.length; i++) {\n                    this.addAtoms(parsedAtoms[i]);\n                }\n            }\n        }\n\n        for (let i = 0; i < this.frames.length; i++) {\n            this.setAtomDefaults(this.frames[i]);\n        }\n\n        if (options.vibrate && options.vibrate.frames && options.vibrate.amplitude) {\n            //fill in vibrational modes\n            this.vibrate(options.vibrate.frames, options.vibrate.amplitude);\n        }\n\n        if (options.style) {\n            this.setStyle({}, options.style);\n        }\n    };\n\n    public setDontDuplicateAtoms(dup: boolean) {\n        this.dontDuplicateAtoms = dup;\n    };\n\n    public setModelData(mData) {\n        this.modelData = mData;\n    };\n\n    //return true if atom value matches property val\n    private propertyMatches(atomval, val) {\n        if (atomval == val) {\n            return true;\n        } else if (typeof (val) == 'string' && typeof (atomval) == 'number') {\n            //support numerical integer ranges, e.g. resi: 3-7\n            var match = val.match(/(-?\\d+)\\s*-\\s*(-?\\d+)/);\n            if (match) {\n                var lo = parseInt(match[1]);\n                var hi = parseInt(match[2]);\n                if (match && atomval >= lo && atomval <= hi) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // make a deep copy of a selection object and create caches of expensive\n    // selections.  We create a copy so caches are not attached to user\n    // supplied objects where the user might change them invalidating the cache.\n    // This does not support arbitrary\n    // javascript objects, but support enough for eveything that is\n    // used in selections: number, string, boolean, functions; as well\n    // as arrays and nested objects with values of the aformentioned\n    // types.\n    private static deepCopyAndCache(selobject, model) {\n        if (typeof selobject != 'object' || selobject == null || selobject instanceof GLModel) return selobject;\n        if (selobject.__cache_created) return selobject; //already done\n        const copy: any = {};\n        for (const key in selobject) {\n            const item = selobject[key];\n            if (Array.isArray(item)) {\n                // handle array separatly from other typeof == \"object\"\n                // elements\n                copy[key] = [];\n                for (let i = 0; i < item.length; i++) {\n                    copy[key].push(GLModel.deepCopyAndCache(item[i], model));\n                }\n            } else if (typeof item === \"object\" && key != \"properties\" && key != \"model\") {\n                copy[key] = GLModel.deepCopyAndCache(item, model);\n            } else {\n                copy[key] = item;\n            }\n\n            //create caches of expensive selection types - the cache\n            //stores the atoms matching the selection type\n            if (key == \"and\" || key == \"or\") {\n                // create a list of sets of matching atoms indexes for\n                // each sub-selection\n                const results = [];\n                for (const subSelection of copy[key]) {\n                    const set = new Set();\n                    for (const match of model.selectedAtoms(subSelection)) {\n                        set.add(match.index);\n                    }\n                    results.push(set);\n                }\n\n                if (key == \"and\") {\n                    // get the intersection of two sets\n                    const intersect = function (first, other) {\n                        const result = new Set();\n                        for (const elem of other) {\n                            if (first.has(elem)) {\n                                result.add(elem);\n                            }\n                        }\n                        return result;\n                    };\n\n                    let intersection = new Set(results[0]);\n                    for (const set of results.splice(1)) {\n                        intersection = intersect(intersection, set);\n                    }\n                    copy[key].__cached_results = intersection;\n\n                } else if (key == \"or\") {\n                    const union = new Set();\n                    for (const set of results) {\n                        for (const elem of set) {\n                            union.add(elem);\n                        }\n                    }\n\n                    copy[key].__cached_results = union;\n                }\n            }\n\n        }\n        copy.__cache_created = true;\n        return copy;\n    };\n\n    private static readonly ignoredKeys = new Set<string>([\"props\", \"invert\", \"model\", \"frame\", \"byres\", \"expand\", \"within\", \"and\", \"or\", \"not\"]);\n\n    /** given a selection specification, return true if atom is selected.\n     * Does not support context-aware selectors like expand/within/byres.\n     *\n     * @param {AtomSpec} atom\n     * @param {AtomSelectionSpec} sel\n     * @return {boolean}\n     */\n    public atomIsSelected(atom: AtomSpec, sel?: AtomSelectionSpec) {\n        if (typeof (sel) === \"undefined\")\n            return true; // undef gets all\n        var invert = !!sel.invert;\n        var ret = true;\n        for (var key in sel) {\n            if (key == \"and\" || key == \"or\" || key == \"not\") {  //boolean operators\n                if (key == \"not\") {\n                    if (this.atomIsSelected(atom, sel[key])) {\n                        ret = false;\n                        break;\n                    }\n                } else { //\"or\" and \"and\"\n                    // these selections are expensive so when called via\n                    //selectedAtoms shoudl be cached - but if atomIsSelected\n                    //is called directly create the cache\n                    if (sel[key].__cached_results === undefined) {\n                        sel = GLModel.deepCopyAndCache(sel, this);\n                    }\n\n                    ret = sel[key].__cached_results.has(atom.index);\n                    if (!ret) {\n                        break;\n                    }\n                }\n\n            } else if (key === 'predicate') { //a user supplied function for evaluating atoms\n                if (!sel.predicate(atom)) {\n                    ret = false;\n                    break;\n                }\n            }\n            else if (key == \"properties\" && atom[key]) {\n                for (var propkey in sel.properties) {\n                    if (propkey.startsWith(\"__cache\")) continue;\n                    if (typeof (atom.properties[propkey]) === 'undefined') {\n                        ret = false;\n                        break;\n                    }\n                    if (atom.properties[propkey] != sel.properties[propkey]) {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            else if (key == \"model\") {\n                let m = sel.model;\n                if(typeof m  === 'number' && m < 0) {\n                    m = this.viewer.getNextModelId()+m;\n                }\n\n                if (Array.isArray(m)) {  // handle list\n                    let isokay = false;\n                    for (let i = 0; i < m.length; i++) {\n                        if(m[i] == this || m[i] == this.id) {\n                            isokay = true;\n                            break;\n                        }\n                    }\n                    if (!isokay) {\n                        ret = false;\n                        break;\n                    }\n                } else {\n                    if(m != this && m != this.id) {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            else if (sel.hasOwnProperty(key) && !GLModel.ignoredKeys.has(key) && !key.startsWith('__cache')) {\n\n                // if something is in sel, atom must have it\n                if (typeof (atom[key]) === \"undefined\") {\n                    ret = false;\n                    break;\n                }\n                let isokay = false;\n                if (key === \"bonds\") {\n                    //special case counting number of bonds, for selecting nonbonded mostly\n                    var val = sel[key];\n                    if (val != atom.bonds.length) {\n                        ret = false;\n                        break;\n                    }\n                }\n                else if (Array.isArray(sel[key])) {\n                    // can be any of the listed values\n                    var valarr = sel[key];\n                    var atomval = atom[key];\n                    for (let i = 0; i < valarr.length; i++) {\n                        if (this.propertyMatches(atomval, valarr[i])) {\n                            isokay = true;\n                            break;\n                        }\n                    }\n                    if (!isokay) {\n                        ret = false;\n                        break;\n                    }\n                } else { // single match\n                    let val = sel[key];\n                    if (!this.propertyMatches(atom[key], val)) {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return invert ? !ret : ret;\n    };\n\n\n    private static squaredDistance(atom1: XYZ | AtomSpec, atom2: XYZ | AtomSpec) {\n        var xd = atom2.x - atom1.x;\n        var yd = atom2.y - atom1.y;\n        var zd = atom2.z - atom1.z;\n        return xd * xd + yd * yd + zd * zd;\n    };\n\n    /** returns a list of atoms in the expanded bounding box, but not in the current one\n     *\n     *  Bounding box:\n     *\n     *    [ [ xmin, ymin, zmin ],\n     *      [ xmax, ymax, zmax ],\n     *      [ xctr, yctr, zctr ] ]\n     *\n     **/\n    private expandAtomList(atomList: AtomSpec[], amt: number) {\n\n        if (amt <= 0) return atomList;\n\n        var pb = getExtent(atomList, undefined); // previous bounding box\n        var nb = [[], [], []]; // expanded bounding box\n\n        for (var i = 0; i < 3; i++) {\n            nb[0][i] = pb[0][i] - amt;\n            nb[1][i] = pb[1][i] + amt;\n            nb[2][i] = pb[2][i];\n        }\n\n        // look in added box \"shell\" for new atoms\n        var expand = [];\n        for (let i = 0; i < this.atoms.length; i++) {\n\n            var x = this.atoms[i].x;\n            var y = this.atoms[i].y;\n            var z = this.atoms[i].z;\n\n            if (x >= nb[0][0] && x <= nb[1][0] && y >= nb[0][1] && y <= nb[1][1] && z >= nb[0][2] && z <= nb[1][2]) {\n                if (!(x >= pb[0][0] && x <= pb[1][0] && y >= pb[0][1] && y <= pb[1][1] && z >= pb[0][2] && z <= pb[1][2])) {\n                    expand.push(this.atoms[i]);\n                }\n            }\n        }\n        return expand;\n    };\n\n\n\n    private static getFloat(val: string | number): number {\n        if (typeof (val) === 'number')\n            return val;\n        else\n            return parseFloat(val);\n    }\n    /** return list of atoms selected by sel, this is specific to glmodel\n     *\n     * @param {AtomSelectionSpec} sel\n     * @return {Object[]}\n     * @example\n     $3Dmol.download(\"pdb:4wwy\",viewer,{},function(){\n              var atoms = viewer.selectedAtoms({chain:'A'});\n              for(var i = 0, n = atoms.length; i < n; i++) {\n                 atoms[i].b = 0.0;\n              }\n              viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});\n              viewer.render();\n          });\n     */\n    public selectedAtoms(sel: AtomSelectionSpec, from?: AtomSpec[]): AtomSpec[] {\n        var ret = [];\n\n        // make a copy of the selection to allow caching results without\n        // the possibility for the user to change the selection and this\n        // code not noticing the changes\n        sel = GLModel.deepCopyAndCache(sel || {}, this);\n\n        if (!from) from = this.atoms;\n        var aLength = from.length;\n        for (var i = 0; i < aLength; i++) {\n            var atom = from[i];\n            if (atom) {\n                if (this.atomIsSelected(atom, sel))\n                    ret.push(atom);\n            }\n        }\n\n        // expand selection by some distance\n        if (sel.hasOwnProperty(\"expand\")) {\n            // get atoms in expanded bounding box\n            const exdist: number = GLModel.getFloat(sel.expand);\n            let expand = this.expandAtomList(ret, exdist);\n            let retlen = ret.length;\n            const thresh = exdist * exdist;\n            for (let i = 0; i < expand.length; i++) {\n                for (let j = 0; j < retlen; j++) {\n\n                    var dist = GLModel.squaredDistance(expand[i], ret[j]);\n                    if (dist < thresh && dist > 0) {\n                        ret.push(expand[i]);\n                    }\n                }\n            }\n        }\n\n        // selection within distance of sub-selection\n        if (sel.hasOwnProperty(\"within\") && sel.within.hasOwnProperty(\"sel\") &&\n            sel.within.hasOwnProperty(\"distance\")) {\n\n            // get atoms in second selection\n            var sel2 = this.selectedAtoms(sel.within.sel, this.atoms);\n            var within = {};\n            const dist = GLModel.getFloat(sel.within.distance);\n            const thresh = dist * dist;\n            for (let i = 0; i < sel2.length; i++) {\n                for (let j = 0; j < ret.length; j++) {\n\n                    let dist = GLModel.squaredDistance(sel2[i], ret[j]);\n                    if (dist < thresh && dist > 0) {\n                        within[j] = 1;\n                    }\n                }\n            }\n            var newret = [];\n            if (sel.within.invert) {\n                for (let j = 0; j < ret.length; j++) {\n                    if (!within[j]) newret.push(ret[j]);\n                }\n            } else {\n                for (let j in within) {\n                    newret.push(ret[j]);\n                }\n            }\n            ret = newret;\n        }\n\n        // byres selection flag\n        if (sel.hasOwnProperty(\"byres\")) {\n\n            // Keep track of visited residues, visited atoms, and atom stack\n            var vResis = {};\n            var vAtoms = [];\n            var stack = [];\n\n            for (let i = 0; i < ret.length; i++) {\n\n                // Check if atom is part of a residue, and that the residue hasn't been traversed yet\n                let atom = ret[i];\n                var c = atom.chain;\n                var r = atom.resi;\n                if (vResis[c] === undefined) vResis[c] = {};\n                if (atom.hasOwnProperty(\"resi\") && vResis[c][r] === undefined) {\n\n                    // Perform a depth-first search of atoms with the same resi\n                    vResis[c][r] = true;\n                    stack.push(atom);\n                    while (stack.length > 0) {\n                        atom = stack.pop();\n                        c = atom.chain;\n                        r = atom.resi;\n                        if (vAtoms[atom.index] === undefined) {\n                            vAtoms[atom.index] = true;\n                            for (var j = 0; j < atom.bonds.length; j++) {\n                                var atom2 = this.atoms[atom.bonds[j]];\n                                if (vAtoms[atom2.index] === undefined && atom2.hasOwnProperty(\"resi\") && atom2.chain == c && atom2.resi == r) {\n                                    stack.push(atom2);\n                                    ret.push(atom2);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return ret;\n    };\n\n\n    /** Add list of new atoms to model.  Adjusts bonds appropriately.\n     *\n     * @param {AtomSpec[]} newatoms\n     * @example\n     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];\n\n        viewer.setBackgroundColor(0xffffffff);\n        var m = viewer.addModel();\n        m.addAtoms(atoms);\n        m.setStyle({},{stick:{}});\n        viewer.zoomTo();\n        viewer.render();\n     */\n    public addAtoms(newatoms: AtomSpec[]) {\n        this.molObj = null;\n        var start = this.atoms.length;\n        var indexmap = [];\n        // mapping from old index to new index\n        var i;\n        for (i = 0; i < newatoms.length; i++) {\n            if (typeof (newatoms[i].index) == \"undefined\")\n                newatoms[i].index = i;\n            if (typeof (newatoms[i].serial) == \"undefined\")\n                newatoms[i].serial = i;\n            indexmap[newatoms[i].index] = start + i;\n        }\n\n        // copy and push newatoms onto atoms\n        for (i = 0; i < newatoms.length; i++) {\n            var olda = newatoms[i];\n            var nindex = indexmap[olda.index];\n            var a = extend({}, olda);\n            a.index = nindex;\n            a.bonds = [];\n            a.bondOrder = [];\n            a.model = this.id;\n            a.style = a.style || deepCopy(GLModel.defaultAtomStyle);\n            if (typeof (a.color) == \"undefined\")\n                a.color = this.ElementColors[a.elem] || this.defaultColor;\n            // copy over all bonds contained in selection,\n            // updating indices appropriately\n            var nbonds = olda.bonds ? olda.bonds.length : 0;\n            for (var j = 0; j < nbonds; j++) {\n                var neigh = indexmap[olda.bonds[j]];\n                if (typeof (neigh) != \"undefined\") {\n                    a.bonds.push(neigh);\n                    a.bondOrder.push(olda.bondOrder ? olda.bondOrder[j] : 1);\n                }\n            }\n            this.atoms.push(a);\n        }\n    };\n\n    /** Assign bonds based on atomic coordinates.\n     *  This currently uses a primitive distance-based algorithm that does not\n     * consider valence constraints and will only create single bonds.\n     */\n    public assignBonds() {\n        assignBonds(this.atoms, { assignBonds: true });\n    }\n\n    /** Remove specified atoms from model\n     *\n     * @param {AtomSpec[]} badatoms - list of atoms\n     */\n    public removeAtoms(badatoms: AtomSpec[]) {\n        this.molObj = null;\n        // make map of all baddies\n        var baddies = [];\n        var i;\n        for (i = 0; i < badatoms.length; i++) {\n            baddies[badatoms[i].index] = true;\n        }\n\n        // create list of good atoms\n        var newatoms = [];\n        for (i = 0; i < this.atoms.length; i++) {\n            var a = this.atoms[i];\n            if (!baddies[a.index])\n                newatoms.push(a);\n        }\n\n        // clear it all out\n        this.atoms = [];\n        // and add back in to get updated bonds\n        this.addAtoms(newatoms);\n    };\n\n\n    /** Set atom style of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     * @param {boolean} add - if true, add to current style, don't replace\n     @example\n    $3Dmol.download(\"pdb:4UB9\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n\n              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.render();\n          });\n     */\n    public setStyle(sel: AtomSelectionSpec | AtomStyleSpec | string, style?: AtomStyleSpec | string, add?) {\n\n        if (typeof (style) === 'undefined' && typeof (add) == 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel as AtomStyleSpec | string;\n            sel = {};\n        }\n        sel = sel as AtomSelectionSpec;\n        //if type is just a string, promote it to an object\n        if (typeof (style) === 'string') {\n            style = specStringToObject(style);\n        }\n\n        var changedAtoms = false;\n        // somethings we only calculate if there is a change in a certain\n        // style, although these checks will only catch cases where both\n        // are either null or undefined\n        var that = this;\n        var setStyleHelper = function (atomArr) {\n            var selected = that.selectedAtoms(sel as AtomSelectionSpec, atomArr);\n            for (let i = 0; i < atomArr.length; i++) {\n                if (atomArr[i]) atomArr[i].capDrawn = false; //reset for proper stick render\n            }\n\n            for (let i = 0; i < selected.length; i++) {\n                changedAtoms = true;\n                if (selected[i].clickable || selected[i].hoverable)\n                    selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n\n\n                if (!add) selected[i].style = {};\n                for (let s in style as AtomStyleSpec) {\n                    if (style.hasOwnProperty(s)) {\n                        selected[i].style[s] = selected[i].style[s] || {}; //create distinct object for each atom\n                        Object.assign(selected[i].style[s], style[s]);\n                    }\n                }\n            }\n        };\n\n        if (sel.frame !== undefined && sel.frame < this.frames.length) { //set specific frame only\n            let frame = sel.frame;\n            if (frame < 0) frame = this.frames.length + frame;\n            setStyleHelper(this.frames[frame]);\n        } else {\n            setStyleHelper(this.atoms);\n            for (var i = 0; i < this.frames.length; i++) {\n                if (this.frames[i] !== this.atoms) setStyleHelper(this.frames[i]);\n            }\n        }\n        if (changedAtoms)\n            this.molObj = null; //force rebuild\n\n    };\n\n    /** Set clickable and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to\n     * @param {boolean} clickable - whether click-handling is enabled for the selection\n     * @param {function} callback - function called when an atom in the selection is clicked\n\n     */\n    public setClickable(sel: AtomSelectionSpec, clickable: boolean, callback) {\n\n        // make sure clickable is a boolean\n        clickable = !!clickable;\n        callback = makeFunction(callback);\n        if (callback === null) {\n            console.log(\"Callback is not a function\");\n            return;\n        }\n\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (let i = 0; i < len; i++) {\n\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].clickable = clickable;\n            if (callback) selected[i].callback = callback;\n\n        }\n\n        if (len > 0) this.molObj = null; // force rebuild to get correct intersection shapes\n    };\n\n    /** Set hoverable and callback of selected atoms\n    *\n    * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n    * @param {boolean} hoverable - whether hover-handling is enabled for the selection\n    * @param {function} hover_callback - function called when an atom in the selection is hovered over\n    * @param {function} unhover_callback - function called when the mouse moves out of the hover area\n    */\n    public setHoverable(sel: AtomSelectionSpec, hoverable: boolean, hover_callback, unhover_callback) {\n\n        // make sure hoverable is a boolean\n        hoverable = !!hoverable;\n        hover_callback = makeFunction(hover_callback);\n        unhover_callback = makeFunction(unhover_callback);\n\n        // report to console if hover_callback is not a valid function\n        if (hover_callback === null) {\n            console.log(\"Hover_callback is not a function\");\n            return;\n        }\n        // report to console if unhover_callback is not a valid function\n        if (unhover_callback === null) {\n            console.log(\"Unhover_callback is not a function\");\n            return;\n        }\n\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (let i = 0; i < len; i++) {\n\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].hoverable = hoverable;\n            if (hover_callback) selected[i].hover_callback = hover_callback;\n            if (unhover_callback) selected[i].unhover_callback = unhover_callback;\n\n        }\n\n        if (len > 0) this.molObj = null; // force rebuild to get correct intersection shapes\n    };\n\n    /** enable context menu of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection\n     */\n    public enableContextMenu(sel: AtomSelectionSpec, contextMenuEnabled) {\n        // make sure contextMenuEnabled is a boolean\n        contextMenuEnabled = !!contextMenuEnabled;\n\n        var i;\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (i = 0; i < len; i++) {\n\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].contextMenuEnabled = contextMenuEnabled;\n        }\n\n        if (len > 0) this.molObj = null; // force rebuild to get correct intersection shapes\n    };\n\n    /** given a mapping from element to color, set atom colors\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {object} colors\n     */\n    public setColorByElement(sel: AtomSelectionSpec, colors) {\n\n        if (this.molObj !== null && GLModel.sameObj(colors, this.lastColors))\n            return; // don't recompute\n        this.lastColors = colors;\n        var atoms = this.selectedAtoms(sel, atoms);\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n        for (var i = 0; i < atoms.length; i++) {\n            var a = atoms[i];\n            if (typeof (colors[a.elem]) !== \"undefined\") {\n                a.color = colors[a.elem];\n            }\n        }\n    };\n\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {string} prop\n     * @param {Gradient|string} scheme\n     */\n    public setColorByProperty(sel: AtomSelectionSpec, prop: string, scheme: Gradient | string, range?) {\n        var i, a;\n        var atoms = this.selectedAtoms(sel, atoms);\n        this.lastColors = null; // don't bother memoizing\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n\n        if (typeof scheme === 'string' && typeof (Gradient.builtinGradients[scheme]) != \"undefined\") {\n            scheme = new Gradient.builtinGradients[scheme]();\n        }\n        scheme = scheme as Gradient;\n        if (!range) { //no explicit range, get from scheme\n            range = scheme.range();\n        }\n\n        if (!range) { //no range in scheme, compute the range for this model\n            range = getPropertyRange(atoms, prop);\n        }\n        // now apply colors using scheme\n        for (i = 0; i < atoms.length; i++) {\n            a = atoms[i];\n            var val = getAtomProperty(a, prop);\n            if (val != null) {\n                a.color = scheme.valueToHex(parseFloat(a.properties[prop]), range);\n            }\n        }\n    };\n\n    /**\n     * @deprecated use setStyle and colorfunc attribute\n     * @param {AtomSelectionSpec} sel - selection object\n     * @param {function} func - function to be used to set the color\n     @example\n      $3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n              var colorAsSnake = function(atom) {\n                return atom.resi % 2 ? 'white': 'green'\n              };\n\n              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});\n\n              viewer.render();\n          });\n\n     */\n    public setColorByFunction(sel: AtomSelectionSpec, colorfun) {\n        var atoms = this.selectedAtoms(sel, atoms);\n        if (typeof (colorfun) !== 'function')\n            return;\n        this.lastColors = null; // don't bother memoizing\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n\n        // now apply colorfun\n        for (let i = 0; i < atoms.length; i++) {\n            let a = atoms[i];\n            a.color = colorfun(a);\n        }\n    };\n\n    /** Convert the model into an object in the format of a ChemDoodle JSON model.\n     *\n     * @param {boolean} whether or not to include style information. Defaults to false.\n     * @return {Object}\n     */\n    public toCDObject(includeStyles: boolean = false) {\n        var out: any = { a: [], b: [] };\n        if (includeStyles) {\n            out.s = [];\n        }\n        for (let i = 0; i < this.atoms.length; i++) {\n            let atomJSON: any = {};\n            let atom = this.atoms[i];\n            atomJSON.x = atom.x;\n            atomJSON.y = atom.y;\n            atomJSON.z = atom.z;\n            if (atom.elem != \"C\") {\n                atomJSON.l = atom.elem;\n            }\n            if (includeStyles) {\n                var s = 0;\n                while (s < out.s.length &&\n                    (JSON.stringify(atom.style) !== JSON.stringify(out.s[s]))) {\n                    s++;\n                }\n                if (s === out.s.length) {\n                    out.s.push(atom.style);\n                }\n                if (s !== 0) {\n                    atomJSON.s = s;\n                }\n            }\n\n            out.a.push(atomJSON);\n\n            for (let b = 0; b < atom.bonds.length; b++) {\n                let firstAtom = i;\n                let secondAtom = atom.bonds[b];\n                if (firstAtom >= secondAtom)\n                    continue;\n                let bond: any = {\n                    b: firstAtom,\n                    e: secondAtom\n                };\n                let bondOrder = atom.bondOrder[b];\n                if (bondOrder != 1) {\n                    bond.o = bondOrder;\n                }\n                out.b.push(bond);\n            }\n        }\n        return out;\n    };\n\n\n    /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add\n     *\n     * @param {Object3D} group\n     * @param Object options\n     */\n    public globj(group, options) {\n        if (this.molObj === null || options.regen) { // have to regenerate\n            this.molObj = this.createMolObj(this.atoms, options);\n            if (this.renderedMolObj) { // previously rendered, remove\n                group.remove(this.renderedMolObj);\n                this.renderedMolObj = null;\n            }\n            this.renderedMolObj = this.molObj.clone();\n            if (this.hidden) {\n                this.renderedMolObj.setVisible(false);\n                this.molObj.setVisible(false);\n            }\n            group.add(this.renderedMolObj);\n        }\n    };\n\n    /** return a VRML string representation of the model.  Does not include VRML header information\n     * @return VRML\n     */\n    public exportVRML() {\n        //todo: export spheres and cylinder objects instead of all mesh\n        var tmpobj = this.createMolObj(this.atoms, { supportsImposters: false, supportsAIA: false });\n        return tmpobj.vrml();\n    };\n\n    /** Remove any renderable mol object from scene\n     *\n     * @param {Object3D} group\n     */\n    public removegl(group) {\n        if (this.renderedMolObj) {\n            //dispose of geos and materials\n            if (this.renderedMolObj.geometry !== undefined) this.renderedMolObj.geometry.dispose();\n            if (this.renderedMolObj.material !== undefined) this.renderedMolObj.material.dispose();\n            group.remove(this.renderedMolObj);\n            this.renderedMolObj = null;\n        }\n        this.molObj = null;\n    };\n\n    /**\n     * Don't show this model in future renderings. Keep all styles and state\n     * so it can be efficiencly shown again.\n     *\n     * * @see GLModel#show\n\n     * @example\n        $3Dmol.download(\"pdb:3ucr\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.getModel().hide();\n        viewer.render();\n        });\n     */\n    public hide() {\n        this.hidden = true;\n        if (this.renderedMolObj) this.renderedMolObj.setVisible(false);\n        if (this.molObj) this.molObj.setVisible(false);\n    };\n\n    /**\n     * Unhide a hidden model\n     * @see GLModel#hide\n     * @example\n        $3Dmol.download(\"pdb:3ucr\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.getModel().hide();\n        viewer.render(  )\n        viewer.getModel().show()\n        viewer.render();\n        });\n     */\n    public show() {\n        this.hidden = false;\n        if (this.renderedMolObj) this.renderedMolObj.setVisible(true);\n        if (this.molObj) this.molObj.setVisible(true);\n    };\n\n\n    /** Create labels for atoms that show the value of the passed property.\n     *\n     * @param {String} prop - property name\n     * @param {AtomSelectionSpec} sel\n     * @param {LabelSpec} options\n     */\n    public addPropertyLabels(prop: string, sel: AtomSelectionSpec, style: LabelSpec) {\n        let atoms = this.selectedAtoms(sel);\n        let viewer = this.viewer;\n        let mystyle = deepCopy(style);\n        for (let i = 0; i < atoms.length; i++) {\n            let a = atoms[i];\n            var label = null;\n            if (typeof (a[prop]) != 'undefined') {\n                label = String(a[prop]);\n            } else if (typeof (a.properties[prop]) != 'undefined') {\n                label = String(a.properties[prop]);\n            }\n\n            if (label != null) {\n                mystyle.position = a;\n                viewer.addLabel(label, mystyle);\n            }\n        }\n    };\n\n\n    /** Create labels for residues of selected atoms.\n     * Will create a single label at the center of mass of all atoms\n     * with the same chain,resn, and resi.\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {LabelSpec} options\n     * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already\n     */\n    public addResLabels(sel: AtomSelectionSpec, style: LabelSpec, byframe: boolean = false) {\n        let viewer = this.viewer;\n        var created_labels = [];\n        var helper = function (model, framenum?) {\n            var atoms = model.selectedAtoms(sel, atoms);\n            var bylabel = {};\n            //collect by chain:resn:resi\n            for (var i = 0; i < atoms.length; i++) {\n                var a = atoms[i];\n                var c = a.chain;\n                var resn = a.resn;\n                var resi = a.resi;\n                var label = resn + '' + resi;\n                if (!bylabel[c]) bylabel[c] = {};\n                if (!bylabel[c][label]) bylabel[c][label] = [];\n                bylabel[c][label].push(a);\n            }\n\n            var mystyle = deepCopy(style);\n            //now compute centers of mass\n            for (let c in bylabel) {\n                if (bylabel.hasOwnProperty(c)) {\n                    var labels = bylabel[c];\n                    for (let label in labels) {\n                        if (labels.hasOwnProperty(label)) {\n                            let atoms = labels[label];\n                            let sum = new Vector3(0, 0, 0);\n                            for (let i = 0; i < atoms.length; i++) {\n                                let a = atoms[i];\n                                sum.x += a.x;\n                                sum.y += a.y;\n                                sum.z += a.z;\n                            }\n                            sum.divideScalar(atoms.length);\n                            mystyle.position = sum;\n                            mystyle.frame = framenum;\n                            let l = viewer.addLabel(label, mystyle, undefined, true);\n                            created_labels.push(l);\n                        }\n                    }\n                }\n            }\n        };\n\n        if (byframe) {\n            var n = this.getNumFrames();\n            let savedatoms = this.atoms;\n            for (let i = 0; i < n; i++) {\n                if (this.frames[i]) {\n                    this.atoms = this.frames[i];\n                    helper(this, i);\n                }\n            }\n            this.atoms = savedatoms;\n        } else {\n            helper(this);\n        }\n        return created_labels;\n    };\n\n\n    //recurse over the current atoms to establish a depth first order\n    private setupDFS() {\n        this.atomdfs = [];\n        var self = this;\n        var visited = new Int8Array(this.atoms.length);\n        visited.fill(0);\n\n        var search = function (i, prev, component) {\n            //add i to component and recursive explore connected atoms\n            component.push([i, prev]);\n            var atom = self.atoms[i];\n            visited[i] = 1;\n            for (var b = 0; b < atom.bonds.length; b++) {\n                var nexti = atom.bonds[b];\n                if (self.atoms[nexti] && !visited[nexti]) {\n                    search(nexti, i, component);\n                }\n            }\n        };\n\n        for (var i = 0; i < this.atoms.length; i++) {\n            var atom = this.atoms[i];\n            if (atom && !visited[i]) {\n                var component = [];\n                search(i, -1, component);\n                this.atomdfs.push(component);\n            }\n        }\n    };\n\n    /**\n    * Set coordinates from remote trajectory file.\n    * @param {string} url - contains the url where mdsrv has been hosted\n    * @param {string} path - contains the path of the file (<root>/filename)\n    * @return {Promise}\n    */\n    public setCoordinatesFromURL(url: string, path: string) {\n        this.frames = [];\n        var self = this;\n        if (this.box) this.setupDFS();\n        if (!url.startsWith('http'))\n            url = 'http://' + url;\n        return get(url + \"/traj/numframes/\" + path, function (numFrames) {\n            if (!isNaN(parseInt(numFrames))) {\n                self.frames.push(self.atoms);\n                self.frames.numFrames = numFrames;\n                self.frames.url = url;\n                self.frames.path = path;\n                return self.setFrame(0);\n            }\n        });\n    };\n\n\n    /**\n    * Set coordinates for the atoms from provided trajectory file.\n    * @param {string|ArrayBuffer} str - contains the data of the file\n    * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.\n      @example\n         let m = viewer.addModel()  //create an empty model\n         m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms\n         viewer.setStyle({'sphere':{}})\n         m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');\n         viewer.animate({loop: \"forward\",reps: 1});\n         viewer.zoomTo();\n         viewer.zoom(0.5);\n         viewer.render();\n    */\n\n    public setCoordinates(str: string | ArrayBuffer, format: string) {\n        format = format || \"\";\n        if (!str)\n            return []; // leave an empty model\n\n        if (/\\.gz$/.test(format)) {\n            // unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                str = inflateString(str)\n            } catch (err) {\n                console.log(err);\n            }\n        }\n        var supportedFormats = { \"mdcrd\": \"\", \"inpcrd\": \"\", \"pdb\": \"\", \"netcdf\": \"\", \"array\": \"\" };\n        if (supportedFormats.hasOwnProperty(format)) {\n            this.frames = [];\n            var atomCount = this.atoms.length;\n            var values = GLModel.parseCrd(str, format);\n            var count = 0;\n            while (count < values.length) {\n                var temp = [];\n                for (var i = 0; i < atomCount; i++) {\n                    var newAtom = {};\n                    for (var k in this.atoms[i]) {\n                        newAtom[k] = this.atoms[i][k];\n                    }\n                    temp[i] = newAtom;\n                    temp[i].x = values[count++];\n                    temp[i].y = values[count++];\n                    temp[i].z = values[count++];\n                }\n\n                this.frames.push(temp);\n            }\n            this.atoms = this.frames[0];\n            return this.frames;\n        }\n        return [];\n    };\n\n    /**\n     * add atomSpecs to validAtomSelectionSpecs\n     * @deprecated\n     * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs\n     * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.\n     * These messages are no longer generated as, in theory, typescript will catch problems at compile time.\n     * In practice, there may still be issues at run-time but we don't check for them...\n     *\n     * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime\n     * type checking, but it currently doesn't work with our types...\n     */\n\n    public addAtomSpecs(customAtomSpecs) {\n\n    };\n\n    static parseCrd(data, format: string) {\n        var values = []; // this will contain the all the float values in the\n        // file.\n        var counter = 0;\n        if (format == \"pdb\") {\n            var index = data.indexOf(\"\\nATOM\");\n            while (index != -1) {\n                while (data.slice(index, index + 5) == \"\\nATOM\" ||\n                    data.slice(index, index + 7) == \"\\nHETATM\") {\n                    values[counter++] = parseFloat(data.slice(index + 31,\n                        index + 39));\n                    values[counter++] = parseFloat(data.slice(index + 39,\n                        index + 47));\n                    values[counter++] = parseFloat(data.slice(index + 47,\n                        index + 55));\n                    index = data.indexOf(\"\\n\", index + 54);\n                    if (data.slice(index, index + 4) == \"\\nTER\")\n                        index = data.indexOf(\"\\n\", index + 5);\n                }\n                index = data.indexOf(\"\\nATOM\", index);\n            }\n\n        } else if (format == \"netcdf\") {\n            var reader = new NetCDFReader(data);\n            values = [].concat.apply([], reader.getDataVariable('coordinates'));\n\n        } else if (format == \"array\" || Array.isArray(data)) {\n            return data.flat(2);\n        } else {\n            let index = data.indexOf(\"\\n\"); // remove the first line containing title\n            if (format == 'inpcrd') {\n                index = data.indexOf(\"\\n\", index + 1); //remove second line w/#atoms\n            }\n\n            data = data.slice(index + 1);\n            values = data.match(/\\S+/g).map(parseFloat);\n        }\n        return values;\n    };\n\n    static parseMolData(data?: string | ArrayBuffer, format: string = \"\", options?: ParserOptionsSpec) {\n        if (!data)\n            return []; //leave an empty model\n\n        if (/\\.gz$/.test(format)) {\n            //unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                if (format.match(/bcif/i)) {\n                    data = inflateString(data, false);\n                } else {\n                    data = inflateString(data);\n                }\n            } catch (err) {\n                console.log(err);\n            }\n        }\n\n        if (typeof (Parsers[format]) == \"undefined\") {\n            // let someone provide a file name and get format from extension\n            format = format.split('.').pop();\n            if (typeof (Parsers[format]) == \"undefined\") {\n                console.log(\"Unknown format: \" + format);\n                // try to guess correct format from data contents\n                if (data instanceof Uint8Array) {\n                    format = \"bcif\"; //mmtf deprecated so go with bcif\n                } else if ((data as string).match(/^@<TRIPOS>MOLECULE/gm)) {\n                    format = \"mol2\";\n                } else if ((data as string).match(/^data_/gm) && (data as string).match(/^loop_/gm)) {\n                    format = \"cif\";\n                } else if ((data as string).match(/^HETATM/gm) || (data as string).match(/^ATOM/gm)) {\n                    format = \"pdb\";\n                } else if ((data as string).match(/ITEM: TIMESTEP/gm)) {\n                    format = \"lammpstrj\";\n                } else if ((data as string).match(/^.*\\n.*\\n.\\s*(\\d+)\\s+(\\d+)/gm)) {\n                    format = \"sdf\"; // could look at line 3\n                } else if ((data as string).match(/^%VERSION\\s+VERSION_STAMP/gm)) {\n                    format = \"prmtop\";\n                } else {\n                    format = \"xyz\";\n                }\n                console.log(\"Best guess: \" + format);\n            }\n        }\n        var parse = Parsers[format];\n        var parsedAtoms = parse((data as string), options);\n\n        return parsedAtoms;\n    };\n\n}\n\n/** Atom style specification */\nexport interface AtomStyleSpec {\n    /** draw bonds as lines */\n    line?: LineStyleSpec;\n    /** draw atoms as crossed lines (aka stars) */\n    cross?: CrossStyleSpec;\n    /** draw bonds as capped cylinders */\n    stick?: StickStyleSpec;\n    /** draw atoms as spheres */\n    sphere?: SphereStyleSpec;\n    /** draw cartoon representation of secondary structure */\n    cartoon?: CartoonStyleSpec;\n    /** invisible style for click handling only */\n    clicksphere?: ClickSphereStyleSpec;\n};\n\n/** Line style specification\n */\nexport interface LineStyleSpec {\n    /** do not show line */\n    hidden?: boolean;\n    /** *deprecated due to vanishing browser support*  */\n    linewidth?: number;\n    /** colorscheme to use on atoms; overrides color */\n    colorscheme?: ColorschemeSpec;\n    /** fixed coloring */\n    color?: ColorSpec;\n    /**  Allows the user to provide a function for setting the colorschemes. */\n    colorfunc?: Function;\n    /** opacity (zero to one), must be the same for all atoms in a model */\n    opacity?: number;\n    /** wireframe style */\n    wireframe?: boolean;\n\n}\n\n/** Cross style specification\n */\nexport interface CrossStyleSpec {\n    /** do not show line */\n    hidden?: boolean;\n    /** *deprecated due to vanishing browser support*  */\n    linewidth?: number;\n    /** radius of cross */\n    radius?: number;\n    /** scale VDW radius by specified amount */\n    scale?: number;\n    /** colorscheme to use on atoms; overrides color */\n    colorscheme?: ColorschemeSpec;\n    /** fixed coloring */\n    color?: ColorSpec;\n    /**  Allows the user to provide a function for setting the colorschemes. */\n    colorfunc?: Function;\n    /** opacity (zero to one), must be the same for all atoms in a model */\n    opacity?: number;\n}\n\n/** Dashed Bond style specification\n */\nexport interface DashedBondSpec {\n    /** length of dash (default 0.1) */\n    dashLength?: number;\n    /** length of gap (default 0.25) */\n    gapLength?: number;\n    // Color for the solid portion of aromatic bonds (default: atom color)\n    solidColor?: ColorSpec;\n    // Color for the dashed portion of aromatic bonds (default: atom color)\n    dashedColor?: ColorSpec;\n}\n\n/** Stick (cylinder) style specification\n */\nexport interface StickStyleSpec {\n    /** do not show sticks */\n    hidden?: boolean;\n    /** radius of stick */\n    radius?: number;\n    /** radius scaling factor for drawing double bonds (default 0.4) */\n    doubleBondScaling?: number;\n    /** radius scaling factor for drawing triple bonds (default 0.25) */\n    tripleBondScaling?: number;\n    /** dashed bond properties */\n    dashedBondConfig?: DashedBondSpec;\n    /** draw all bonds as dashed bonds */\n    dashedBonds?: boolean;\n    /** draw all bonds as single bonds */\n    singleBonds?: boolean;\n    /** colorscheme to use on atoms; overrides color */\n    colorscheme?: ColorschemeSpec;\n    /** fixed coloring */\n    color?: ColorSpec;\n    /**  Allows the user to provide a function for setting the colorschemes. */\n    colorfunc?: Function;\n    /** opacity (zero to one), must be the same for all atoms in a model */\n    opacity?: number;\n    /** display nonbonded atoms as spheres */\n    showNonBonded?: boolean;\n}\n\n\n/** Sphere (spacefill) style specification\n */\nexport interface SphereStyleSpec {\n    /** do not show sticks */\n    hidden?: boolean;\n    /** fixed radius of sphere */\n    radius?: number;\n    /** scale VDW radius by specified amount */\n    scale?: number;\n    /** colorscheme to use on atoms; overrides color */\n    colorscheme?: ColorschemeSpec;\n    /** fixed coloring */\n    color?: ColorSpec;\n    /**  Allows the user to provide a function for setting the colorschemes. */\n    colorfunc?: Function;\n    /** opacity (zero to one), must be the same for all atoms in a model */\n    opacity?: number;\n}\n\n/** Invisible click sphere style specification.  This lets you set\n * larger (or smaller) click targets on atoms then the default radii or\n * have clickable atoms even if they aren't being rendered visibly.\n */\nexport interface ClickSphereStyleSpec {\n    /** do not show sticks */\n    hidden?: boolean;\n    /** fixed radius of sphere */\n    radius?: number;\n    /** scale VDW radius by specified amount */\n    scale?: number;\n}\n\n/** Style for individual bond. */\nexport interface BondStyle {\n    iswire?: boolean;\n    /**  */\n    singleBond?: boolean;\n    /**  */\n    radius?: number;\n    /**  */\n    color1?: ColorSpec;\n    /**  */\n    color2?: ColorSpec;\n}\n", "import { Geometry, Material } from \"./WebGL\";\nimport { Sphere, Cylinder, Triangle } from \"./WebGL/shapes\";\nimport { Vector3, XYZ } from \"./WebGL/math\";\nimport { clamp } from \"./WebGL/math\";\nimport { DoubleSide } from \"./WebGL\";\nimport { Color, CC, ColorSpec, Colored } from \"./colors\";\nimport { MarchingCube } from \"./ProteinSurface4\";\nimport { VolumeData } from \"./VolumeData\";\nimport { MeshDoubleLambertMaterial, MeshLambertMaterial, Object3D, Coloring, Mesh, LineBasicMaterial, Line, LineStyle } from \"./WebGL\";\nimport { CAP, GLDraw } from \"./GLDraw\"\nimport { subdivide_spline } from \"./glcartoon\";\nimport { adjustVolumeStyle, extend, Func, makeFunction } from \"./utilities\";\nimport { GradientType } from \"./Gradient\";\nimport { AtomSelectionSpec } from \"specs\";\nimport { GLViewer } from \"GLViewer\";\n\n\n/**\n * A GLShape is a collection of user specified shapes.\n * \n * @class\n * @extends {ShapeSpec}\n * @param {number} sid - Unique identifier\n * @param {ShapeSpec} stylespec - shape style specification\n */\nexport class GLShape {\n\n    // Marching cube, to match with protein surface generation\n    private static ISDONE = 2;\n\n    private static finalizeGeo(geo) {\n        //to avoid creating a bunch of geometries, we leave geoGroup untruncated\n        //until render is called, at which point we truncate; \n        //successive called up updateGeo will return a new geometry\n        var geoGroup = geo.updateGeoGroup(0);\n        if (geoGroup.vertices > 0) {\n            geoGroup.truncateArrayBuffers(true, true);\n        }\n    };\n\n    /* \n     * \n     * @param {Geometry}\n     *            geo\n     * @param {Color | colorlike} color\n     */\n    static updateColor(geo: Geometry, color) {\n\n        color = color || CC.color(color);\n        geo.colorsNeedUpdate = true;\n\n        var r, g, b;\n        if (color.constructor !== Array) {\n            r = color.r;\n            g = color.g;\n            b = color.b;\n        }\n\n\n        for (let gg in geo.geometryGroups) {\n\n            let geoGroup = geo.geometryGroups[gg];\n            let colorArr = geoGroup.colorArray;\n\n            for (let i = 0, il = geoGroup.vertices; i < il; ++i) {\n\n                if (color.constructor === Array) {\n                    let c = color[i];\n                    r = c.r;\n                    g = c.g;\n                    b = c.b;\n                }\n\n                colorArr[i * 3] = r;\n                colorArr[i * 3 + 1] = g;\n                colorArr[i * 3 + 2] = b;\n            }\n        }\n    };\n\n\n    /*\n     * @param {GLShape}\n     *            shape\n     * @param {geometryGroup}\n     *            geoGroup\n     * @param {ArrowSpec}\n     *            spec\n     */\n    static drawArrow(shape: GLShape, geo: Geometry, spec: ArrowSpec) {\n\n        var from = spec.start, end = spec.end, radius = spec.radius,\n            radiusRatio = spec.radiusRatio, mid = spec.mid, midoffset = spec.midpos;\n\n        if (!(from && end))\n            return;\n\n        var geoGroup = geo.updateGeoGroup(51);\n\n        // vertices\n\n        var dir = new Vector3(end.x, end.y, end.z).sub(from);\n        if (midoffset) { //absolute offset, convert to relative\n            let length = dir.length();\n            if (midoffset > 0) mid = midoffset / length;\n            else mid = (length + midoffset) / length;\n        }\n\n        dir.multiplyScalar(mid);\n\n        var to = new Vector3(from.x, from.y, from.z).add(dir);\n        var negDir = dir.clone().negate();\n\n        let fromv = new Vector3(from.x, from.y, from.z);\n        shape.intersectionShape.cylinder.push(new Cylinder(fromv, to.clone(), radius));\n        shape.intersectionShape.sphere.push(new Sphere(fromv, radius));\n\n        // get orthonormal vector\n        var nvecs = [];\n        nvecs[0] = dir.clone();\n        if (Math.abs(nvecs[0].x) > 0.0001)\n            nvecs[0].y += 1;\n        else\n            nvecs[0].x += 1;\n        nvecs[0].cross(dir);\n        nvecs[0].normalize();\n\n        // another orth vector\n        nvecs[4] = nvecs[0].clone();\n        nvecs[4].crossVectors(nvecs[0], dir);\n        nvecs[4].normalize();\n        nvecs[8] = nvecs[0].clone().negate();\n        nvecs[12] = nvecs[4].clone().negate();\n\n        // now quarter positions\n        nvecs[2] = nvecs[0].clone().add(nvecs[4]).normalize();\n        nvecs[6] = nvecs[4].clone().add(nvecs[8]).normalize();\n        nvecs[10] = nvecs[8].clone().add(nvecs[12]).normalize();\n        nvecs[14] = nvecs[12].clone().add(nvecs[0]).normalize();\n\n        // eights\n        nvecs[1] = nvecs[0].clone().add(nvecs[2]).normalize();\n        nvecs[3] = nvecs[2].clone().add(nvecs[4]).normalize();\n        nvecs[5] = nvecs[4].clone().add(nvecs[6]).normalize();\n        nvecs[7] = nvecs[6].clone().add(nvecs[8]).normalize();\n        nvecs[9] = nvecs[8].clone().add(nvecs[10]).normalize();\n        nvecs[11] = nvecs[10].clone().add(nvecs[12]).normalize();\n        nvecs[13] = nvecs[12].clone().add(nvecs[14]).normalize();\n        nvecs[15] = nvecs[14].clone().add(nvecs[0]).normalize();\n\n        var start = geoGroup.vertices;\n        var vertexArray = geoGroup.vertexArray;\n        var faceArray = geoGroup.faceArray;\n        var normalArray = geoGroup.normalArray;\n        var lineArray = geoGroup.lineArray;\n\n        var offset, i, n;\n        // add vertices, opposing vertices paired together\n        for (i = 0, n = nvecs.length; i < n; ++i) {\n            offset = 3 * (start + 3 * i);\n            var bottom = nvecs[i].clone().multiplyScalar(radius).add(from);\n            var top = nvecs[i].clone().multiplyScalar(radius).add(to);\n            var conebase = nvecs[i].clone()\n                .multiplyScalar(radius * radiusRatio).add(to);\n\n            vertexArray[offset] = bottom.x;\n            vertexArray[offset + 1] = bottom.y;\n            vertexArray[offset + 2] = bottom.z;\n\n            vertexArray[offset + 3] = top.x;\n            vertexArray[offset + 4] = top.y;\n            vertexArray[offset + 5] = top.z;\n\n            vertexArray[offset + 6] = conebase.x;\n            vertexArray[offset + 7] = conebase.y;\n            vertexArray[offset + 8] = conebase.z;\n\n            if (i > 0) {\n                var prev_x = vertexArray[offset - 3];\n                var prev_y = vertexArray[offset - 2];\n                var prev_z = vertexArray[offset - 1];\n\n                var c = new Vector3(prev_x, prev_y, prev_z);\n                var b = new Vector3(end.x, end.y, end.z), b2 = to.clone();\n                var a = new Vector3(conebase.x, conebase.y, conebase.z);\n\n                shape.intersectionShape.triangle.push(new Triangle(a, b, c));\n                shape.intersectionShape.triangle.push(new Triangle(c.clone(), b2, a.clone()));\n            }\n        }\n\n        geoGroup.vertices += 48;\n        offset = geoGroup.vertices * 3;\n\n        // caps\n        vertexArray[offset] = from.x;\n        vertexArray[offset + 1] = from.y;\n        vertexArray[offset + 2] = from.z;\n\n        vertexArray[offset + 3] = to.x;\n        vertexArray[offset + 4] = to.y;\n        vertexArray[offset + 5] = to.z;\n\n        vertexArray[offset + 6] = end.x;\n        vertexArray[offset + 7] = end.y;\n        vertexArray[offset + 8] = end.z;\n\n        geoGroup.vertices += 3;\n\n        // now faces\n        var face, faceoffset, lineoffset;\n        var t1, t2, t2b, t3, t3b, t4, t1offset, t2offset, t2boffset, t3offset, t3boffset, t4offset;\n        var n1, n2, n3, n4;\n        var fromi = geoGroup.vertices - 3, toi = geoGroup.vertices - 2, endi = geoGroup.vertices - 1;\n        var fromoffset = fromi * 3, tooffset = toi * 3, endoffset = endi * 3;\n        for (i = 0, n = nvecs.length - 1; i < n; ++i) {\n\n            var ti = start + 3 * i;\n            offset = ti * 3;\n            faceoffset = geoGroup.faceidx;\n            lineoffset = geoGroup.lineidx;\n\n            t1 = ti;\n            t1offset = t1 * 3;\n            t2 = ti + 1;\n            t2offset = t2 * 3;\n            t2b = ti + 2;\n            t2boffset = t2b * 3;\n            t3 = ti + 4;\n            t3offset = t3 * 3;\n            t3b = ti + 5;\n            t3boffset = t3b * 3;\n            t4 = ti + 3;\n            t4offset = t4 * 3;\n\n            // face = [t1, t2, t4], [t2, t3, t4];\n            // face = [t1, t2, t3, t4];\n\n            //   norm = [nvecs[i], nvecs[i], nvecs[i + 1], nvecs[i + 1]];\n\n            n1 = n2 = nvecs[i];\n            n3 = n4 = nvecs[i + 1];\n\n            normalArray[t1offset] = n1.x;\n            normalArray[t2offset] = n2.x;\n            normalArray[t4offset] = n4.x;\n            normalArray[t1offset + 1] = n1.y;\n            normalArray[t2offset + 1] = n2.y;\n            normalArray[t4offset + 1] = n4.y;\n            normalArray[t1offset + 2] = n1.z;\n            normalArray[t2offset + 2] = n2.z;\n            normalArray[t4offset + 2] = n4.z;\n\n            normalArray[t2offset] = n2.x;\n            normalArray[t3offset] = n3.x;\n            normalArray[t4offset] = n4.x;\n            normalArray[t2offset + 1] = n2.y;\n            normalArray[t3offset + 1] = n3.y;\n            normalArray[t4offset + 1] = n4.y;\n            normalArray[t2offset + 2] = n2.z;\n            normalArray[t3offset + 2] = n3.z;\n            normalArray[t4offset + 2] = n4.z;\n\n            normalArray[t2boffset] = n2.x;\n            normalArray[t3boffset] = n3.x;\n            normalArray[t2boffset + 1] = n2.y;\n            normalArray[t3boffset + 1] = n3.y;\n            normalArray[t2boffset + 2] = n2.z;\n            normalArray[t3boffset + 2] = n3.z;\n\n            // sides\n            faceArray[faceoffset] = t1;\n            faceArray[faceoffset + 1] = t2;\n            faceArray[faceoffset + 2] = t4;\n            faceArray[faceoffset + 3] = t2;\n            faceArray[faceoffset + 4] = t3;\n            faceArray[faceoffset + 5] = t4;\n            // caps\n            faceArray[faceoffset + 6] = t1;\n            faceArray[faceoffset + 7] = t4;\n            faceArray[faceoffset + 8] = fromi;\n            faceArray[faceoffset + 9] = t2b;\n            faceArray[faceoffset + 10] = toi;\n            faceArray[faceoffset + 11] = t3b;\n            // arrowhead\n            faceArray[faceoffset + 12] = t2b;\n            faceArray[faceoffset + 13] = endi;\n            faceArray[faceoffset + 14] = t3b;\n\n            // sides\n            lineArray[lineoffset] = t1;\n            lineArray[lineoffset + 1] = t2;\n            lineArray[lineoffset + 2] = t1;\n            lineArray[lineoffset + 3] = t4;\n            // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;\n            lineArray[lineoffset + 4] = t3;\n            lineArray[lineoffset + 5] = t4;\n            // caps\n            lineArray[lineoffset + 6] = t1;\n            lineArray[lineoffset + 7] = t4;\n            // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;\n            // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;\n\n            lineArray[lineoffset + 8] = t2b;\n            lineArray[lineoffset + 9] = t2; // toi\n            lineArray[lineoffset + 10] = t2b;\n            lineArray[lineoffset + 11] = t3b;\n            lineArray[lineoffset + 12] = t3;\n            lineArray[lineoffset + 13] = t3b; // toi\n            // arrowhead\n            lineArray[lineoffset + 14] = t2b;\n            lineArray[lineoffset + 15] = endi;\n            lineArray[lineoffset + 16] = t2b;\n            lineArray[lineoffset + 17] = t3b;\n            lineArray[lineoffset + 18] = endi;\n            lineArray[lineoffset + 19] = t3b;\n\n            geoGroup.faceidx += 15;\n            geoGroup.lineidx += 20;\n\n        }\n        // final face\n\n        face = [start + 45, start + 46, start + 1, start, start + 47,\n        start + 2];\n        //norm = [nvecs[15], nvecs[15], nvecs[0], nvecs[0]];\n\n        faceoffset = geoGroup.faceidx;\n        lineoffset = geoGroup.lineidx;\n\n        t1 = face[0];\n        t1offset = t1 * 3;\n        t2 = face[1];\n        t2offset = t2 * 3;\n        t2b = face[4];\n        t2boffset = t2b * 3;\n        t3 = face[2];\n        t3offset = t3 * 3;\n        t3b = face[5];\n        t3boffset = t3b * 3;\n        t4 = face[3];\n        t4offset = t4 * 3;\n\n        n1 = n2 = nvecs[15];\n        n3 = n4 = nvecs[0];\n\n        normalArray[t1offset] = n1.x;\n        normalArray[t2offset] = n2.x;\n        normalArray[t4offset] = n4.x;\n        normalArray[t1offset + 1] = n1.y;\n        normalArray[t2offset + 1] = n2.y;\n        normalArray[t4offset + 1] = n4.y;\n        normalArray[t1offset + 2] = n1.z;\n        normalArray[t2offset + 2] = n2.z;\n        normalArray[t4offset + 2] = n4.z;\n\n        normalArray[t2offset] = n2.x;\n        normalArray[t3offset] = n3.x;\n        normalArray[t4offset] = n4.x;\n        normalArray[t2offset + 1] = n2.y;\n        normalArray[t3offset + 1] = n3.y;\n        normalArray[t4offset + 1] = n4.y;\n        normalArray[t2offset + 2] = n2.z;\n        normalArray[t3offset + 2] = n3.z;\n        normalArray[t4offset + 2] = n4.z;\n\n        normalArray[t2boffset] = n2.x;\n        normalArray[t3boffset] = n3.x;\n        normalArray[t2boffset + 1] = n2.y;\n        normalArray[t3boffset + 1] = n3.y;\n        normalArray[t2boffset + 2] = n2.z;\n        normalArray[t3boffset + 2] = n3.z;\n\n        // Cap normals\n        dir.normalize();\n        negDir.normalize();\n        normalArray[fromoffset] = negDir.x;\n        normalArray[tooffset] = normalArray[endoffset] = dir.x;\n        normalArray[fromoffset + 1] = negDir.y;\n        normalArray[tooffset + 1] = normalArray[endoffset + 1] = dir.y;\n        normalArray[fromoffset + 2] = negDir.z;\n        normalArray[tooffset + 2] = normalArray[endoffset + 2] = dir.z;\n\n        // Final side\n        faceArray[faceoffset] = t1;\n        faceArray[faceoffset + 1] = t2;\n        faceArray[faceoffset + 2] = t4;\n        faceArray[faceoffset + 3] = t2;\n        faceArray[faceoffset + 4] = t3;\n        faceArray[faceoffset + 5] = t4;\n        // final caps\n        faceArray[faceoffset + 6] = t1;\n        faceArray[faceoffset + 7] = t4;\n        faceArray[faceoffset + 8] = fromi;\n        faceArray[faceoffset + 9] = t2b;\n        faceArray[faceoffset + 10] = toi;\n        faceArray[faceoffset + 11] = t3b;\n        // final arrowhead\n        faceArray[faceoffset + 12] = t2b;\n        faceArray[faceoffset + 13] = endi;\n        faceArray[faceoffset + 14] = t3b;\n\n        // sides\n        lineArray[lineoffset] = t1;\n        lineArray[lineoffset + 1] = t2;\n        lineArray[lineoffset + 2] = t1;\n        lineArray[lineoffset + 3] = t4;\n        // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;\n        lineArray[lineoffset + 4] = t3;\n        lineArray[lineoffset + 5] = t4;\n        // caps\n        lineArray[lineoffset + 6] = t1;\n        lineArray[lineoffset + 7] = t4;\n        // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;\n        // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;\n\n        lineArray[lineoffset + 8] = t2b;\n        lineArray[lineoffset + 9] = t2; // toi\n        lineArray[lineoffset + 10] = t2b;\n        lineArray[lineoffset + 11] = t3b;\n        lineArray[lineoffset + 12] = t3;\n        lineArray[lineoffset + 13] = t3b; // toi\n        // arrowhead\n        lineArray[lineoffset + 14] = t2b;\n        lineArray[lineoffset + 15] = endi;\n        lineArray[lineoffset + 16] = t2b;\n        lineArray[lineoffset + 17] = t3b;\n        lineArray[lineoffset + 18] = endi;\n        lineArray[lineoffset + 19] = t3b;\n\n        geoGroup.faceidx += 15;\n        geoGroup.lineidx += 20;\n\n    };\n\n    // Update a bounding sphere's position and radius\n    // from list of centroids and new points\n    /*\n     * @param {Sphere}\n     *            sphere\n     * @param {Object}\n     *            components, centroid of all objects in shape\n     * @param {Array}\n     *            points, flat array of all points in shape\n     * @param {int} numPoints, number of valid poitns in points\n     */\n    static updateBoundingFromPoints(sphere: Sphere, components, points, numPoints: number) {\n\n        sphere.center.set(0, 0, 0);\n\n        //previously I weighted each component's center equally, but I think\n        //it is better to use all points\n        let xmin = Infinity, ymin = Infinity, zmin = Infinity;\n        let xmax = -Infinity, ymax = -Infinity, zmax = -Infinity;\n        if (sphere.box) {\n            xmin = sphere.box.min.x;\n            xmax = sphere.box.max.x;\n            ymin = sphere.box.min.y;\n            ymax = sphere.box.max.y;\n            zmin = sphere.box.min.z;\n            zmax = sphere.box.max.z;\n        }\n\n        for (let i = 0, il = numPoints; i < il; i++) {\n            var x = points[i * 3], y = points[i * 3 + 1], z = points[i * 3 + 2];\n            if (x < xmin) xmin = x;\n            if (y < ymin) ymin = y;\n            if (z < zmin) zmin = z;\n            if (x > xmax) xmax = x;\n            if (y > ymax) ymax = y;\n            if (z > zmax) zmax = z;\n        }\n\n        sphere.center.set((xmax + xmin) / 2, (ymax + ymin) / 2, (zmax + zmin) / 2);\n        sphere.radius = sphere.center.distanceTo({ x: xmax, y: ymax, z: zmax });\n        sphere.box = { min: { x: xmin, y: ymin, z: zmin }, max: { x: xmax, y: ymax, z: zmax } };\n    };\n\n    //helper function for adding an appropriately sized mesh\n    private static addCustomGeo(shape: GLShape, geo: Geometry, mesh, color, clickable) {\n        var geoGroup = geo.addGeoGroup();\n        var vertexArr = mesh.vertexArr, normalArr = mesh.normalArr,\n            faceArr = mesh.faceArr;\n\n        geoGroup.vertices = vertexArr.length;\n        geoGroup.faceidx = faceArr.length;\n\n        var offset, v, a, b, c, i, il, r, g;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n\n        if (color.constructor !== Array) {\n            r = color.r;\n            g = color.g;\n            b = color.b;\n        }\n        for (i = 0, il = geoGroup.vertices; i < il; ++i) {\n            offset = i * 3;\n            v = vertexArr[i];\n            vertexArray[offset] = v.x;\n            vertexArray[offset + 1] = v.y;\n            vertexArray[offset + 2] = v.z;\n\n            if (color.constructor === Array) {\n                c = color[i];\n                r = c.r;\n                g = c.g;\n                b = c.b;\n            }\n\n            colorArray[offset] = r;\n            colorArray[offset + 1] = g;\n            colorArray[offset + 2] = b;\n        }\n\n        if (clickable) {\n            for (i = 0, il = geoGroup.faceidx / 3; i < il; ++i) {\n                offset = i * 3;\n                a = faceArr[offset];\n                b = faceArr[offset + 1];\n                c = faceArr[offset + 2];\n                var vA = new Vector3(), vB = new Vector3(), vC = new Vector3();\n                shape.intersectionShape.triangle.push(new Triangle(vA.copy(vertexArr[a]),\n                    vB.copy(vertexArr[b]), vC.copy(vertexArr[c])));\n            }\n        }\n\n        if (clickable) {\n\n            var center = new Vector3(0, 0, 0);\n            var cnt = 0;\n            for (let g = 0; g < geo.geometryGroups.length; g++) {\n                center.add(geo.geometryGroups[g].getCentroid());\n                cnt++;\n            }\n            center.divideScalar(cnt);\n\n\n            GLShape.updateBoundingFromPoints(shape.boundingSphere, { centroid: center }, vertexArray, geoGroup.vertices);\n        }\n\n        geoGroup.faceArray = new Uint16Array(faceArr);\n\n        geoGroup.truncateArrayBuffers(true, true);\n\n        if (normalArr.length < geoGroup.vertices)\n            geoGroup.setNormals();\n        else {\n\n            var normalArray = geoGroup.normalArray = new Float32Array(geoGroup.vertices * 3);\n            var n;\n            for (i = 0, il = geoGroup.vertices; i < il; ++i) {\n                offset = i * 3;\n                n = normalArr[i];\n                normalArray[offset] = n.x;\n                normalArray[offset + 1] = n.y;\n                normalArray[offset + 2] = n.z;\n            }\n        }\n\n        geoGroup.setLineIndices();\n        geoGroup.lineidx = geoGroup.lineArray.length;\n    };\n\n\n\n    // handles custom shape generation from user supplied arrays\n    // May need to generate normal and/or line indices\n    /*\n     * @param {$3Dmol.GLShape}\n     *            shape\n     * @param {geometry}\n     *            geo\n     * @param {CustomShapeSpec}\n     *            customSpec\n     */\n    static drawCustom = function (shape: GLShape, geo: Geometry, customSpec: CustomShapeSpec) {\n        var mesh = customSpec;\n        var vertexArr = mesh.vertexArr;\n        var faceArr = mesh.faceArr;\n        if (vertexArr.length === 0 || faceArr.length === 0) {\n            console\n                .warn(\"Error adding custom shape component: No vertices and/or face indices supplied!\");\n        }\n\n        var color = customSpec.color;\n        if (typeof (color) == 'undefined') {\n            color = shape.color;\n        }\n        color = CC.color(color);\n\n        //var firstgeo = geo.geometryGroups.length;\n        var splits = splitMesh(mesh);\n        for (var i = 0, n = splits.length; i < n; i++) {\n            GLShape.addCustomGeo(shape, geo, splits[i], splits[i].colorArr ? splits[i].colorArr : color, customSpec.clickable);\n        }\n    };\n\n\n    /*\n     * \n     * @param {$3Dmol.GLShape}\n     *            shape\n     * @param {ShapeSpec}\n     *            stylespec\n     * @returns {undefined}\n     */\n    static updateFromStyle(shape: GLShape, stylespec: ShapeSpec) {\n        if (typeof (stylespec.color) != 'undefined') {\n            shape.color = stylespec.color || new Color();\n            if (!(stylespec.color instanceof Color))\n                shape.color = CC.color(stylespec.color);\n        } else {\n            shape.color = CC.color(0);\n        }\n        shape.wireframe = stylespec.wireframe ? true : false;\n        //opacity is the preferred nomenclature, support alpha for backwards compat\n        shape.opacity = stylespec.alpha ? clamp(stylespec.alpha, 0.0,\n            1.0) : 1.0;\n        if (typeof (stylespec.opacity) != 'undefined') {\n            shape.opacity = clamp(stylespec.opacity, 0.0, 1.0);\n        }\n        shape.side = (stylespec.side !== undefined) ? stylespec.side : DoubleSide;\n        shape.linewidth = typeof (stylespec.linewidth) == 'undefined' ? 1 : stylespec.linewidth;\n        // Click handling\n        shape.clickable = stylespec.clickable ? true : false;\n        shape.callback = makeFunction(stylespec.callback);\n        shape.hoverable = stylespec.hoverable ? true : false;\n        shape.hover_callback = makeFunction(stylespec.hover_callback);\n        shape.unhover_callback = makeFunction(stylespec.unhover_callback);\n        shape.contextMenuEnabled = !!stylespec.contextMenuEnabled;\n\n        shape.hidden = stylespec.hidden;\n        shape.frame = stylespec.frame;\n    };\n\n    boundingSphere: Sphere;\n    intersectionShape: any;\n    color: any = 0xffffff;\n    hidden = false;\n    wireframe = false;\n    opacity = 1;\n    linewidth = 1;\n    clickable = false;\n    callback: Func;\n    hoverable = false;\n    hover_callback: Func;\n    unhover_callback: Func;\n    contextMenuEnabled: boolean = false;\n    frame: any;\n    side = DoubleSide;\n    shapePosition: any;\n\n    private geo: Geometry;\n    private linegeo: Geometry;\n    private stylespec: any;\n    private components: any;\n    private shapeObj: any;\n    private renderedShapeObj: any;\n    /**\n     * Custom renderable shape\n     * \n     * @constructor \n     * \n     * @param {ShapeSpec} stylespec\n     */\n    constructor(stylespec: ShapeSpec) {\n\n        this.stylespec = stylespec || {};\n\n        this.boundingSphere = new Sphere();\n        /** @type {IntersectionShapes} */\n        this.intersectionShape = {\n            sphere: [],\n            cylinder: [],\n            line: [],\n            triangle: []\n        };\n\n        GLShape.updateFromStyle(this, this.stylespec);\n\n        // Keep track of shape components and their centroids\n        this.components = [];\n        this.shapeObj = null;\n        this.renderedShapeObj = null;\n\n        this.geo = new Geometry(true);\n        this.linegeo = new Geometry(true);\n    };\n\n    /** Update shape with new style specification\n     * @param {ShapeSpec} newspec\n       @example \n        let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n        sphere.updateStyle({color:'yellow',opacity:0.5});\n        viewer.render();\n     */\n    updateStyle(newspec: ShapeSpec) {\n\n        for (var prop in newspec) {\n            this.stylespec[prop] = newspec[prop];\n        }\n\n        GLShape.updateFromStyle(this, this.stylespec);\n\n        if (newspec.voldata && newspec.volscheme) {\n            adjustVolumeStyle(newspec);\n\n            //convert volumetric data into colors\n            const scheme = newspec.volscheme;\n            const voldata = newspec.voldata;\n            const cc = CC;\n            const range = scheme.range() || [-1, 1];\n            this.geo.setColors(function (x, y, z) {\n                let val = voldata.getVal(x, y, z);\n                let col = cc.color(scheme.valueToHex(val, range));\n                return col;\n            });\n            delete this.color;\n        }\n    };\n\n    /**\n     * Creates a custom shape from supplied vertex and face arrays\n     * @param {CustomShapeSpec} customSpec     \n     */\n    public addCustom(customSpec: CustomShapeSpec) {\n\n        customSpec.vertexArr = customSpec.vertexArr || [];\n        customSpec.faceArr = customSpec.faceArr || [];\n        customSpec.normalArr = customSpec.normalArr || [];\n\n        // will split mesh as needed\n        GLShape.drawCustom(this, this.geo, customSpec);\n    };\n\n    /**\n     * Creates a sphere shape\n     * @param {SphereSpec} sphereSpec\n     @example \n     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n     \n     viewer.render();\n     */\n    public addSphere(sphereSpec: SphereSpec) {\n\n        if (!sphereSpec.center) {\n            sphereSpec.center = new Vector3(0, 0, 0);\n        }\n\n        sphereSpec.radius = sphereSpec.radius ? clamp(sphereSpec.radius, 0, Infinity) : 1.5;\n        sphereSpec.color = CC.color(sphereSpec.color);\n\n        this.intersectionShape.sphere.push(new Sphere(sphereSpec.center, sphereSpec.radius));\n \n         GLDraw.drawSphere(this.geo, sphereSpec.center,\n           sphereSpec.radius, sphereSpec.color as Colored, sphereSpec.quality);\n\n        this.components.push({\n            centroid: new Vector3(sphereSpec.center.x,\n                sphereSpec.center.y, sphereSpec.center.z)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components,\n            geoGroup.vertexArray, geoGroup.vertices);\n    };\n\n\n    /**\n     * Creates a box\n     * @param {BoxSpec} boxSpec\n     @example \n     var shape = viewer.addShape({color:'red'});\n     shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});\n     shape.addBox({corner: {x:-5,y:-3,z:0},\n                   dimensions: { w: {x:1,y:1,z:0},\n                                 h: {x:-1,y:1,z:0},\n                                 d: {x:0,y:0,z:1} }});\n     viewer.zoomTo();\n     viewer.rotate(30);\n     viewer.render();\n     */\n    public addBox(boxSpec: BoxSpec) {\n\n        var dim = boxSpec.dimensions || { w: 1, h: 1, d: 1 };\n\n        //dimensions may be scalar or vector quantities\n        var w: XYZ;\n        if (typeof (dim.w) == \"number\") {\n            w = { x: dim.w, y: 0, z: 0 };\n        } else {\n            w = dim.w;\n        }\n        var h: XYZ;\n        if (typeof (dim.h) == \"number\") {\n            h = { x: 0, y: dim.h, z: 0 };\n        } else {\n            h = dim.h;\n        }\n        var d: XYZ;\n        if (typeof (dim.d) == \"number\") {\n            d = { x: 0, y: 0, z: dim.d };\n        } else {\n            d = dim.d;\n        }\n\n        //can position using corner OR center\n        var c = boxSpec.corner;\n        if (c == undefined) {\n            if (boxSpec.center !== undefined) {\n\n                c = {\n                    x: boxSpec.center.x - 0.5 * (w.x + h.x + d.x),\n                    y: boxSpec.center.y - 0.5 * (w.y + h.y + d.y),\n                    z: boxSpec.center.z - 0.5 * (w.z + h.z + d.z)\n                };\n            } else { // default to origin\n                c = { x: 0, y: 0, z: 0 };\n            }\n        }\n\n        //8 vertices\n        var uv =\n            [{ x: c.x, y: c.y, z: c.z },\n            { x: c.x + w.x, y: c.y + w.y, z: c.z + w.z },\n            { x: c.x + h.x, y: c.y + h.y, z: c.z + h.z },\n            { x: c.x + w.x + h.x, y: c.y + w.y + h.y, z: c.z + w.z + h.z },\n            { x: c.x + d.x, y: c.y + d.y, z: c.z + d.z },\n            { x: c.x + w.x + d.x, y: c.y + w.y + d.y, z: c.z + w.z + d.z },\n            { x: c.x + h.x + d.x, y: c.y + h.y + d.y, z: c.z + h.z + d.z },\n            { x: c.x + w.x + h.x + d.x, y: c.y + w.y + h.y + d.y, z: c.z + w.z + h.z + d.z }];\n\n        //but.. so that we can have sharp issues, we want a unique normal\n        //for each face - since normals are associated with vertices, need to duplicate \n\n        //bottom\n        // 0 1\n        // 2 3\n        //top\n        // 4 5\n        // 6 7\n        var verts = [];\n        var faces = [];\n        //bottom\n        verts.splice(verts.length, 0, uv[0], uv[1], uv[2], uv[3]);\n        faces.splice(faces.length, 0, 0, 2, 1, 1, 2, 3);\n        var foff = 4;\n        //front\n        verts.splice(verts.length, 0, uv[2], uv[3], uv[6], uv[7]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //back\n        verts.splice(verts.length, 0, uv[4], uv[5], uv[0], uv[1]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //top\n        verts.splice(verts.length, 0, uv[6], uv[7], uv[4], uv[5]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //right\n        verts.splice(verts.length, 0, uv[3], uv[1], uv[7], uv[5]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //left\n        verts.splice(verts.length, 0, uv[2], uv[6], uv[0], uv[4]); // fix: was 2 0 6 4 , was flipped! will this ruin anything?\n        // and is this the reason for having double sided lambert shading? the box had a flipped face\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n\n        var spec = extend({}, boxSpec);\n        spec.vertexArr = verts;\n        spec.faceArr = faces;\n        spec.normalArr = [];\n        GLShape.drawCustom(this, this.geo, spec);\n\n        var centroid = new Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(uv[0], uv[7]).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    };\n\n    /**\n     * Creates a cylinder shape\n     * @param {CylinderSpec} cylinderSpec\n     @example\n          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},\n                              end:{x:10.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              fromCap:1,\n                              toCap:2,\n                              color:'red',\n                              hoverable:true,\n                              clickable:true,\n                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},\n                              hover_callback: function(){ viewer.render( );},\n                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}\n                             });\n          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},\n                              end:{x:0.0,y:10.0,z:0.0},\n                              radius:0.5,\n                              fromCap:false,\n                              toCap:true,\n                              color:'teal'});\n          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},\n                              end:{x:20.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              color:'black',\n                              fromCap:false,\n                              toCap:false});\n          viewer.render();\n     */\n    public addCylinder(cylinderSpec: CylinderSpec) {\n\n        var start: Vector3;\n        var end: Vector3;\n        if (!cylinderSpec.start) {\n            start = new Vector3(0, 0, 0);\n        } else {\n            start = new Vector3(cylinderSpec.start.x || 0,\n                cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        }\n\n        if (!cylinderSpec.end) {\n            end = new Vector3(0, 0, 0);\n        } else {\n            end = new Vector3(cylinderSpec.end.x,\n                cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined') end.x = 3; //show something even if undefined\n        }\n        var radius = cylinderSpec.radius || 0.1;\n        var color = CC.color(cylinderSpec.color);\n\n        this.intersectionShape.cylinder.push(new Cylinder(start, end, radius));\n\n        GLDraw.drawCylinder(this.geo, start, end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);\n\n        var centroid = new Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components,\n            geoGroup.vertexArray, geoGroup.vertices);\n\n    };\n\n    /**\n     * Creates a dashed cylinder shape\n     * @param {CylinderSpec} cylinderSpec\n     */\n    public addDashedCylinder(cylinderSpec: CylinderSpec) {\n  \n        cylinderSpec.dashLength = cylinderSpec.dashLength || 0.25;\n        cylinderSpec.gapLength = cylinderSpec.gapLength || 0.25;\n\n        var start: Vector3;\n        if (!cylinderSpec.start) start = new Vector3(0, 0, 0);\n        else {\n            start = new Vector3(cylinderSpec.start.x || 0,\n                cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        }\n\n        var end: Vector3;\n        if (!cylinderSpec.end) end = new Vector3(3, 0, 0);\n        else {\n            end = new Vector3(cylinderSpec.end.x,\n                cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined') end.x = 3; //show something even if undefined\n        }\n\n        var radius = cylinderSpec.radius || 0.1;\n        var color = CC.color(cylinderSpec.color);\n\n        var cylinderLength = Math.sqrt(Math.pow((start.x - end.x), 2) + Math.pow((start.y - end.y), 2) + Math.pow((start.z - end.z), 2));\n\n        var count = cylinderLength / (cylinderSpec.gapLength + cylinderSpec.dashLength);\n\n        var new_start = new Vector3(cylinderSpec.start.x || 0,\n            cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        var new_end = new Vector3(cylinderSpec.end.x,\n            cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n\n        var gapVector = new Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.gapLength), (end.y - start.y) / (cylinderLength / cylinderSpec.gapLength), (end.z - start.z) / (cylinderLength / cylinderSpec.gapLength));\n        var dashVector = new Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.dashLength), (end.y - start.y) / (cylinderLength / cylinderSpec.dashLength), (end.z - start.z) / (cylinderLength / cylinderSpec.dashLength));\n\n        for (var place = 0; place < count; place++) {\n            new_end = new Vector3(new_start.x + dashVector.x, new_start.y + dashVector.y, new_start.z + dashVector.z);\n\n            this.intersectionShape.cylinder.push(new Cylinder(new_start, new_end, radius));\n\n            GLDraw.drawCylinder(this.geo, new_start, new_end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);\n\n            new_start = new Vector3(new_end.x + gapVector.x, new_end.y + gapVector.y, new_end.z + gapVector.z);\n\n        }\n        var centroid = new Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components,\n            geoGroup.vertexArray, geoGroup.vertices);\n    };\n\n    /**\n     * Creates a curved shape\n     * @param {CurveSpec} curveSpec\n     */\n    public addCurve(curveSpec: CurveSpec) {\n\n        curveSpec.points = curveSpec.points || [];\n        curveSpec.smooth = curveSpec.smooth || 10;\n        if (typeof (curveSpec.fromCap) == \"undefined\") curveSpec.fromCap = 2;\n        if (typeof (curveSpec.toCap) == \"undefined\") curveSpec.toCap = 2;\n\n        //subdivide into smoothed spline points\n        var points = subdivide_spline(curveSpec.points, curveSpec.smooth);\n\n        if (points.length < 3) {\n            console.log(\"Too few points in addCurve\");\n            return;\n        }\n\n        var radius = curveSpec.radius || 0.1;\n        var color = CC.color(curveSpec.color);\n        //TODO TODO - this is very inefficient, should create our\n        //own water tight model with proper normals...\n\n\n        //if arrows are requested, peel off enough points to fit\n        //at least 2*r of arrowness\n        var start = 0;\n        var end = points.length - 1;\n        var segmentlen = points[0].distanceTo(points[1]);\n        var npts = Math.ceil(2 * radius / segmentlen);\n        if (curveSpec.toArrow) {\n            end -= npts;\n            let arrowspec = {\n                start: points[end],\n                end: points[points.length - 1],\n                radius: radius,\n                color: color as ColorSpec,\n                mid: 0.0001\n            };\n            this.addArrow(arrowspec);\n        }\n        if (curveSpec.fromArrow) {\n            start += npts;\n            let arrowspec = {\n                start: points[start],\n                end: points[0],\n                radius: radius,\n                color: color as ColorSpec,\n                mid: 0.0001\n            };\n            this.addArrow(arrowspec);\n        }\n\n        var midway = Math.ceil(points.length / 2);\n        var middleSpec: any = { radius: radius, color: color, fromCap: 2, toCap: 2 };\n        for (var i = start; i < end; i++) {\n            middleSpec.start = points[i];\n            middleSpec.end = points[i + 1];\n            middleSpec.fromCap = 2;\n            middleSpec.toCap = 2;\n            if (i < midway) {\n                middleSpec.fromCap = 2;\n                middleSpec.toCap = 0;\n            } else if (i > midway) {\n                middleSpec.fromCap = 0;\n                middleSpec.toCap = 2;\n            } else {\n                middleSpec.fromCap = 2;\n                middleSpec.toCap = 2;\n            }\n\n            this.addCylinder(middleSpec);\n        }\n\n    };\n\n    /**\n     * Creates a line shape\n     * @param {LineSpec} lineSpec\n     @example\n     $3Dmol.download(\"pdb:2ABJ\",viewer,{},function(){\n              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});\n              viewer.render(callback);\n          });\n    \n     */\n    public addLine(lineSpec: LineSpec) {\n\n        var start: Vector3;\n        var end: Vector3;\n        if (!lineSpec.start) {\n            start = new Vector3(0, 0, 0);\n        } else {\n            start = new Vector3(lineSpec.start.x || 0,\n                lineSpec.start.y || 0, lineSpec.start.z || 0);\n        }\n        if (!lineSpec.end) {\n            end = new Vector3(3, 0, 0);\n        } else {\n            end = new Vector3(lineSpec.end.x,\n                lineSpec.end.y || 0, lineSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined') end.x = 3; //show something even if undefined\n        }\n\n        var geoGroup = this.geo.updateGeoGroup(2);\n\n        //make line from start to end\n        //for consistency with rest of shapes, uses vertices and lines rather\n        //than a separate line geometry\n        var vstart = geoGroup.vertices;\n        var i = vstart * 3;\n        var vertexArray = geoGroup.vertexArray;\n        vertexArray[i] = start.x;\n        vertexArray[i + 1] = start.y;\n        vertexArray[i + 2] = start.z;\n        vertexArray[i + 3] = end.x;\n        vertexArray[i + 4] = end.y;\n        vertexArray[i + 5] = end.z;\n        geoGroup.vertices += 2;\n\n        var lineArray = geoGroup.lineArray;\n        var li = geoGroup.lineidx;\n        lineArray[li] = vstart;\n        lineArray[li + 1] = vstart + 1;\n        geoGroup.lineidx += 2;\n\n        var centroid = new Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components,\n            geoGroup.vertexArray, geoGroup.vertices);\n    };\n\n\n    /**\n     * Creates an arrow shape\n     * @param {ArrowSpec} arrowSpec\n     @example\n      $3Dmol.download(\"pdb:4DM7\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n              viewer.addArrow({\n                  start: {x:-10.0, y:0.0, z:0.0},\n                  end: {x:0.0, y:-10.0, z:0.0},\n                  radius: 1.0,\n                  radiusRadio:1.0,\n                  mid:1.0,\n                  clickable:true,\n                  callback:function(){\n                      this.color.setHex(0xFF0000FF);\n                      viewer.render( );\n                  }\n              });\n              viewer.render();\n            });\n     */\n    public addArrow(arrowSpec: ArrowSpec) {\n\n        if (!arrowSpec.start) {\n            arrowSpec.start = new Vector3(0, 0, 0);\n        } else {\n            arrowSpec.start = new Vector3(arrowSpec.start.x || 0,\n                arrowSpec.start.y || 0, arrowSpec.start.z || 0);\n        }\n\n        if (arrowSpec.dir instanceof Vector3 && typeof (arrowSpec.length) === 'number') {\n            var end = arrowSpec.dir.clone().multiplyScalar(arrowSpec.length).add(\n                arrowSpec.start);\n            arrowSpec.end = end;\n        }\n        else if (!arrowSpec.end) {\n            arrowSpec.end = new Vector3(3, 0, 0);\n        } else {\n            arrowSpec.end = new Vector3(arrowSpec.end.x,\n                arrowSpec.end.y || 0, arrowSpec.end.z || 0);\n            if (typeof (arrowSpec.end.x) == 'undefined') arrowSpec.end.x = 3; //show something even if undefined\n        }\n\n        arrowSpec.radius = arrowSpec.radius || 0.1;\n\n        arrowSpec.radiusRatio = arrowSpec.radiusRatio || 1.618034;\n\n        arrowSpec.mid = (0 < arrowSpec.mid && arrowSpec.mid < 1) ? arrowSpec.mid\n            : 0.618034;\n\n        GLShape.drawArrow(this, this.geo, arrowSpec);\n\n        var centroid = new Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(arrowSpec.start, arrowSpec.end)\n                .multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components,\n            geoGroup.vertexArray, geoGroup.vertices);\n    };\n\n\n    static distance_from(c1: XYZ, c2: XYZ) {\n        return Math.sqrt(Math.pow((c1.x - c2.x), 2) + Math.pow((c1.y - c2.y), 2) + Math.pow((c1.z - c2.z), 2));\n    };\n\n    static inSelectedRegion(coordinate: XYZ, selectedRegion, radius: number) {\n\n        for (var i = 0; i < selectedRegion.length; i++) {\n            if (GLShape.distance_from(selectedRegion[i], coordinate) <= radius)\n                return true;\n        }\n        return false;\n    };\n\n    /**\n     * Create isosurface from volumetric data.\n     * @param {VolumeData} data - volumetric input data\n     * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification\n     * @example //the user can specify a selected region for the isosurface \n     $.get('../test_structs/benzene-homo.cube', function(data){\n              var voldata = new $3Dmol.VolumeData(data, \"cube\");\n              viewer.addIsosurface(voldata, {isoval: 0.01,\n                                             color: \"blue\",\n                                             alpha: 0.5,\n                                             smoothness: 10});\n              viewer.addIsosurface(voldata, {isoval: -0.01,\n                                             color: \"red\",\n                                             smoothness: 5,\n                                             opacity:0.5,\n                                             wireframe:true,\n                                             clickable:true,\n                                             callback:\n                                             function() {\n                                                 this.opacity = 0.0;\n                                                 viewer.render( );\n                                             }});\n              viewer.setStyle({}, {stick:{}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    addIsosurface(data, volSpec:IsoSurfaceSpec, callback?, viewer?: GLViewer) {//may want to cache the arrays generated when selectedRegion ==true\n\n        var isoval = (volSpec.isoval !== undefined && typeof (volSpec.isoval) === \"number\") ? volSpec.isoval\n            : 0.0;\n        var voxel = (volSpec.voxel) ? true : false;\n        var smoothness = (volSpec.smoothness === undefined) ? 1 : volSpec.smoothness;\n\n        var nX = data.size.x;\n        var nY = data.size.y;\n        var nZ = data.size.z;\n        var vertnums = new Int16Array(nX * nY * nZ);\n        var vals = data.data;\n\n        var i, il;\n\n        for (i = 0, il = vertnums.length; i < il; ++i)\n            vertnums[i] = -1;\n\n        var bitdata = new Uint8Array(nX * nY * nZ);\n\n        //mark locations partitioned by isoval\n        for (i = 0, il = vals.length; i < il; ++i) {\n            var val = (isoval >= 0) ? vals[i] - isoval : isoval - vals[i];\n            if (val > 0)\n                bitdata[i] |= GLShape.ISDONE;\n\n        }\n\n        var verts = [], faces = [];\n        MarchingCube.march(bitdata, verts, faces, {\n            fulltable: true,\n            voxel: voxel,\n            unitCube: data.unit,\n            origin: data.origin,\n            matrix: data.matrix,\n            nX: nX,\n            nY: nY,\n            nZ: nZ\n        });\n\n        if (!voxel && smoothness > 0)\n            MarchingCube.laplacianSmooth(smoothness, verts, faces);\n        var vertexmapping = [];\n        var newvertices = [];\n        var newfaces = [];\n\n        if (volSpec.selectedRegion && volSpec.coords === undefined) {\n            volSpec.coords = volSpec.selectedRegion; //backwards compat for incorrectly documented feature\n        }\n        if (volSpec.coords === undefined && volSpec.selection !== undefined) {\n            if(!viewer) {\n                console.log(\"addIsosurface needs viewer is selection provided.\");\n            } else {\n                volSpec.coords = viewer.selectedAtoms(volSpec.selection) as XYZ[];\n            }\n        }\n        if (volSpec.coords !== undefined) {\n\n            var xmax = volSpec.coords[0].x,\n                ymax = volSpec.coords[0].y,\n                zmax = volSpec.coords[0].z,\n                xmin = volSpec.coords[0].x,\n                ymin = volSpec.coords[0].y,\n                zmin = volSpec.coords[0].z;\n\n            for (let i = 0; i < volSpec.coords.length; i++) {\n                if (volSpec.coords[i].x > xmax)\n                    xmax = volSpec.coords[i].x;\n                else if (volSpec.coords[i].x < xmin)\n                    xmin = volSpec.coords[i].x;\n                if (volSpec.coords[i].y > ymax)\n                    ymax = volSpec.coords[i].y;\n                else if (volSpec.coords[i].y < ymin)\n                    ymin = volSpec.coords[i].y;\n                if (volSpec.coords[i].z > zmax)\n                    zmax = volSpec.coords[i].z;\n                else if (volSpec.coords[i].z < zmin)\n                    zmin = volSpec.coords[i].z;\n            }\n\n            var rad = 2;\n            if (volSpec.radius !== undefined) {\n                rad = volSpec.radius; //backwards compat\n            }\n            if (volSpec.selectedOffset !== undefined) { //backwards compat\n                rad = volSpec.selectedOffset;\n            }\n            if (volSpec.seldist !== undefined) {\n                rad = volSpec.seldist;\n            }\n\n            xmin -= rad;\n            xmax += rad;\n            ymin -= rad;\n            ymax += rad;\n            zmin -= rad;\n            zmax += rad;\n\n            // accounts for radius\n            for (let i = 0; i < verts.length; i++) {\n                if (verts[i].x > xmin &&\n                    verts[i].x < xmax &&\n                    verts[i].y > ymin &&\n                    verts[i].y < ymax &&\n                    verts[i].z > zmin &&\n                    verts[i].z < zmax &&\n                    GLShape.inSelectedRegion(verts[i],\n                        volSpec.coords, rad)) {\n                    vertexmapping.push(newvertices.length);\n                    newvertices.push(verts[i]);\n\n                } else {\n                    vertexmapping.push(-1);\n                }\n\n            }\n            for (let i = 0; i + 2 < faces.length; i += 3) {\n                if (vertexmapping[faces[i]] !== -1 &&\n                    vertexmapping[faces[i + 1]] !== -1 &&\n                    vertexmapping[faces[i + 2]] !== -1) {\n                    newfaces.push(faces[i] - (faces[i] - vertexmapping[faces[i]]));\n                    newfaces.push(faces[i + 1] - (faces[i + 1] - vertexmapping[faces[i + 1]]));\n                    newfaces.push(faces[i + 2] - (faces[i + 2] - vertexmapping[faces[i + 2]]));\n                }\n            }\n            verts = newvertices;\n            faces = newfaces;\n        }\n\n        GLShape.drawCustom(this, this.geo, {\n            vertexArr: verts,\n            faceArr: faces,\n            normalArr: [],\n            clickable: volSpec.clickable,\n            hoverable: volSpec.hoverable\n        });\n\n        this.updateStyle(volSpec);\n\n        //computing bounding sphere from vertices\n        var origin = new Vector3(data.origin.x, data.origin.y, data.origin.z);\n        var size = new Vector3(data.size.x * data.unit.x, data.size.y * data.unit.y, data.size.z * data.unit.z);\n\n        var total = new Vector3(0, 0, 0);\n        var maxv = origin.clone();\n        var minv = origin.clone().add(size);\n        for (let i = 0; i < verts.length; i++) {\n            total.add(verts[i]);\n            maxv.max(verts[i]);\n            minv.min(verts[i]);\n        }\n        total.divideScalar(verts.length);\n        var len1 = total.distanceTo(minv);\n        var len2 = total.distanceTo(maxv);\n        this.boundingSphere.center = total;\n        this.boundingSphere.radius = Math.max(len1, len2);\n        if (typeof callback == \"function\")\n            callback();\n    };\n\n    /** \n     * @deprecated Use addIsosurface instead\n     * Creates custom shape from volumetric data \n     * @param {string} data - Volumetric input data \n     * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)\n     * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification\n     */\n    public addVolumetricData(data, fmt, volSpec: IsoSurfaceSpec) {\n        data = new VolumeData(data, fmt);\n        this.addIsosurface(data, volSpec);\n    };\n\n    //for internal use, truncate buffers to save memory\n    finalize() {\n        GLShape.finalizeGeo(this.geo);\n        this.geo.initTypedArrays();\n        return this.geo;\n    };\n\n    /*\n     * Initialize webgl objects for rendering\n     * @param {$3Dmol.Object3D} group\n     * \n     */\n    globj(group) {\n\n        if (this.renderedShapeObj) {\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n\n        if (this.hidden)\n            return;\n        GLShape.finalizeGeo(this.geo);\n        this.geo.initTypedArrays();\n\n        if (this.wireframe) {\n            this.geo.setUpWireframe();\n        }\n\n        if (typeof (this.color) != 'undefined')\n            GLShape.updateColor(this.geo, this.color);\n\n        this.shapeObj = new Object3D();\n        var material = null;\n\n        if (this.side == DoubleSide) {\n            material = new MeshDoubleLambertMaterial({\n                wireframe: this.wireframe,\n                side: this.side,\n                transparent: (this.opacity < 1) ? true : false,\n                opacity: this.opacity,\n                wireframeLinewidth: this.linewidth,\n                vertexColors: Coloring.VertexColors\n            });\n        } else {\n            material = new MeshLambertMaterial({\n                wireframe: this.wireframe,\n                side: this.side,\n                transparent: (this.opacity < 1) ? true : false,\n                opacity: this.opacity,\n                wireframeLinewidth: this.linewidth,\n                vertexColors: Coloring.VertexColors\n            });\n        }\n\n        var mesh = new Mesh(this.geo, material);\n\n        this.shapeObj.add(mesh);\n\n        if(this.linegeo && this.linegeo.vertices > 0) {\n            var lineMaterial = new LineBasicMaterial({\n                linewidth: this.linewidth,\n                color: this.color\n            });\n            var line = new Line(this.linegeo, lineMaterial as Material, LineStyle.LinePieces);\n            this.shapeObj.add(line);\n        }\n\n        this.renderedShapeObj = this.shapeObj.clone();\n        group.add(this.renderedShapeObj);\n\n    };\n\n    removegl(group) {\n        if (this.renderedShapeObj) {\n            // dispose of geos and materials\n            if (this.renderedShapeObj.geometry !== undefined)\n                this.renderedShapeObj.geometry.dispose();\n            if (this.renderedShapeObj.material !== undefined)\n                this.renderedShapeObj.material.dispose();\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        this.shapeObj = null;\n    };\n\n    get position() {\n        return this.boundingSphere.center;\n    }\n\n    get x() {\n        return this.boundingSphere.center.x;\n    }\n    get y() {\n        return this.boundingSphere.center.y;\n    }\n    get z() {\n        return this.boundingSphere.center.z;\n    }\n};\n\n\n\nexport function splitMesh(mesh) {\n    var MAXVERT = 64000; //webgl only supports 2^16 elements, leave a little breathing room (require at least 2)\n    //peel off 64k vertices rsvh into their own mesh\n    //duplicating vertices and normals as necessary to preserve faces and lines\n\n    if (mesh.vertexArr.length < MAXVERT) return [mesh]; //typical case\n\n    var slices: any = [{ vertexArr: [], normalArr: [], faceArr: [] }];\n    if (mesh.colorArr) slices.colorArr = [];\n    var vertSlice = []; //indexed by original vertex to get current slice\n    var vertIndex = []; //indexed by original vertex to get index within slice\n    var currentSlice = 0;\n\n    //for each face, make sure all three vertices (or copies) are in the same slice\n    var faces = mesh.faceArr;\n    for (let i = 0, nf = faces.length; i < nf; i += 3) {\n        let slice = slices[currentSlice];\n        for (let j = 0; j < 3; j++) {\n            //process each vertex to make sure it is assigned a slice\n            //all vertices of a face must belong to the same slice\n            var v = faces[i + j];\n            if (vertSlice[v] !== currentSlice) { //true if undefined\n                vertSlice[v] = currentSlice;\n                vertIndex[v] = slice.vertexArr.length;\n                slice.vertexArr.push(mesh.vertexArr[v]);\n                if (mesh.normalArr && mesh.normalArr[v]) slice.normalArr.push(mesh.normalArr[v]);\n                if (mesh.colorArr && mesh.colorArr[v]) slice.colorArr.push(mesh.colorArr[v]);\n            }\n            slice.faceArr.push(vertIndex[v]);\n        }\n\n        if (slice.vertexArr.length >= MAXVERT) {\n            //new slice\n            slices.push({ vertexArr: [], normalArr: [], faceArr: [] });\n            if (mesh.colorArr) slices.colorArr = [];\n            currentSlice++;\n        }\n    }\n    return slices;\n};\n\n/**\n * GLShape style specification\n */\nexport interface ShapeSpec {\n    /** Either a single color for the whole object or an array specifying the color at each vertex ({@link CustomShapeSpec}). */\n    color?: ColorSpec | ColorSpec[];\n    alpha?: number; //prefer opacity\n    /** transparency, between 0 (invisible) and 1 (opaque) */\n    opacity?: number;\n    /** draw as wireframe, not surface */\n    wireframe?: boolean;\n    /** if true, do not display object */\n    hidden?: boolean;\n    /** width of line for wireframe rendering **No longer supported by most browsers** */\n    linewidth?: number;\n    /** if true, user can click on object to trigger callback */\n    clickable?: boolean;\n    /** function to call on click */\n    callback?: Func;\n    /** if true, user can hover on object to trigger callback */\n    hoverable?: boolean;\n    /** hover callback */\n    hover_callback?: Func;\n    /** unhover callback */\n    unhover_callback?: Func;\n    /** if true, user can right-click or long press to trigger callback */\n    contextMenuEnabled?: boolean;\n    /** if set, only display in this frame of an animation */\n    frame?: number;\n    side?: number;\n    voldata?: VolumeData;\n    volscheme?: GradientType\n};\n\n\n/**\n * Isosurface style specification\n * @extends ShapeSpec\n */\nexport interface IsoSurfaceSpec extends ShapeSpec {\n    /** specifies the isovalue to draw surface at */\n    isoval?: number;\n    /** if true uses voxel style rendering */\n    voxel?: boolean;\n    /** amount to smooth surface (default 1) */\n    smoothness?: number;\n    /** coordinates around which to include data; use viewer.selectedAtoms() to convert an AtomSelectionSpec to coordinates */\n    coords?: XYZ[];\n    /** selection around which to include data (alternative to coords) */\n    selection?: AtomSelectionSpec;\n    /** distance around coords to include data [default = 2.0] */\n    seldist?: number;\n    /** volumetric data for vertex coloring, can be VolumeData object or raw data if volformat is specified */\n    voldata?: VolumeData;\n    /** coloring scheme for mapping volumetric data to vertex color, if not a Gradient object, show describe a builtin gradient one by providing an object with gradient, min, max, and (optionally) mid fields. */\n    volscheme?: GradientType;\n    /** format of voldata if not a $3Dmol.VolumeData object */\n    volformat?: string;\n\n    selectedRegion?: XYZ[]; //deprecated\n    selectedOffset?: number; //deprecated\n    radius?: number; //also deprecated\n};\n\n\n\n/**\n * Arrow shape specification.  \n  * @extends ShapeSpec\n */\nexport interface ArrowSpec extends ShapeSpec {\n    /** starting position */\n    start?: XYZ;\n    /** ending position */\n    end?: XYZ;\n    /** direction to extend from start (instead of specifying end) */\n    dir?: XYZ;\n    /** length to extend in dir direction from start (instead of specifying end) */\n    length?: number;\n    /** radius (default 0.1A) */\n    radius?: number;\n    /** color */\n    color?: ColorSpec;\n    /** hidden */\n    hidden?: boolean;\n    /** ratio of arrow base to cylinder (1.618034 default) */\n    radiusRatio?: number;\n    /** relative position of arrow base (0.618034 default) */\n    mid?: number;\n    /** position of arrow base in length units, if negative positioned from end instead of start.  Overrides mid. */\n    midpos?: number;\n};\n\n/**\n * Cylinder shape specification.  \n * @extends ShapeSpec\n * \n */\nexport interface CylinderSpec extends ShapeSpec {\n    /** starting vector */\n    start?: XYZ;\n    /** ending position */\n    end?: XYZ;\n    /** radius */\n    radius?: number;\n    /** Place a cap at the start (none, flat or round) */\n    fromCap?: CAP | string;\n    /** Place a cap at the end (none, flat or round) */\n    toCap?: CAP | string;\n    /** Make the cylinder dashed. */\n    dashed?: boolean;\n    /** Length of dashes (default 0.25) */\n    dashLength?: number;\n    /** Length of gaps (default 0.25) */\n    gapLength?: number;\n    /** hidden */\n    hidden?: boolean;    \n};\n\n/**\n * Curve shape specification.  \n * @extends ShapeSpec\n */\nexport interface CurveSpec extends ShapeSpec {\n    /** Sequence of points to draw curve through */\n    points?: XYZ[];\n    /** amount of interpolation */\n    smooth?: number;\n    /** radius of curve */\n    radius?: number;\n    /** if an arrow should be drawn at the start */\n    fromArrow?: boolean;\n    /** if an arrow should be drawn at the end */\n    toArrow?: boolean;\n    /** have cap at start */\n    fromCap?: CAP;\n    /** have cap at end */\n    toCap?: CAP;\n};\n\n/**\n * Line shape specification.  Default to wireframe.\n * @extends ShapeSpec\n */\nexport interface LineSpec extends ShapeSpec {\n    /** Starting position */\n    start?: XYZ;\n    /** Ending position */\n    end?: XYZ;\n    /** make dashed */\n    dashed?: boolean;\n};\n\n/**\n * Box shape specification. \n * @extends ShapeSpec\n */\nexport interface BoxSpec extends ShapeSpec {\n    /** bottom corner of box */\n    corner?: XYZ;\n    /** center of box */\n    center?: XYZ;\n    /** width, height, depth of box */\n    dimensions?: {\n        w: number | XYZ;\n        h: number | XYZ;\n        d: number | XYZ;\n    };\n};\n\n\n/**\n * Specification for adding custom shape. \n * @extends ShapeSpec\n */\nexport interface CustomShapeSpec extends ShapeSpec {\n    /** List of vertex positions */\n    vertexArr?: XYZ[];\n    /** List of normal vectors for each vertex */\n    normalArr?: XYZ[];\n    /** List of triangles to build the custom shape. Each triangle is defined by the indices of 3 vertices in vertexArr, so the array length should be 3 times the number of faces. */\n    faceArr?: number[];\n};\n\n/**\n * Sphere shape specification. Extends {@link ShapeSpec}.\n */\nexport interface SphereSpec extends ShapeSpec {\n    /** center of sphere */\n    center?: XYZ;\n    /** radius of sphere */\n    radius?: number;\n    /** quality metric, higher uses more triangles (default 2) */\n    quality?: number;\n};\n\n", "//a molecular viewer based on GLMol\n\nimport { decode, encode, toRGBA8 } from 'upng-js';\nimport { AtomStyleSpec, GLModel, LineStyleSpec } from \"./GLModel\";\nimport { ArrowSpec, BoxSpec, CurveSpec, CustomShapeSpec, CylinderSpec, GLShape, IsoSurfaceSpec, LineSpec, ShapeSpec, SphereSpec, splitMesh } from \"./GLShape\";\nimport { getGradient, Gradient } from \"./Gradient\";\nimport { Label, LabelSpec } from \"./Label\";\nimport { ProteinSurface, SurfaceType, syncSurface } from \"./ProteinSurface4\";\nimport { VolumeData } from \"./VolumeData\";\nimport { GLVolumetricRender, VolumetricRendererSpec } from \"./VolumetricRender\";\nimport { Camera, Coloring, Fog, FrontSide, Geometry, Light, Line, LineBasicMaterial, Material, Mesh, MeshDoubleLambertMaterial, MeshLambertMaterial, Object3D, Projector, Raycaster, Renderer, Scene } from \"./WebGL\";\nimport { Matrix3, Matrix4, Quaternion, Vector3, XYZ } from \"./WebGL/math\";\nimport { CC, ColorschemeSpec, ColorSpec, elementColors } from \"./colors\";\nimport { AtomSelectionSpec, AtomSpec } from \"./specs\";\nimport { adjustVolumeStyle, extend, getColorFromStyle, getElement, getExtent, getPropertyRange, isEmptyObject, makeFunction, mergeGeos, PausableTimer } from \"./utilities\";\n\nexport const CONTEXTS_PER_VIEWPORT = 16;\n\ninterface SurfObj {\n    geo: Geometry;\n    mat: Material;\n    done: Boolean;\n    finished: Boolean;\n    lastGL?: any;\n    symmetries?: any[];\n    style?: SurfaceStyleSpec;\n}\n\n/**\n * A surface.\n *\n * @class\n*/\nclass Surface extends Array<SurfObj> {\n    style?: SurfaceStyleSpec;\n    atomsel?: AtomSelectionSpec;\n    allsel?: AtomSelectionSpec;\n    focus?: AtomSelectionSpec;\n\n    constructor(items: SurfObj[]) {\n        super(...items); // spread the array elements into the Array constructor\n    }\n    /**\n     * Returns list of rotational/translational matrices if there is BIOMT data\n     * Otherwise returns a list of just the ID matrix\n     *\n     * @return {Array<Matrix4>}\n     *\n     */\n    public getSymmetries() {\n        //we assume all sub-objects have same symmetries\n        if (this.length == 0) return [];\n        let obj = this[0];\n        if (typeof (obj.symmetries) == 'undefined') {\n            this.setSymmetries([new Matrix4()]);\n        }\n        return obj.symmetries;\n    };\n\n    /**\n     * Sets symmetries based on specified matrices in list\n     *\n     * @param {Array<Matrix4>} list\n     *\n     */\n    public setSymmetries(syms) {\n        if (typeof (syms) == \"undefined\") { //delete sym data\n            syms = [new Matrix4()];\n        }\n        for (let obj of this) {\n            obj.symmetries = syms;\n            obj.finished = false; //trigger redraw\n        }\n    };\n}\n\n/**\n * WebGL-based 3Dmol.js viewer\n * Note: The preferred method of instantiating a GLViewer is through {@link createViewer}\n *\n * @class\n*/\nexport class GLViewer {\n    // private class variables\n    private static numWorkers = 4; // number of threads for surface generation\n    private static maxVolume = 64000; // how much to break up surface calculations\n\n    private callback: any;\n    private defaultcolors: any;\n    private config: ViewerSpec;\n    private nomouse = false;\n    private bgColor: any;\n    private camerax: number;\n    private _viewer: GLViewer;\n    private glDOM: HTMLCanvasElement | null = null;\n\n    private models: GLModel[] = []; // atomistic molecular models\n    private surfaces: Record<number, Surface> = {};\n    private shapes = []; // Generic shapes\n    private labels: Label[] = [];\n    private clickables = []; //things you can click on\n    private hoverables = []; //things you can hover over\n    private contextMenuEnabledObjects = []; // atoms and shapes with context menu\n    private current_hover: any = null;\n    private hoverDuration = 500;\n    private longTouchDuration = 1000;\n    private viewer_frame = 0;\n    private WIDTH: number;\n    private HEIGHT: number;\n    private viewChangeCallback: any = null;\n    private stateChangeCallback: any = null;\n\n    private NEAR = 1;\n    private FAR = 800;\n    private CAMERA_Z = 150;\n    private fov = 20;\n\n    private linkedViewers = [];\n    private renderer: Renderer | null = null;\n\n    private row: number;\n    private col: number;\n    private cols: number;\n    private rows: number;\n    private viewers: any;\n    private control_all = false;\n\n    private ASPECT: any;\n    private camera: Camera;\n    private lookingAt: Vector3;\n\n    private raycaster: Raycaster;\n    private projector: Projector;\n\n    private scene: any = null;\n    private rotationGroup: any = null; // which contains modelGroup\n    private modelGroup: any = null;\n\n    private fogStart = 0.4;\n    private fogEnd = 1.0;\n    private slabNear = -50; // relative to the center of rotationGroup\n    private slabFar = 50;\n\n    public container: HTMLElement | null;\n\n    static readonly surfaceTypeMap = {\n        \"VDW\": SurfaceType.VDW,\n        \"MS\": SurfaceType.MS,\n        \"SAS\": SurfaceType.SAS,\n        \"SES\": SurfaceType.SES\n    };\n\n    private cq = new Quaternion(0, 0, 0, 1);\n    private dq = new Quaternion(0, 0, 0, 1);\n    private animated = 0;\n    private animationTimers = new Set<PausableTimer>();\n    private isDragging = false;\n    private mouseStartX = 0;\n    private mouseStartY = 0;\n    private touchDistanceStart = 0;\n    private touchHold = false;\n    private currentModelPos = 0;\n    private cz = 0;\n    private cslabNear = 0;\n    private cslabFar = 0;\n\n    private mouseButton: any;\n    private hoverTimeout: any;\n    private longTouchTimeout: any;\n\n    private divwatcher: any;\n    private intwatcher: any;\n    private spinInterval: any;\n\n\n    private getWidth() {\n        let div = this.container;\n        //offsetwidth accounts for scaling\n        let w = div.offsetWidth;\n        if (w == 0 && div.style.display === 'none') {\n            let oldpos = div.style.position;\n            let oldvis = div.style.visibility;\n            div.style.display = 'block';\n            div.style.visibility = 'hidden';\n            div.style.position = 'absolute';\n            w = div.offsetWidth;\n            div.style.display = 'none';\n            div.style.visibility = oldvis;\n            div.style.position = oldpos;\n        }\n        return w;\n    };\n\n    private getHeight() {\n        let div = this.container;\n        let h = div.offsetHeight;\n        if (h == 0 && div.style.display === 'none') {\n            let oldpos = div.style.position;\n            let oldvis = div.style.visibility;\n            div.style.display = 'block';\n            div.style.visibility = 'hidden';\n            div.style.position = 'absolute';\n            h = div.offsetHeight;\n            div.style.display = 'none';\n            div.style.visibility = oldvis;\n            div.style.position = oldpos;\n        }\n        return h;\n    };\n\n    private setupRenderer() {\n        let rendopt = {\n            ...this.config,\n            preserveDrawingBuffer: true, //so we can export images\n            premultipliedAlpha: false,/* more traditional compositing with background */\n            //cannot initialize with zero size - render will start out lost\n            containerWidth: this.WIDTH,\n            containerHeight: this.HEIGHT\n        };\n        this.renderer = new Renderer(rendopt);\n        this.renderer.domElement.style.width = \"100%\";\n        this.renderer.domElement.style.height = \"100%\";\n        this.renderer.domElement.style.padding = \"0\";\n        this.renderer.domElement.style.position = \"absolute\"; //TODO: get rid of this\n        this.renderer.domElement.style.top = \"0px\";\n        this.renderer.domElement.style.left = \"0px\";\n        this.renderer.domElement.style.zIndex = \"0\";\n    }\n\n    private initializeScene() {\n\n        this.scene = new Scene();\n        this.scene.fog = new Fog(this.bgColor, 100, 200);\n\n        this.modelGroup = new Object3D();\n        this.rotationGroup = new Object3D();\n        this.rotationGroup.useQuaternion = true;\n        this.rotationGroup.quaternion = new Quaternion(0, 0, 0, 1);\n        this.rotationGroup.add(this.modelGroup);\n\n        this.scene.add(this.rotationGroup);\n\n        // setup lights\n        var directionalLight = new Light(0xFFFFFF);\n        directionalLight.position = new Vector3(0.2, 0.2, 1)\n            .normalize();\n        directionalLight.intensity = 1.0;\n        this.scene.add(directionalLight);\n    };\n\n    private _handleLostContext(event) {\n\n        //when contexts go missing, try to regenerate any that are visible on screen\n        //but no more than CONTEXTS_PER_VIEWPORT (if this is set higher than the\n        //browser limit there will be an infinity loop of refreshing contexts of\n        //too many are on screen)\n        const isVisible = function (cont) {\n            const rect = cont.getBoundingClientRect();\n            return !(\n                rect.right < 0 ||\n                rect.bottom < 0 ||\n                rect.top > (window.innerHeight || document.documentElement.clientHeight) ||\n                rect.left > (window.innerWidth || document.documentElement.clientWidth)\n            );\n        };\n\n        if (isVisible(this.container)) {\n            let restored = 0;\n            for (let c of document.getElementsByTagName('canvas')) {\n                if (isVisible(c) && (c as any)._3dmol_viewer != undefined) {\n                    (c as any)._3dmol_viewer.resize();\n                    restored += 1;\n                    if (restored >= CONTEXTS_PER_VIEWPORT) break;\n                }\n            }\n        }\n    }\n\n    private initContainer(element) {\n        this.container = element;\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.container.append(this.renderer.domElement);\n        this.glDOM = this.renderer.domElement;\n\n        (this.glDOM as any)._3dmol_viewer = this;\n        this.glDOM.addEventListener(\"webglcontextlost\", this._handleLostContext.bind(this));\n\n        if (!this.nomouse) {\n            // user can request that the mouse handlers not be installed\n            this.glDOM.addEventListener('mousedown', this._handleMouseDown.bind(this), { passive: false });\n            this.glDOM.addEventListener('touchstart', this._handleMouseDown.bind(this), { passive: false });\n            this.glDOM.addEventListener('wheel', this._handleMouseScroll.bind(this), { passive: false });\n            this.glDOM.addEventListener('mousemove', this._handleMouseMove.bind(this), { passive: false });\n            this.glDOM.addEventListener('touchmove', this._handleMouseMove.bind(this), { passive: false });\n            this.glDOM.addEventListener(\"contextmenu\", this._handleContextMenu.bind(this), { passive: false });\n        }\n\n    };\n\n    private decAnim() {\n        //decrement the number of animations currently\n        this.animated--;\n        if (this.animated < 0) this.animated = 0;\n    };\n\n    private incAnim() {\n        this.animated++;\n    };\n\n    private nextSurfID() {\n        //compute the next highest surface id directly from surfaces\n        //this is necessary to support linking of model data\n        var max = 0;\n        for (let i in this.surfaces) { // this is an object with possible holes\n            if (!this.surfaces.hasOwnProperty(i)) continue;\n            var val = parseInt(i);\n            if (!isNaN(val)) {\n                if (val > max)\n                    max = val;\n            }\n        }\n        return max + 1;\n    };\n\n    private setSlabAndFog() {\n\n        let center = this.camera.position.z - this.rotationGroup.position.z;\n        if (center < 1)\n            center = 1;\n        this.camera.near = center + this.slabNear;\n        if (!this.camera.ortho && this.camera.near < 1)\n            this.camera.near = 1;\n        this.camera.far = center + this.slabFar;\n        if (this.camera.near + 1 > this.camera.far)\n            this.camera.far = this.camera.near + 1;\n\n        this.camera.fov = this.fov;\n        this.camera.right = center * Math.tan(Math.PI / 180 * this.fov);\n        this.camera.left = -this.camera.right;\n        this.camera.top = this.camera.right / this.ASPECT;\n        this.camera.bottom = -this.camera.top;\n\n        this.camera.updateProjectionMatrix();\n\n        this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near);\n        this.scene.fog.far = this.camera.near + this.fogEnd * (this.camera.far - this.camera.near);\n\n        if (this.config.disableFog) {\n            this.scene.fog.near = this.scene.fog.far;\n        }\n    };\n\n    // display scene\n    //if nolink is set/true, don't propagate changes to linked viewers\n    private show(nolink?) {\n        this.renderer.setViewport();\n        if (!this.scene)\n            return;\n        //let time = new Date();\n        this.setSlabAndFog();\n        this.renderer.render(this.scene, this.camera);\n        //console.log(\"rendered in \" + (+new Date() - (time as any)) + \"ms\");\n\n        //have any scene change trigger a callback\n        if (this.viewChangeCallback) this.viewChangeCallback(this._viewer.getView());\n\n        if (!nolink && this.linkedViewers.length > 0) {\n            var view = this._viewer.getView();\n            for (var i = 0; i < this.linkedViewers.length; i++) {\n                var other = this.linkedViewers[i];\n                other.setView(view, true);\n            }\n        }\n    };\n\n\n    //regenerate the list of clickables\n    //also updates hoverables\n    private updateClickables() {\n        this.clickables.splice(0, this.clickables.length);\n        this.hoverables.splice(0, this.hoverables.length);\n        this.contextMenuEnabledObjects.splice(0, this.contextMenuEnabledObjects.length);\n\n        for (let i = 0, il = this.models.length; i < il; i++) {\n            let model = this.models[i];\n            if (model) {\n                let atoms = model.selectedAtoms({\n                    clickable: true\n                });\n\n                let hoverable_atoms = model.selectedAtoms({\n                    hoverable: true\n                });\n\n                let contextMenuEnabled_atom = model.selectedAtoms({ contextMenuEnabled: true });\n                // Array.prototype.push.apply(hoverables,hoverable_atoms);\n                for (let n = 0; n < hoverable_atoms.length; n++) {\n                    this.hoverables.push(hoverable_atoms[n]);\n                }\n\n                // Array.prototype.push.apply(clickables, atoms); //add atoms into clickables\n                for (let m = 0; m < atoms.length; m++) {\n                    this.clickables.push(atoms[m]);\n                }\n\n                // add atoms into contextMenuEnabledObjects\n                for (let m = 0; m < contextMenuEnabled_atom.length; m++) {\n                    this.contextMenuEnabledObjects.push(contextMenuEnabled_atom[m]);\n                }\n\n            }\n        }\n        for (let i = 0, il = this.shapes.length; i < il; i++) {\n\n            let shape = this.shapes[i];\n            if (shape && shape.clickable) {\n                this.clickables.push(shape);\n            }\n            if (shape && shape.hoverable) {\n                this.hoverables.push(shape);\n            }\n            if (shape && shape.contextMenuEnabled) {\n                this.contextMenuEnabledObjects.push(shape);\n            }\n        }\n    };\n\n    // Checks for selection intersects on mousedown\n    private handleClickSelection(mouseX: number, mouseY: number, event) {\n        let intersects = this.targetedObjects(mouseX, mouseY, this.clickables);\n        // console.log('handleClickSelection', mouseX, mouseY, intersects);\n        if (intersects.length) {\n            var selected = intersects[0].clickable;\n            if (selected.callback !== undefined) {\n                if (typeof (selected.callback) != \"function\") {\n                    selected.callback = makeFunction(selected.callback);\n                }\n                if (typeof (selected.callback) === \"function\") {\n                    // Suppress click callbacks when context menu will be invoked.\n                    // This only applies to clicks from \"mouseup\" events after right-click.\n                    // Clicks from \"touchend\" after longtouch contextmenu are suppressed\n                    // in _handleContextMenu.\n                    const isContextMenu = this.mouseButton === 3\n                        && this.contextMenuEnabledObjects.includes(selected)\n                        && this.userContextMenuHandler;\n                    if (!isContextMenu) {\n                        selected.callback(selected, this._viewer, event, this.container, intersects);\n                    }\n                }\n            }\n        }\n    };\n\n\n    //return offset of container\n    private canvasOffset() {\n        let canvas = this.glDOM;\n        let rect = canvas.getBoundingClientRect();\n        let doc = canvas.ownerDocument;\n        let docElem = doc.documentElement;\n        let win = doc.defaultView;\n        return {\n            top: rect.top + win.pageYOffset - docElem.clientTop,\n            left: rect.left + win.pageXOffset - docElem.clientLeft\n        };\n    };\n\n    //set current_hover to sel (which can be null), calling appropraite callbacks\n    private setHover(selected, event?, intersects?) {\n        if (this.current_hover == selected) return;\n        if (this.current_hover) {\n            if (typeof (this.current_hover.unhover_callback) != \"function\") {\n                this.current_hover.unhover_callback = makeFunction(this.current_hover.unhover_callback);\n            }\n            this.current_hover.unhover_callback(this.current_hover, this._viewer, event, this.container, intersects);\n        }\n        this.current_hover = selected;\n\n        if (selected && selected.hover_callback !== undefined) {\n            if (typeof (selected.hover_callback) != \"function\") {\n                selected.hover_callback = makeFunction(selected.hover_callback);\n            }\n            if (typeof (selected.hover_callback) === \"function\") {\n                selected.hover_callback(selected, this._viewer, event, this.container, intersects);\n            }\n        }\n\n    };\n\n    //checks for selection intersects on hover\n    private handleHoverSelection(mouseX, mouseY, event) {\n        if (this.hoverables.length == 0) return;\n        let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);\n        if (intersects.length) {\n            var selected = intersects[0].clickable;\n            this.setHover(selected, event, intersects);\n            this.current_hover = selected;\n        }\n        else {\n            this.setHover(null);\n        }\n    };\n\n    //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called\n    private handleHoverContinue(mouseX: number, mouseY: number) {\n        let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);\n        if (intersects.length == 0 || intersects[0] === undefined) {\n            this.setHover(null);\n        }\n        if (intersects[0] !== undefined && intersects[0].clickable !== this.current_hover) {\n            this.setHover(null);\n        }\n    };\n\n    /**\n     * Determine if a positioned event is \"close enough\" to mouseStart to be considered a click.\n     * With a mouse, the position should be exact, but allow a slight delta for a touch interface.\n     * @param {Event} event\n     * @param {{ allowTolerance, tolerance: number }} options\n     */\n    private closeEnoughForClick(event, { allowTolerance = event.targetTouches, tolerance = 5 } = {}) {\n        const x = this.getX(event);\n        const y = this.getY(event);\n        if (allowTolerance) {\n            const deltaX = Math.abs(x - this.mouseStartX);\n            const deltaY = Math.abs(y - this.mouseStartY);\n            return deltaX <= tolerance && deltaY <= tolerance;\n        } else {\n            return x === this.mouseStartX && y === this.mouseStartY;\n        }\n    }\n\n    private calcTouchDistance(ev) { // distance between first two\n        // fingers\n        var xdiff = ev.targetTouches[0].pageX -\n            ev.targetTouches[1].pageX;\n        var ydiff = ev.targetTouches[0].pageY -\n            ev.targetTouches[1].pageY;\n        return Math.hypot(xdiff, ydiff);\n    };\n\n    //check targetTouches as well\n    private getX(ev) {\n        var x = ev.pageX;\n        if (x == undefined) x = ev.pageX; //firefox\n        if (ev.targetTouches &&\n            ev.targetTouches[0]) {\n            x = ev.targetTouches[0].pageX;\n        }\n        else if (ev.changedTouches &&\n            ev.changedTouches[0]) {\n            x = ev.changedTouches[0].pageX;\n        }\n        return x;\n    };\n\n    private getY(ev) {\n        var y = ev.pageY;\n        if (y == undefined) y = ev.pageY;\n        if (ev.targetTouches &&\n            ev.targetTouches[0]) {\n            y = ev.targetTouches[0].pageY;\n        }\n        else if (ev.changedTouches &&\n            ev.changedTouches[0]) {\n            y = ev.changedTouches[0].pageY;\n        }\n        return y;\n    };\n\n    //for grid viewers, return true if point is in this viewer\n    private isInViewer(x: number, y: number) {\n        if (this.viewers != undefined) {\n            var width = this.WIDTH / this.cols;\n            var height = this.HEIGHT / this.rows;\n            var offset = this.canvasOffset();\n            var relx = (x - offset.left);\n            var rely = (y - offset.top);\n\n            var r = this.rows - Math.floor(rely / height) - 1;\n            var c = Math.floor(relx / width);\n\n            if (r != this.row || c != this.col)\n                return false;\n        }\n        return true;\n    };\n\n    //if the user has specify zoom limits, readjust to fit within them\n    //also, make sure we don't go past CAMERA_Z\n    private adjustZoomToLimits(z: number) {\n        //a lower limit of 0 is at CAMERA_Z\n        if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {\n            let lower = this.CAMERA_Z - this.config.lowerZoomLimit;\n            if (z > lower) z = lower;\n        }\n\n        if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {\n            let upper = this.CAMERA_Z - this.config.upperZoomLimit;\n            if (z < upper) z = upper;\n        }\n\n        if (z > this.CAMERA_Z - 1) {\n            z = this.CAMERA_Z - 1; //avoid getting stuck\n        }\n\n        return z;\n    };\n    //interpolate between two normalized quaternions (t between 0 and 1)\n    //https://en.wikipedia.org/wiki/Slerp\n    private static slerp(v0: Quaternion, v1: Quaternion, t: number) {\n        // Compute the cosine of the angle between the two vectors.\n        //dot product\n        if (t == 1) return v1.clone();\n        else if (t == 0) return v0.clone();\n        let dot = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w;\n        if (dot > 0.9995) {\n            // If the inputs are too close for comfort, linearly interpolate\n            // and normalize the result.\n            let result = new Quaternion(\n                v0.x + t * (v1.x - v0.x),\n                v0.y + t * (v1.y - v0.y),\n                v0.z + t * (v1.z - v0.z),\n                v0.w + t * (v1.w - v0.w));\n\n            result.normalize();\n            return result;\n        }\n\n        // If the dot product is negative, the quaternions\n        // have opposite handed-ness and slerp won't take\n        // the shorted path. Fix by reversing one quaternion.\n        if (dot < 0.0) {\n            v1 = v1.clone().multiplyScalar(-1);\n            dot = -dot;\n        }\n\n        if (dot > 1) dot = 1.0;\n        else if (dot < -1) dot = -1.0;\n\n        var theta_0 = Math.acos(dot);  // theta_0 = angle between input vectors\n        var theta = theta_0 * t;    // theta = angle between v0 and result\n\n        var v2 = v1.clone();\n        v2.sub(v0.clone().multiplyScalar(dot));\n        v2.normalize();              // { v0, v2 } is now an orthonormal basis\n\n        var c = Math.cos(theta);\n        var s = Math.sin(theta);\n        var ret = new Quaternion(\n            v0.x * c + v2.x * s,\n            v0.y * c + v2.y * s,\n            v0.z * c + v2.z * s,\n            v0.w * c + v2.w * s\n        );\n        ret.normalize();\n        return ret;\n    };\n\n\n    /* @param {Object} element HTML element within which to create viewer\n     * @param {ViewerSpec} config Object containing optional configuration for the viewer\n     */\n    constructor(element, c: ViewerSpec = {}) {\n        // set variables\n        this.config = c;\n        this.callback = this.config.callback;\n        this.defaultcolors = this.config.defaultcolors;\n        if (!this.defaultcolors)\n            this.defaultcolors = elementColors.defaultColors;\n        this.nomouse = Boolean(this.config.nomouse);\n        this.bgColor = 0;\n        this.config.backgroundColor = this.config.backgroundColor || \"#ffffff\";\n        if (typeof (this.config.backgroundColor) != 'undefined') {\n            this.bgColor = CC.color(this.config.backgroundColor).getHex();\n        }\n        this.config.backgroundAlpha = this.config.backgroundAlpha == undefined ? 1.0 : this.config.backgroundAlpha;\n\n        this.camerax = 0;\n        if (typeof (this.config.camerax) != 'undefined') {\n            this.camerax = typeof (this.config.camerax) === 'string' ? parseFloat(this.config.camerax) : this.config.camerax;\n        }\n        this._viewer = this;\n        this.container = element; //we expect container to be HTMLElement\n\n        if (this.config.hoverDuration != undefined) {\n            this.hoverDuration = this.config.hoverDuration;\n        }\n        if (this.config.antialias === undefined) this.config.antialias = true;\n        if (this.config.cartoonQuality === undefined) this.config.cartoonQuality = 10;\n\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n\n        this.setupRenderer();\n\n        this.row = this.config.row == undefined ? 0 : this.config.row;\n        this.col = this.config.col == undefined ? 0 : this.config.col;\n        this.cols = this.config.cols;\n        this.rows = this.config.rows;\n        this.viewers = this.config.viewers;\n        this.control_all = this.config.control_all;\n\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n\n        this.camera = new Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic);\n        this.camera.position = new Vector3(this.camerax, 0, this.CAMERA_Z);\n        this.lookingAt = new Vector3();\n        this.camera.lookAt(this.lookingAt);\n\n        this.raycaster = new Raycaster(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        this.projector = new Projector();\n\n        this.initializeScene();\n        this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);\n        this.scene.fog.color = CC.color(this.bgColor);\n\n        // this event is bound to the body element, not the container,\n        // so no need to put it inside initContainer()\n        document.body.addEventListener('mouseup', this._handleMouseUp.bind(this));\n        document.body.addEventListener('touchend', this._handleMouseUp.bind(this));\n\n        this.initContainer(this.container);\n        if (this.config.style) { //enable setting style in constructor\n            this.setViewStyle(this.config as ViewStyle);\n        }\n\n        window.addEventListener(\"resize\", this.resize.bind(this));\n\n        if (typeof (window.ResizeObserver) !== \"undefined\") {\n            this.divwatcher = new window.ResizeObserver(this.resize.bind(this));\n            this.divwatcher.observe(this.container);\n        }\n\n        if (typeof (window.IntersectionObserver) !== \"undefined\") {\n            //make sure a viewer that is becoming visible is alive\n            let intcallback = (entries, observer) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        this.resize();\n                    }\n                });\n            };\n            this.intwatcher = new window.IntersectionObserver(intcallback);\n            this.intwatcher.observe(this.container);\n        }\n\n        try {\n            if (typeof (this.callback) === \"function\")\n                this.callback(this);\n        } catch (e) {\n            // errors in callback shouldn't invalidate the viewer\n            console.log(\"error with glviewer callback: \" + e);\n        }\n\n    };\n\n    /**\n    * Return a list of objects that intersect that at the specified viewer position.\n    *\n    * @param x - x position in screen coordinates\n    * @param y - y position in screen coordinates\n    * @param {Object[]} - list of objects or selection object specifying what object to check for targeting\n    */\n    public targetedObjects(x: number, y: number, objects) {\n        var mouse = {\n            x: x,\n            y: y,\n            z: -1.0\n        };\n        if (!Array.isArray(objects)) { //assume selection object\n            objects = this.selectedAtoms(objects);\n        }\n        if (objects.length == 0) return [];\n        this.raycaster.setFromCamera(mouse, this.camera);\n        return this.raycaster.intersectObjects(this.modelGroup, objects);\n    };\n\n    /** Convert model coordinates to screen coordinates.\n     * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)\n     * @return {object | list} - and object or list of {x: screenX, y: screenY}\n     */\n    public modelToScreen(coords) {\n        let returnsingle = false;\n        if (!Array.isArray(coords)) {\n            coords = [coords];\n            returnsingle = true;\n        }\n\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n\n        let col = this.col;\n        let row = this.row;\n        let viewxoff = col * (this.WIDTH / ratioX);\n        //row is from bottom \n        let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);\n\n        let results = [];\n        let offset = this.canvasOffset();\n        coords.forEach(coord => {\n            let t = new Vector3(coord.x, coord.y, coord.z);\n            t.applyMatrix4(this.modelGroup.matrixWorld);\n            this.projector.projectVector(t, this.camera);\n            let screenX = (this.WIDTH / ratioX) * (t.x + 1) / 2.0 + offset.left + viewxoff;\n            let screenY = -(this.HEIGHT / ratioY) * (t.y - 1) / 2.0 + offset.top + viewyoff;\n            results.push({ x: screenX, y: screenY });\n        });\n        if (returnsingle) results = results[0];\n        return results;\n    };\n\n    /**\n     * For a given screen (x,y) displacement return model displacement\n     * @param{x} x displacement in screen coordinates\n     * @param{y} y displacement in screen corodinates\n     * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis\n    */\n    public screenOffsetToModel(x: number, y: number, modelz?) {\n        var dx = x / this.WIDTH;\n        var dy = y / this.HEIGHT;\n        var zpos = (modelz === undefined ? this.rotationGroup.position.z : modelz);\n        var q = this.rotationGroup.quaternion;\n        var t = new Vector3(0, 0, zpos);\n        this.projector.projectVector(t, this.camera);\n        t.x += dx * 2;\n        t.y -= dy * 2;\n        this.projector.unprojectVector(t, this.camera);\n        t.z = 0;\n        t.applyQuaternion(q);\n        return t;\n    };\n\n    /**\n     * Distance from screen coordinate to model coordinate assuming screen point\n     * is projected to the same depth as model coordinate\n     * @param{screen} xy screen coordinate\n     * @param{model} xyz model coordinate\n    */\n    public screenToModelDistance(screen: XYZ, model) {\n        let offset = this.canvasOffset();\n\n        //convert model to screen to get screen z\n        let mvec = new Vector3(model.x, model.y, model.z);\n        mvec.applyMatrix4(this.modelGroup.matrixWorld);\n        let m = mvec.clone();\n        this.projector.projectVector(mvec, this.camera);\n\n        let t = new Vector3((screen.x - offset.left) * 2 / this.WIDTH - 1, (screen.y - offset.top) * 2 / -this.HEIGHT + 1, mvec.z);\n        this.projector.unprojectVector(t, this.camera);\n\n        return t.distanceTo(m);\n    };\n\n    /**\n     * Set a callback to call when the view has potentially changed.\n     *\n    */\n    public setViewChangeCallback(callback) {\n        if (typeof (callback) === 'function' || callback == null)\n            this.viewChangeCallback = callback;\n    };\n\n    /**\n     * Set a callback to call when the view has potentially changed.\n     *\n    */\n    public setStateChangeCallback(callback) {\n        if (typeof (callback) === 'function' || callback == null)\n            this.stateChangeCallback = callback;\n    };\n\n    /**\n     * Return configuration of viewer\n     */\n    public getConfig() {\n        return this.config;\n    };\n\n    /**\n     * Set the configuration object.  Note that some settings may only\n     * have an effect at viewer creation time.\n     */\n    public setConfig(c: ViewerSpec) {\n        this.config = c;\n        if (c.ambientOcclusion) {\n            this.renderer.enableAmbientOcclusion(c.ambientOcclusion);\n        }\n    };\n\n    /**\n     * Return object representing internal state of\n     * the viewer appropriate for passing to setInternalState\n     *\n    */\n    public getInternalState() {\n        var ret = { 'models': [], 'surfaces': [], 'shapes': [], 'labels': [] };\n        for (let i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                ret.models[i] = this.models[i].getInternalState();\n            }\n        }\n\n        //todo: labels, shapes, surfaces\n\n        return ret;\n    };\n\n    /**\n     * Overwrite internal state of the viewer with passed  object\n     * which should come from getInternalState.\n     *\n    */\n    public setInternalState(state) {\n\n        //clear out current viewer\n        this.clear();\n\n        //set model state\n        var newm = state.models;\n        for (let i = 0; i < newm.length; i++) {\n            if (newm[i]) {\n                this.models[i] = new GLModel(i, undefined, this);\n                this.models[i].setInternalState(newm[i]);\n            }\n        }\n\n        //todo: labels, shapes, surfaces\n        this.render();\n    };\n\n    /**\n     * Set lower and upper limit stops for zoom.\n     *\n     * @param {lower} - limit on zoom in (positive number).  Default 0.\n     * @param {upper} - limit on zoom out (positive number).  Default infinite.\n     * @example\n      $3Dmol.get(\"data/set1_122_complex.mol2\", function(moldata) {\n            var m = viewer.addModel(moldata);\n            viewer.setStyle({stick:{colorscheme:\"Jmol\"}});\n            viewer.setZoomLimits(100,200);\n            viewer.zoomTo();\n            viewer.zoom(10); //will not zoom all the way\n            viewer.render();\n        });\n    */\n    public setZoomLimits(lower, upper) {\n        if (typeof (lower) !== 'undefined') this.config.lowerZoomLimit = lower;\n        if (upper) this.config.upperZoomLimit = upper;\n        this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        this.show();\n    };\n\n    /**\n     * Set camera parameters (distance to the origin and field of view)\n     *\n     * @param {parameters} - new camera parameters, with possible fields\n     *                       being fov for the field of view, z for the\n     *                       distance to the origin, and orthographic (boolean)\n     *                       for kind of projection (default false).\n     * @example\n      $3Dmol.get(\"data/set1_122_complex.mol2\", function(data) {\n            var m = viewer.addModel(data);\n            viewer.setStyle({stick:{}});\n            viewer.zoomTo();\n            viewer.setCameraParameters({ fov: 10 , z: 300 });\n            viewer.render();\n        });\n    */\n    public setCameraParameters(parameters) {\n        if (parameters.fov !== undefined) {\n            this.fov = parameters.fov;\n            this.camera.fov = this.fov;\n        }\n\n        if (parameters.z !== undefined) {\n            this.CAMERA_Z = parameters.z;\n            this.camera.z = this.CAMERA_Z;\n        }\n        if (parameters.orthographic !== undefined) {\n            this.camera.ortho = parameters.orthographic;\n        }\n        this.setSlabAndFog();\n    };\n\n    public _handleMouseDown(ev) {\n        ev.preventDefault();\n        if (!this.scene)\n            return;\n        var x = this.getX(ev);\n        var y = this.getY(ev);\n        if (x === undefined)\n            return;\n        this.isDragging = true;\n        this.mouseButton = ev.which;\n        this.mouseStartX = x;\n        this.mouseStartY = y;\n        this.touchHold = true;\n        this.touchDistanceStart = 0;\n        if (ev.targetTouches &&\n            ev.targetTouches.length == 2) {\n            this.touchDistanceStart = this.calcTouchDistance(ev);\n        }\n        this.cq = this.rotationGroup.quaternion.clone();\n        this.cz = this.rotationGroup.position.z;\n        this.currentModelPos = this.modelGroup.position.clone();\n        this.cslabNear = this.slabNear;\n        this.cslabFar = this.slabFar;\n\n        let self = this;\n        if (ev.targetTouches && ev.targetTouches.length === 1) {\n            this.longTouchTimeout = setTimeout(function () {\n                if (self.touchHold == true) {\n                    // console.log('Touch hold', x,y);\n                    self.glDOM = self.renderer.domElement;\n                    const touch = ev.targetTouches[0];\n                    const newEvent = new PointerEvent('contextmenu', {\n                        ...ev,\n                        pageX: touch.pageX, pageY: touch.pageY,\n                        screenX: touch.screenX, screenY: touch.screenY,\n                        clientX: touch.clientX, clientY: touch.clientY,\n                    });\n                    self.glDOM.dispatchEvent(newEvent);\n                }\n                else {\n                    // console.log('Touch hold ended earlier');\n\n                }\n            }, this.longTouchDuration);\n        }\n\n    };\n\n    public _handleMouseUp(ev) {\n        // handle touch\n        this.touchHold = false;\n\n        // handle selection\n        if (this.isDragging && this.scene) { //saw mousedown, haven't moved\n            var x = this.getX(ev);\n            var y = this.getY(ev);\n            if (this.closeEnoughForClick(ev) && this.isInViewer(x, y)) {\n                let mouse = this.mouseXY(x, y);\n                this.handleClickSelection(mouse.x, mouse.y, ev);\n            }\n        }\n\n        this.isDragging = false;\n    }\n\n    public _handleMouseScroll(ev) { // Zoom\n        ev.preventDefault();\n        if (!this.scene)\n            return;\n\n        var x = this.getX(ev);\n        var y = this.getY(ev);\n        if (x === undefined)\n            return;\n        if (!this.control_all && !this.isInViewer(x, y)) {\n            return;\n        }\n\n        var scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;\n        var mult = 1.0;\n        if (ev.ctrlKey) {\n            mult = -1.0; //this is a pinch event turned into a wheel event (or they're just holding down the ctrl)\n        }\n        if (ev.detail) {\n            this.rotationGroup.position.z += mult * scaleFactor * ev.detail / 10;\n        } else if (ev.wheelDelta) {\n            //dampen the wheelDelta since some browser/OS/mouse combinations can be quite large\n            let wd = ev.wheelDelta * 600 / (ev.wheelDelta + 600);\n            this.rotationGroup.position.z -= mult * scaleFactor * wd / 400;\n        }\n        this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        this.show();\n    };\n\n    /**\n     * Return image URI of viewer contents (base64 encoded).     *\n     */\n    public pngURI() {\n        return this.getCanvas().toDataURL('image/png');\n    };\n\n    /**\n     * Return a promise that resolves to an animated PNG image URI of\n     viewer contents (base64 encoded) for nframes of viewer changes.\n     * @return {Promise}\n     */\n    public apngURI(nframes: number) {\n        let viewer = this;\n        nframes = nframes ? nframes : 1;\n        return new Promise(function (resolve) {\n            let framecnt = 0;\n            let oldcb = viewer.viewChangeCallback;\n            let bufpromise = [];\n            let delays = [];\n            let lasttime = Date.now();\n            viewer.viewChangeCallback = function () {\n                delays.push(Date.now() - lasttime);\n                lasttime = Date.now();\n                bufpromise.push(new Promise(resolve => {\n                    viewer.getCanvas().toBlob(function (blob) {\n                        blob.arrayBuffer().then(resolve);\n                    }, \"image/png\");\n                }));\n                framecnt += 1;\n                if (framecnt == nframes) {\n                    viewer.viewChangeCallback = oldcb;\n\n                    Promise.all(bufpromise).then((buffers) => {\n                        //convert to apng\n                        let rgbas = [];\n                        //have to convert png to rgba, before creating the apng\n                        for (let i = 0; i < buffers.length; i++) {\n                            let img = decode(buffers[i]);\n                            rgbas.push(toRGBA8(img)[0]);\n                        }\n                        let width = viewer.getCanvas().width;\n                        let height = viewer.getCanvas().height;\n                        let apng = encode(rgbas, width, height, 0, delays);\n                        let blob = new Blob([apng], { type: 'image/png' });\n                        let fr = new FileReader();\n                        fr.onload = function (e) {\n                            resolve(e.target.result);\n                        };\n                        fr.readAsDataURL(blob);\n                    });\n                }\n            };\n        });\n\n    };\n\n\n    /**\n     * Return underlying canvas element.\n     */\n    public getCanvas(): HTMLCanvasElement {\n        return this.glDOM;\n    };\n\n    /**\n     * Return renderer element.\n     */\n    public getRenderer() {\n        return this.renderer;\n    };\n\n    /**\n         * Set the duration of the hover delay\n         *\n         * @param {number}\n         *            [hoverDuration] - an optional parameter that denotes\n         *            the duration of the hover delay (in milliseconds) before the hover action is called\n         *\n     */\n    public setHoverDuration(duration?: number) {\n        this.hoverDuration = duration;\n    };\n\n    private mouseXY(x, y) {\n        //convert to -1..1 coordinates\n        let offset = this.canvasOffset();\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n\n        let col = this.col;\n        let row = this.row;\n        let viewxoff = col * (this.WIDTH / ratioX);\n        //row is from bottom \n        let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);\n\n        let mouseX = ((x - offset.left - viewxoff) / (this.WIDTH / ratioX)) * 2 - 1;\n        let mouseY = -((y - offset.top - viewyoff) / (this.HEIGHT / ratioY)) * 2 + 1;\n\n        return { x: mouseX, y: mouseY };\n    }\n\n    public _handleMouseMove(ev) { // touchmove\n\n        clearTimeout(this.hoverTimeout);\n        ev.preventDefault();\n\n\n        let x = this.getX(ev);\n        let y = this.getY(ev);\n        if (x === undefined)\n            return;\n\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n\n        let mouse = this.mouseXY(x, y);\n\n        let self = this;\n        // hover timeout\n        if (this.current_hover !== null) {\n            this.handleHoverContinue(mouse.x, mouse.y);\n        }\n\n        var mode = 0;\n        if (!this.control_all && !this.isInViewer(x, y)) {\n            return;\n        }\n\n        if (!this.scene)\n            return;\n\n        if (this.hoverables.length > 0) {\n            this.hoverTimeout = setTimeout(\n                function () {\n                    self.handleHoverSelection(mouse.x, mouse.y, ev);\n                },\n                this.hoverDuration);\n        }\n\n        if (!this.isDragging)\n            return;\n\n        // Cancel longtouch timer to avoid invoking context menu if dragged away from start\n        if (ev.targetTouches && (ev.targetTouches.length > 1 ||\n            (ev.targetTouches.length === 1 && !this.closeEnoughForClick(ev)))) {\n            clearTimeout(this.longTouchTimeout);\n        }\n\n        var dx = (x - this.mouseStartX) / this.WIDTH;\n        var dy = (y - this.mouseStartY) / this.HEIGHT;\n        // check for pinch\n        if (this.touchDistanceStart != 0 &&\n            ev.targetTouches &&\n            ev.targetTouches.length == 2) {\n            var newdist = this.calcTouchDistance(ev);\n            // change to zoom\n            mode = 2;\n            dy = (newdist - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);\n        } else if (ev.targetTouches &&\n            ev.targetTouches.length == 3) {\n            // translate\n            mode = 1;\n        }\n\n        dx *= ratioX;\n        dy *= ratioY;\n        var r = Math.hypot(dx, dy);\n        var scaleFactor;\n        if (mode == 3 || (this.mouseButton == 3 && ev.ctrlKey)) { // Slab\n            this.slabNear = this.cslabNear + dx * 100;\n            this.slabFar = this.cslabFar - dy * 100;\n        } else if (mode == 2 || this.mouseButton == 3 || ev.shiftKey) { // Zoom\n            scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;\n            if (scaleFactor < 80)\n                scaleFactor = 80;\n            this.rotationGroup.position.z = this.cz + dy * scaleFactor;\n            this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        } else if (mode == 1 || this.mouseButton == 2 || ev.ctrlKey) { // Translate\n            var t = this.screenOffsetToModel(ratioX * (x - this.mouseStartX), ratioY * (y - this.mouseStartY));\n            this.modelGroup.position.addVectors(this.currentModelPos, t);\n\n        } else if ((mode === 0 || this.mouseButton == 1) && r !== 0) { // Rotate\n            var rs = Math.sin(r * Math.PI) / r;\n            this.dq.x = Math.cos(r * Math.PI);\n            this.dq.y = 0;\n            this.dq.z = rs * dx;\n            this.dq.w = -rs * dy;\n            this.rotationGroup.quaternion.set(1, 0, 0, 0);\n            this.rotationGroup.quaternion.multiply(this.dq);\n            this.rotationGroup.quaternion.multiply(this.cq);\n        }\n        this.show();\n    };\n\n    /** User specified function for handling a context menu event.\n     * Handler is passed the selected object, x and y in canvas coordinates,\n     * and original event.\n     */\n    public userContextMenuHandler: Function | null = null;\n\n    public _handleContextMenu(ev) {\n        ev.preventDefault();\n        if (this.closeEnoughForClick(ev)) {\n            var x = this.mouseStartX;\n            var y = this.mouseStartY;\n            var offset = this.canvasOffset();\n            let mouse = this.mouseXY(x, y);\n            let mouseX = mouse.x;\n            let mouseY = mouse.y;\n\n            let intersects = this.targetedObjects(mouseX, mouseY, this.contextMenuEnabledObjects);\n            var selected = null;\n            if (intersects.length) {\n                selected = intersects[0].clickable;\n            }\n\n            var offset = this.canvasOffset();\n            var x = this.mouseStartX - offset.left;\n            var y = this.mouseStartY - offset.top;\n            if (this.userContextMenuHandler) {\n                this.userContextMenuHandler(selected, x, y, intersects, ev);\n                // We've processed this as a context menu evt; ignore further mouseup / touchend.\n                // This is really for touchend after longtouch, since the mouseup for right-click\n                // occurs before the contextmenu event.\n                this.isDragging = false;\n            }\n        }\n    };\n\n\n    /**\n     * Change the viewer's container element\n     * Also useful if the original container element was removed from the DOM.\n     *\n     * @param {Object | string} element\n     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.\n\n     */\n    public setContainer(element) {\n        let elem = getElement(element) || this.container;\n        this.initContainer(elem);\n        return this;\n    };\n\n    /**\n     * Set the background color (default white)\n     *\n     * @param {number}\n     *            hex Hexcode specified background color, or standard color spec\n     * @param {number}\n     *            a Alpha level (default 1.0)\n     *\n     * @example\n     *\n     * viewer.setBackgroundColor(\"green\",0.5);\n\n\n     *\n     */\n    public setBackgroundColor(hex: ColorSpec, a: number) {\n        if (typeof (a) == \"undefined\") {\n            a = 1.0;\n        }\n        else if (a < 0 || a > 1.0) {\n            a = 1.0;\n        }\n        var c = CC.color(hex);\n        this.scene.fog.color = c;\n        this.bgColor = c.getHex();\n        this.renderer.setClearColorHex(c.getHex(), a);\n        this.show();\n\n        return this;\n    };\n\n    /**\n     * Set view projection scheme.  Either orthographic or perspective.\n     * Default is perspective.  Orthographic can also be enabled on viewer creation\n     * by setting orthographic to true in the config object.\n     *\n     *\n     * @example\n     viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n              });\n              viewer.zoomTo();\n\n              viewer.setProjection(\"orthographic\");\n              viewer.render(callback);\n          });\n     *\n     */\n    public setProjection(proj) {\n        this.camera.ortho = (proj === \"orthographic\");\n        this.setSlabAndFog();\n    };\n\n    /**\n     * Set global view styles.\n     *\n     * @example\n     *   viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n              });\n              viewer.zoomTo();\n              viewer.render(callback);\n          });\n     *\n     */\n    public setViewStyle(parameters: ViewStyle) {\n        parameters = parameters || {};\n        parameters.style = parameters.style || \"\";\n\n        if (parameters.style.includes(\"outline\")) {\n            this.renderer.enableOutline(parameters);\n        } else {\n            this.renderer.disableOutline();\n        }\n        if (parameters.style.includes(\"ambientOcclusion\")) {\n            var params: any = {};\n            if (parameters.strength) params.strength = parameters.strength;\n            if (parameters.radius) params.radius = parameters.radius;\n            this.renderer.enableAmbientOcclusion(params);\n        } else {\n            this.renderer.disableAmbientOcclusion();\n        }\n        return this;\n    };\n\n\n    private updateSize() {\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.camera.aspect = this.ASPECT;\n        this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Set viewer width independently of the HTML container.  This is probably not what you want.\n     *\n     * @param {number} w Width in pixels\n     */\n    public setWidth(w: number) {\n        this.WIDTH = w || this.WIDTH;\n        this.updateSize();\n        return this;\n    };\n\n    /**\n     * Set viewer height independently of the HTML container.  This is probably not what you want.\n     *\n     * @param {number} h Height in pixels\n     */\n    public setHeight(h: number) {\n        this.HEIGHT = h || this.HEIGHT;\n        this.updateSize();\n        return this;\n    };\n\n    /**\n     * Resize viewer according to containing HTML element's dimensions\n     *\n     */\n    public resize() {\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n        let regen = false;\n        if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0) {\n            //create new context\n            let resetcanvas = false;\n            let currentcanvas = this.container.querySelector('canvas');\n            if (currentcanvas && currentcanvas != this.renderer.getCanvas()) {\n                //canvas has been replaced, use new one\n                this.config.canvas = currentcanvas;\n            } else {\n                currentcanvas.remove(); //remove existing\n                if (this.config && this.config.canvas != undefined) {\n                    delete this.config.canvas;\n                    resetcanvas = true;\n                }\n            }\n            this.setupRenderer();\n            this.initContainer(this.container);\n            this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);\n\n            regen = true;\n            if (resetcanvas) {\n                this.config.canvas = this.renderer.getCanvas();\n            }\n        }\n        if (this.WIDTH == 0 || this.HEIGHT == 0) {\n            if (this.animated) this._viewer.pauseAnimate();\n        } else if (this.animated) {\n            this._viewer.resumeAnimate();\n        }\n        this.updateSize();\n\n        if (regen) { //restored rendere, need to regenerate scene\n            let options = this.renderer.supportedExtensions();\n            options.regen = true;\n            if (this.viewers) {\n                for (let i = 0, n = this.viewers.length; i < n; i++) {\n                    for (let j = 0, m = this.viewers[i].length; j < m; j++) {\n                        this.viewers[i][j].render(null, options);\n                    }\n                }\n            }\n            this._viewer.render(null, options);\n        } else if (this.WIDTH > 0 && this.HEIGHT > 0) {\n            this.show();\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Return specified model\n     *\n     * @param {number}\n     *            [id=last model id] - Retrieve model with specified id\n     * @default Returns last model added to viewer or null if there are no models\n     * @return {GLModel}\n     *\n     * @example // Retrieve reference to first GLModel added var m =\n     *    $3Dmol.download(\"pdb:1UBQ\",viewer,{},function(m1){\n              $3Dmol.download(\"pdb:1UBI\", viewer,{}, function(m2) {\n                viewer.zoomTo();\n                m1.setStyle({cartoon: {color:'green'}});\n                //could use m2 here as well\n                viewer.getModel().setStyle({cartoon: {color:'blue'}});\n                viewer.render();\n            })\n          });\n     */\n    public getModel(id?: number | GLModel) {\n        if (id === undefined) {\n            return this.models.length == 0 ? null : this.models[this.models.length - 1];\n        }\n        if (id instanceof GLModel) {\n            return id;\n        }\n        if (!(id in this.models)) {\n            if (this.models.length == 0)\n                return null;\n            else\n                return this.models[this.models.length - 1]; //get last model if no (or invalid) id specified\n        }\n        return this.models[id];\n    };\n\n\n    /**\n     * Continuously rotate a scene around the specified axis.\n     *\n     * Call `spin(false)` to stop spinning.\n     *\n     * @param  {string|boolean|Array} axis\n     *            [axis] - Axis (\"x\", \"y\", \"z\", \"vx\", \"vy\", or \"vz\") to rotate around.\n     *            Default \"y\".  View relative (rather than model relative) axes are prefixed with v.\n     * @param  {number} speed\n     *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative\n     *             value reverses the direction of the spin.\n     * @param {boolean} only_when_visable\n     *            [only_when_visable] - if true, will only update spin when canvas is visible\n     *\n     */\n    public spin(axis, speed: number = 1, only_when_visable: boolean = false) {\n        clearInterval(this.spinInterval);\n        if (typeof axis == 'undefined')\n            axis = 'y';\n        if (typeof axis == \"boolean\") {\n            if (!axis)\n                return;\n            else\n                axis = 'y';\n        }\n\n        if (Array.isArray(axis)) {\n            axis = { x: axis[0], y: axis[1], z: axis[2] };\n        }\n        //out of bounds check\n\n        var viewer = this;\n\n        this.spinInterval = setInterval(\n            function () {\n                if (!viewer.getCanvas().isConnected && viewer.renderer.isLost()) {\n                    clearInterval(viewer.spinInterval);\n                }\n                if (!only_when_visable || (viewer.container.checkVisibility && viewer.container.checkVisibility())) {\n                    viewer.rotate(1 * speed, axis);\n                }\n            }, 25);\n\n    };\n\n    //animate motion between current position and passed position\n    // can set some parameters to null\n    //if fixed is true will enforce the request animation, otherwise\n    //does relative updates\n    //positions objects have modelggroup position, rotation group position.z,\n    //and rotationgroup quaternion\n    //return array includes final position, but not current\n    //the returned array includes an animate method\n    private animateMotion(duration: number, fixed: boolean, mpos: Vector3, rz: number, rot: Quaternion, cam: Vector3) {\n        var interval = 20;\n        var nsteps: number = Math.ceil(duration / interval);\n        if (nsteps < 1) nsteps = 1;\n        this.incAnim();\n\n        var curr = {\n            mpos: this.modelGroup.position.clone(),\n            rz: this.rotationGroup.position.z,\n            rot: this.rotationGroup.quaternion.clone(),\n            cam: this.lookingAt.clone()\n        };\n\n        if (fixed) { //precompute path and stick to it\n            let steps = new Array(nsteps);\n            for (let i = 0; i < nsteps; i++) {\n                let frac = (i + 1) / nsteps;\n                let next: any = { mpos: curr.mpos, rz: curr.rz, rot: curr.rot };\n                next.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac).add(curr.mpos);\n                next.rz = curr.rz + frac * (rz - curr.rz);\n                next.rot = GLViewer.slerp(curr.rot, rot, frac);\n                next.cam = cam.clone().sub(curr.cam).multiplyScalar(frac).add(curr.cam);\n                steps[i] = next;\n            }\n\n            let step = 0;\n            let self = this;\n            let callback = function () {\n                var p = steps[step];\n                step += 1;\n                self.modelGroup.position = p.mpos;\n                self.rotationGroup.position.z = p.rz;\n                self.rotationGroup.quaternion = p.rot;\n                self.camera.lookAt(p.cam);\n\n                if (step < steps.length) {\n                    setTimeout(callback, interval);\n                } else {\n                    self.decAnim();\n                }\n                self.show();\n            };\n            setTimeout(callback, interval);\n\n        } else { //relative update\n            var delta: any = {};\n            let frac = 1.0 / nsteps;\n            if (mpos) {\n                delta.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac);\n            }\n            if (typeof (rz) != 'undefined' && rz != null) {\n                delta.rz = frac * (rz - curr.rz);\n            }\n            if (rot) {\n                var next = GLViewer.slerp(curr.rot, rot, frac);\n                //comptute step delta rotation\n                delta.rot = curr.rot.clone().inverse().multiply(next);\n            }\n            if (cam) {\n                delta.cam = cam.clone().sub(curr.cam).multiplyScalar(frac);\n            }\n            let step = 0.0;\n            let self = this;\n            let callback = function () {\n                step += 1;\n                if (delta.mpos) {\n                    self.modelGroup.position.add(delta.mpos);\n                }\n                if (delta.rz) {\n                    self.rotationGroup.position.z += delta.rz;\n                }\n                if (delta.rot) {\n                    self.rotationGroup.quaternion.multiply(delta.rot);\n                }\n                if (delta.cam) {\n                    self.lookingAt.add(delta.cam);\n                    self.camera.lookAt(self.lookingAt);\n                }\n\n                if (step < nsteps) {\n                    setTimeout(callback, interval);\n                } else {\n                    self.decAnim();\n                }\n                self.show();\n            };\n            setTimeout(callback, interval);\n        }\n    };\n\n    /**\n     * Rotate scene by angle degrees around axis\n     *\n     * @param {number}\n     *            [angle] - Angle, in degrees, to rotate by.\n     * @param {string}\n     *            [axis] - Axis (\"x\", \"y\", \"z\", \"vx\", \"vy\", or \"vz\") to rotate around.\n     *            Default \"y\".  View relative (rather than model relative) axes are prefixed with v.\n     *            Axis can also be specified as a vector.\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of the rotation animation. Default 0 (no animation)\n     * @param {boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {\n    viewer.setStyle({stick:{}});\n    viewer.zoomTo();\n    viewer.rotate(90,'y',1);\n    viewer.render(callback);\n    });\n\n     *\n     */\n    public rotate(angle: number, axis: any = \"y\", animationDuration: number = 0, fixedPath: boolean = false) {\n\n        if (axis == \"x\") {\n            axis = { x: 1, y: 0, z: 0 };\n        } else if (axis == \"y\") {\n            axis = { x: 0, y: 1, z: 0 };\n        } else if (axis == \"z\") {\n            axis = { x: 0, y: 0, z: 1 };\n        }\n\n        //support rotating with respect to view axis, not model\n        if (axis == \"vx\") {\n            axis = { vx: 1, vy: 0, vz: 0 };\n        } else if (axis == \"vy\") {\n            axis = { vx: 0, vy: 1, vz: 0 };\n        } else if (axis == \"vz\") {\n            axis = { vx: 0, vy: 0, vz: 1 };\n        }\n\n        if (typeof (axis.vx) !== 'undefined') {\n            var vaxis = new Vector3(axis.vx, axis.vy, axis.vz);\n            vaxis.applyQuaternion(this.rotationGroup.quaternion);\n            axis = { x: vaxis.x, y: vaxis.y, z: vaxis.z };\n        }\n\n        var qFromAngle = function (rangle) {\n            var s = Math.sin(rangle / 2.0);\n            var c = Math.cos(rangle / 2.0);\n            var i = 0, j = 0, k = 0;\n\n            i = axis.x * s;\n            j = axis.y * s;\n            k = axis.z * s;\n\n            return new Quaternion(i, j, k, c).normalize();\n        };\n\n        var rangle = Math.PI * angle / 180.0;\n        var q = qFromAngle(rangle);\n\n        if (animationDuration) {\n            var final = new Quaternion().copy(this.rotationGroup.quaternion).multiply(q);//final\n            this.animateMotion(animationDuration, fixedPath,\n                this.modelGroup.position,\n                this.rotationGroup.position.z,\n                final,\n                this.lookingAt);\n        } else { //not animated\n            this.rotationGroup.quaternion.multiply(q);\n            this.show();\n        }\n        return this;\n\n    };\n\n    public surfacesFinished() {\n        for (var key in this.surfaces) {\n            if (!this.surfaces[key][0].done) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /** Returns an array representing the current viewpoint.\n     * Translation, zoom, and rotation quaternion.\n     * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]\n     *  */\n    public getView() {\n        if (!this.modelGroup)\n            return [0, 0, 0, 0, 0, 0, 0, 1];\n        var pos = this.modelGroup.position;\n        var q = this.rotationGroup.quaternion;\n        return [pos.x, pos.y, pos.z, this.rotationGroup.position.z, q.x, q.y,\n        q.z, q.w];\n    };\n\n    /** Sets the view to the specified translation, zoom, and rotation.\n     *\n     * @param {Array.<number>} arg Array formatted identically to the return value of getView */\n    public setView(arg, nolink?) {\n\n        if (arg === undefined ||\n            !(arg instanceof Array || arg.length !== 8))\n            return this;\n\n        if (!this.modelGroup || !this.rotationGroup)\n            return this;\n        this.modelGroup.position.x = arg[0];\n        this.modelGroup.position.y = arg[1];\n        this.modelGroup.position.z = arg[2];\n        this.rotationGroup.position.z = arg[3];\n        this.rotationGroup.quaternion.x = arg[4];\n        this.rotationGroup.quaternion.y = arg[5];\n        this.rotationGroup.quaternion.z = arg[6];\n        this.rotationGroup.quaternion.w = arg[7];\n        if (typeof (arg[8]) != \"undefined\") {\n            this.rotationGroup.position.x = arg[8];\n            this.rotationGroup.position.y = arg[9];\n        }\n\n        this.show(nolink);\n        return this;\n\n    };\n\n    // apply styles, models, etc in viewer\n    /**\n     * Render current state of viewer, after\n     * adding/removing models, applying styles, etc.\n     *\n     */\n    public render(callback?, exts?) {\n        this.renderer.setViewport();\n        this.updateClickables(); //must render for clickable styles to take effect\n        var view = this.getView();\n\n        if (this.stateChangeCallback) {\n            //todo: have ability to only send delta updates\n            this.stateChangeCallback(this.getInternalState());\n        }\n\n        var i, n;\n        if (!exts) exts = this.renderer.supportedExtensions();\n        for (i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                this.models[i].globj(this.modelGroup, exts);\n            }\n        }\n\n        for (i = 0; i < this.shapes.length; i++) {\n            if (this.shapes[i]) { //exists\n                if ((typeof (this.shapes[i].frame) === 'undefined' || this.viewer_frame < 0 ||\n                    this.shapes[i].frame < 0 || this.shapes[i].frame == this.viewer_frame)) {\n                    this.shapes[i].globj(this.modelGroup, exts);\n                } else { //should not be displayed in current frame\n                    this.shapes[i].removegl(this.modelGroup);\n                }\n            }\n        }\n\n        for (i = 0; i < this.labels.length; i++) {\n            if (exts.regen) {\n                this.labels[i].dispose();\n                this.modelGroup.remove(this.labels[i].sprite);\n                this.labels[i].setContext();\n                this.modelGroup.add(this.labels[i].sprite);\n            }\n            if (this.labels[i] && typeof (this.labels[i].frame) != 'undefined' && this.labels[i].frame >= 0) { //exists and has frame specifier\n                this.modelGroup.remove(this.labels[i].sprite);\n                if (this.viewer_frame < 0 || this.labels[i].frame == this.viewer_frame) {\n                    this.modelGroup.add(this.labels[i].sprite);\n                }\n            }\n        }\n\n        for (i in this.surfaces) { // this is an object with possible holes\n            if (!this.surfaces.hasOwnProperty(i)) continue;\n            var surfArr = this.surfaces[i];\n            for (n = 0; n < surfArr.length; n++) {\n                if (surfArr.hasOwnProperty(n)) {\n                    var geo = surfArr[n].geo;\n                    // async surface generation can cause\n                    // the geometry to be webgl initialized before it is fully\n                    // formed; force various recalculations until full surface\n                    // is available\n                    if (!surfArr[n].finished || exts.regen) {\n                        geo.verticesNeedUpdate = true;\n                        geo.elementsNeedUpdate = true;\n                        geo.normalsNeedUpdate = true;\n                        geo.colorsNeedUpdate = true;\n                        geo.buffersNeedUpdate = true;\n                        surfArr[n].mat.needsUpdate = true;\n\n                        if (surfArr[n].done) {\n                            surfArr[n].finished = true;\n                        }\n\n                        // remove partially rendered surface\n                        if (surfArr[n].lastGL)\n                            this.modelGroup.remove(surfArr[n].lastGL);\n\n                        // create new surface\n                        var smesh = null;\n\n                        if (surfArr[n].mat instanceof LineBasicMaterial) {\n                            //special case line meshes\n                            smesh = new Line(geo, surfArr[n].mat);\n                        }\n                        else {\n                            if ('wireframe' in surfArr.style && surfArr.style.wireframe) {\n                                geo.setUpWireframe();\n                            }\n                            smesh = new Mesh(geo, surfArr[n].mat);\n                        }\n                        if (surfArr[n].mat.transparent && surfArr[n].mat.opacity == 0) {\n                            //don't bother with hidden surfaces\n                            smesh.visible = false;\n                        } else {\n                            smesh.visible = true;\n                        }\n                        if (surfArr[n].symmetries.length > 1 ||\n                            (surfArr[n].symmetries.length == 1 &&\n                                !(surfArr[n].symmetries[0].isIdentity()))) {\n                            var j;\n                            var tmeshes = new Object3D(); //transformed meshes\n                            for (j = 0; j < surfArr[n].symmetries.length; j++) {\n                                var tmesh = smesh.clone();\n                                tmesh.matrix = surfArr[n].symmetries[j];\n                                tmesh.matrixAutoUpdate = false;\n                                tmeshes.add(tmesh);\n                            }\n                            surfArr[n].lastGL = tmeshes;\n                            this.modelGroup.add(tmeshes);\n                        }\n                        else {\n                            surfArr[n].lastGL = smesh;\n                            this.modelGroup.add(smesh);\n                        }\n                    } // else final surface already there\n                }\n            }\n        }\n\n        this.setView(view); // Calls show() => renderer render\n        if (typeof callback === 'function') {\n            callback(this);\n        }\n        return this;\n    };\n\n    /* @param {AtomSelectionSpec|any} sel\n     * @return list of models specified by sel\n     */\n    private getModelList(sel: any): GLModel[] {\n        let ms: GLModel[] = [];\n        if (typeof sel === 'undefined' || typeof sel.model === \"undefined\") {\n            for (let i = 0; i < this.models.length; i++) {\n                if (this.models[i])\n                    ms.push(this.models[i]);\n            }\n        } else { // specific to some models\n            let selm: any = sel.model;\n            if (!Array.isArray(selm))\n                selm = [selm];\n\n            for (let i = 0; i < selm.length; i++) {\n                //allow referencing models by order of creation\n                if (typeof selm[i] === 'number') {\n                    var index = selm[i];\n                    //support python backward indexing\n                    if (index < 0) index += this.models.length;\n                    ms.push(this.models[index]);\n                } else {\n                    ms.push(selm[i]);\n                }\n            }\n        }\n\n        return ms;\n    }\n    /**\n     *\n     * @param {AtomSelectionSpec}\n     *            sel\n     * @return {AtomSpec[]}\n     */\n    private getAtomsFromSel(sel: AtomSelectionSpec): AtomSpec[] {\n        var atoms = [];\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n\n        var ms = this.getModelList(sel);\n\n        for (let i = 0; i < ms.length; i++) {\n            atoms = atoms.concat(ms[i].selectedAtoms(sel));\n        }\n\n        return atoms;\n    }\n\n    /**\n     *\n     * @param {AtomSpec}\n     *            atom\n     * @param {AtomSelectionSpec}\n     *            sel\n     * @return {boolean}\n     */\n    private atomIsSelected(atom: AtomSpec, sel: AtomSelectionSpec) {\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n\n        var ms = this.getModelList(sel);\n\n        for (var i = 0; i < ms.length; i++) {\n            if (ms[i].atomIsSelected(atom, sel))\n                return true;\n        }\n\n        return false;\n    }\n\n\n    /** return list of atoms selected by sel\n     *\n     * @param {AtomSelectionSpec} sel\n     * @return {AtomSpec[]}\n     */\n    public selectedAtoms(sel: AtomSelectionSpec): AtomSpec[] {\n        return this.getAtomsFromSel(sel);\n    };\n\n    /**\n    * Returns valid values for the specified attribute in the given selection\n    * @param {string} attribute\n    * @param {AtomSelectionSpec} sel\n    * @return {Array.<Object>}\n    *\n    */\n    public getUniqueValues(attribute: string, sel?: AtomSelectionSpec) {\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n        var atoms = this.getAtomsFromSel(sel);\n        var values = {};\n\n        for (var atom in atoms) {\n            if (atoms[atom].hasOwnProperty(attribute)) {\n                var value = atoms[atom][attribute];\n                values[value] = true;\n            }\n        }\n\n        return Object.keys(values);\n    };\n\n    /**\n     * Return pdb output of selected atoms (if atoms from pdb input)\n     *\n     * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer\n     * @return {string} PDB string of selected atoms\n     */\n    public pdbData(sel: AtomSelectionSpec) {\n        var atoms = this.getAtomsFromSel(sel);\n        var ret = \"\";\n        for (var i = 0, n = atoms.length; i < n; ++i) {\n            ret += atoms[i].pdbline + \"\\n\";\n        }\n        return ret;\n    };\n\n\n    /**\n     * Zoom current view by a constant factor\n     *\n     * @param {number}\n     *            [factor] - Magnification factor. Values greater than 1\n     *            will zoom in, less than one will zoom out. Default 2.\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation\n     * @example\n    $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo()\n    viewer.zoom(2,1000);\n    viewer.render();\n    });\n\n         */\n    public zoom(factor: number = 2, animationDuration: number = 0, fixedPath: boolean = false) {\n        var scale = (this.CAMERA_Z - this.rotationGroup.position.z) / factor;\n        var final_z = this.CAMERA_Z - scale;\n\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath,\n                this.modelGroup.position,\n                this.adjustZoomToLimits(final_z),\n                this.rotationGroup.quaternion,\n                this.lookingAt);\n        } else { //no animation\n            this.rotationGroup.position.z = this.adjustZoomToLimits(final_z);\n            this.show();\n        }\n        return this;\n    };\n\n    /**\n     * Translate current view by x,y screen coordinates\n     * This pans the camera rather than translating the model.\n     *\n     * @param {number} x Relative change in view coordinates of camera\n     * @param {number} y Relative change in view coordinates of camera\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.translate(200,50);\n    viewer.rotate(90,'z');\n    viewer.render(callback);\n    });\n     */\n    public translate(x: number, y: number, animationDuration: number = 0, fixedPath: boolean = false) {\n        var dx = x / this.WIDTH;\n        var dy = y / this.HEIGHT;\n        var v = new Vector3(0, 0, -this.CAMERA_Z);\n\n        this.projector.projectVector(v, this.camera);\n        v.x -= dx;\n        v.y -= dy;\n        this.projector.unprojectVector(v, this.camera);\n        v.z = 0;\n\n        var final_position = this.lookingAt.clone().add(v);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath,\n                this.modelGroup.position,\n                this.rotationGroup.position.z,\n                this.rotationGroup.quaternion,\n                final_position);\n        } else { //no animation\n            this.lookingAt = final_position;\n            this.camera.lookAt(this.lookingAt);\n            this.show();\n        }\n        return this;\n    };\n\n    /**\n     * Translate current models by x,y screen coordinates\n     * This translates the models relative to the current view. It does\n     * not change the center of rotation.\n     *\n     * @param {number} x Relative change in x screen coordinate\n     * @param {number} y Relative change in y screen coordinate\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.translateScene(200,50);\n    viewer.rotate(90,'z'); // will no longer be around model center\n    viewer.render(callback);\n    });\n     */\n    public translateScene(x: number, y: number, animationDuration: number = 0, fixedPath = false) {\n\n        var t = this.screenOffsetToModel(x, y);\n        var final_position = this.modelGroup.position.clone().add(t);\n\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath,\n                this.modelGroup.position,\n                this.rotationGroup.position.z,\n                this.rotationGroup.quaternion,\n                this.lookingAt);\n        } else { //no animation\n            this.modelGroup.position = final_position;\n            this.show();\n        }\n        return this;\n    };\n\n    /**\n     * Adjust slab to fully enclose selection (default everything).\n     *\n     * @param {AtomSelectionSpec} sel\n     *            Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     * @example\n            $3Dmol.get('data/1jpy.cif', function(data) {\n              let m = viewer.addModel(data);\n              viewer.setStyle('stick');\n              viewer.zoomTo({resn:'NAG',chain:'B'});\n              viewer.fitSlab({resn:'NAG',chain:'B'});\n              viewer.render();\n    });\n     */\n    public fitSlab(sel: AtomSelectionSpec) {\n        sel = sel || {};\n        var atoms = this.getAtomsFromSel(sel);\n        var tmp = getExtent(atoms);\n\n        // fit to bounding box\n        var x = tmp[1][0] - tmp[0][0],\n            y = tmp[1][1] - tmp[0][1],\n            z = tmp[1][2] - tmp[0][2];\n\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n\n        return this;\n    };\n\n    /**\n     * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).\n     *\n     * @param {AtomSelectionSpec}\n     *            [sel] - Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example // if the user were to pass the animationDuration value to\n     *           // the function like so viewer.zoomTo({resn:'STI'},1000);\n     *         //   the program would center on resn 'STI' over the course\n     *         //   of 1 second(1000 milleseconds).\n     *  // Reposition to centroid of all atoms of all models in this\n     * //viewer glviewer.center();\n    $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.center();\n    viewer.render(callback);\n    });\n     */\n    public center(sel: AtomSelectionSpec = {}, animationDuration: number = 0, fixedPath: boolean = false) {\n        var allatoms, alltmp;\n        var atoms = this.getAtomsFromSel(sel);\n        var tmp = getExtent(atoms);\n\n        if (isEmptyObject(sel)) {\n            //include shapes when zooming to full scene\n            //TODO: figure out a good way to specify shapes as part of a selection\n            this.shapes.forEach((shape) => {\n                if (shape && shape.boundingSphere && shape.boundingSphere.center) {\n                    var c = shape.boundingSphere.center;\n                    var r = shape.boundingSphere.radius;\n                    if (r > 0) {\n                        //make sure full shape is visible\n                        atoms.push(new Vector3(c.x + r, c.y, c.z));\n                        atoms.push(new Vector3(c.x - r, c.y, c.z));\n                        atoms.push(new Vector3(c.x, c.y + r, c.z));\n                        atoms.push(new Vector3(c.x, c.y - r, c.z));\n                        atoms.push(new Vector3(c.x, c.y, c.z + r));\n                        atoms.push(new Vector3(c.x, c.y, c.z - r));\n                    } else {\n                        atoms.push(c);\n                    }\n                }\n            });\n            tmp = getExtent(atoms);\n            allatoms = atoms;\n            alltmp = tmp;\n\n        }\n        else {\n            allatoms = this.getAtomsFromSel({});\n            alltmp = getExtent(allatoms);\n        }\n\n        // use selection for center\n        var center = new Vector3(tmp[2][0], tmp[2][1], tmp[2][2]);\n\n        // but all for bounding box\n        var x = alltmp[1][0] - alltmp[0][0], y = alltmp[1][1] -\n            alltmp[0][1], z = alltmp[1][2] - alltmp[0][2];\n\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n\n        // for zoom, use selection box\n        x = tmp[1][0] - tmp[0][0];\n        y = tmp[1][1] - tmp[0][1];\n        z = tmp[1][2] - tmp[0][2];\n        maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n\n        //find the farthest atom from center to get max distance needed for view\n        var maxDsq = 25;\n        for (var i = 0; i < atoms.length; i++) {\n            if (atoms[i]) {\n                var dsq = center.distanceToSquared(atoms[i] as XYZ);\n                if (dsq > maxDsq)\n                    maxDsq = dsq;\n            }\n        }\n\n        maxD = Math.sqrt(maxDsq) * 2;\n        var finalpos = center.clone().multiplyScalar(-1);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath,\n                finalpos,\n                this.rotationGroup.position.z,\n                this.rotationGroup.quaternion,\n                this.lookingAt);\n        } else { //no animation\n            this.modelGroup.position = finalpos;\n            this.show();\n        }\n        return this;\n    };\n\n    /**\n     * Zoom to center of atom selection.  The slab will be set appropriately for\n     * the selection, unless an empty selection is provided, in which case there will be no slab.\n     *\n     * @param {Object}\n     *            [sel] - Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n      * @example\n\n\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n          viewer.zoomTo();\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {\n                      opacity:0.85,\n                      voldata: new $3Dmol.VolumeData(volumedata, \"cube\"),\n                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))\n                  },{});\n\n              viewer.render();\n              });\n            });\n     */\n    public zoomTo(sel: AtomSelectionSpec = {}, animationDuration: number = 0, fixedPath: boolean = false) {\n        let atoms = this.getAtomsFromSel(sel);\n        let atombox = getExtent(atoms);\n        let allbox = atombox;\n\n        if (isEmptyObject(sel)) {\n            //include shapes when zooming to full scene\n            //TODO: figure out a good way to specify shapes as part of a selection\n            let natoms = atoms && atoms.length;\n            this.shapes.forEach((shape) => {\n                if (shape && shape.boundingSphere) {\n                    if (shape.boundingSphere.box) {\n                        let box = shape.boundingSphere.box;\n                        atoms.push(new Vector3(box.min.x, box.min.y, box.min.z));\n                        atoms.push(new Vector3(box.max.x, box.max.y, box.max.z));\n                    } else if (shape.boundingSphere.center) {\n                        var c = shape.boundingSphere.center;\n                        var r = shape.boundingSphere.radius;\n                        if (r > 0) {\n                            //make sure full shape is visible\n                            atoms.push(new Vector3(c.x + r, c.y, c.z));\n                            atoms.push(new Vector3(c.x - r, c.y, c.z));\n                            atoms.push(new Vector3(c.x, c.y + r, c.z));\n                            atoms.push(new Vector3(c.x, c.y - r, c.z));\n                            atoms.push(new Vector3(c.x, c.y, c.z + r));\n                            atoms.push(new Vector3(c.x, c.y, c.z - r));\n                        } else {\n                            atoms.push(c);\n                        }\n                    }\n                }\n            });\n            allbox = getExtent(atoms);\n            if (!natoms) { //if no atoms, use shapes for center\n                for (let i = 0; i < 3; i++) { //center of bounding box\n                    atombox[2][i] = (allbox[0][i] + allbox[1][i]) / 2;\n                }\n            }\n        } else { //include all atoms in slab calculation\n            let allatoms = this.getAtomsFromSel({});\n            allbox = getExtent(allatoms);\n        }\n\n        // use selection for center\n        var center = new Vector3(atombox[2][0], atombox[2][1], atombox[2][2]);\n\n        // but all for bounding box\n        var x = allbox[1][0] - allbox[0][0], y = allbox[1][1]\n            - allbox[0][1], z = allbox[1][2] - allbox[0][2];\n\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n\n        //if we are selecting everything, have ver permissive slab\n        //can't do \"infinity\" size since this will break orthographic\n        if (Object.keys(sel).length === 0) {\n            this.slabNear = Math.min(-maxD * 2, -50);\n            this.slabFar = Math.max(maxD * 2, 50);\n        }\n\n        // keep at least this much space in view\n        var MAXD = this.config.minimumZoomToDistance || 5;\n        // for zoom, use selection box\n        x = atombox[1][0] - atombox[0][0];\n        y = atombox[1][1] - atombox[0][1];\n        z = atombox[1][2] - atombox[0][2];\n        maxD = Math.hypot(x, y, z);\n        if (maxD < MAXD)\n            maxD = MAXD;\n\n        //find the farthest atom from center to get max distance needed for view\n        var maxDsq = MAXD * MAXD;\n        for (var i = 0; i < atoms.length; i++) {\n            if (atoms[i]) {\n                var dsq = center.distanceToSquared(atoms[i] as XYZ);\n                if (dsq > maxDsq)\n                    maxDsq = dsq;\n            }\n        }\n\n        maxD = Math.sqrt(maxDsq) * 2;\n        var finalpos = center.clone().multiplyScalar(-1);\n        var finalz = -(maxD * 0.5\n            / Math.tan(Math.PI / 180.0 * this.camera.fov / 2) - this.CAMERA_Z);\n\n        finalz = this.adjustZoomToLimits(finalz);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath,\n                finalpos,\n                finalz,\n                this.rotationGroup.quaternion,\n                this.lookingAt);\n        } else {\n            this.modelGroup.position = finalpos;\n            this.rotationGroup.position.z = finalz;\n            this.show();\n        }\n        return this;\n\n    };\n\n    /**\n     * Set slab of view (contents outside of slab are clipped).\n     * Must call render to update.\n     *\n     * @param {number} near near clipping plane distance\n     * @param {number} far far clipping plane distance\n     */\n    public setSlab(near: number, far: number) {\n        this.slabNear = near;\n        this.slabFar = far;\n    };\n\n    /**\n     * Get slab of view (contents outside of slab are clipped).\n     *\n     * @return {Object}\n     *      @property {number} near - near clipping plane distance\n     *      @property {number} far - far clipping plane distance\n     */\n    public getSlab() {\n        return { near: this.slabNear, far: this.slabFar };\n    };\n\n    /**\n     * Add label to viewer\n     *\n     * @param {string}\n     *            text - Label text\n     * @param {LabelSpec}\n     *            options - Label style specification\n      @param {AtomSelection}\n     *            sel - Set position of label to center of this selection\n     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient\n     * @return {Label}\n     *\n     * @example\n     *  $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n\n              viewer.addLabel(\"Aromatic\", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});\n              viewer.addLabel(\"Label\",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,\n                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,\n                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});\n              viewer.setStyle({chain:'A'},{cross:{hidden:true}});\n              viewer.setStyle({chain:'B'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  colorscheme:'greenCarbon'}});\n              viewer.setStyle({chain:'C'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  radius:0.5}});\n              viewer.setStyle({chain:'D'},{cross:{hidden:false,\n                                                  linewidth:10.0}});\n              viewer.setStyle({chain:'E'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  color:'black'}});\n\n              viewer.render();\n\n\n            });\n\n     */\n    public addLabel(text: string, options: LabelSpec = {}, sel?: AtomSelectionSpec, noshow: boolean = false) {\n        if (sel) {\n            var extent = getExtent(this.getAtomsFromSel(sel));\n            options.position = { x: extent[2][0], y: extent[2][1], z: extent[2][2] };\n        }\n        var label = new Label(text, options);\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.labels.push(label);\n\n        if (!noshow) this.show();\n        return label;\n    };\n\n\n\n    /** Add residue labels.  This will generate one label per a\n     * residue within the selected atoms.  The label will be at the\n     * centroid of the atoms and styled according to the passed style.\n     * The label text will be [resn][resi]\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     * @param {boolean} byframe - if true, create labels for every individual frame, not just current\n     *\n     * @example\n         $3Dmol.download(\"mmtf:2ll5\",viewer,{},function(){\n              viewer.setStyle({stick:{radius:0.15},cartoon:{}});\n              viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    public addResLabels(sel: AtomSelectionSpec, style: LabelSpec, byframe: boolean = false) {\n        let start = this.labels.length;\n        this.applyToModels(\"addResLabels\", sel, style, byframe);\n        this.show();\n        return this.labels.slice(start);\n    };\n\n    /** Add property labels.  This will generate one label per a selected\n     * atom at the atom's coordinates with the property value as the label text.\n     *\n     * @param {string} prop - property name\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     *\n     * * @example\n         $3Dmol.download(\"cid:5291\",viewer,{},function(){\n              viewer.setStyle({stick: {radius:.2}});\n              viewer.addPropertyLabels(\"index\",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    public addPropertyLabels(prop: string, sel: AtomSelectionSpec, style: LabelSpec) {\n        this.applyToModels(\"addPropertyLabels\", prop, sel, style);\n        this.show();\n        return this;\n    };\n\n    /**\n     * Remove label from viewer\n     *\n     * @param {Label} label - $3Dmol label\n     *\n     * @example // Remove labels created in\n     $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n              var toremove = viewer.addLabel(\"Aromatic\", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});\n              viewer.addLabel(\"Label\",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,\n                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,\n                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});\n              viewer.removeLabel(toremove);\n              viewer.render();\n\n\n            });\n\n     */\n    public removeLabel(label: Label) {\n        //todo: don't do the linear search\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i] == label) {\n                this.labels.splice(i, 1);\n                label.dispose();\n                this.modelGroup.remove(label.sprite);\n                break;\n            }\n        }\n        this.show();\n        return this;\n    };\n\n    /**\n     * Remove all labels from viewer\n     *\n     *         @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.addResLabels();\n           viewer.setStyle({},{stick:{}});\n           viewer.render( ); //show labels\n\n           viewer.removeAllLabels();\n           viewer.render(); //hide labels\n    });\n     */\n    public removeAllLabels() {\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i] && this.labels[i].sprite) {\n                this.modelGroup.remove(this.labels[i].sprite);\n            }\n        }\n        this.labels.splice(0, this.labels.length); //don't overwrite in case linked\n        this.show();\n        return this;\n    };\n\n    /**\n     * Hide all labels in viewer\n     *\n     *         @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.addResLabels();\n           viewer.setStyle({},{stick:{}});\n           viewer.render( ); //show labels\n\n           viewer.hideAllLabels();\n           viewer.render(); //hide labels\n    });\n     */\n    public hideAllLabels() {\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i]) {\n                this.labels[i].hide();\n            }\n        }\n        this.show();\n        return this;\n    };\n\n    /**\n     * Show all labels in viewer\n     *\n     *         @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.addLabel(\"Hello World\",{position:{x:10,y:0,z:0},backgroundColor: \"blue\",useScreen: true, fontSize: 64})\n           viewer.setStyle({},{stick:{}});\n           viewer.render( ); //show labels\n\n           viewer.hideAllLabels();\n           viewer.showAllLabels();\n           viewer.render(); //hide labels\n    });\n     */\n    public showAllLabels() {\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i]) {\n                this.labels[i].show();\n            }\n        }\n        this.show();\n        return this;\n    };\n\n    // Modify label style\n    /**\n     * Modify existing label's style\n     *\n     * @param {Label} label - $3Dmol label\n     * @param {LabelSpec}\n     *            stylespec - Label style specification\n     * @return {Label}\n     */\n    public setLabelStyle(label: Label, stylespec: LabelSpec) {\n        this.modelGroup.remove(label.sprite);\n        label.dispose();\n        label.stylespec = stylespec;\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.show();\n        return label;\n\n    };\n\n    // Change label text\n    /**\n     * Modify existing label's text\n     *\n     * @param {Label}  label - $3Dmol label\n     * @param {String}\n     *            text - Label text\n     * @return {Label}\n     */\n    public setLabelText(label: Label, text: string) {\n        this.modelGroup.remove(label.sprite);\n        label.dispose();\n        label.text = text;\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.show();\n        return label;\n\n    };\n\n    /**\n     * Add shape object to viewer\n     * @see {GLShape}\n     *\n     * @param {ShapeSpec} shapeSpec - style specification for label\n     * @return {GLShape}\n     */\n    public addShape(shapeSpec: ShapeSpec) {\n        shapeSpec = shapeSpec || {};\n        var shape = new GLShape(shapeSpec);\n        shape.shapePosition = this.shapes.length;\n        this.shapes.push(shape);\n\n        return shape;\n    };\n\n    /**\n     * Remove shape object from viewer\n     *\n     * @param {GLShape} shape - Reference to shape object to remove\n     */\n    public removeShape(shape: GLShape) {\n        if (!shape)\n            return this;\n        shape.removegl(this.modelGroup);\n        delete this.shapes[shape.shapePosition];\n        // clear off back of model array\n        while (this.shapes.length > 0\n            && typeof (this.shapes[this.shapes.length - 1]) === \"undefined\")\n            this.shapes.pop();\n        return this;\n    };\n\n    /**\n     * Remove all shape objects from viewer\n     */\n    public removeAllShapes() {\n        for (var i = 0; i < this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            if (shape) shape.removegl(this.modelGroup);\n        }\n        this.shapes.splice(0, this.shapes.length);\n        return this;\n    };\n\n    //gets the center of the selection\n    private getSelectionCenter(spec: AtomSelectionSpec): XYZ {\n        if (spec.hasOwnProperty(\"x\") && spec.hasOwnProperty(\"y\") && spec.hasOwnProperty(\"z\"))\n            return spec as XYZ;\n        var atoms = this.getAtomsFromSel(spec);\n        if (atoms.length == 0)\n            return { x: 0, y: 0, z: 0 };\n\n        var extent = getExtent(atoms);\n        return { x: extent[0][0] + (extent[1][0] - extent[0][0]) / 2, y: extent[0][1] + (extent[1][1] - extent[0][1]) / 2, z: extent[0][2] + (extent[1][2] - extent[0][2]) / 2 };\n    };\n\n    /**\n     * Create and add sphere shape. This method provides a shorthand\n     * way to create a spherical shape object\n     *\n     * @param {SphereShapeSpec} spec - Sphere shape style specification\n     * @return {GLShape}\n     @example\n\n     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n\n     viewer.render();\n     */\n    public addSphere(spec: SphereSpec) {\n        spec = spec || {};\n\n        spec.center = this.getSelectionCenter(spec.center);\n\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addSphere(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    };\n\n    /**\n     * Create and add box shape. This method provides a shorthand\n     * way to create a box shape object\n     *\n     * @param {BoxSpec} spec - Box shape style specification\n     * @return {GLShape}\n     @example\n\n     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});\n     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});\n     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});\n\n     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});\n     viewer.zoomTo();\n     viewer.rotate(45, {x:1,y:1,z:1});\n     viewer.render();\n     */\n    public addBox(spec: BoxSpec = {}) {\n\n        if (spec.corner != undefined) {\n            spec.corner = this.getSelectionCenter(spec.corner);\n        }\n        if (spec.center != undefined) {\n            spec.center = this.getSelectionCenter(spec.center);\n        }\n\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addBox(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n    /**\n     * Create and add arrow shape\n     *\n     * @param {ArrowSpec} spec - Style specification\n     * @return {GLShape}\n     @example\n    $3Dmol.download(\"pdb:4DM7\",viewer,{},function(){\n\n              viewer.setBackgroundColor(0xffffffff);\n              viewer.addArrow({\n                  start: {x:-10.0, y:0.0, z:0.0},\n                  end: {x:0.0, y:-10.0, z:0.0},\n                  radius: 1.0,\n                  radiusRadio:1.0,\n                  mid:1.0,\n                  clickable:true,\n                  callback:function(){\n                      this.color.setHex(0xFF0000FF);\n                      viewer.render( );\n                  }\n              });\n              viewer.render();\n            });\n     */\n    public addArrow(spec: ArrowSpec = {}) {\n\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addArrow(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n    /**\n     * Create and add cylinder shape\n     *\n     * @param {CylinderSpec} spec - Style specification\n     * @return {GLShape}\n\n      @example\n     viewer.setBackgroundColor(0xffffffff);\n          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},\n                              end:{x:10.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              fromCap:1,\n                              toCap:2,\n                              color:'red',\n                              hoverable:true,\n                              clickable:true,\n                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},\n                              hover_callback: function(){ viewer.render( );},\n                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}\n                             });\n          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},\n                              end:{x:0.0,y:10.0,z:0.0},\n                              radius:0.5,\n                              fromCap:false,\n                              toCap:true,\n                              color:'teal'});\n          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},\n                              end:{x:20.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              color:'black',\n                              fromCap:false,\n                              toCap:false});\n          viewer.render();\n     */\n    public addCylinder(spec: CylinderSpec = {}) {\n\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        if (spec.dashed)\n            s.addDashedCylinder(spec);\n        else\n            s.addCylinder(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n    /**\n     * Create and add Curve shape\n     *\n     * @param {CurveSpec} spec - Style specification\n     * @return {GLShape}\n\n     @example\n          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],\n                              radius:0.5,\n                              smooth: 10,\n                              fromArrow:false,\n                              toArrow: true,\n                              color:'orange',\n                              });\n          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],\n                              radius:1,\n                              fromArrow:true,\n                              toArrow: false,\n                              color:'purple',\n                              });\n          viewer.zoomTo();\n          viewer.render();\n     */\n    public addCurve(spec: CurveSpec = {}) {\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addCurve(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n\n    /**\n     * Create and add line shape\n     *\n     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength\n     * @return {GLShape}\n     @example\n     $3Dmol.download(\"pdb:2ABJ\",viewer,{},function(){\n\n              viewer.setViewStyle({style:\"outline\"});\n              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});\n              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});\n              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});\n              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});\n              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});\n              viewer.render();\n          });\n\n     */\n    public addLine(spec: LineSpec = {}) {\n\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n\n        spec.wireframe = true;\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        if (spec.dashed)\n            s = this.addLineDashed(spec, s);\n        else\n            s.addLine(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n\n    /**\n     * Create and add unit cell visualization.\n     *\n     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n     * @param {UnitCellStyleSpec} spec - visualization style\n       @example\n\n            $3Dmol.get('data/1jpy.cif', function(data) {\n              let m = viewer.addModel(data);\n              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});\n              viewer.zoomTo();\n              viewer.render();\n    });\n     */\n    public addUnitCell(model?: GLModel | number, spec?: UnitCellStyleSpec) {\n        model = this.getModel(model);\n        spec = spec || { alabel: 'a', blabel: 'b', clabel: 'c' };\n\n        spec.box = spec.box || {};\n        spec.astyle = spec.astyle || { color: 'red', radius: 0.1, midpos: -1 };\n        spec.bstyle = spec.bstyle || { color: 'green', radius: 0.1, midpos: -1 };\n        spec.cstyle = spec.cstyle || { color: 'blue', radius: 0.1, midpos: -1 };\n        spec.alabelstyle = spec.alabelstyle || { fontColor: 'red', showBackground: false, alignment: 'center', inFront: false };\n        spec.blabelstyle = spec.blabelstyle || { fontColor: 'green', showBackground: false, alignment: 'center', inFront: false };\n        spec.clabelstyle = spec.clabelstyle || { fontColor: 'blue', showBackground: false, alignment: 'center', inFront: false };\n\n        //clear any previous box\n        if (model.unitCellObjects) {\n            this.removeUnitCell(model);\n        }\n        model.unitCellObjects = { shapes: [], labels: [] };\n        //calculate points\n        var data = model.getCrystData();\n        var matrix = null;\n        if (data) {\n\n            if (data.matrix) {\n                matrix = data.matrix;\n            } else {\n                var a = data.a, b = data.b, c = data.c, alpha = data.alpha, beta = data.beta, gamma = data.gamma;\n                alpha = alpha * Math.PI / 180.0;\n                beta = beta * Math.PI / 180.0;\n                gamma = gamma * Math.PI / 180.0;\n\n                var u, v, w;\n\n                u = Math.cos(beta);\n                v = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);\n                w = Math.sqrt(Math.max(0, 1 - u * u - v * v));\n\n                matrix = new Matrix3(a, b * Math.cos(gamma), c * u,\n                    0, b * Math.sin(gamma), c * v,\n                    0, 0, c * w);\n            }\n\n            var points = [new Vector3(0, 0, 0),\n            new Vector3(1, 0, 0),\n            new Vector3(0, 1, 0),\n            new Vector3(0, 0, 1),\n            new Vector3(1, 1, 0),\n            new Vector3(0, 1, 1),\n            new Vector3(1, 0, 1),\n            new Vector3(1, 1, 1)];\n\n            // console.log('Matrix4', data.matrix4, data.matrix);\n            if (data.matrix4) {\n                for (let i = 0; i < points.length; i++) {\n                    if (data.size) points[i].multiplyVectors(points[i], data.size); //matrix is for unit vectors, not whole box\n                    points[i] = points[i].applyMatrix4(data.matrix4);\n                }\n            } else {\n                for (let i = 0; i < points.length; i++) {\n                    points[i] = points[i].applyMatrix3(matrix);\n                }\n            }\n\n            //draw box\n            if (spec.box && !spec.box.hidden) {\n                spec.box.wireframe = true;\n                var s = new GLShape(spec.box);\n                s.shapePosition = this.shapes.length;\n\n                s.addLine({ start: points[0], end: points[1] });\n                s.addLine({ start: points[0], end: points[2] });\n                s.addLine({ start: points[1], end: points[4] });\n                s.addLine({ start: points[2], end: points[4] });\n\n                s.addLine({ start: points[0], end: points[3] });\n                s.addLine({ start: points[3], end: points[5] });\n                s.addLine({ start: points[2], end: points[5] });\n\n                s.addLine({ start: points[1], end: points[6] });\n                s.addLine({ start: points[4], end: points[7] });\n                s.addLine({ start: points[6], end: points[7] });\n\n                s.addLine({ start: points[3], end: points[6] });\n                s.addLine({ start: points[5], end: points[7] });\n\n                this.shapes.push(s);\n                model.unitCellObjects.shapes.push(s);\n                s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n            }\n\n            //draw arrows\n            if (!spec.astyle.hidden) {\n                spec.astyle.start = points[0];\n                spec.astyle.end = points[1];\n                let arrow = this.addArrow(spec.astyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n\n            if (!spec.bstyle.hidden) {\n                spec.bstyle.start = points[0];\n                spec.bstyle.end = points[2];\n                let arrow = this.addArrow(spec.bstyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n\n            if (!spec.cstyle.hidden) {\n                spec.cstyle.start = points[0];\n                spec.cstyle.end = points[3];\n                let arrow = this.addArrow(spec.cstyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n\n            if (spec.alabel) {\n                spec.alabelstyle.position = points[1];\n                let label = this.addLabel(spec.alabel, spec.alabelstyle);\n                model.unitCellObjects.labels.push(label);\n\n            }\n            if (spec.blabel) {\n                spec.blabelstyle.position = points[2];\n                let label = this.addLabel(spec.blabel, spec.blabelstyle);\n                model.unitCellObjects.labels.push(label);\n            }\n            if (spec.clabel) {\n                spec.clabelstyle.position = points[3];\n                let label = this.addLabel(spec.clabel, spec.clabelstyle);\n                model.unitCellObjects.labels.push(label);\n            }\n\n        }\n\n    };\n\n    /**\n    * Remove unit cell visualization from model.\n    *\n    * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n      @example\n           $3Dmol.get('data/icsd_200866.cif', function(data) {\n             let m = viewer.addModel(data);\n             viewer.setStyle({sphere:{}})\n             viewer.addUnitCell();\n             viewer.zoomTo();\n             viewer.removeUnitCell();\n             viewer.render();\n       });\n    */\n    public removeUnitCell(model?: GLModel | number) {\n        model = this.getModel(model);\n        if (model.unitCellObjects) {\n            let viewer = this;\n            model.unitCellObjects.shapes.forEach(function (s) { viewer.removeShape(s); });\n            model.unitCellObjects.labels.forEach(function (l) { viewer.removeLabel(l); });\n        }\n        delete model.unitCellObjects;\n    };\n\n    /**\n    * Replicate atoms in model to form a super cell of the specified dimensions.\n    * Original cell will be centered as much as possible.\n    *\n    * @param {integer} A - number of times to replicate cell in X dimension.\n    * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.\n    * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.\n    * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n    * @param {boolean} addBonds - Create bonds between unit cells based on distances.\n    * @param {boolean} prune - Keep only atoms that are within the original unit cell (i.e., on edges).  Alternatively, call replicateUnitCell(1).\n      @example\n           $3Dmol.get('data/icsd_200866.cif', function(data) {\n             let m = viewer.addModel(data);\n             viewer.setStyle({sphere:{scale:.25}})\n             viewer.addUnitCell();\n             viewer.zoomTo();\n             viewer.replicateUnitCell(3,2,1,m);\n             viewer.render();\n       });\n    */\n    public replicateUnitCell(A: number = 3, B: number = A, C: number = B, model?: GLModel | number, addBonds?: boolean, prune?) {\n        model = this.getModel(model);\n        let cryst = model.getCrystData();\n        if (cryst) {\n            const atoms = model.selectedAtoms({});\n            const matrix = cryst.matrix;\n            let makeoff = function (I) {\n                //alternate around zero: 1,-1,2,-2...\n                if (I % 2 == 0) return -I / 2;\n                else return Math.ceil(I / 2);\n            };\n\n            if (A <= 1 && B <= 1 && C <= 1) {\n                prune = true;\n                A = B = C = 3;\n            }\n\n            let omitPosition = function (x, y, z) { return false; };\n            if (prune) {\n                const invmatrix = new Matrix3().getInverse3(matrix);\n                omitPosition = function (x, y, z) {\n                    //must reside within unit cell\n                    let pos = new Vector3(x, y, z).applyMatrix3(invmatrix);\n                    if (pos.x > -0.0001 && pos.x < 1.0001 &&\n                        pos.y > -0.0001 && pos.y < 1.0001 &&\n                        pos.z > -0.0001 && pos.z < 1.0001) {\n                        return false;\n                    } else {\n                        return true;\n                    }\n                }\n\n            }\n\n            for (let i = 0; i < A; i++) {\n                for (let j = 0; j < B; j++) {\n                    for (let k = 0; k < C; k++) {\n                        if (i == 0 && j == 0 && k == 0) continue; //actual unit cell\n                        let offset = new Vector3(makeoff(i), makeoff(j), makeoff(k));\n                        offset.applyMatrix3(matrix);\n\n                        let newatoms = [];\n                        for (let a = 0; a < atoms.length; a++) {\n                            let newx = atoms[a].x + offset.x,\n                                newy = atoms[a].y + offset.y,\n                                newz = atoms[a].z + offset.z;\n                            if (omitPosition(newx, newy, newz)) {\n                                continue;\n                            }\n                            let newAtom: any = {};\n                            for (let p in atoms[a]) {\n                                newAtom[p] = atoms[a][p];\n                            }\n                            newAtom.x = newx;\n                            newAtom.y = newy;\n                            newAtom.z = newz;\n                            newatoms.push(newAtom);\n                        }\n                        model.addAtoms(newatoms);\n                    }\n                }\n            }\n\n            if (addBonds) {\n                model.assignBonds();\n            }\n        }\n    };\n\n    /** Add dashed line to shape */\n    public addLineDashed(spec: CylinderSpec, s: GLShape) {\n        spec.dashLength = spec.dashLength || 0.5;\n        spec.gapLength = spec.gapLength || 0.5;\n\n        var p1: Vector3;\n        if (!spec.start) {\n            p1 = new Vector3(0, 0, 0);\n        } else {\n            p1 = new Vector3(spec.start.x || 0,\n                spec.start.y || 0, spec.start.z || 0);\n        }\n\n        var p2: Vector3;\n        if (!spec.end) p2 = new Vector3(0, 0, 0);\n        else p2 = new Vector3(spec.end.x, spec.end.y || 0, spec.end.z || 0);\n\n        var dir = new Vector3();\n        var dash = new Vector3();\n        var gap = new Vector3();\n        var length, dashAmt, gapAmt;\n        var temp = p1.clone();\n        var drawn = 0;\n\n        dir.subVectors(p2, p1);\n        length = dir.length();\n        dir.normalize();\n        dash = dir.clone();\n        gap = dir.clone();\n        dash.multiplyScalar(spec.dashLength);\n        gap.multiplyScalar(spec.gapLength);\n        dashAmt = dash.length();\n        gapAmt = gap.length();\n\n        while (drawn < length) {\n            if ((drawn + dashAmt) > length) {\n                spec.start = p1;\n                spec.end = p2;\n                s.addLine(spec);\n                break;\n            }\n            temp.addVectors(p1, dash);\n            spec.start = p1;\n            spec.end = temp;\n            s.addLine(spec);\n            p1 = temp.clone();\n            drawn += dashAmt;\n\n            temp.addVectors(p1, gap);\n            p1 = temp.clone();\n            drawn += gapAmt;\n        }\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    }\n\n    /**\n     * Add custom shape component from user supplied function\n     *\n     * @param {CustomSpec} spec - Style specification\n     * @return {GLShape}\n     @example\n     function triangle(viewer) {\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var r = 20;\n        //triangle\n        vertices.push(new $3Dmol.Vector3(0,0,0));\n        vertices.push(new $3Dmol.Vector3(r,0,0));\n        vertices.push(new $3Dmol.Vector3(0,r,0));\n\n        normals.push(new $3Dmol.Vector3(0,0,1));\n        normals.push(new $3Dmol.Vector3(0,0,1));\n        normals.push(new $3Dmol.Vector3(0,0,1));\n\n        colors.push({r:1,g:0,b:0});\n        colors.push({r:0,g:1,b:0});\n        colors.push({r:0,g:0,b:1});\n\n        var faces = [ 0,1,2 ];\n\n        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};\n        viewer.addCustom(spec);\n    }\n    triangle(viewer);\n    viewer.render();\n     */\n    public addCustom(spec: CustomShapeSpec) {\n        spec = spec || {};\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addCustom(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n\n        return s;\n    };\n\n    /**\n     * Construct isosurface from volumetric data in gaussian cube format\n     * @param {String} data - Input file contents\n     * @param {String} format - Input file format\n     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification\n     * @return {GLShape}\n     *\n     * @example\n\n\n    $3Dmol.get('data/bohr.cube', function(data) {\n\n    viewer.addVolumetricData(data, \"cube\", {isoval: -0.01, color: \"red\", opacity: 0.95});\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.render();\n    });\n\n\n     */\n    public addVolumetricData(data, format: string, spec: VolumetricRendererSpec | IsoSurfaceSpec = {}) {\n\n        var voldata = new VolumeData(data, format);\n        if (spec.hasOwnProperty('transferfn')) { //volumetric rendering\n            return this.addVolumetricRender(voldata, spec as VolumetricRendererSpec);\n        } else {\n            return this.addIsosurface(voldata, spec as IsoSurfaceSpec);\n        }\n    };\n\n    /**\n     * Construct isosurface from volumetric data.  This is more flexible\n    * than addVolumetricData, but can not be used with py3Dmol.\n     * @param {VolumeData} data - volumetric data\n     * @param {IsoSurfaceSpec} spec - Shape style specification\n     * @return {GLShape}\n     *\n     @example\n     $3Dmol.get('../test_structs/benzene-homo.cube', function(data){\n              var voldata = new $3Dmol.VolumeData(data, \"cube\");\n              viewer.addIsosurface(voldata, {isoval: 0.01,\n                                             color: \"blue\"});\n              viewer.addIsosurface(voldata, {isoval: -0.01,\n                                             color: \"red\"});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    public addIsosurface(data, spec: IsoSurfaceSpec = {}, callback?) {\n        var s = new GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addIsosurface(data, spec, callback, this);\n        this.shapes.push(s);\n        return s;\n    };\n\n    /**\n     * Create volumetric renderer for volumetricData\n     * @param {VolumeData} data - volumetric data\n     * @param {VolumetricRenderSpec} spec - specification of volumetric render\n     *\n     * @return {GLShape}\n     *\n     */\n    public addVolumetricRender(data, spec: VolumetricRendererSpec) {\n        spec = spec || {};\n        var s = new GLVolumetricRender(data, spec, this);\n        s.shapePosition = this.shapes.length;\n        this.shapes.push(s);\n        return s;\n    };\n\n    /**\n     * Return true if volumetric rendering is supported (WebGL 2.0 required)\n     *\n     * @return {boolean}\n     */\n    public hasVolumetricRender() {\n        return this.renderer.supportsVolumetric();\n    };\n\n    /**\n     * Enable/disable fog for content far from the camera\n     *\n     * @param {boolean} fog whether to enable or disable the fog\n     * \n     * @example\n            $3Dmol.get('data/1jpy.cif', function(data) {\n              let m = viewer.addModel(data);\n              viewer.setStyle('stick');\n              viewer.zoomTo({resn:'NAG',chain:'B'});\n              viewer.enableFog({fogStart:.2,fogEnd:.6});\n              viewer.render();\n    });\n     */\n    public enableFog(fog: boolean | FogSpec) {\n        if (fog) {\n            this.scene.fog = new Fog(this.bgColor, 100, 200);\n            this.config.disableFog = false;\n\n            const f = fog as FogSpec;\n            if (f.fogStart == undefined) this.fogStart = 0.4;\n            else this.fogStart = f.fogStart;\n            if (f.fogEnd == undefined) this.fogEnd = 1.0;\n            else this.fogEnd = f.fogEnd;\n\n        } else {\n            this.config.disableFog = true;\n            this.show();\n        }\n    };\n\n    /**\n     * Sets the atomlists of all models in the viewer to specified frame.\n     * Shapes and labels can also be displayed by frame.\n     * Sets to last frame if framenum out of range\n     *\n     * @param {number} framenum - fame index to use, starts at zero\n     * @return {Promise}\n     */\n    public setFrame(framenum: number) {\n        this.viewer_frame = framenum;\n        let viewer = this;\n        return new Promise<void>(function (resolve) {\n            var modelMap = viewer.models.map(function (model) {\n                return model.setFrame(framenum);\n            });\n            Promise.all(modelMap)\n                .then(function () { resolve(); });\n        });\n    };\n\n    /**\n     * Gets the current viewer frame.\n     *\n     */\n    public getFrame() {\n        return this.viewer_frame;\n    };\n\n    /**\n     * Returns the number of frames that the model with the most frames in the viewer has\n     *\n     * @return {number}\n     */\n    public getNumFrames() {\n        var mostFrames = 0;\n        for (let i = 0; i < this.models.length; i++) {\n            if (this.models[i].getNumFrames() > mostFrames) {\n                mostFrames = this.models[i].getNumFrames();\n            }\n        }\n        for (let i = 0; i < this.shapes.length; i++) {\n            if (this.shapes[i].frame && this.shapes[i].frame >= mostFrames) {\n                mostFrames = this.shapes[i].frame + 1;\n            }\n        }\n        for (let i = 0; i < this.labels.length; i++) {\n            if (this.labels[i].frame && this.labels[i].frame >= mostFrames) {\n                mostFrames = this.labels[i].frame + 1;\n            }\n        }\n        return mostFrames;\n    };\n\n    public getNextModelId() {\n        return this.models.length;\n    }\n\n\n    /**\n     * Animate all models in viewer from their respective frames\n     * @param {Object} options - can specify interval (speed of animation), loop (direction\n     * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)\n     *\n     */\n\n    public animate(options) {\n        this.incAnim();\n        var interval = 100;\n        var loop = \"forward\";\n        var reps = Infinity;\n        options = options || {};\n        if (options.interval) {\n            interval = options.interval;\n        }\n        if (options.loop) {\n            loop = options.loop;\n        }\n        if (options.reps) {\n            reps = options.reps;\n        }\n        var mostFrames = this.getNumFrames();\n        var self = this;\n        var currFrame = 0;\n        if (options.startFrame) {\n            currFrame = options.startFrame % mostFrames;\n        }\n        var inc = 1;\n        if (options.step) {\n            inc = options.step;\n            reps /= inc;\n        }\n        var displayCount = 0;\n        var displayMax = mostFrames * reps;\n        var time = new Date();\n        var resolve, timer;\n        var display = function (direction) {\n            time = new Date();\n            if (direction == \"forward\") {\n                self.setFrame(currFrame)\n                    .then(function () {\n                        currFrame = (currFrame + inc) % mostFrames;\n                        resolve();\n                    });\n            }\n            else if (direction == \"backward\") {\n                self.setFrame((mostFrames - 1) - currFrame)\n                    .then(function () {\n                        currFrame = (currFrame + inc) % mostFrames;\n                        resolve();\n                    });\n            }\n            else { //back and forth\n                self.setFrame(currFrame)\n                    .then(function () {\n                        currFrame += inc;\n                        inc *= (((currFrame % (mostFrames - 1)) == 0) ? -1 : 1);\n                        resolve();\n                    });\n            }\n        };\n\n        resolve = function () {\n            self.render();\n            if (!self.getCanvas().isConnected) {\n                //we no longer exist as part of the DOM\n                self.stopAnimate();\n            }\n            else if (++displayCount >= displayMax || !self.isAnimated()) {\n                timer.cancel();\n                self.animationTimers.delete(timer);\n                self.decAnim();\n            }\n            else {\n                var newInterval = interval - (new Date().getTime() - time.getTime());\n                newInterval = (newInterval > 0) ? newInterval : 0;\n                timer.cancel();\n                self.animationTimers.delete(timer);\n                timer = new PausableTimer(display, newInterval, loop);\n                self.animationTimers.add(timer);\n            }\n        };\n\n        timer = new PausableTimer(display, 0, loop);\n        this.animationTimers.add(timer);\n        return this;\n    };\n\n    /**\n     * Stop animation of all models in viewer\n     */\n    public stopAnimate() {\n        this.animated = 0;\n        this.animationTimers.forEach(function (timer: PausableTimer) { timer.cancel(); });\n        this.animationTimers = new Set();\n        return this;\n    };\n\n    /**\n     * Pause animation of all models in viewer\n     */\n    public pauseAnimate() {\n        this.animationTimers.forEach(function (timer) { timer.pause(); });\n        return this;\n    };\n\n    /**\n     * Resume animation of all models in viewer\n     */\n    public resumeAnimate() {\n        this.animationTimers.forEach(function (timer) { timer.resume(); });\n        return this;\n    };\n\n\n    /**\n     * Return true if viewer is currently being animated, false otherwise\n     * @return {boolean}\n     */\n    public isAnimated() {\n        return this.animated > 0;\n    };\n\n\n    //setup options dict\n    private getModelOpt(options) {\n        if (options && !options.defaultcolors) {\n            options.defaultcolors = this.defaultcolors;\n            options.cartoonQuality = options.cartoonQuality || this.config.cartoonQuality;\n        } else if (typeof (options) === 'undefined') {\n            options = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality };\n        }\n        return options;\n    }\n    /**\n     * Create and add model to viewer, given molecular data and its format\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')\n     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.\n     * @example\n\n\n          viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n\n              viewer.render();\n              });\n              viewer.zoomTo();\n          });\n     *\n     * @return {GLModel}\n     */\n    public addModel(data?, format = \"\", options?) {\n        options = this.getModelOpt(options);\n\n        var m = new GLModel(this.models.length, options, this);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n\n        return m;\n    };\n\n    /**\n     * Given multimodel file and its format, add atom data to the viewer as separate models\n     * and return list of these models\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {Array<GLModel>}\n     */\n    public addModels(data, format: string, options?) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.frames = true;\n\n        var modelatoms = GLModel.parseMolData(data, format, options);\n\n        for (var i = 0; i < modelatoms.length; i++) {\n            var newModel = new GLModel(this.models.length, options, this);\n            newModel.setAtomDefaults(modelatoms[i]);\n            newModel.addFrame(modelatoms[i]);\n            newModel.setFrame(0);\n            if (modelatoms.modelData)\n                newModel.setModelData(modelatoms.modelData[i]);\n            newModel.setDontDuplicateAtoms(!options.duplicateAssemblyAtoms);\n            this.models.push(newModel);\n        }\n\n        return this.models;\n    };\n\n    /**\n     * Create and add model to viewer. Given multimodel file and its format,\n     * different atomlists are stored in model's frame\n     * property and model's atoms are set to the 0th frame\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {GLModel}\n     *\n     * @example\n            $3Dmol.get('../test_structs/multiple2.xyz', function(data){\n              viewer.addModelsAsFrames(data, \"xyz\");\n              viewer.animate({loop: \"forward\",reps: 1});\n              viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});\n              viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    public addModelsAsFrames(data, format: string, options?) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.frames = true;\n        var m = new GLModel(this.models.length, options, this);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n\n        return m;\n    };\n\n    /**\n     * Create and add model to viewer. Given multimodel file and its format,\n     * all atoms are added to one model\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {GLModel}\n     @example\n\n\n          $3Dmol.get('../test_structs/multiple.sdf', function(data){\n              viewer.addAsOneMolecule(data, \"sdf\");\n              viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    public addAsOneMolecule(data, format: string, options?) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.onemol = true;\n        var m = new GLModel(this.models.length, options, this);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n\n        return m;\n    };\n\n\n    /**\n     * Delete specified model from viewer\n     *\n     * @param {GLModel|number} model\n     */\n    public removeModel(model?: GLModel | number) {\n        model = this.getModel(model);\n        if (!model)\n            return;\n        model.removegl(this.modelGroup);\n        delete this.models[model.getID()];\n        // clear off back of model array\n        while (this.models.length > 0\n            && typeof (this.models[this.models.length - 1]) === \"undefined\")\n            this.models.pop();\n        return this;\n    };\n\n    /**\n     * Delete all existing models\n     */\n    public removeAllModels() {\n        for (var i = 0; i < this.models.length; i++) {\n            var model = this.models[i];\n            if (model) model.removegl(this.modelGroup);\n\n        }\n        this.models.splice(0, this.models.length); //don't simply overwrite array in case linked\n        return this;\n    };\n\n    /**\n     * Export one or all of the loaded models into ChemDoodle compatible JSON.\n     * @param {boolean} includeStyles - Whether or not to include style information.\n     * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.\n     * @return {string}\n     */\n    public exportJSON(includeStyles: boolean, modelID: number) {\n        var object: any = {};\n        if (modelID === undefined) {\n            object.m = this.models.map(function (model) {\n                return model.toCDObject(includeStyles);\n            });\n        } else {\n            object.m = [this.models[modelID].toCDObject()];\n        }\n        return JSON.stringify(object);\n    };\n\n    /** return a VRML string representation of the scene.  Include VRML header information\n     * @return VRML\n     */\n    public exportVRML() {\n        var savedmodelGroup = this.modelGroup;\n        this.applyToModels(\"removegl\", this.modelGroup); //cleanup\n        this.modelGroup = new Object3D();\n        //rendering with plain mesh\n        this.render(null, { supportsImposters: false, supportsAIA: false, regen: true });\n        var ret = '#VRML V2.0 utf8\\n' + this.modelGroup.vrml() + '\\n';\n        this.applyToModels(\"removegl\", this.modelGroup); //cleanup\n        this.modelGroup = savedmodelGroup;\n        return ret;\n    };\n\n    /**\n     * Create a new model from atoms specified by sel.\n     * If extract, removes selected atoms from existing models\n     *\n     * @param {AtomSelectionSpec} sel - Atom selection specification\n     * @param {boolean=} extract - If true, remove selected atoms from existing models\n     * @return {GLModel}\n     */\n    public createModelFrom(sel: AtomSelectionSpec, extract: boolean = false) {\n        var m = new GLModel(this.models.length, this.defaultcolors, this);\n        for (var i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                var atoms = this.models[i].selectedAtoms(sel);\n                m.addAtoms(atoms);\n                if (extract)\n                    this.models[i].removeAtoms(atoms);\n            }\n        }\n        this.models.push(m);\n        return m;\n    };\n\n    private applyToModels(func: string, sel: any, value1?, value2?, value3?, value4?, value5?) {\n\n        //apply func to all models that are selected by sel with value1 and 2\n        //sel might not be a selection, in which case getModelList returns everything\n        var ms = this.getModelList(sel);\n        for (var i = 0; i < ms.length; i++) {\n            ms[i][func](sel, value1, value2, value3, value4, value5);\n        }\n    }\n\n    /**\n     * Set style properties to all selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - Atom selection specification.  Can be omitted to select all.\n     * @param {AtomStyleSpec} style - Style spec to apply to specified atoms\n     *\n     * @example\n     viewer.setBackgroundColor(0xffffffff);\n    $3Dmol.download('pdb:5IRE',viewer,{doAssembly: false},function(m) {\n    m.setStyle({chain:'A'},{'cartoon':{color:'spectrum'}});\n    m.setStyle({chain:'C'},{'cartoon':{style:'trace',color:'blue'}});\n    m.setStyle({chain:'E'},{'cartoon':{tubes:true,arrows:true,color:'green',opacity:0.75}});\n    m.setStyle({chain:'B'},{'cartoon':{color:'red',opacity:0.5}});\n    m.setStyle({chain:'D'},{'cartoon':{style:'trace',color:'grey',opacity:0.75}});\n    m.setStyle({chain:'F'},{'cartoon':{arrows:true,color:'white'}});\n    // viewer.addStyle({chain:'B'},{line:{}});\n    viewer.zoomTo();\n    viewer.render();\n    });\n     */\n    public setStyle(sel: AtomSelectionSpec, style: AtomStyleSpec);\n    public setStyle(sel: AtomStyleSpec);\n    public setStyle(sel: unknown, style?: unknown) {\n        if (typeof (style) === 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel as AtomStyleSpec;\n            sel = {};\n        }\n\n        this.applyToModels(\"setStyle\", sel, style, false);\n        return this;\n    };\n\n    /**\n     * Add style properties to all selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - Atom selection specification.  Can be omitted to select all\n     * @param {AtomStyleSpec} style - style spec to add to specified atoms\n     @example\n\n    $3Dmol.download('pdb:5IRE',viewer,{doAssembly: false},function(m) {\n    viewer.setStyle({cartoon:{}});\n    //keep cartoon style, but show thick sticks for chain A\n    viewer.addStyle({chain:'A'},{stick:{radius:.5,colorscheme:\"magentaCarbon\"}});\n    viewer.zoomTo();\n    viewer.render();\n    });\n     */\n    public addStyle(sel: AtomSelectionSpec, style: AtomStyleSpec);\n    public addStyle(sel: AtomStyleSpec);\n    public addStyle(sel: unknown, style?: unknown) {\n        if (typeof (style) === 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel;\n            sel = {};\n        }\n        this.applyToModels(\"setStyle\", sel, style, true);\n        return this;\n    };\n\n\n    /**\n     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to\n     * @param {boolean} clickable - whether click-handling is enabled for the selection\n     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed\n     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list\n     * of all intersecting objects with their distances from the viewer.\n     *\n     * @example\n        $3Dmol.download(\"cid:307900\",viewer,{},function(){\n\n               viewer.setStyle({},{sphere:{}});\n               viewer.setClickable({},true,function(atom,viewer,event,container) {\n                   viewer.addLabel(atom.resn+\":\"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});\n               });\n               viewer.render();\n    });\n     */\n    public setClickable(sel: AtomSelectionSpec, clickable: boolean, callback) {\n        this.applyToModels(\"setClickable\", sel, clickable, callback);\n        return this;\n    };\n    /** Set hoverable and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} hoverable - whether hover-handling is enabled for the selection\n     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.\n     * @param {function} unhover_callback - function called when the mouse moves out of the hover area\n    @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.setHoverable({},true,function(atom,viewer,event,container) {\n               if(!atom.label) {\n                atom.label = viewer.addLabel(atom.resn+\":\"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});\n               }\n           },\n           function(atom,viewer) {\n               if(atom.label) {\n                viewer.removeLabel(atom.label);\n                delete atom.label;\n               }\n            }\n           );\n           viewer.setStyle({},{stick:{}});\n           viewer.render();\n    });\n\n     */\n    public setHoverable(sel: AtomSelectionSpec, hoverable: boolean, hover_callback, unhover_callback) {\n        this.applyToModels(\"setHoverable\", sel, hoverable, hover_callback, unhover_callback);\n        return this;\n    };\n\n    /** enable context menu and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection\n\n     */\n    public enableContextMenu(sel: AtomSelectionSpec, contextMenuEnabled: boolean) {\n        this.applyToModels(\"enableContextMenu\", sel, contextMenuEnabled);\n        return this;\n    };\n\n    /**\n     * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.\n     * Models can then be animated\n     *\n     * @param {number} numFrames - number of frames to be created, default to 10\n     * @param {number} amplitude - amplitude of distortion, default to 1 (full)\n     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames\n     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.\n     */\n    public vibrate(numFrames: number, amplitude: number, bothways: boolean, arrowSpec: ArrowSpec) {\n        this.applyToModels(\"vibrate\", numFrames, amplitude, bothways, arrowSpec);\n        return this;\n    };\n\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {string} prop\n     * @param {Gradient|string} scheme\n     * @param {object} range\n     */\n    public setColorByProperty(sel: AtomSelectionSpec, prop: string, scheme: Gradient | string, range) {\n        this.applyToModels(\"setColorByProperty\", sel, prop, scheme, range);\n        return this;\n    };\n\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {object} colors\n     */\n    public setColorByElement(sel: AtomSelectionSpec, colors) {\n        this.applyToModels(\"setColorByElement\", sel, colors);\n        return this;\n    };\n\n    /**\n     *\n     * @param {AtomSpec[]} atomlist\n     * @param {Array}\n     *            extent\n     * @return {Array}\n     */\n    private static getAtomsWithin(atomlist: AtomSpec[], extent) {\n        var ret = [];\n\n        for (let i = 0; i < atomlist.length; i++) {\n            var atom = atomlist[i];\n            if (typeof (atom) == \"undefined\")\n                continue;\n\n            if (atom.x < extent[0][0] || atom.x > extent[1][0])\n                continue;\n            if (atom.y < extent[0][1] || atom.y > extent[1][1])\n                continue;\n            if (atom.z < extent[0][2] || atom.z > extent[1][2])\n                continue;\n            ret.push(atom);\n        }\n        return ret;\n    };\n\n    // return volume of extent\n    private static volume(extent) {\n        var w = extent[1][0] - extent[0][0];\n        var h = extent[1][1] - extent[0][1];\n        var d = extent[1][2] - extent[0][2];\n        return w * h * d;\n    }; // volume\n    /*\n     * Break up bounding box/atoms into smaller pieces so we can parallelize\n     * with webworkers and also limit the size of the working memory Returns\n     * a list of bounding boxes with the corresponding atoms. These extents\n     * are expanded by 4 angstroms on each side.\n     */\n    /**\n     *\n     * @param {Array}\n     *            extent\n     * @param {AtomSpec[]} atomlist\n     * @param {AtomSpec[]} atomstoshow\n     * @return {Array}\n     */\n    private carveUpExtent(extent, atomlist: AtomSpec[], atomstoshow: AtomSpec[]) {\n        let ret = [];\n\n        let index2atomlist = {}; //map from atom.index to position in atomlist\n        for (let i = 0, n = atomlist.length; i < n; i++) {\n            index2atomlist[atomlist[i].index] = i;\n        }\n\n        let atomsToListIndex = function (atoms) {\n            //return a list of indices into atomlist\n            let ret = [];\n            for (let i = 0, n = atoms.length; i < n; i++) {\n                if (atoms[i].index in index2atomlist)\n                    ret.push(index2atomlist[atoms[i].index]);\n            }\n            return ret;\n        };\n        let copyExtent = function (extent) {\n            // copy just the dimensions\n            let ret = [];\n            ret[0] = [extent[0][0], extent[0][1], extent[0][2]];\n            ret[1] = [extent[1][0], extent[1][1], extent[1][2]];\n            return ret;\n        }; // copyExtent\n        let splitExtentR = function (extent) {\n            // recursively split until volume is below maxVol\n            if (GLViewer.volume(extent) < GLViewer.maxVolume) {\n                return [extent];\n            } else {\n                // find longest edge\n                var w = extent[1][0] - extent[0][0];\n                var h = extent[1][1] - extent[0][1];\n                var d = extent[1][2] - extent[0][2];\n\n                var index;\n\n                if (w > h && w > d) {\n                    index = 0;\n                } else if (h > w && h > d) {\n                    index = 1;\n                } else {\n                    index = 2;\n                }\n\n                // create two halves, splitting at index\n                var a = copyExtent(extent);\n                var b = copyExtent(extent);\n                var mid = (extent[1][index] - extent[0][index]) / 2\n                    + extent[0][index];\n                a[1][index] = mid;\n                b[0][index] = mid;\n\n                var alist = splitExtentR(a);\n                var blist = splitExtentR(b);\n                return alist.concat(blist);\n            }\n        }; // splitExtentR\n\n        // divide up extent\n        let splits = splitExtentR(extent);\n        // now compute atoms within expanded (this could be more efficient)\n        let off = 6; // enough for water and 2*r, also depends on scale\n        // factor\n        for (let i = 0, n = splits.length; i < n; i++) {\n            let e = copyExtent(splits[i]);\n            e[0][0] -= off;\n            e[0][1] -= off;\n            e[0][2] -= off;\n            e[1][0] += off;\n            e[1][1] += off;\n            e[1][2] += off;\n\n            let atoms = GLViewer.getAtomsWithin(atomlist, e);\n            let toshow = GLViewer.getAtomsWithin(atomstoshow, splits[i]);\n\n            // ultimately, divide up by atom for best meshing\n            ret.push({\n                extent: splits[i],\n                atoms: atomsToListIndex(atoms),\n                toshow: atomsToListIndex(toshow)\n            });\n        }\n\n        return ret;\n    };\n\n    // create a mesh defined from the passed vertices and faces and material\n    // Just create a single geometry chunk - broken up whether sync or not\n    /**\n     *\n     * @param {AtomSpec[]} atoms\n     * @param {{vertices:number,faces:number}}\n     *            VandF\n     * @param {MeshLambertMaterial}\n     *            mat\n     * @return {Mesh}\n     */\n    private static generateSurfaceMesh(atoms: AtomSpec[], VandF, mat: MeshLambertMaterial) {\n        var geo = new Geometry(true);\n        // Only one group per call to generate surface mesh (addSurface\n        // should split up mesh render)\n        var geoGroup = geo.updateGeoGroup(0);\n\n        // set colors for vertices\n        var colors = [];\n        for (let i = 0, il = atoms.length; i < il; i++) {\n            var atom = atoms[i];\n            if (atom) {\n                if (typeof (atom.surfaceColor) != \"undefined\") {\n                    colors[i] = atom.surfaceColor;\n                } else if (atom.color) // map from atom\n                    colors[i] = CC.color(atom.color);\n            }\n        }\n\n        var vertexArray = geoGroup.vertexArray;\n        // reconstruct vertices and faces\n        var v = VandF.vertices;\n        for (let i = 0, il = v.length; i < il; i++) {\n            let offset = geoGroup.vertices * 3;\n            vertexArray[offset] = v[i].x;\n            vertexArray[offset + 1] = v[i].y;\n            vertexArray[offset + 2] = v[i].z;\n            geoGroup.vertices++;\n        }\n\n        //set colorArray of there are per-atom colors\n        var colorArray = geoGroup.colorArray;\n        let atomArray = geoGroup.atomArray;\n\n        if (mat.voldata && mat.volscheme) {\n            //convert volumetric data into colors\n            var scheme = mat.volscheme;\n            var voldata = mat.voldata;\n            var range = scheme.range() || [-1, 1];\n            for (let i = 0, il = v.length; i < il; i++) {\n                let A = v[i].atomid;\n                let val = voldata.getVal(v[i].x, v[i].y, v[i].z);\n                let col = CC.color(scheme.valueToHex(val, range));\n                let offset = i * 3;\n                colorArray[offset] = col.r;\n                colorArray[offset + 1] = col.g;\n                colorArray[offset + 2] = col.b;\n                atomArray[i] = atoms[A];\n            }\n        }\n        else if (colors.length > 0) { //have atom colors\n            for (let i = 0, il = v.length; i < il; i++) {\n                let A = v[i].atomid;\n                let offsetA = i * 3;\n\n                colorArray[offsetA] = colors[A].r;\n                colorArray[offsetA + 1] = colors[A].g;\n                colorArray[offsetA + 2] = colors[A].b;\n                atomArray[i] = atoms[A];\n            }\n        }\n\n        var faces = VandF.faces;\n        geoGroup.faceidx = faces.length;// *3;\n        geo.initTypedArrays();\n\n        var verts = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var vA, vB, vC, norm;\n\n        // Setup colors, faces, and normals\n        for (let i = 0, il = faces.length; i < il; i += 3) {\n\n            // var a = faces[i].a, b = faces[i].b, c = faces[i].c;\n            var a = faces[i], b = faces[i + 1], c = faces[i + 2];\n            var offsetA = a * 3, offsetB = b * 3, offsetC = c * 3;\n\n            // setup Normals\n            // todo - calculate normals in parallel code\n            vA = new Vector3(verts[offsetA], verts[offsetA + 1],\n                verts[offsetA + 2]);\n            vB = new Vector3(verts[offsetB], verts[offsetB + 1],\n                verts[offsetB + 2]);\n            vC = new Vector3(verts[offsetC], verts[offsetC + 1],\n                verts[offsetC + 2]);\n\n            vC.subVectors(vC, vB);\n            vA.subVectors(vA, vB);\n            vC.cross(vA);\n\n            // face normal\n            norm = vC;\n            norm.normalize();\n\n            normalArray[offsetA] += norm.x;\n            normalArray[offsetB] += norm.x;\n            normalArray[offsetC] += norm.x;\n            normalArray[offsetA + 1] += norm.y;\n            normalArray[offsetB + 1] += norm.y;\n            normalArray[offsetC + 1] += norm.y;\n            normalArray[offsetA + 2] += norm.z;\n            normalArray[offsetB + 2] += norm.z;\n            normalArray[offsetC + 2] += norm.z;\n\n        }\n        geoGroup.faceArray = new Uint16Array(faces);\n        var mesh = new Mesh(geo, mat as Material);\n        return mesh;\n    };\n\n    // do same thing as worker in main thread\n    /**\n     *\n     * @param {SurfaceType}\n     *            type\n     * @param {Array}\n     *            expandedExtent\n     * @param {AtomSpec[]}\n     *            extendedAtoms\n     * @param {AtomSpec[]}\n     *            atomsToShow\n     * @param {AtomSpec[]} atoms\n     * @param {number}\n     *            vol\n     * @return {Object}\n     */\n    private static generateMeshSyncHelper(type: SurfaceType, expandedExtent,\n        extendedAtoms: AtomSpec[], atomsToShow: AtomSpec[], atoms: AtomSpec[], vol: number) {\n        //            var time = new Date();\n        var ps = new ProteinSurface();\n        ps.initparm(expandedExtent, (type === 1) ? false : true, vol);\n\n        //            var time2 = new Date();\n        //console.log(\"initialize \" + (time2 - time) + \"ms\");\n\n        ps.fillvoxels(atoms, extendedAtoms);\n\n        //            var time3 = new Date();\n        //console.log(\"fillvoxels \" + (time3 - time2) + \"  \" + (time3 - time) + \"ms\");\n\n        ps.buildboundary();\n\n        if (type == SurfaceType.SES || type == SurfaceType.MS) {\n            ps.fastdistancemap();\n            ps.boundingatom(false);\n            ps.fillvoxelswaals(atoms, extendedAtoms);\n        }\n\n        //            var time4 = new Date();\n        //console.log(\"buildboundaryetc \" + (time4 - time3) + \"  \" + (time4 - time) + \"ms\");\n\n        ps.marchingcube(type);\n\n        //            var time5 = new Date();\n        //console.log(\"marching cube \" + (time5 - time4) + \"  \"+ (time5 - time) + \"ms\");\n\n        return ps.getFacesAndVertices(atomsToShow);\n    };\n\n    /*\n     *\n     * @param {SurfaceStyleSpec}\n     *            style\n     * @return {MeshLambertMaterial}\n     */\n    private static getMatWithStyle(style: SurfaceStyleSpec) {\n        let mat = null;\n        if (style.onesided) {\n            mat = new MeshLambertMaterial();\n        } else {\n            mat = new MeshDoubleLambertMaterial();\n        }\n        mat.vertexColors = Coloring.VertexColors;\n\n        for (var prop in style) {\n            if (prop === \"color\" || prop === \"map\") {\n                // ignore\n            } else if (style.hasOwnProperty(prop))\n                mat[prop] = style[prop];\n        }\n        if (style.opacity !== undefined) {\n            if (style.opacity === 1)\n                mat.transparent = false;\n            else\n                mat.transparent = true;\n        }\n\n        if (style.wireframe !== undefined) {\n            mat.wireframe = style.wireframe;\n        }\n\n        return mat;\n    }\n\n    /**\n     * Adds an explicit mesh as a surface object.\n     * @param {Mesh}\n     *            mesh\n     * @param {Object}\n     *            style\n     * @returns {number} surfid\n     */\n    public addMesh(mesh: Mesh) {\n        let surfobj: SurfObj = {\n            geo: mesh.geometry,\n            mat: mesh.material,\n            done: true,\n            finished: false //the rendered finishes surfaces when they are done\n        };\n        var surfid = this.nextSurfID();\n        this.surfaces[surfid] = new Surface([surfobj]);\n        return surfid;\n    };\n\n    //return a shallow copy of list l, e.g., for atoms so we can\n    //ignore superficial changes (ie surfacecolor, position) that happen\n    //while we're surface building\n    private static shallowCopy(l) {\n        var ret = [];\n        let length = l.length;\n        for (let i = 0; i < length; i++) {\n            ret[i] = extend({}, l[i]);\n        }\n        return ret;\n    };\n\n\n\n    /**\n     * Add surface representation to atoms\n     * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)\n     * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)\n     * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection\n     * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'\n     * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms\n     * @param {function} surfacecallback - function to be called after setting the surface\n     * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.\n     */\n    public addSurface(stype: SurfaceType | string, style: SurfaceStyleSpec = {}, atomsel: AtomSelectionSpec = {},\n        allsel?: AtomSelectionSpec, focus?: AtomSelectionSpec, surfacecallback?) {\n        // type 1: VDW 3: SAS 4: MS 2: SES\n        // if sync is true, does all work in main thread, otherwise uses\n        // workers\n        // with workers, must ensure group is the actual modelgroup since\n        // surface\n        // will get added asynchronously\n        // all atoms in atomlist are used to compute surfaces, but only the\n        // surfaces\n        // of atomsToShow are displayed (e.g., for showing cavities)\n        // if focusSele is specified, will start rending surface around the\n\n        //surfacecallback gets called when done\n        let surfid = this.nextSurfID();\n        let mat = null;\n        let self = this;\n        let type: SurfaceType | 0 = SurfaceType.VDW;\n\n        if (typeof stype == \"string\") {\n            if (GLViewer.surfaceTypeMap[stype.toUpperCase()] !== undefined)\n                type = GLViewer.surfaceTypeMap[stype];\n            else {\n                console.log(\"Surface type : \" + stype + \" is not recognized\");\n            }\n        } else if (typeof stype == \"number\") {\n            type = stype;\n        }\n\n        // atoms specified by this selection\n        var atomlist = null, focusSele = null;\n        //TODO: currently generating a shallow copy to avoid problems when atoms are chagned\n        //during surface generation - come up with a better solution\n        var atomsToShow = GLViewer.shallowCopy(this.getAtomsFromSel(atomsel));\n        if (!allsel) {\n            atomlist = atomsToShow;\n        }\n        else {\n            atomlist = GLViewer.shallowCopy(this.getAtomsFromSel(allsel));\n        }\n\n        adjustVolumeStyle(style);\n        var symmetries = false;\n        var n;\n        for (n = 0; n < this.models.length; n++) {\n            if (this.models[n]) {\n                var symMatrices = this.models[n].getSymmetries();\n                if (symMatrices.length > 1 || (symMatrices.length == 1 && !(symMatrices[0].isIdentity()))) {\n                    symmetries = true;\n                    break;\n                }\n            }\n        }\n\n        var addSurfaceHelper = function addSurfaceHelper(surfobj: SurfObj, atomlist: AtomSpec[], atomsToShow: AtomSpec[]) {\n            //function returns promise with surfid resolved\n            if (!focus) {\n                focusSele = atomsToShow;\n            } else {\n                focusSele = GLViewer.shallowCopy(self.getAtomsFromSel(focus));\n            }\n\n            var atom;\n            //                var time = new Date();\n            var extent = getExtent(atomsToShow, true);\n            if (style.map && style.map.prop) {\n                // map color space using already set atom properties\n                var prop = style.map.prop;\n                let scheme = getGradient(style.map.scheme || style.map.gradient || new Gradient.RWB());\n                let range = scheme.range();\n                if (!range) {\n                    range = getPropertyRange(atomsToShow, prop);\n                }\n                style.colorscheme = { prop: prop as string, gradient: scheme };\n\n            }\n\n            //cache surface color on each atom\n            for (let i = 0, il = atomlist.length; i < il; i++) {\n                atom = atomlist[i];\n                atom.surfaceColor = getColorFromStyle(atom, style);\n            }\n\n            var totalVol = GLViewer.volume(extent); // used to scale resolution\n            var extents = self.carveUpExtent(extent, atomlist, atomsToShow);\n\n            if (focusSele && focusSele.length && focusSele.length > 0) {\n                var seleExtent = getExtent(focusSele, true);\n                // sort by how close to center of seleExtent\n                var sortFunc = function (a, b) {\n                    var distSq = function (ex, sele) {\n                        // distance from e (which has no center of mass) and\n                        // sele which does\n                        var e = ex.extent;\n                        var x = e[1][0] - e[0][0];\n                        var y = e[1][1] - e[0][1];\n                        var z = e[1][2] - e[0][2];\n                        var dx = (x - sele[2][0]);\n                        dx *= dx;\n                        var dy = (y - sele[2][1]);\n                        dy *= dy;\n                        var dz = (z - sele[2][2]);\n                        dz *= dz;\n\n                        return dx + dy + dz;\n                    };\n                    var d1 = distSq(a, seleExtent);\n                    var d2 = distSq(b, seleExtent);\n                    return d1 - d2;\n                };\n                extents.sort(sortFunc);\n            }\n\n            var reducedAtoms = [];\n            // to reduce amount data transfered, just pass x,y,z,serial and elem\n            for (let i = 0, il = atomlist.length; i < il; i++) {\n                atom = atomlist[i];\n                reducedAtoms[i] = {\n                    x: atom.x,\n                    y: atom.y,\n                    z: atom.z,\n                    serial: i,\n                    elem: atom.elem\n                };\n            }\n\n            var sync = !!(syncSurface);\n            if (typeof $3Dmol == \"undefined\" || typeof $3Dmol.SurfaceWorker == \"undefined\") {\n                console.log(\n                    \"$3Dmol.SurfaceWorker is not defined, using synchronous surface generation.\",\n                );\n                sync = true;\n            }\n\n            if (sync) { // don't use worker, still break up for memory purposes\n\n                // to keep the browser from locking up, call through setTimeout\n                var callSyncHelper = function callSyncHelper(i) {\n                    return new Promise<void>(function (resolve) {\n                        var VandF = GLViewer.generateMeshSyncHelper(type as SurfaceType, extents[i].extent,\n                            extents[i].atoms, extents[i].toshow, reducedAtoms,\n                            totalVol);\n                        //complicated surfaces sometimes have > 2^16 vertices\n                        var VandFs = splitMesh({ vertexArr: VandF.vertices, faceArr: VandF.faces });\n                        for (var vi = 0, vl = VandFs.length; vi < vl; vi++) {\n                            VandF = {\n                                vertices: VandFs[vi].vertexArr,\n                                faces: VandFs[vi].faceArr\n                            };\n                            var mesh = GLViewer.generateSurfaceMesh(atomlist, VandF, mat);\n                            mergeGeos(surfobj.geo, mesh);\n                        }\n                        self.render();\n                        resolve();\n                    });\n                };\n                var promises = [];\n                for (let i = 0; i < extents.length; i++) {\n                    promises.push(callSyncHelper(i));\n                }\n                return Promise.all(promises)\n                    .then(function () {\n                        surfobj.done = true;\n                        self.render(); // for consistency with parallel case, call render when done\n                        return Promise.resolve(surfid);\n                    });\n\n                // TODO: Asynchronously generate geometryGroups (not separate\n                // meshes) and merge them into a single geometry\n            } else { // use worker\n\n                var workers = [];\n                if (type < 0)\n                    type = 0; // negative reserved for atom data\n                for (let i = 0, il = GLViewer.numWorkers; i < il; i++) {\n                    var w = new Worker($3Dmol.SurfaceWorker);\n                    workers.push(w);\n                    w.postMessage({\n                        'type': -1,\n                        'atoms': reducedAtoms,\n                        'volume': totalVol\n                    });\n                }\n\n                return new Promise(function (resolve, reject) {\n                    var cnt = 0;\n\n                    var releaseMemory = function () {\n                        if (!workers || !workers.length) return;\n                        workers.forEach(function (worker) {\n                            if (worker && worker.terminate) {\n                                worker.terminate();\n                            }\n                        });\n                    };\n\n                    var rfunction = function (event) {\n                        var VandFs = splitMesh({\n                            vertexArr: event.data.vertices,\n                            faceArr: event.data.faces\n                        });\n                        for (var i = 0, vl = VandFs.length; i < vl; i++) {\n                            var VandF = {\n                                vertices: VandFs[i].vertexArr,\n                                faces: VandFs[i].faceArr\n                            };\n                            var mesh = GLViewer.generateSurfaceMesh(atomlist, VandF, mat);\n                            mergeGeos(surfobj.geo, mesh);\n                        }\n                        self.render();\n\n                        //    console.log(\"async mesh generation \" + (+new Date() - time) + \"ms\");\n                        cnt++;\n                        if (cnt == extents.length) {\n                            surfobj.done = true;\n                            releaseMemory();\n                            resolve(surfid); //caller of helper will resolve callback if present\n                        }\n                    };\n\n                    var efunction = function (event) {\n                        releaseMemory();\n                        console.log(event.message + \" (\" + event.filename + \":\" + event.lineno + \")\");\n                        reject(event);\n                    };\n\n                    for (let i = 0; i < extents.length; i++) {\n                        var worker = workers[i % workers.length];\n                        worker.onmessage = rfunction;\n                        worker.onerror = efunction;\n\n                        worker.postMessage({\n                            'type': type,\n                            'expandedExtent': extents[i].extent,\n                            'extendedAtoms': extents[i].atoms,\n                            'atomsToShow': extents[i].toshow\n                        });\n                    }\n                });\n            }\n        };\n\n        style = style || {};\n        mat = GLViewer.getMatWithStyle(style);\n        let surf: Surface = new Surface([]);\n        //save configuration of surface\n        surf.style = style;\n        surf.atomsel = atomsel;\n        surf.allsel = allsel;\n        surf.focus = focus;\n        var promise = null;\n        if (symmetries) { //do preprocessing\n            var modelsAtomList = {};\n            var modelsAtomsToShow = {};\n            for (n = 0; n < this.models.length; n++) {\n                modelsAtomList[n] = [];\n                modelsAtomsToShow[n] = [];\n            }\n            for (n = 0; n < atomlist.length; n++) {\n                modelsAtomList[atomlist[n].model].push(atomlist[n]);\n            }\n            for (n = 0; n < atomsToShow.length; n++) {\n                modelsAtomsToShow[atomsToShow[n].model].push(atomsToShow[n]);\n            }\n            var promises = [];\n            for (n = 0; n < this.models.length; n++) {\n                if (modelsAtomsToShow[n].length > 0) {\n                    surf.push({\n                        geo: new Geometry(true),\n                        mat: mat,\n                        done: false,\n                        finished: false,\n                        symmetries: this.models[n].getSymmetries()\n                        // also webgl initialized\n                    });\n                    promises.push(addSurfaceHelper(surf[surf.length - 1], modelsAtomList[n], modelsAtomsToShow[n]));\n                }\n            }\n            promise = Promise.all(promises);\n        }\n        else {\n            surf.push({\n                geo: new Geometry(true),\n                mat: mat,\n                done: false,\n                finished: false,\n                symmetries: [new Matrix4()]\n            });\n            promise = addSurfaceHelper(surf[surf.length - 1], atomlist, atomsToShow);\n        }\n        this.surfaces[surfid] = surf;\n        promise.surfid = surfid;\n\n        if (surfacecallback && typeof (surfacecallback) == \"function\") {\n            promise.then(function (surfid) {\n                surfacecallback(surfid);\n            });\n            return surfid;\n        }\n        else {\n            return promise;\n        }\n    };\n\n    /**\n     * Set the surface material to something else, must render change\n     * @param {number} surf - Surface ID to apply changes to\n     * @param {SurfaceStyleSpec} style - new material style specification\n     @example\n     $3Dmol.get(\"data/9002806.cif\",function(data){\n        viewer.addModel(data);\n        viewer.setStyle({stick:{}});\n        let surf = viewer.addSurface(\"SAS\");\n        surf.then(function() {\n            viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});\n            viewer.render();\n            });\n       });\n     */\n    public setSurfaceMaterialStyle(surf: number, style: SurfaceStyleSpec) {\n        adjustVolumeStyle(style);\n        if (this.surfaces[surf]) {\n            var surfArr = this.surfaces[surf];\n            for (let i = 0; i < surfArr.length; i++) {\n                var mat = surfArr[i].mat = GLViewer.getMatWithStyle(style);\n                surfArr[i].mat.side = FrontSide;\n                if (style.wireframe) {\n                    surfArr[i].geo.setUpWireframe();\n                }\n                if (style.color) {\n                    surfArr[i].mat.color = CC.color(style.color);\n                    surfArr[i].geo.colorsNeedUpdate = true;\n                    const c = CC.color(style.color);\n                    surfArr[i].geo.setColor(c);\n                }\n                else if (mat.voldata && mat.volscheme) {\n                    //convert volumetric data into colors\n                    const scheme = mat.volscheme;\n                    const voldata = mat.voldata;\n                    const cc = CC;\n                    const range = scheme.range() || [-1, 1];\n                    surfArr[i].geo.setColors(function (x, y, z) {\n                        let val = voldata.getVal(x, y, z);\n                        let col = cc.color(scheme.valueToHex(val, range));\n                        return col;\n                    });\n                } else {\n                    surfArr[i].geo.colorsNeedUpdate = true;\n                    for (let geo of surfArr[i].geo.geometryGroups) {\n                        for (let j = 0; j < geo.vertices; j++) {\n                            let c = getColorFromStyle(geo.atomArray[j], style);\n                            let off = 3 * j;\n                            geo.colorArray[off] = c.r;\n                            geo.colorArray[off + 1] = c.g;\n                            geo.colorArray[off + 2] = c.b;\n                        }\n                    }\n                }\n                surfArr[i].finished = false; // trigger redraw\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Return surface object\n     * @param {number} surf - surface id\n     */\n    public getSurface(surf: number) {\n        return this.surfaces[surf];\n    };\n\n    /**\n     * Remove surface with given ID\n     * @param {number} surf - surface id\n     */\n    public removeSurface(surf: number) {\n        var surfArr = this.surfaces[surf];\n        for (var i = 0; i < surfArr.length; i++) {\n            if (surfArr[i] && surfArr[i].lastGL) {\n                if (surfArr[i].geo !== undefined)\n                    surfArr[i].geo.dispose();\n                if (surfArr[i].mat !== undefined)\n                    surfArr[i].mat.dispose();\n                this.modelGroup.remove(surfArr[i].lastGL); // remove from scene\n            }\n        }\n        delete this.surfaces[surf];\n        this.show();\n        return this;\n    };\n\n    /** Remove all surfaces.\n     **/\n    public removeAllSurfaces() {\n        for (var n in this.surfaces) {\n            if (!this.surfaces.hasOwnProperty(n)) continue;\n            var surfArr = this.surfaces[n];\n            for (var i = 0; i < surfArr.length; i++) {\n                if (surfArr[i] && surfArr[i].lastGL) {\n                    if (surfArr[i].geo !== undefined)\n                        surfArr[i].geo.dispose();\n                    if (surfArr[i].mat !== undefined)\n                        surfArr[i].mat.dispose();\n                    this.modelGroup.remove(surfArr[i].lastGL); // remove from scene\n                }\n            }\n            delete this.surfaces[n];\n        }\n        this.show();\n        return this;\n    };\n\n    /** return Jmol moveto command to position this scene */\n    public jmolMoveTo() {\n        var pos = this.modelGroup.position;\n        // center on same position\n        var ret = \"center { \" + (-pos.x) + \" \" + (-pos.y) + \" \" + (-pos.z)\n            + \" }; \";\n        // apply rotation\n        var q = this.rotationGroup.quaternion;\n        ret += \"moveto .5 quaternion { \" + q.x + \" \" + q.y + \" \" + q.z\n            + \" \" + q.w + \" };\";\n        // zoom is tricky.. maybe i would be best to let callee zoom on\n        // selection?\n        // can either do a bunch of math, or maybe zoom to the center with a\n        // fixed\n        // but reasonable percentage\n\n        return ret;\n    };\n\n    /** Clear scene of all objects\n     * */\n    public clear() {\n        this.removeAllSurfaces();\n        this.removeAllModels();\n        this.removeAllLabels();\n        this.removeAllShapes();\n        this.show();\n        return this;\n    };\n\n    // props is a list of objects that select certain atoms and enumerate\n    // properties for those atoms\n    /**\n     * Add specified properties to all atoms matching input argument\n     * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties\n     * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here\n         @example\n         $3Dmol.get('../test_structs/b.sdf', function(data){\n                  viewer.addModel(data,'sdf');\n                  let props = [];\n                  //make the atom index a property x\n                  for(let i = 0; i < 8; i++) {\n                    props.push({index:i,props:{'x':i}});\n                  }\n                  viewer.mapAtomProperties(props);\n                  viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});\n                  viewer.zoomTo();\n                  viewer.render();\n                });\n     */\n    public mapAtomProperties(props, sel: AtomSelectionSpec) {\n        sel = sel || {};\n        var atoms = this.getAtomsFromSel(sel);\n\n        if (typeof (props) == \"function\") {\n            for (let a = 0, numa = atoms.length; a < numa; a++) {\n                let atom = atoms[a];\n                props(atom);\n            }\n        }\n        else {\n            for (let a = 0, numa = atoms.length; a < numa; a++) {\n                var atom = atoms[a];\n                for (let i = 0, n = props.length; i < n; i++) {\n                    let prop = props[i];\n                    if (prop.props) {\n                        for (var p in prop.props) {\n                            if (prop.props.hasOwnProperty(p)) {\n                                // check the atom\n                                if (this.atomIsSelected(atom, prop)) {\n                                    if (!atom.properties)\n                                        atom.properties = {};\n                                    atom.properties[p] = prop.props[p];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Synchronize this view matrix of this viewer to the passed viewer.\n     * When the viewpoint of this viewer changes, the other viewer will\n     * be set to this viewer's view.\n     * @param {GLViewer} otherview\n     */\n    public linkViewer(otherviewer: GLViewer) {\n        this.linkedViewers.push(otherviewer);\n        return this;\n    };\n\n    /**\n     * Return the z distance between the model and the camera\n     * @return {number} distance\n     */\n    public getPerceivedDistance() {\n        return this.CAMERA_Z - this.rotationGroup.position.z;\n    };\n\n    /**\n     * Set the distance between the model and the camera\n     * Essentially zooming. Useful while stereo rendering.\n     */\n    public setPerceivedDistance(dist: number) {\n        this.rotationGroup.position.z = this.CAMERA_Z - dist;\n    };\n\n    /**\n     * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object\n     * @return {number} camera x position\n     */\n    public setAutoEyeSeparation(isright: boolean, x: number) {\n        var dist = this.getPerceivedDistance();\n        if (!x) x = 5.0;\n        if (isright || this.camera.position.x > 0) //setting a value of dist*tan(x)\n            this.camera.position.x = dist * Math.tan(Math.PI / 180.0 * x);\n        else\n            this.camera.position.x = -dist * Math.tan(Math.PI / 180.0 * x);\n        this.camera.lookAt(new Vector3(0, 0, this.rotationGroup.position.z));\n        return this.camera.position.x;\n    };\n\n    /**\n     * Set the default cartoon quality for newly created models.  Default is 5.\n     * Current models are not affected.\n     * @number quality, higher results in higher resolution renders\n     */\n    public setDefaultCartoonQuality(val: number) {\n        this.config.cartoonQuality = val;\n    };\n\n}\n\n\n/**\n * Create and initialize an appropriate viewer at supplied HTML element using specification in config\n * @param {Object | string} element - Either HTML element or string identifier\n * @param {ViewerSpec} [config] Viewer configuration\n * @return {GLViewer} GLViewer, null if unable to instantiate WebGL\n * @example\n   var viewer = $3Dmol.createViewer(\n     'gldiv', //id of div to create canvas in\n     {\n       defaultcolors: $3Dmol.elementColors.rasmol,\n       backgroundColor: 'black'\n     }\n   );\n *\n */\nexport function createViewer(element, config?: ViewerSpec) {\n    element = getElement(element);\n    if (!element) return;\n\n    config = config || {};\n    //try to create the  viewer\n    try {\n        var viewer = new GLViewer(element, config);\n        return viewer;\n    }\n    catch (e) {\n        throw \"error creating viewer: \" + e;\n    }\n};\n\n/**\n * Create and initialize an appropriate a grid of viewers that share a WebGL canvas\n * @param {Object | string} element - Either HTML element or string identifier\n * @param {GridSpec} [config] - grid configuration\n * @param {ViewerGridSpec} [viewer_config] - Viewer specification to apply to all subviewers\n * @return [[GLViewer]] 2D array of GLViewers\n * @example\n   var viewers = $3Dmol.createViewerGrid(\n     'gldiv', //id of div to create canvas in\n     {\n       rows: 2,\n       cols: 2,\n       control_all: true  //mouse controls all viewers\n     },\n     { backgroundColor: 'lightgrey' }\n   );\n   $3Dmol.get('data/1jpy.cif', function(data) {\n     var viewer = viewers[0][0];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({sphere:{}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[0][1];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({stick:{}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[1][0];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({cartoon:{color:'spectrum'}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[1][1];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({cartoon:{colorscheme:'chain'}});\n     viewer.zoomTo();\n     viewer.render();\n\n\n   });\n\n */\nexport function createViewerGrid(element, config: ViewerGridSpec = {}, viewer_config: ViewerSpec = {}) {\n    element = getElement(element);\n    if (!element) return;\n\n    var viewers = [];\n    //create canvas\n    var canvas = document.createElement('canvas');\n\n    viewer_config.rows = config.rows;\n    viewer_config.cols = config.cols;\n    viewer_config.control_all = config.control_all != undefined ? config.control_all : false;\n    element.appendChild(canvas);\n\n    //try to create the  viewer\n    try {\n        for (var r = 0; r < config.rows; r++) {\n            var row = [];\n            for (var c = 0; c < config.cols; c++) {\n                viewer_config.row = r;\n                viewer_config.col = c;\n                viewer_config.canvas = canvas;\n                viewer_config.viewers = viewers;\n                viewer_config.control_all = config.control_all;\n                var viewer = createViewer(element, extend({}, viewer_config));\n                row.push(viewer);\n            }\n            viewers.unshift(row); //compensate for weird ordering in renderer\n        }\n    } catch (e) {\n        throw \"error creating viewer grid: \" + e;\n    }\n\n    return viewers;\n};\n\n\n/* StereoViewer for stereoscopic viewing\n* @param {Object | string} element - Either HTML element or string identifier\n*\n*/\nexport function createStereoViewer(element) {\n    var that = this;\n    element = getElement(element);\n    if (!element) return;\n\n    var viewers = createViewerGrid(element, { rows: 1, cols: 2, control_all: true });\n\n    this.glviewer1 = viewers[0][0];\n    this.glviewer2 = viewers[0][1];\n\n    this.glviewer1.setAutoEyeSeparation(false);\n    this.glviewer2.setAutoEyeSeparation(true);\n\n    this.glviewer1.linkViewer(this.glviewer2);\n    this.glviewer2.linkViewer(this.glviewer1);\n\n    var methods = Object.getOwnPropertyNames(this.glviewer1.__proto__) //get all methods of glviewer object\n        .filter(function (property) {\n            return typeof that.glviewer1[property] == 'function';\n        });\n\n    for (var i = 0; i < methods.length; i++) { //create methods of the same name\n        this[methods[i]] = (function (method) {\n            return function () {\n                var m1 = this.glviewer1[method].apply(this.glviewer1, arguments);\n                var m2 = this.glviewer2[method].apply(this.glviewer2, arguments);\n                return [m1, m2];\n            };\n        })(methods[i]);\n    }\n\n    //special cased methods\n    this.setCoordinates = function (models, data, format) { //for setting the coordinates of the models\n        for (var i = 0; i < models.length; i++) {\n            models[i].setCoordinates(data, format);\n        }\n    };\n\n    this.surfacesFinished = function () {\n        return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();\n    };\n\n    this.isAnimated = function () {\n        return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();\n    };\n\n    this.render = function (callback) {\n        this.glviewer1.render();\n        this.glviewer2.render();\n        if (callback) {\n            callback(this); //call only once\n        }\n    };\n\n    this.getCanvas = function () {\n        return this.glviewer1.getCanvas(); //same for both\n    };\n\n};\n\n\n/**\n * Outline style configuration parameters\n */\nexport interface OutlineStyle {\n    /** Width of the outline */\n    width?: number;\n    /** Color of the outline */\n    color?: ColorSpec;\n    /** Maximum width in screen pixels of outline. */\n    maxpixels?: number;\n}\n\n/**\n * AmbientOcclusion style configuration parameters\n */\nexport interface AmbientOcclusionStyle {\n    /** Strength (darkness) of shading (default 1.0) */\n    strength?: number;\n    /** Radius (in Angstroms) used to detect occlusions (default 5.0). */\n    radius?: number;\n}\n\n/**\n * View style configuration\n */\nexport interface ViewStyle {\n    /** How to style viewer: outline|ambientOcclusion|none */\n    style?: string;\n    /** Ambient occlusion strength (darkness) of shading (default 1.0) */\n    strength?: number;\n    /** Ambient occlusion radius (in Angstroms) used to detect occlusions (default 5.0). */\n    radius?: number;\n    /** Width of the outline */\n    width?: number;\n    /** Color of the outline */\n    color?: ColorSpec;\n}\n/**\n * GLViewer input specification\n */\nexport interface ViewerSpec {\n    /** Callback function to be executed with this viewer after setup is complete */\n    callback?: (viewer: ViewerSpec) => void;\n    /** Object defining default atom colors as atom => color property value pairs for all models within this viewer */\n    defaultcolors?: Record<string, ColorSpec>;\n    /**\n     * Whether to disable disable handling of mouse events.\n     * If you want to use your own mouse handlers, set this then bind your handlers to the canvas object.\n                  The default 3Dmol.js handlers are available for use:\n                  'mousedown touchstart': viewer._handleMouseDown,\n                  'DOMMouseScroll mousewheel': viewer._handleMouseScroll\n                  'mousemove touchmove': viewer._handleMouseMove\n     */\n    nomouse?: boolean | string;\n    /** Color of the canvas background */\n    backgroundColor?: string;\n    /** Alpha transparency of canvas background */\n    backgroundAlpha?: number;\n    /** */\n    camerax?: number | string;\n    /** */\n    hoverDuration?: number;\n    /** id of the canvas */\n    id?: string;\n    /** default 10 */\n    cartoonQuality?: number;\n    /** */\n    row?: number;\n    /** */\n    col?: number;\n    /** */\n    rows?: number;\n    /** */\n    cols?: number;\n    /** */\n    canvas?: HTMLCanvasElement;\n    viewers?: GLViewer[];\n    /** */\n    minimumZoomToDistance?: number;\n    /** */\n    lowerZoomLimit?: number;\n    /** */\n    upperZoomLimit?: number;\n    /** Enable antialiasing */\n    antialias?: boolean;\n    /** Render upscaled to 2x resolution. Defaults to antialiasing setting. Ignored for Retina displays. */\n    upscale?: boolean;\n    /** */\n    control_all?: boolean;\n    /** Orthographic instead of perspective rendering. Default false. */\n    orthographic?: boolean;\n    /** Disable fog, default to false */\n    disableFog?: boolean;\n    /** outline or ambientOcclusion **deprecated** */\n    style?: string;\n    /** Outline parameters */\n    outline?: OutlineStyle;\n    /** Ambient occlusion settings */\n    ambientOcclusion?: AmbientOcclusionStyle;\n\n};\n\n/**\n * Grid GLViewer input specification\n */\nexport interface ViewerGridSpec {\n    /** number of rows in grid */\n    rows?: number;\n    /** number of columns in grid */\n    cols?: number;\n    /** if true, mouse events are linked */\n    control_all?: boolean;\n};\n\n\n/**\n * @example\n * var setStyles = function(volumedata){\n *  var data = new $3Dmol.VolumeData(volumedata, \"cube\");\n *  viewer.addSurface(\"VDW\", {opacity:0.85, voldata: data, volscheme: new $3Dmol.Gradient.RWB(-10,10)},{chain:'A'});\n *  viewer.mapAtomProperties($3Dmol.applyPartialCharges);\n *  viewer.addSurface($3Dmol.SurfaceType.SAS, {map:{prop:'partialCharge',scheme:new $3Dmol.Gradient.RWB(-.05,.05)}, opacity:1.0},{chain:'B'});\n *  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: data, color:'red'},{chain:'C'});\n *  viewer.addSurface($3Dmol.SurfaceType.SAS, {opacity:0.85,voldata: data, colorscheme:'greenCarbon'},{chain:'D'});\n *  viewer.render();\n * };\n * $3Dmol.download(\"pdb:4DLN\",viewer,{},function(){\n *   $.get(\"data/1fas.cube\",setStyles);\n * });\n */\nexport interface SurfaceStyleSpec {\n    /** one sided material - back is transparent */\n    onesided?: boolean;\n    /** sets the transparency: 0 to hide, 1 for fully opaque */\n    opacity?: number;\n    /** element based coloring */\n    colorscheme?: ColorschemeSpec;\n    /** fixed coloring, overrides colorscheme */\n    color?: ColorSpec;\n    /** volumetric data for vertex coloring, can be VolumeData object or raw data if volformat is specified */\n    voldata?: VolumeData;\n    /** coloring scheme for mapping volumetric data to vertex color, if not a Gradient object, show describe a builtin gradient one by providing an object with gradient, min, max, and (optionally) mid fields. */\n    volscheme?: Gradient;\n    /** format of voldata if not a {VolumeData} object */\n    volformat?: string;\n    /** Display as wireframe */\n    wireframe?: boolean;\n    /* specifies a numeric atom property (prop) and color mapping (scheme) such as {@link $3Dmol.Gradient.RWB}.  Deprecated, use colorscheme instead. */\n    map?: Record<string, unknown>\n};\n\n\n/** Style specification ofr unit cell shape.  */\nexport interface UnitCellStyleSpec {\n    /** line style used to draw box */\n    box?: LineStyleSpec;\n    /** arrow specification of the \"a\" axis */\n    astyle?: ArrowSpec;\n    /** arrow specification of the \"b\" axis */\n    bstyle?: ArrowSpec;\n    /** arrow specification of the \"c\" axis */\n    cstyle?: ArrowSpec;\n    /** label for \"a\" axis */\n    alabel?: string;\n    /** label style for a axis */\n    alabelstyle?: LabelSpec;\n    /** label for \"b\" axis */\n    blabel?: string;\n    /** label style for b axis */\n    blabelstyle?: LabelSpec;\n    /** label for \"c\" axis */\n    clabel?: string;\n    /** label style for c axis */\n    clabelstyle?: LabelSpec;\n}\n\n/** Fog specification. */\nexport interface FogSpec {\n    /** Fraction within the slab where fog starts to be linearly added. Default 0.4. */\n    fogStart?: number;\n    /** Fraction with the slab where fog ends (nothing visible after this point). Default 1.0. */\n    fogEnd?: number;\n}\n", "import { CC, Color, ColorSpec } from \"./colors\";\n\nexport abstract class GradientType {\n  gradient?: string;\n  abstract valueToHex(value: number, range?: number[]): number;\n  abstract range(): number[] | null;\n}\n\nexport function normalizeValue(\n  lo: number,\n  hi: number,\n  val: number\n): { lo: number; hi: number; val: number } {\n  if (hi >= lo) {\n    if (val < lo) val = lo;\n    if (val > hi) val = hi;\n    return { lo: lo, hi: hi, val: val };\n  } else {\n    if (val > lo) val = lo;\n    if (val < hi) val = hi;\n    //flip the meaning of val, lo, hi\n    val = lo - val + hi;\n    return { lo: hi, hi: lo, val: val };\n  }\n}\n\n/**\n*  Gradient specification.\n* @see builtinGradients\n*/\nexport type GradientSpec = {\n  /** Kind of gradient. E.g. RWB, ROYGB, sinebow.  Can also specify linear[_color]* as a\n   * shorthand for CustomLinear and passing a colors array.   */\n  gradient?: string;\n  /** Lower range of gradient */\n  min?: number;\n  /** Upper range of gradient */\n  max?: number;\n  /**  {AtomSpec} property to use for gradient calculation.  E.g., 'b' for temperature factors of a PDB. */\n  prop?: string;\n  /** mid point value for gradient (for rwb) */\n  mid?: number;\n  /** Custom colors for gradient (for {@link CustomLinear}) */\n  colors?: Array<ColorSpec>;\n  /** map of a certain {@link AtomSpec} property to a color of the form `{'prop': 'elem', map:elementColors.greenCarbon}` Allows the user to provide a mapping of elements to colors to the colorscheme.  This can be done with any properties, and not just 'elem'.\n */\n  map?: Record<string, unknown>\n};\n\n//return a Gradient object, even if what is specified is descriptive\nexport function getGradient(grad: GradientSpec|GradientType): GradientType {\n  if (grad instanceof GradientType) {\n    return grad;\n  } else if (grad.gradient !== undefined && builtinGradients[grad.gradient]\n  ) {\n    let min = grad.min === undefined ? -1 : grad.min;\n    let max = grad.max === undefined ? 1 : grad.max;\n    if (grad.mid === undefined) {\n      if (grad.colors === undefined) {\n        return new builtinGradients[grad.gradient](min, max);\n      } else {\n        return new builtinGradients[grad.gradient](min, max, grad.colors);\n      }\n    } else {\n      return new builtinGradients[grad.gradient](min, max, grad.mid);\n    }\n  } else if(typeof(grad.gradient) == \"string\" && grad.gradient.startsWith('linear_')) {\n    let colors = grad.gradient.split('_');\n    colors.shift();\n    let min = grad.min === undefined ? -1 : grad.min;\n    let max = grad.max === undefined ? 1 : grad.max;    \n    return new CustomLinear(min,max,colors);\n  }\n  return grad as GradientType;\n}\n\n/**\n * Color scheme red to white to blue, for charges\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * @subcategory Gradients\n */\nexport class RWB extends GradientType {\n  gradient = \"RWB\";\n  min: number;\n  max: number;\n  mid?: number;\n  mult: number;\n  constructor(min?: number | [number, number], max?: number, mid?: number) {\n    super();\n    this.mult = 1.0;\n    this.mid = mid;\n    this.min = min as number;\n    this.max = max as number;\n    if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n      //we were passed a single range\n      this.max = min[1];\n      this.min = min[0];\n    } else if (!!min && !!max && !Array.isArray(min)) {\n      this.min = min;\n      this.max = max;\n    }\n  }\n\n  //return range used for color mapping, null if none set\n  range() {\n    if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n      return [this.min, this.max] as [number, number];\n    }\n    return null;\n  }\n\n  //map value to hex color, range is provided\n  valueToHex(val: number, range?: number[]) {\n    var lo: number, hi: number;\n    val = this.mult * val; //reverse if necessary\n    if (range) {\n      lo = range[0];\n      hi = range[1];\n    } else {\n      lo = this.min;\n      hi = this.max;\n    }\n\n    if (val === undefined) return 0xffffff;\n\n    var norm = normalizeValue(lo, hi, val);\n    lo = norm.lo;\n    hi = norm.hi;\n    val = norm.val;\n\n    var middle = (hi + lo) / 2;\n    if (range && typeof range[2] != \"undefined\") middle = range[2];\n    else if (typeof this.mid != \"undefined\")\n      middle = this.mid; //allow user to specify midpoint\n    else middle = (lo + hi) / 2;\n    var scale: number, color: number;\n\n    //scale bottom from red to white\n    if (val < middle) {\n      scale = Math.floor(255 * Math.sqrt((val - lo) / (middle - lo)));\n      color = 0xff0000 + 0x100 * scale + scale;\n      return color;\n    } else if (val > middle) {\n      //form white to blue\n      scale = Math.floor(255 * Math.sqrt(1 - (val - middle) / (hi - middle)));\n      color = 0x10000 * scale + 0x100 * scale + 0xff;\n      return color;\n    } else {\n      //val == middle\n      return 0xffffff;\n    }\n  }\n}\n\n/**\n * rainbow gradient, but without purple to match jmol\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * @subcategory Gradients\n */\nexport class ROYGB extends GradientType {\n  gradient = \"ROYGB\";\n  mult: number;\n  max?: number;\n  min?: number;\n  constructor(min?: number, max?: number) {\n    super();\n    this.mult = 1.0;\n    this.min = min;\n    this.max = max;\n    if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n      //we were passed a single range\n      this.max = min[1];\n      this.min = min[0];\n    } else if (!!min && !!max && !Array.isArray(min)) {\n      this.min = min;\n      this.max = max;\n    }\n  };\n  //map value to hex color, range is provided\n  valueToHex(val: number, range?: any[]) {\n    var lo: number, hi: number;\n    val = this.mult * val;\n    if (range) {\n      lo = range[0];\n      hi = range[1];\n    } else {\n      lo = this.min!;\n      hi = this.max!;\n    }\n\n    if (typeof val == \"undefined\") return 0xffffff;\n\n    var norm = normalizeValue(lo, hi, val);\n    lo = norm.lo;\n    hi = norm.hi;\n    val = norm.val;\n\n    var mid = (lo + hi) / 2;\n    var q1 = (lo + mid) / 2;\n    var q3 = (mid + hi) / 2;\n\n    var scale: number, color: number;\n    if (val < q1) {\n      //scale green up, red up, blue down\n      scale = Math.floor(255 * Math.sqrt((val - lo) / (q1 - lo)));\n      color = 0xff0000 + 0x100 * scale + 0;\n      return color;\n    } else if (val < mid) {\n      //scale red down, green up, blue down\n      scale = Math.floor(255 * Math.sqrt(1 - (val - q1) / (mid - q1)));\n      color = 0x010000 * scale + 0xff00 + 0x0;\n      return color;\n    } else if (val < q3) {\n      //scale blue up, red down, green up\n      scale = Math.floor(255 * Math.sqrt((val - mid) / (q3 - mid)));\n      color = 0x000000 + 0xff00 + 0x1 * scale;\n      return color;\n    } else {\n      //scale green down, blue up, red down\n      scale = Math.floor(255 * Math.sqrt(1 - (val - q3) / (hi - q3)));\n      color = 0x000000 + 0x0100 * scale + 0xff;\n      return color;\n    }\n  };\n\n  //return range used for color mapping, null if none set\n  range() {\n    if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n      return [this.min, this.max] as [number, number];\n    }\n    return null;\n  };\n}\n/**\n * rainbow gradient with constant saturation, all the way to purple!\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n  * @subcategory Gradients \n * \n * @example $.get('data/1fas.pqr', function(data){\n      viewer.addModel(data, \"pqr\");\n      $.get(\"data/1fas.cube\",function(volumedata){\n          viewer.addSurface($3Dmol.SurfaceType.VDW, {\n              opacity:0.85,\n              voldata: new $3Dmol.VolumeData(volumedata, \"cube\"),\n              volscheme: new $3Dmol.Gradient.Sinebow(2,0,1)\n          },{});\n          \n      viewer.render();\n      });\n      viewer.zoomTo();\n  });\n */\nexport class Sinebow extends GradientType {\n  gradient = \"Sinebow\";\n  mult: number;\n  max: number;\n  min: number;\n  constructor(min: number, max: number) {\n    super();\n    this.mult = 1.0;\n    this.min = min;\n    this.max = max;\n    if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n      //we were passed a single range\n      this.max = min[1];\n      this.min = min[0];\n    }\n    if (max < min) {\n      //reverse the order\n      this.mult = -1.0;\n      this.min *= -1.0;\n      this.max *= -1.0;\n    }\n  };\n\n  //map value to hex color, range is provided\n  valueToHex(val: number, range?: any[]) {\n    var lo: number, hi: number;\n    val = this.mult * val;\n    if (range) {\n      lo = range[0];\n      hi = range[1];\n    } else {\n      lo = this.min;\n      hi = this.max;\n    }\n\n    if (typeof val == \"undefined\") return 0xffffff;\n    var norm = Gradient.normalizeValue(lo, hi, val);\n    lo = norm.lo;\n    hi = norm.hi;\n    val = norm.val;\n\n    var scale = (val - lo) / (hi - lo);\n    var h = (5 * scale) / 6.0 + 0.5;\n    var r = Math.sin(Math.PI * h);\n    r *= r * 255;\n    var g = Math.sin(Math.PI * (h + 1 / 3.0));\n    g *= g * 255;\n    var b = Math.sin(Math.PI * (h + 2 / 3.0));\n    b *= b * 255;\n\n    return (\n      0x10000 * Math.floor(r) + 0x100 * Math.floor(b) + 0x1 * Math.floor(g)\n    );\n  };\n\n  //return range used for color mapping, null if none set\n  range() {\n    if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n      return [this.min, this.max] as [number, number];\n    }\n    return null;\n  };\n}\n\n\n/**\n * Custom linear gradient using user supplied colors.\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * Midpoints are not supported - color map should be specified to get desired middle color.\n * \n * @param {number} min \n * @param {number} max\n * @param {Array} colors  Array of colors that will be linearly interpolated between from min to max values.\n * @subcategory Gradients\n * \n * @example\n       $3Dmol.get('../test_structs/af.pdb', function(data){\n              viewer.addModel(data);\n              viewer.setStyle({cartoon:{colorscheme:{prop: 'b', gradient:'linear', min: 70, max: 100, colors: [\"blue\",\"yellow\",\"green\"]}}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n */\nexport class CustomLinear extends GradientType {\n  gradient = \"linear\";\n  min: number;\n  max: number;\n  colors = new Array<Color>();\n\n  constructor(min: any, max: any, colors?: any) {\n    super();\n\n    var carr: Array<any>;\n    if (Array.isArray(min) && min.length >= 2) {\n      //we were passed a single range\n      this.max = min[1] as number;\n      this.min = min[0] as number;\n      carr = max;\n    } else {\n      this.min = min as number;\n      this.max = max as number;\n      carr = colors;\n    }\n\n    //convert colors\n    if (carr) {\n      for (let c of carr) {\n        this.colors.push(CC.color(c));\n      }\n    } else {\n      this.colors.push(CC.color(0));\n    }\n\n  }\n\n  //return range used for color mapping, null if none set\n  range() {\n    if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n      return [this.min, this.max] as [number, number];\n    }\n    return null;\n  }\n\n  //map value to hex color, range is provided\n  valueToHex(val: number, range?: any[]) {\n    var lo: number, hi: number;\n    if (range) {\n      lo = range[0];\n      hi = range[1];\n    } else {\n      lo = this.min;\n      hi = this.max;\n    }\n\n    if (val === undefined) return 0xffffff;\n\n    var norm = normalizeValue(lo, hi, val);\n    lo = norm.lo;\n    hi = norm.hi;\n    val = norm.val;\n\n    let nsteps = this.colors.length;\n    let stepsize = (hi - lo) / nsteps;\n    let startpos = Math.min(Math.floor((val - lo) / stepsize), nsteps - 1);\n    let endpos = Math.min(startpos + 1, nsteps - 1);\n\n    let frac = (val - lo - (startpos * stepsize)) / stepsize;\n\n    let startcol = this.colors[startpos];\n    let endcol = this.colors[endpos];\n\n    let col = new Color(startcol.r + frac * (endcol.r - startcol.r),\n      startcol.g + frac * (endcol.g - startcol.g),\n      startcol.b + frac * (endcol.b - startcol.b));\n    return col.getHex();\n  }\n}\n\n/**\n * built in gradient schemes\n * The user can pass these strings directly as the gradient\n * @prop rwb - red/white/blue, supports setting a mid point for white\n * @prop roygb - rainbow\n * @prop sinebow - rainbow with better saturation properties\n * @prop linear  - linearly maps between provided colors\n *\n  */\n export const builtinGradients  = {\n  \"rwb\": RWB,\n  \"RWB\": RWB,\n  \"roygb\": ROYGB,\n  \"ROYGB\": ROYGB,\n  \"sinebow\": Sinebow,\n  \"linear\": CustomLinear\n};\n\nexport class Gradient extends GradientType {\n  static RWB = RWB;\n  static ROYGB = ROYGB;\n  static Sinebow = Sinebow;\n  static CustomLinear = CustomLinear;\n  static builtinGradients = builtinGradients;\n  static normalizeValue = normalizeValue;\n  static getGradient = getGradient;\n  valueToHex(_value: number, _range?: number[]): number { return 0; }\n  range(): [number, number] | null { return null; }\n}", "import {\n  SpriteAlignment,\n  Texture,\n  SpriteMaterial,\n  Sprite,\n  Vector2,\n  Material,\n} from \"./WebGL\";\nimport { Gradient } from \"./Gradient\";\nimport { Color, CC, ColorSpec } from \"./colors\";\nimport {XYZ} from \"./WebGL/math\"\n\n// Adapted from the text sprite example from http://stemkoski.github.io/Three.js/index.html\n\nexport let LabelCount = 0;\n\n// Function for drawing rounded rectangles - for Label drawing\nfunction roundRect(ctx: CanvasRenderingContext2D, x: any, y: any, w: number, h: number, r: number, drawBorder: boolean) {\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.lineTo(x + w - r, y);\n  ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n  ctx.lineTo(x + w, y + h - r);\n  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n  ctx.lineTo(x + r, y + h);\n  ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n  ctx.lineTo(x, y + r);\n  ctx.quadraticCurveTo(x, y, x + r, y);\n  ctx.closePath();\n  ctx.fill();\n  if (drawBorder) ctx.stroke();\n}\n\n//do all the checks to figure out what color is desired\nfunction getColor(style: any, stylealpha?: any, init?: any) {\n  var ret = init;\n  if (typeof style != \"undefined\") {\n    //convet regular colors\n    if (style instanceof Color) ret = style.scaled();\n    else {\n      //hex or name\n      ret = CC.color(style);\n      if (typeof ret.scaled != \"undefined\") {\n        ret = ret.scaled(); //not already scaled to 255\n      }\n    }\n  }\n  if (typeof stylealpha != \"undefined\") {\n    ret.a = parseFloat(stylealpha);\n  }\n  return ret;\n}\n\n/** Label style specification */\nexport interface LabelSpec {\n/** font name, default sans-serif */\n  font?: string;\n  /** height of text, default 18 */\n  fontSize?: number;\n  /** font color, default white */\n  fontColor?: ColorSpec;\n  /** font opacity, default 1 */\n  fontOpacity?: number;\n  /** line width of border around label, default 0  */\n  borderThickness?: number;\n  /** color of border, default backgroundColor */\n  borderColor?: ColorSpec;\n  /** opacity of border */\n  borderOpacity?: number;\n  /** color of background, default black */\n  backgroundColor?: ColorSpec;\n  /** opacity of background, default 1.0 */\n  backgroundOpacity?: number;\n  /** coordinates for label */\n  position?: XYZ;\n  /** x,y,z pixel offset of label from position; for screen labels z is a z-index */\n  screenOffset?: Vector2;\n  /** always put labels in front of model */\n  inFront?: boolean;\n  /** show background rounded rectangle, default true */\n  showBackground?: boolean;\n  /** position is in screen (not model) coordinates which are pixel offsets from the upper left corner */\n  useScreen?: boolean;\n  /** An elment to draw into the label. Any CanvasImageSource is allowed.  Label is resized to size of image */\n  backgroundImage?: any;\n  /** how to orient the label w/respect to position: \"topLeft\" (default),\n   * \"topCenter\", \"topRight\", \"centerLeft\", \"center\", \"centerRight\",\n   * \"bottomLeft\", \"bottomCenter\", \"bottomRight\", or an arbitrary offset */\n  alignment?: string | Vector2;\n  /** if set, only display in this frame of an animation */\n  frame?: number;\n}\n\n/**\n * Renderable labels\n * @constructor $3Dmol.Label\n * @param {string} tag - Label text\n * @param {LabelSpec} parameters Label style and font specifications\n */\nexport class Label {\n  id: number;\n  stylespec: any;\n  canvas: HTMLCanvasElement;\n  context: any;\n  sprite: Sprite;\n  text: any;\n  frame: any;\n  constructor(text: string, parameters: LabelSpec) {\n    this.id = LabelCount++;\n    this.stylespec = parameters || {};\n\n    this.canvas = document.createElement(\"canvas\");\n    //todo: implement resizing canvas..\n    this.canvas.width = 134;\n    this.canvas.height = 35;\n    this.context = this.canvas.getContext(\"2d\");\n    this.sprite = new Sprite();\n    this.text = text;\n    this.frame = this.stylespec.frame;\n  }\n\n  getStyle() {\n    return this.stylespec;\n  }\n\n  /** Hide this label. */\n  public hide() {\n    if(this.sprite) {\n      this.sprite.visible = false;\n    }\n  }\n\n  /** Show a hidden label. */\n  public show() {\n    if(this.sprite) {\n      this.sprite.visible = true;\n    }\n  }\n\n  setContext() {\n    var style = this.stylespec;\n    var useScreen =\n      typeof style.useScreen == \"undefined\" ? false : style.useScreen;\n\n    var showBackground = style.showBackground;\n    if (showBackground === \"0\" || showBackground === \"false\")\n      showBackground = false;\n    if (typeof showBackground == \"undefined\") showBackground = true; //default\n    var font = style.font ? style.font : \"sans-serif\";\n\n    var fontSize = parseInt(style.fontSize) ? parseInt(style.fontSize) : 18;\n\n    var fontColor = getColor(style.fontColor, style.fontOpacity, {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0,\n    });\n\n    var padding = style.padding ? style.padding : 4;\n    var borderThickness = style.borderThickness ? style.borderThickness : 0;\n\n    var backgroundColor = getColor(\n      style.backgroundColor,\n      style.backgroundOpacity,\n      {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 1.0,\n      }\n    );\n\n    var borderColor = getColor(\n      style.borderColor,\n      style.borderOpacity,\n      backgroundColor\n    );\n\n    var position = style.position\n      ? style.position\n      : {\n        x: -10,\n        y: 1,\n        z: 1,\n      };\n\n    // Should labels always be in front of model?\n    var inFront = style.inFront !== undefined ? style.inFront : true;\n    if (inFront === \"false\" || inFront === \"0\") inFront = false;\n\n    // clear canvas\n\n    var spriteAlignment = style.alignment || SpriteAlignment.topLeft;\n    if (\n      typeof spriteAlignment == \"string\" &&\n      spriteAlignment in SpriteAlignment\n    ) {\n      spriteAlignment = (SpriteAlignment as any)[spriteAlignment] ;\n    }\n\n    var bold = \"\";\n    if (style.bold) bold = \"bold \";\n    this.context.font = bold + fontSize + \"px  \" + font;\n\n    var metrics = this.context.measureText(this.text);\n    var textWidth = metrics.width;\n\n    if (!showBackground) borderThickness = 0;\n\n    var width = textWidth + 2.5 * borderThickness + 2 * padding;\n    var height = fontSize * 1.25 + 2 * borderThickness + 2 * padding; // 1.25 is extra height factor for text below baseline: g,j,p,q.\n\n    if (style.backgroundImage) {\n      //resize label to image\n      var img = style.backgroundImage;\n      var w = style.backgroundWidth ? style.backgroundWidth : img.width;\n      var h = style.backgroundHeight ? style.backgroundHeight : img.height;\n      if (w > width) width = w;\n      if (h > height) height = h;\n    }\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    bold = \"\";\n    if (style.bold) bold = \"bold \";\n    this.context.font = bold + fontSize + \"px  \" + font;\n\n    // background color\n    this.context.fillStyle =\n      \"rgba(\" +\n      backgroundColor.r +\n      \",\" +\n      backgroundColor.g +\n      \",\" +\n      backgroundColor.b +\n      \",\" +\n      backgroundColor.a +\n      \")\";\n    // border color\n    this.context.strokeStyle =\n      \"rgba(\" +\n      borderColor.r +\n      \",\" +\n      borderColor.g +\n      \",\" +\n      borderColor.b +\n      \",\" +\n      borderColor.a +\n      \")\";\n\n    if (style.backgroundGradient) {\n      let gradient = this.context.createLinearGradient(\n        0,\n        height / 2,\n        width,\n        height / 2\n      );\n      let g = Gradient.getGradient(style.backgroundGradient);\n      let minmax = g.range();\n      let min = -1;\n      let max = 1;\n      if (minmax) {\n        min = minmax[0];\n        max = minmax[1];\n      }\n      let d = max - min;\n      for (let i = 0; i < 1.01; i += 0.1) {\n        let c = getColor(g.valueToHex(min + d * i));\n        let cname = \"rgba(\" + c.r + \",\" + c.g + \",\" + c.b + \",\" + c.a + \")\";\n        gradient.addColorStop(i, cname);\n      }\n      this.context.fillStyle = gradient;\n    }\n\n    this.context.lineWidth = borderThickness;\n    if (showBackground) {\n      roundRect(\n        this.context,\n        borderThickness,\n        borderThickness,\n        width - 2 * borderThickness,\n        height - 2 * borderThickness,\n        6,\n        borderThickness > 0\n      );\n    }\n\n    if (style.backgroundImage) {\n      this.context.drawImage(img, 0, 0, width, height);\n    }\n\n    // text color\n    this.context.fillStyle =\n      \"rgba(\" +\n      fontColor.r +\n      \",\" +\n      fontColor.g +\n      \",\" +\n      fontColor.b +\n      \",\" +\n      fontColor.a +\n      \")\";\n\n    this.context.fillText(\n      this.text,\n      borderThickness + padding,\n      fontSize + borderThickness + padding,\n      textWidth\n    );\n\n    // canvas contents will be used for a texture\n    var texture = new Texture(this.canvas);\n    texture.needsUpdate = true;\n    this.sprite.material = new SpriteMaterial({\n      map: texture,\n      useScreenCoordinates: useScreen,\n      alignment: spriteAlignment,\n      depthTest: !inFront,\n      screenOffset: style.screenOffset || null,\n    }) as Material;\n\n    this.sprite.scale.set(1, 1, 1);\n\n    this.sprite.position.set(position.x, position.y, position.z);\n  }\n\n  // clean up material and texture\n  dispose() {\n    if (this.sprite.material.map !== undefined)\n      this.sprite.material.map.dispose();\n    if (this.sprite.material !== undefined) this.sprite.material.dispose();\n  }\n}\n", "/*  ProteinSurface.js by biochem_fan\n\nPorted and modified for Javascript based on EDTSurf,\n  whose license is as follows.\n\nPermission to use, copy, modify, and distribute this program for any\npurpose, with or without fee, is hereby granted, provided that this\ncopyright notice and the reference information appear in all copies or\nsubstantial portions of the Software. It is provided \"as is\" without\nexpress or implied warranty. \n\nReference:\nhttp://zhanglab.ccmb.med.umich.edu/EDTSurf/\nD. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces\nby Euclidean Distance Transform. PLoS ONE 4(12): e8140.\n\n=======\n\n\n */\nimport {Vector3} from \"./WebGL/math\"\n\n\n/**\n * Surface types\n * @readonly\n * @enum {number}\n * @property VDW - van der Waals surface\n * @property MS - Molecular surface\n * @property SAS - Solvent accessible surface\n * @property SES - Solvent exposed surface\n */\nexport enum SurfaceType {\n    VDW = 1,\n    MS = 2,\n    SAS = 3,\n    SES = 4\n};\n\n/** \n * Render surface synchronously if true\n * @param {boolean} [$3Dmol.syncSurface=false]\n * @type {boolean} */\nexport var syncSurface = false;\n\n/**\n * \n * @param {boolean} val - Whether surfaces should be rendered synchronously or in parallel.\n */\nexport function setSyncSurface(val:boolean) {\n    syncSurface = val;\n}\n\n// Internet Explorer refuses to allow webworkers in data blobs.  I can find\n// no way of checking for this feature directly, so must do a browser check\nif (window.navigator.userAgent.indexOf('MSIE ') >= 0 ||\n    window.navigator.userAgent.indexOf('Trident/') >= 0) {\n    syncSurface = true; // can't use webworkers\n}\n\n\n//Encapsulate marching cube algorithm for isosurface generation\n// (currently used by protein surface rendering and generic volumetric data reading)\nexport class MarchingCubeInitializer {\n    \n    //Marching cube algorithm - assume data has been pre-treated so isovalue is 0 \n    // (i.e. select points greater than 0)\n    //origin -  vector of origin of volumetric data (default is (0,0,0))\n    // nX, nY, nZ - specifies number of voxels in each dimension\n    // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube\n    // - default is 1 - assumes unit cube (1,1,1) diag)\n    // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)\n    // voxel - if true, draws with a blocky voxel style (default false)\n    // verts, faces - vertex and face arrays to fill up\n    \n    //to match with protein surface...\n    ISDONE: number = 2;\n\n    constructor() {\n\n    }\n\n    march(data, verts, faces, spec) {\n\n        let fulltable = !!(spec.fulltable);\n        let origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : {x:0, y:0, z:0};\n        let voxel = !!(spec.voxel);\n        let transform = spec.matrix; //if this is set, it overrides origin and unitCube\n        \n        let nX = spec.nX || 0;\n        let nY = spec.nY || 0;\n        let nZ = spec.nZ || 0;\n        \n        let scale = spec.scale || 1.0;\n        let unitCube = null;\n        if(spec.unitCube) {\n            unitCube = spec.unitCube;\n        } else {\n            unitCube = {x:scale,y:scale,z:scale};\n        }\n        \n        //keep track of calculated vertices to avoid repeats\n        let vertnums = new Int32Array(nX*nY*nZ);\n        \n        let i, il;\n        \n        for (i = 0, il = vertnums.length; i < il; ++i)\n            vertnums[i] = -1;\n\n        // create (or retrieve) a vertex at the appropriate point for\n        // the edge (p1,p2)\n        \n        let getVertex = function(i, j, k, code, p1, p2) {\n            let pt = {x:0,y:0,z:0};\n            let val1 = !!(code & (1 << p1));\n            let val2 = !!(code & (1 << p2));\n             \n            // p1 if they are the same or if !val1\n            let p = p1;\n            if (!val1 && val2)\n                p = p2;\n            \n            // adjust i,j,k by p\n            if (p & 1)\n                k++;\n            if (p & 2)\n                j++;\n            if (p & 4)\n                i++;\n\n            if(transform) {\n                let vpt = new Vector3(i,j,k);\n                vpt = vpt.applyMatrix4(transform);\n                pt = {x: vpt.x, y: vpt.y, z: vpt.z}; //remove vector gunk\n            } else {\n                pt.x = origin.x+unitCube.x*i;\n                pt.y = origin.y+unitCube.y*j;\n                pt.z = origin.z+unitCube.z*k;\n            }\n            \n            let index = ((nY * i) + j) * nZ + k;\n            //Have to add option to do voxels\n            if (!voxel) {\n            \n                if (vertnums[index] < 0) // not created yet\n                {\n                    vertnums[index] = verts.length;\n                    verts.push( pt );\n                }\n                return vertnums[index];\n            \n            }\n            \n            else {\n                verts.push(pt);\n                return verts.length - 1;\n            }\n            \n        };\n            \n        let intersects = new Int32Array(12);\n        \n        let etable = (fulltable) ? this.edgeTable2 : this.edgeTable;\n        let tritable = (fulltable) ? this.triTable2 : this.triTable;\n                \n        //Run marching cubes algorithm\n        for (i = 0; i < nX-1; ++i) {\n            \n            for (let j = 0; j < nY-1; ++j){\n                \n                for (let k = 0; k < nZ-1; ++k){\n                    \n                    let code = 0;\n                    \n                    for (let p = 0; p < 8; ++p) {\n                        let index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *\n                                        nZ + k + (p & 1);\n\n                        //TODO: Need to fix vpBits in protein surface for this to work\n                        let val:any = !!(data[index] & this.ISDONE);\n                        //let val = !!(data[index] > 0);   \n                        \n                        code |= val << p;                        \n                    }\n                    \n                    if (code === 0 || code === 255)\n                        continue;\n                    \n                    let ecode = etable[code];\n                    \n                    if (ecode === 0)\n                        continue;\n                        \n                    let ttable = tritable[code];                        \n                    \n                    if (ecode & 1)\n                        intersects[0] = getVertex(i, j, k, code, 0, 1);\n                    if (ecode & 2)\n                        intersects[1] = getVertex(i, j, k, code, 1, 3);\n                    if (ecode & 4)\n                        intersects[2] = getVertex(i, j, k, code, 3, 2);\n                    if (ecode & 8)\n                        intersects[3] = getVertex(i, j, k, code, 2, 0);\n                    if (ecode & 16)\n                        intersects[4] = getVertex(i, j, k, code, 4, 5);\n                    if (ecode & 32)\n                        intersects[5] = getVertex(i, j, k, code, 5, 7);\n                    if (ecode & 64)\n                        intersects[6] = getVertex(i, j, k, code, 7, 6);\n                    if (ecode & 128)\n                        intersects[7] = getVertex(i, j, k, code, 6, 4);\n                    if (ecode & 256)\n                        intersects[8] = getVertex(i, j, k, code, 0, 4);\n                    if (ecode & 512)\n                        intersects[9] = getVertex(i, j, k, code, 1, 5);\n                    if (ecode & 1024)\n                        intersects[10] = getVertex(i, j, k, code, 3, 7);\n                    if (ecode & 2048)\n                        intersects[11] = getVertex(i, j, k, code, 2, 6);       \n\n                    for (let t = 0; t < ttable.length; t += 3) {\n                        \n                        let a = intersects[ttable[t]],\n                            b = intersects[ttable[t+1]],\n                            c = intersects[ttable[t+2]];         \n                                           \n                        if (voxel && t >= 3) {\n                            verts.push(verts[a]); a = verts.length - 1;\n                            verts.push(verts[b]); b = verts.length - 1;\n                            verts.push(verts[c]); c = verts.length - 1;\n                        }\n\n                        \n                        faces.push(a); faces.push(b); faces.push(c);                               \n                    }              \n                    \n                }\n                \n            }\n            \n        }\n             \n        \n    };\n\n    laplacianSmooth (numiter, verts, faces) {\n            let tps = new Array(verts.length);\n            let i, il, j, jl, k;\n            for (i = 0, il = verts.length; i < il; i++)\n                    tps[i] = {\n                        x : 0,\n                        y : 0,\n                        z : 0\n                    };\n            let vertdeg = new Array(20);\n            let flagvert;\n            for (i = 0; i < 20; i++)\n                    vertdeg[i] = new Array(verts.length);\n            for (i = 0, il = verts.length; i < il; i++)\n                    vertdeg[0][i] = 0;\n            for (i = 0, il = faces.length / 3; i < il; i++) {\n                let aoffset = i*3, boffset = i*3 + 1, coffset = i*3 + 2;\n                flagvert = true;\n                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {\n                    if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[aoffset]]++;\n                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];\n                }\n                flagvert = true;\n                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {\n                    if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[aoffset]]++;\n                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];\n                }\n                // b\n                flagvert = true;\n                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {\n                    if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[boffset]]++;\n                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];\n                }\n                flagvert = true;\n                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {\n                    if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[boffset]]++;\n                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];\n                }\n                // c\n                flagvert = true;\n                for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {\n                    if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[coffset]]++;\n                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];\n                }\n                flagvert = true;\n                for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {\n                    if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {\n                        flagvert = false;\n                        break;\n                    }\n                }\n                if (flagvert) {\n                    vertdeg[0][faces[coffset]]++;\n                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];\n                }\n            }\n\n            let wt = 1.00;\n            let wt2 = 0.50;\n\n            for (k = 0; k < numiter; k++) {\n                    for (i = 0, il = verts.length; i < il; i++) {\n                            if (vertdeg[0][i] < 3) {\n                                    tps[i].x = verts[i].x;\n                                    tps[i].y = verts[i].y;\n                                    tps[i].z = verts[i].z;\n                            } else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {\n                                    tps[i].x = 0;\n                                    tps[i].y = 0;\n                                    tps[i].z = 0;\n                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {\n                                            tps[i].x += verts[vertdeg[j + 1][i]].x;\n                                            tps[i].y += verts[vertdeg[j + 1][i]].y;\n                                            tps[i].z += verts[vertdeg[j + 1][i]].z;\n                                    }\n                                    tps[i].x += wt2 * verts[i].x;\n                                    tps[i].y += wt2 * verts[i].y;\n                                    tps[i].z += wt2 * verts[i].z;\n                                    tps[i].x /= wt2 + vertdeg[0][i];\n                                    tps[i].y /= wt2 + vertdeg[0][i];\n                                    tps[i].z /= wt2 + vertdeg[0][i];\n                            } else {\n                                    tps[i].x = 0;\n                                    tps[i].y = 0;\n                                    tps[i].z = 0;\n                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {\n                                            tps[i].x += verts[vertdeg[j + 1][i]].x;\n                                            tps[i].y += verts[vertdeg[j + 1][i]].y;\n                                            tps[i].z += verts[vertdeg[j + 1][i]].z;\n                                    }\n                                    tps[i].x += wt * verts[i].x;\n                                    tps[i].y += wt * verts[i].y;\n                                    tps[i].z += wt * verts[i].z;\n                                    tps[i].x /= wt + vertdeg[0][i];\n                                    tps[i].y /= wt + vertdeg[0][i];\n                                    tps[i].z /= wt + vertdeg[0][i];\n                            }\n                    }\n                    for (i = 0, il = verts.length; i < il; i++) {\n                            verts[i].x = tps[i].x;\n                            verts[i].y = tps[i].y;\n                            verts[i].z = tps[i].z;\n                    }\n                    /*\n                     * computenorm(); for (let i = 0; i < vertnumber; i++) { if\n                     * (verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *\n                     * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *\n                     * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }\n                     */\n            }\n    };\n\n\n    /*\n     * These tables are based off those by Paul Bourke and Geoffrey Heller:\n     * http://paulbourke.net/geometry/polygonise/\n     * http://paulbourke.net/geometry/polygonise/table2.txt\n     * \n     * However, they have been substantially modified to reflect a more \n     * sensible corner numbering scheme and the discrete nature of our voxel data\n     * (resulting in fewer faces).\n     */\n    edgeTable: Uint32Array = new Uint32Array([ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n            0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,\n            0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,\n            0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,\n            0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,\n            0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,\n            0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,\n            0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,\n            0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,\n            0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,\n            0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,\n            0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n            0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,\n            0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,\n            0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,\n            0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,\n            0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,\n            0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,\n            0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,\n            0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,\n            0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,\n            0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,\n            0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,\n            0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ]);\n    \n    \n    triTable =  [ [], [], [], [], [], [], [], [ 11, 9, 8 ], [], [], [],\n            [ 8, 10, 9 ], [], [ 10, 8, 11 ], [ 9, 11, 10 ],\n            [ 8, 10, 9, 8, 11, 10 ], [], [], [], [ 1, 7, 3 ], [], [ 4, 2, 0 ], [],\n            [ 2, 1, 7 ], [], [], [], [ 2, 7, 3, 2, 9, 7 ], [],\n            [ 1, 4, 11, 1, 0, 4 ], [ 3, 8, 0, 11, 9, 4, 11, 10, 9 ],\n            [ 4, 11, 9, 11, 10, 9 ], [], [], [], [ 5, 3, 1 ], [], [], [],\n            [ 2, 5, 8, 2, 1, 5 ], [], [], [ 2, 4, 0 ], [ 3, 2, 4 ], [],\n            [ 0, 9, 1, 8, 10, 5, 8, 11, 10 ], [ 3, 4, 0, 3, 10, 4 ],\n            [ 5, 8, 10, 8, 11, 10 ], [], [ 3, 5, 7 ], [ 7, 1, 5 ],\n            [ 1, 7, 3, 1, 5, 7 ], [], [ 9, 2, 0, 9, 7, 2 ],\n            [ 0, 3, 8, 1, 7, 11, 1, 5, 7 ], [ 11, 1, 7, 1, 5, 7 ], [],\n            [ 9, 1, 0, 5, 3, 2, 5, 7, 3 ], [ 8, 2, 5, 8, 0, 2 ],\n            [ 2, 5, 3, 5, 7, 3 ], [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],\n            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],\n            [ 11, 5, 7, 11, 10, 5 ], [], [], [], [], [], [ 0, 6, 2 ], [],\n            [ 7, 2, 9, 7, 9, 8 ], [], [], [], [ 8, 10, 9 ], [ 7, 1, 3 ],\n            [ 7, 1, 0 ], [ 6, 9, 3, 6, 10, 9 ], [ 7, 10, 8, 10, 9, 8 ], [],\n            [ 6, 0, 4 ], [], [ 11, 1, 4, 11, 3, 1 ], [ 2, 4, 6 ],\n            [ 2, 0, 4, 2, 4, 6 ], [ 2, 4, 6 ], [ 1, 4, 2, 4, 6, 2 ], [],\n            [ 6, 0, 4 ], [], [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ], [ 8, 6, 1, 8, 1, 3 ],\n            [ 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],\n            [ 10, 4, 6, 10, 9, 4 ], [], [], [], [ 5, 3, 1 ], [], [ 0, 6, 2 ], [],\n            [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ], [], [], [ 2, 4, 0 ],\n            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ], [ 7, 1, 3 ],\n            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],\n            [ 10, 5, 6, 4, 8, 7 ], [ 9, 11, 8 ], [ 3, 5, 6 ],\n            [ 0, 5, 11, 0, 11, 8 ], [ 6, 3, 5, 3, 1, 5 ], [ 3, 9, 6, 3, 8, 9 ],\n            [ 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],\n            [ 1, 6, 2, 1, 5, 6 ], [ 9, 11, 8 ], [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ],\n            [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ], [ 3, 2, 11, 10, 5, 6 ],\n            [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ], [ 0, 9, 1, 5, 6, 10 ],\n            [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ], [], [], [], [], [], [], [],\n            [ 1, 10, 2, 9, 11, 6, 9, 8, 11 ], [], [], [ 6, 0, 2 ],\n            [ 3, 6, 9, 3, 2, 6 ], [ 3, 5, 1 ], [ 0, 5, 1, 0, 11, 5 ], [ 0, 3, 5 ],\n            [ 6, 9, 11, 9, 8, 11 ], [], [], [], [ 4, 5, 9, 7, 1, 10, 7, 3, 1 ], [],\n            [ 11, 6, 7, 2, 4, 5, 2, 0, 4 ],\n            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],\n            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [],\n            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ], [ 9, 4, 5, 0, 6, 7, 0, 2, 6 ],\n            [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ], [ 6, 7, 11, 5, 3, 8, 5, 1, 3 ],\n            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],\n            [ 9, 4, 5, 7, 11, 6 ], [], [], [ 0, 6, 4 ], [ 8, 6, 4, 8, 1, 6 ], [],\n            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],\n            [ 10, 2, 1, 6, 0, 3, 6, 4, 0 ], [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ],\n            [ 4, 2, 6 ], [ 1, 0, 9, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],\n            [ 8, 2, 4, 2, 6, 4 ], [ 11, 4, 1, 11, 6, 4 ],\n            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 3, 6, 0, 6, 4, 0 ],\n            [ 8, 6, 4, 8, 11, 6 ], [ 10, 8, 9 ], [ 6, 3, 9, 6, 7, 3 ], [ 6, 7, 1 ],\n            [ 10, 7, 1, 7, 3, 1 ], [ 7, 11, 6, 8, 10, 2, 8, 9, 10 ],\n            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],\n            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2 ],\n            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 7, 0, 6, 0, 2, 6 ],\n            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],\n            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ], [], [], [],\n            [], [ 5, 3, 7 ], [ 8, 5, 2, 8, 7, 5 ], [ 5, 3, 7 ],\n            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 1, 7, 5 ], [ 1, 7, 5 ],\n            [ 9, 2, 7, 9, 7, 5 ], [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ],\n            [ 1, 3, 7, 1, 7, 5 ], [ 0, 7, 1, 7, 5, 1 ], [ 9, 3, 5, 3, 7, 5 ],\n            [ 9, 7, 5, 9, 8, 7 ], [ 8, 10, 11 ], [ 3, 4, 10, 3, 10, 11 ],\n            [ 8, 10, 11 ], [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ], [ 2, 4, 5 ],\n            [ 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],\n            [ 2, 1, 10, 9, 4, 5 ], [ 2, 8, 5, 2, 11, 8 ],\n            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],\n            [ 11, 3, 2, 9, 4, 5 ], [ 8, 5, 3, 5, 1, 3 ], [ 5, 0, 4, 5, 1, 0 ],\n            [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ], [ 11, 9, 10 ], [ 11, 9, 10 ],\n            [ 1, 11, 4, 1, 10, 11 ], [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],\n            [ 2, 7, 9, 2, 9, 10 ], [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ],\n            [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ], [ 10, 2, 1, 8, 7, 4 ], [ 1, 7, 4 ],\n            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 11, 4, 2, 4, 0, 2 ],\n            [ 2, 11, 3, 7, 4, 8 ], [ 4, 1, 7, 1, 3, 7 ], [ 1, 0, 9, 8, 7, 4 ],\n            [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ], [ 8, 9, 10, 8, 10, 11 ],\n            [ 3, 9, 11, 9, 10, 11 ], [ 0, 10, 8, 10, 11, 8 ],\n            [ 10, 3, 1, 10, 11, 3 ], [ 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],\n            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 1, 11, 9, 11, 8, 9 ],\n            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],\n            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];\n     \n    edgeTable2 = [ 0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,\n            0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,\n            0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,\n            0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,\n            0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,\n            0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,\n            0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,\n            0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,\n            0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,\n            0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,\n            0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,\n            0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,\n            0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,\n            0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,\n            0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,\n            0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,\n            0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,\n            0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,\n            0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,\n            0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,\n            0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,\n            0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,\n            0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,\n            0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,\n            0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,\n            0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];\n     \n    triTable2 = [ [], [ 8, 3, 0 ], [ 9, 0, 1 ], [ 8, 3, 1, 8, 1, 9 ],\n            [ 11, 2, 3 ], [ 11, 2, 0, 11, 0, 8 ], [ 11, 2, 3, 0, 1, 9 ],\n            [ 2, 1, 11, 1, 9, 11, 11, 9, 8 ], [ 10, 1, 2 ], [ 8, 3, 0, 1, 2, 10 ],\n            [ 9, 0, 2, 9, 2, 10 ], [ 3, 2, 8, 2, 10, 8, 8, 10, 9 ],\n            [ 10, 1, 3, 10, 3, 11 ], [ 1, 0, 10, 0, 8, 10, 10, 8, 11 ],\n            [ 0, 3, 9, 3, 11, 9, 9, 11, 10 ], [ 8, 10, 9, 8, 11, 10 ], [ 8, 4, 7 ],\n            [ 3, 0, 4, 3, 4, 7 ], [ 1, 9, 0, 8, 4, 7 ],\n            [ 9, 4, 1, 4, 7, 1, 1, 7, 3 ], [ 2, 3, 11, 7, 8, 4 ],\n            [ 7, 11, 4, 11, 2, 4, 4, 2, 0 ], [ 3, 11, 2, 4, 7, 8, 9, 0, 1 ],\n            [ 2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4 ], [ 10, 1, 2, 8, 4, 7 ],\n            [ 2, 10, 1, 0, 4, 7, 0, 7, 3 ], [ 4, 7, 8, 0, 2, 10, 0, 10, 9 ],\n            [ 2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9 ],\n            [ 8, 4, 7, 11, 10, 1, 11, 1, 3 ],\n            [ 11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4 ],\n            [ 3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9 ],\n            [ 7, 11, 4, 4, 11, 9, 11, 10, 9 ], [ 9, 5, 4 ], [ 3, 0, 8, 4, 9, 5 ],\n            [ 5, 4, 0, 5, 0, 1 ], [ 4, 8, 5, 8, 3, 5, 5, 3, 1 ],\n            [ 11, 2, 3, 9, 5, 4 ], [ 9, 5, 4, 8, 11, 2, 8, 2, 0 ],\n            [ 3, 11, 2, 1, 5, 4, 1, 4, 0 ],\n            [ 8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5 ], [ 2, 10, 1, 9, 5, 4 ],\n            [ 0, 8, 3, 5, 4, 9, 10, 1, 2 ], [ 10, 5, 2, 5, 4, 2, 2, 4, 0 ],\n            [ 3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5 ],\n            [ 5, 4, 9, 1, 3, 11, 1, 11, 10 ],\n            [ 0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10 ],\n            [ 3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10 ],\n            [ 4, 8, 5, 5, 8, 10, 8, 11, 10 ], [ 9, 5, 7, 9, 7, 8 ],\n            [ 0, 9, 3, 9, 5, 3, 3, 5, 7 ], [ 8, 0, 7, 0, 1, 7, 7, 1, 5 ],\n            [ 1, 7, 3, 1, 5, 7 ], [ 11, 2, 3, 8, 9, 5, 8, 5, 7 ],\n            [ 9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7 ],\n            [ 0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7 ],\n            [ 2, 1, 11, 11, 1, 7, 1, 5, 7 ], [ 1, 2, 10, 5, 7, 8, 5, 8, 9 ],\n            [ 9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3 ],\n            [ 5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2 ],\n            [ 10, 5, 2, 2, 5, 3, 5, 7, 3 ],\n            [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],\n            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],\n            [ 11, 5, 7, 11, 10, 5 ], [ 11, 7, 6 ], [ 0, 8, 3, 11, 7, 6 ],\n            [ 9, 0, 1, 11, 7, 6 ], [ 7, 6, 11, 3, 1, 9, 3, 9, 8 ],\n            [ 2, 3, 7, 2, 7, 6 ], [ 8, 7, 0, 7, 6, 0, 0, 6, 2 ],\n            [ 1, 9, 0, 3, 7, 6, 3, 6, 2 ], [ 7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8 ],\n            [ 1, 2, 10, 6, 11, 7 ], [ 2, 10, 1, 7, 6, 11, 8, 3, 0 ],\n            [ 11, 7, 6, 10, 9, 0, 10, 0, 2 ],\n            [ 7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9 ],\n            [ 6, 10, 7, 10, 1, 7, 7, 1, 3 ],\n            [ 6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8 ],\n            [ 9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7 ],\n            [ 6, 10, 7, 7, 10, 8, 10, 9, 8 ], [ 8, 4, 6, 8, 6, 11 ],\n            [ 11, 3, 6, 3, 0, 6, 6, 0, 4 ], [ 0, 1, 9, 4, 6, 11, 4, 11, 8 ],\n            [ 1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6 ],\n            [ 3, 8, 2, 8, 4, 2, 2, 4, 6 ], [ 2, 0, 4, 2, 4, 6 ],\n            [ 1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6 ], [ 9, 4, 1, 1, 4, 2, 4, 6, 2 ],\n            [ 10, 1, 2, 11, 8, 4, 11, 4, 6 ],\n            [ 10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4 ],\n            [ 0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11 ],\n            [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ],\n            [ 8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3 ],\n            [ 1, 0, 10, 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],\n            [ 10, 4, 6, 10, 9, 4 ], [ 9, 5, 4, 7, 6, 11 ],\n            [ 4, 9, 5, 3, 0, 8, 11, 7, 6 ], [ 6, 11, 7, 4, 0, 1, 4, 1, 5 ],\n            [ 6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1 ], [ 4, 9, 5, 6, 2, 3, 6, 3, 7 ],\n            [ 9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2 ],\n            [ 4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3 ], [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ],\n            [ 6, 11, 7, 1, 2, 10, 9, 5, 4 ],\n            [ 11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4 ],\n            [ 11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0 ],\n            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ],\n            [ 4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3 ],\n            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],\n            [ 10, 5, 6, 4, 8, 7 ], [ 5, 6, 9, 6, 11, 9, 9, 11, 8 ],\n            [ 0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11 ],\n            [ 0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8 ],\n            [ 11, 3, 6, 6, 3, 5, 3, 1, 5 ], [ 9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2 ],\n            [ 5, 6, 9, 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],\n            [ 1, 6, 2, 1, 5, 6 ], [ 1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8 ],\n            [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ], [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ],\n            [ 3, 2, 11, 10, 5, 6 ], [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ],\n            [ 0, 9, 1, 5, 6, 10 ], [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ],\n            [ 10, 6, 5 ], [ 8, 3, 0, 10, 6, 5 ], [ 0, 1, 9, 5, 10, 6 ],\n            [ 10, 6, 5, 9, 8, 3, 9, 3, 1 ], [ 3, 11, 2, 10, 6, 5 ],\n            [ 6, 5, 10, 2, 0, 8, 2, 8, 11 ], [ 1, 9, 0, 6, 5, 10, 11, 2, 3 ],\n            [ 1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11 ], [ 1, 2, 6, 1, 6, 5 ],\n            [ 0, 8, 3, 2, 6, 5, 2, 5, 1 ], [ 5, 9, 6, 9, 0, 6, 6, 0, 2 ],\n            [ 9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6 ], [ 11, 6, 3, 6, 5, 3, 3, 5, 1 ],\n            [ 0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11 ],\n            [ 0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6 ],\n            [ 5, 9, 6, 6, 9, 11, 9, 8, 11 ], [ 10, 6, 5, 4, 7, 8 ],\n            [ 5, 10, 6, 7, 3, 0, 7, 0, 4 ], [ 5, 10, 6, 0, 1, 9, 8, 4, 7 ],\n            [ 4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1 ],\n            [ 7, 8, 4, 2, 3, 11, 10, 6, 5 ],\n            [ 11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4 ],\n            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],\n            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [ 7, 8, 4, 5, 1, 2, 5, 2, 6 ],\n            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ],\n            [ 9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6 ], [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ],\n            [ 6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3 ],\n            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],\n            [ 9, 4, 5, 7, 11, 6 ], [ 10, 6, 4, 10, 4, 9 ],\n            [ 8, 3, 0, 9, 10, 6, 9, 6, 4 ], [ 1, 10, 0, 10, 6, 0, 0, 6, 4 ],\n            [ 8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1 ],\n            [ 2, 3, 11, 6, 4, 9, 6, 9, 10 ],\n            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],\n            [ 10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0 ],\n            [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ], [ 9, 1, 4, 1, 2, 4, 4, 2, 6 ],\n            [ 1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],\n            [ 3, 2, 8, 8, 2, 4, 2, 6, 4 ],\n            [ 1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4 ],\n            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 11, 6, 3, 3, 6, 0, 6, 4, 0 ],\n            [ 8, 6, 4, 8, 11, 6 ], [ 6, 7, 10, 7, 8, 10, 10, 8, 9 ],\n            [ 9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3 ],\n            [ 6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0 ],\n            [ 6, 7, 10, 10, 7, 1, 7, 3, 1 ],\n            [ 7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10 ],\n            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],\n            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9 ],\n            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 8, 0, 7, 7, 0, 6, 0, 2, 6 ],\n            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],\n            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ],\n            [ 11, 7, 5, 11, 5, 10 ], [ 3, 0, 8, 7, 5, 10, 7, 10, 11 ],\n            [ 9, 0, 1, 10, 11, 7, 10, 7, 5 ],\n            [ 3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10 ],\n            [ 10, 2, 5, 2, 3, 5, 5, 3, 7 ],\n            [ 5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0 ],\n            [ 9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7 ],\n            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 2, 11, 1, 11, 7, 1, 1, 7, 5 ],\n            [ 0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5 ],\n            [ 9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5 ],\n            [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ], [ 1, 3, 7, 1, 7, 5 ],\n            [ 8, 7, 0, 0, 7, 1, 7, 5, 1 ], [ 0, 3, 9, 9, 3, 5, 3, 7, 5 ],\n            [ 9, 7, 5, 9, 8, 7 ], [ 4, 5, 8, 5, 10, 8, 8, 10, 11 ],\n            [ 3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11 ],\n            [ 0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11 ],\n            [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ],\n            [ 3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10 ],\n            [ 10, 2, 5, 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],\n            [ 2, 1, 10, 9, 4, 5 ], [ 8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1 ],\n            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],\n            [ 11, 3, 2, 9, 4, 5 ], [ 4, 5, 8, 8, 5, 3, 5, 1, 3 ],\n            [ 5, 0, 4, 5, 1, 0 ], [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ],\n            [ 7, 4, 11, 4, 9, 11, 11, 9, 10 ],\n            [ 3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10 ],\n            [ 11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0 ],\n            [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],\n            [ 2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10 ],\n            [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ], [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ],\n            [ 10, 2, 1, 8, 7, 4 ], [ 2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9 ],\n            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 7, 4, 11, 11, 4, 2, 4, 0, 2 ],\n            [ 2, 11, 3, 7, 4, 8 ], [ 9, 1, 4, 4, 1, 7, 1, 3, 7 ],\n            [ 1, 0, 9, 8, 7, 4 ], [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ],\n            [ 8, 9, 10, 8, 10, 11 ], [ 0, 9, 3, 3, 9, 11, 9, 10, 11 ],\n            [ 1, 10, 0, 0, 10, 8, 10, 11, 8 ], [ 10, 3, 1, 10, 11, 3 ],\n            [ 3, 8, 2, 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],\n            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 2, 11, 1, 1, 11, 9, 11, 8, 9 ],\n            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],\n            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];\n            \n};\n\nexport let MarchingCube = new MarchingCubeInitializer();\n//each webworker needs its own marching cube object\n\n\n// a little class for 3d array, should really generalize this and\n// use throughout...\nexport class PointGrid  {\n\n    data: Int32Array;\n    width: number;\n    height: number;\n\n    constructor(length, width, height) {\n        // the standard says this is zero initialized\n        this.data = new Int32Array(length * width * height * 3);\n        this.width = width;\n        this.height = height;\n    }\n\n    // set position x,y,z to pt, which has ix,iy,and iz\n    set(x:number, y:number, z:number, pt) {\n        let index = ((((x * this.width) + y) * this.height) + z) * 3;\n        this.data[index] = pt.ix;\n        this.data[index + 1] = pt.iy;\n        this.data[index + 2] = pt.iz;\n    };\n\n    // return point at x,y,z\n    get(x:number, y:number, z:number) {\n        let index = ((((x * this.width) + y) * this.height) + z) * 3;\n        return {\n            ix : this.data[index],\n            iy : this.data[index + 1],\n            iz : this.data[index + 2]\n        };\n    };\n};\n\n/*\n * @type Class\n*/\nexport class ProteinSurface {\n\n    // constants for vpbits bitmasks\n    readonly INOUT = 1;\n    readonly ISDONE = 2;\n    readonly ISBOUND = 4;\n\n    ptranx:number = 0;\n    ptrany:number = 0;\n    ptranz:number = 0;\n    probeRadius:number = 1.4;\n    defaultScaleFactor:number = 2;\n    scaleFactor:number = this.defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,\n                            // also have to adjust offset used to find non-shown\n                            // atoms\n    pHeight:number = 0;\n    pWidth:number = 0;\n    pLength:number = 0;\n    cutRadius:number = 0;\n    vpBits: any = null; // uint8 array of bitmasks\n    vpDistance: any = null; // floatarray of _squared_ distances\n    vpAtomID: any = null; // intarray\n    \n    pminx:number = 0;\n    pminy:number = 0; \n    pminz:number = 0;\n    pmaxx:number = 0;\n    pmaxy:number = 0;\n    pmaxz:number = 0;\n\n    depty = {};\n    widxz = {};\n    faces: number[] = [];\n    verts = [];\n\n    static MarchingCube = new MarchingCubeInitializer();\n\n    constructor() {\n        if(!ProteinSurface.MarchingCube) {\n            //this is needed by webworkers\n            ProteinSurface.MarchingCube = new MarchingCubeInitializer();\n        }\n    }\n\n    readonly vdwRadii = {\n            \"H\" : 1.2,\n            \"Li\" : 1.82,\n            \"Na\" : 2.27,\n            \"K\" : 2.75,\n            \"C\" : 1.7,\n            \"N\" : 1.55,\n            \"O\" : 1.52,\n            \"F\" : 1.47,\n            \"P\" : 1.80,\n            \"S\" : 1.80,\n            \"CL\" : 1.75,\n            \"BR\" : 1.85,\n            \"SE\" : 1.90,\n            \"ZN\" : 1.39,\n            \"CU\" : 1.4,\n            \"NI\" : 1.63,\n            \"X\" : 2\n        };\n    \n    private getVDWIndex(atom:any) {\n        if(!atom.elem || typeof(this.vdwRadii[atom.elem]) == \"undefined\") {\n            return \"X\";\n        }\n        return atom.elem;\n    };\n    \n\n    readonly nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]), \n               new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),\n               new Int32Array([ 0, 0, 1 ]), \n               new Int32Array([ 0, 0, -1 ]), \n               new Int32Array([ 1, 1, 0 ]), \n               new Int32Array([ 1, -1, 0 ]), \n               new Int32Array([ -1, 1, 0 ]),\n               new Int32Array([ -1, -1, 0 ]), \n               new Int32Array([ 1, 0, 1 ]), \n               new Int32Array([ 1, 0, -1 ]), \n               new Int32Array([ -1, 0, 1 ]),\n               new Int32Array([ -1, 0, -1 ]), \n               new Int32Array([ 0, 1, 1 ]), \n               new Int32Array([ 0, 1, -1 ]), \n               new Int32Array([ 0, -1, 1 ]),\n               new Int32Array([ 0, -1, -1 ]), \n               new Int32Array([ 1, 1, 1 ]), \n               new Int32Array([ 1, 1, -1 ]), \n               new Int32Array([ 1, -1, 1 ]),\n               new Int32Array([ -1, 1, 1 ]), \n               new Int32Array([ 1, -1, -1 ]), \n               new Int32Array([ -1, -1, 1 ]), \n               new Int32Array([ -1, 1, -1 ]),\n               new Int32Array([ -1, -1, -1 ]) ];\n\n\n    public getFacesAndVertices(atomlist: any[]) {\n        let atomsToShow = {};\n        for (let i = 0, il = atomlist.length; i < il; i++)\n            atomsToShow[atomlist[i]] = true;\n        let vertices = this.verts;\n        for (let i = 0, il = vertices.length; i < il; i++) {\n            vertices[i].x = vertices[i].x / this.scaleFactor - this.ptranx;\n            vertices[i].y = vertices[i].y / this.scaleFactor - this.ptrany;\n            vertices[i].z = vertices[i].z / this.scaleFactor - this.ptranz;\n        }\n\n        let finalfaces = [];\n        for (let i = 0, il = this.faces.length; i < il; i += 3) {\n            //let f = faces[i];\n            let fa = this.faces[i], fb = this.faces[i+1], fc = this.faces[i+2];\n            let a = vertices[fa].atomid, b = vertices[fb].atomid, c = vertices[fc].atomid;\n\n            // must be a unique face for each atom\n            let which = a;\n            if (b < which)\n                which = b;\n            if (c < which)\n                which = c;\n            if (!atomsToShow[which]) {\n                continue;\n            }\n\n            if (fa !== fb && fb !== fc && fa !== fc){\n                finalfaces.push(fa); \n                finalfaces.push(fb); \n                finalfaces.push(fc); \n            }\n               \n        }\n\n        //try to help the garbage collector\n        this.vpBits = null; // uint8 array of bitmasks\n        this.vpDistance = null; // floatarray\n        this.vpAtomID = null; // intarray\n        \n        return {\n            'vertices' : vertices,\n            'faces' : finalfaces\n        };\n    };\n\n\n    public initparm (extent: number[][], btype, volume) {\n        if(volume > 1000000) //heuristical decrease resolution to avoid large memory consumption\n            this.scaleFactor = this.defaultScaleFactor/2;\n        \n        let margin = (1 / this.scaleFactor) * 5.5; // need margin to avoid\n                                                // boundary/round off effects\n        this.pminx = extent[0][0]; this.pmaxx = extent[1][0];\n        this.pminy = extent[0][1]; this.pmaxy = extent[1][1];\n        this.pminz = extent[0][2]; this.pmaxz = extent[1][2];\n\n        if (!btype) {\n            this.pminx -= margin;\n            this.pminy -= margin;\n            this.pminz -= margin;\n            this.pmaxx += margin;\n            this.pmaxy += margin;\n            this.pmaxz += margin;\n        } else {\n            this.pminx -= this.probeRadius + margin;\n            this.pminy -= this.probeRadius + margin;\n            this.pminz -= this.probeRadius + margin;\n            this.pmaxx += this.probeRadius + margin;\n            this.pmaxy += this.probeRadius + margin;\n            this.pmaxz += this.probeRadius + margin;\n        }\n\n        this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor;\n        this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor;\n        this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor;\n        this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor;\n        this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor;\n        this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor;\n\n        this.ptranx = -this.pminx;\n        this.ptrany = -this.pminy;\n        this.ptranz = -this.pminz;\n\n        this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1;\n        this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1;\n        this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1;\n\n        this.boundingatom(btype);\n        this.cutRadius = this.probeRadius * this.scaleFactor;\n\n        this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight);\n        this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight); // float 32\n        // doesn't\n        // play\n        // nicely\n        // with\n        // native\n        // floats\n        this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);\n    };\n\n    public boundingatom(btype) {\n        let tradius = {};\n\n        for ( const i in this.vdwRadii) {\n            let r = this.vdwRadii[i];\n            if (!btype)\n                tradius[i] = r * this.scaleFactor + 0.5;\n            else\n                tradius[i] = (r + this.probeRadius) * this.scaleFactor + 0.5;\n\n            let sradius = tradius[i] * tradius[i];\n            this.widxz[i] = Math.floor(tradius[i]) + 1;\n            this.depty[i] = new Int32Array(this.widxz[i] * this.widxz[i]);\n            let indx = 0;\n            for (let j = 0; j < this.widxz[i]; j++) {\n                for (let k = 0; k < this.widxz[i]; k++) {\n                    let txz = j * j + k * k;\n                    if (txz > sradius)\n                        this.depty[i][indx] = -1; // outside\n                    else {\n                        let tdept = Math.sqrt(sradius - txz);\n                        this.depty[i][indx] = Math.floor(tdept);\n                    }\n                    indx++;\n                }\n            }\n        }\n    };\n\n    public fillvoxels(atoms, atomlist) { // (int seqinit,int\n        // seqterm,bool\n        // atomtype,atom*\n        // proseq,bool bcolor)\n        for (let i = 0, il = this.vpBits.length; i < il; i++) {\n            this.vpBits[i] = 0;\n            this.vpDistance[i] = -1.0;\n            this.vpAtomID[i] = -1;\n        }\n\n        for (let i in atomlist) {\n            let atom = atoms[atomlist[i]];\n            if (atom === undefined)\n                continue;\n            this.fillAtom(atom, atoms);\n        }\n\n        for (let i = 0, il = this.vpBits.length; i < il; i++)\n            if (this.vpBits[i] & this.INOUT)\n                this.vpBits[i] |= this.ISDONE;\n\n    };\n\n\n    public fillAtom(atom, atoms) {\n\n        let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));\n        let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));\n        let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));\n\n        let at = this.getVDWIndex(atom);\n        let nind = 0;\n        let pWH = this.pWidth*this.pHeight;\n        \n        for (let i = 0, n = this.widxz[at]; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (this.depty[at][nind] != -1) {\n                    for (let ii = -1; ii < 2; ii++) {\n                        for (let jj = -1; jj < 2; jj++) {\n                            for (let kk = -1; kk < 2; kk++) {\n                                if (ii !== 0 && jj !== 0 && kk !== 0) {\n                                    let mi = ii * i;\n                                    let mk = kk * j;\n                                    for (let k = 0; k <= this.depty[at][nind]; k++) {\n                                        let mj = k * jj;\n                                        let si = cx + mi;\n                                        let sj = cy + mj;\n                                        let sk = cz + mk;\n                                        if (si < 0 || sj < 0 || \n                                                sk < 0 ||\n                                                si >= this.pLength || \n                                                sj >= this.pWidth || \n                                                sk >= this.pHeight)\n                                            continue;\n                                        let index = si * pWH + sj * this.pHeight + sk;\n\n                                        if (!(this.vpBits[index] & this.INOUT)) {\n                                            this.vpBits[index] |= this.INOUT;\n                                            this.vpAtomID[index] = atom.serial;\n                                        } else {\n                                            let atom2 = atoms[this.vpAtomID[index]];\n                                            if(atom2.serial != atom.serial) {\n                                                let ox = cx + mi - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.x + this.ptranx));\n                                                let oy = cy + mj - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.y + this.ptrany));\n                                                let oz = cz + mk - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.z + this.ptranz));\n                                                if (mi * mi + mj * mj + mk * mk < ox *\n                                                        ox + oy * oy + oz * oz)\n                                                    this.vpAtomID[index] = atom.serial;\n                                            }\n                                        }\n\n                                    }// k\n                                }// if\n                            }// kk\n                        }// jj\n                    }// ii\n                }// if\n                nind++;\n            }// j\n        }// i\n    };\n\n    public fillvoxelswaals(atoms, atomlist) {\n        for (let i = 0, il = this.vpBits.length; i < il; i++)\n            this.vpBits[i] &= ~this.ISDONE; // not isdone\n\n        for (let i in atomlist) {\n            let atom = atoms[atomlist[i]];\n            if (atom === undefined)\n                continue;\n\n            this.fillAtomWaals(atom, atoms);\n        }\n    };\n\n    public fillAtomWaals(atom, atoms) {\n        let nind = 0;\n        let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));\n        let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));\n        let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));\n\n        let at = this.getVDWIndex(atom);\n        let pWH = this.pWidth*this.pHeight;\n        for (let i = 0, n = this.widxz[at]; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (this.depty[at][nind] != -1) {\n                    for (let ii = -1; ii < 2; ii++) {\n                        for (let jj = -1; jj < 2; jj++) {\n                            for (let kk = -1; kk < 2; kk++) {\n                                if (ii !== 0 && jj !== 0 && kk !== 0) {\n                                    let mi = ii * i;\n                                    let mk = kk * j;\n                                    for (let k = 0; k <= this.depty[at][nind]; k++) {\n                                        let mj = k * jj;\n                                        let si = cx + mi;\n                                        let sj = cy + mj;\n                                        let sk = cz + mk;\n                                        if (si < 0 || sj < 0 || \n                                                sk < 0 || \n                                                si >= this.pLength || \n                                                sj >= this.pWidth || \n                                                sk >= this.pHeight)\n                                            continue;\n                                        let index = si * pWH + sj * this.pHeight + sk;\n                                        if (!(this.vpBits[index] & this.ISDONE)) {\n                                            this.vpBits[index] |= this.ISDONE;\n                                            this.vpAtomID[index] = atom.serial;\n                                        }  else {\n                                            let atom2 = atoms[this.vpAtomID[index]];\n                                            if(atom2.serial != atom.serial) {\n                                                let ox = cx + mi - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.x + this.ptranx));\n                                                let oy = cy + mj - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.y + this.ptrany));\n                                                let oz = cz + mk - Math.floor(0.5 + this.scaleFactor *\n                                                        (atom2.z + this.ptranz));\n                                                if (mi * mi + mj * mj + mk * mk < ox *\n                                                        ox + oy * oy + oz * oz)\n                                                    this.vpAtomID[index] = atom.serial;\n                                            }\n                                        }\n                                    }// k\n                                }// if\n                            }// kk\n                        }// jj\n                    }// ii\n                }// if\n                nind++;\n            }// j\n        }// i\n    };\n\n    public buildboundary() {\n        let pWH = this.pWidth*this.pHeight;\n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pHeight; j++) {\n                for (let k = 0; k < this.pWidth; k++) {\n                    let index = i * pWH + k * this.pHeight + j;\n                    if (this.vpBits[index] & this.INOUT) {\n                        let ii = 0;\n                        while (ii < 26) {\n                            let ti = i + this.nb[ii][0], tj = j + this.nb[ii][2], tk = k +\n                                    this.nb[ii][1];\n                            if (ti > -1 && \n                                ti < this.pLength && \n                                tk > -1 && \n                                tk < this.pWidth && \n                                tj > -1 && \n                                tj < this.pHeight && \n                                !(this.vpBits[ti * pWH + tk * this.pHeight + tj] & this.INOUT)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                break;\n                            } else\n                                ii++;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public fastdistancemap() {\n        let boundPoint = new PointGrid(this.pLength, this.pWidth, this.pHeight);\n        let pWH = this.pWidth*this.pHeight;\n        let cutRSq = this.cutRadius*this.cutRadius;\n        \n        let inarray = [];\n        let outarray = [];\n        \n        let index;\n        \n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pWidth; j++) {\n                for (let k = 0; k < this.pHeight; k++) {\n                    index = i * pWH + j * this.pHeight + k;\n                    this.vpBits[index] &= ~this.ISDONE; // isdone = false\n                    if (this.vpBits[index] & this.INOUT) {\n                        if (this.vpBits[index] & this.ISBOUND) {\n                            let triple = {\n                                ix : i,\n                                iy : j,\n                                iz : k\n                            };\n                            boundPoint.set(i, j, k, triple);\n                            inarray.push(triple);\n                            this.vpDistance[index] = 0;\n                            this.vpBits[index] |= this.ISDONE;\n                            this.vpBits[index] &= ~this.ISBOUND;\n                        } \n                    }\n                }\n            }\n        }\n\n        do {\n            outarray = this.fastoneshell(inarray, boundPoint);\n            inarray = [];\n            for (let i = 0, n = outarray.length; i < n; i++) {\n                index = pWH * outarray[i].ix + this.pHeight *\n                    outarray[i].iy + outarray[i].iz;\n                this.vpBits[index] &= ~this.ISBOUND;\n                if (this.vpDistance[index] <= 1.0404 * cutRSq) {\n                    inarray.push({\n                        ix : outarray[i].ix,\n                        iy : outarray[i].iy,\n                        iz : outarray[i].iz\n                    });\n                }\n            }\n        } while (inarray.length !== 0);\n\n        inarray = [];\n        outarray = [];\n        boundPoint = null;\n        \n        let cutsf = this.scaleFactor - 0.5;\n        if (cutsf < 0)\n            cutsf = 0;\n        let cutoff = cutRSq - 0.50 / (0.1 + cutsf);\n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pWidth; j++) {\n                for (let k = 0; k < this.pHeight; k++) {\n                    index = i * pWH + j * this.pHeight + k;\n                    this.vpBits[index] &= ~this.ISBOUND;\n                    // ses solid\n                    if (this.vpBits[index] & this.INOUT) {\n                        if (!(this.vpBits[index] & this.ISDONE) ||\n                                ((this.vpBits[index] & this.ISDONE) && this.vpDistance[index] >= cutoff)) {\n                            this.vpBits[index] |= this.ISBOUND;\n                        }\n                    }\n                }\n            }\n        }\n\n    };\n\n    public fastoneshell(inarray, boundPoint) { // (int* innum,int\n        // *allocout,voxel2\n        // ***boundPoint, int*\n        // outnum, int *elimi)\n        let tx, ty, tz;\n        let dx, dy, dz;\n        let square;\n        let bp, index;\n        let outarray = [];\n        if (inarray.length === 0)\n            return outarray;\n\n        let tnv = {\n            ix : -1,\n            iy : -1,\n            iz : -1\n        };\n        let pWH = this.pWidth*this.pHeight;\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n\n            for (let j = 0; j < 6; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n                \n                if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n                    \n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n    \n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n    \n                        outarray.push({\n                            ix : tnv.ix,\n                            iy : tnv.iy,\n                            iz : tnv.iz\n                        });\n                    } else if ((this.vpBits[index] & this.INOUT) && (this.vpBits[index] & this.ISDONE)) {\n    \n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n    \n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix : tnv.ix,\n                                    iy : tnv.iy,\n                                    iz : tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n\n            for (let j = 6; j < 18; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n\n                if(tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n                    \n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n    \n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n    \n                        outarray.push({\n                            ix : tnv.ix,\n                            iy : tnv.iy,\n                            iz : tnv.iz\n                        });\n                    } else if ((this.vpBits[index] & this.INOUT) && (this.vpBits[index] & this.ISDONE)) {\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix : tnv.ix,\n                                    iy : tnv.iy,\n                                    iz : tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n\n            for (let j = 18; j < 26; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n\n                if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n\n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n\n                        outarray.push({\n                            ix : tnv.ix,\n                            iy : tnv.iy,\n                            iz : tnv.iz\n                        });\n                    } else if ((this.vpBits[index] & this.INOUT)  && (this.vpBits[index] & this.ISDONE)) {\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n\n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix : tnv.ix,\n                                    iy : tnv.iy,\n                                    iz : tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return outarray;\n    };\n\n    public marchingcubeinit(stype) {\n        for ( let i = 0, lim = this.vpBits.length; i < lim; i++) {\n            if (stype == 1) {// vdw\n                this.vpBits[i] &= ~this.ISBOUND;\n            } else if (stype == 4) { // ses\n                this.vpBits[i] &= ~this.ISDONE;\n                if (this.vpBits[i] & this.ISBOUND)\n                    this.vpBits[i] |= this.ISDONE;\n                this.vpBits[i] &= ~this.ISBOUND;\n            } else if (stype == 2) {// after vdw\n                if ((this.vpBits[i] & this.ISBOUND) && (this.vpBits[i] & this.ISDONE))\n                    this.vpBits[i] &= ~this.ISBOUND;\n                else if ((this.vpBits[i] & this.ISBOUND) && !(this.vpBits[i] & this.ISDONE))\n                    this.vpBits[i] |= this.ISDONE;\n            } else if (stype == 3) { // sas\n                this.vpBits[i] &= ~this.ISBOUND;\n            }\n        }\n    };\n    \n    public marchingcube(stype:number) {\n        this.marchingcubeinit(stype);\n        this.verts = []; this.faces = [];   \n        ProteinSurface.MarchingCube.march(this.vpBits, this.verts, this.faces, {\n            smooth : 1,\n            nX : this.pLength,\n            nY : this.pWidth,\n            nZ : this.pHeight        \n        });      \n\n        let pWH = this.pWidth*this.pHeight;\n        for (let i = 0, vlen = this.verts.length; i < vlen; i++) {\n            this.verts[i].atomid = this.vpAtomID[this.verts[i].x * pWH + this.pHeight *\n                    this.verts[i].y + this.verts[i].z];\n        }  \n\n        ProteinSurface.MarchingCube.laplacianSmooth(1, this.verts, this.faces);\n\n    };\n\n\n};", "//Hackish way to create webworker (independent of $3Dmol namespace) within minified file\n//We need to convert actual javascript into a string, not typescript, so for the time being\n//this will remain a JS file\n$3Dmol.workerString = function(){\n\n    self.onmessage = function(oEvent) {\n        var obj = oEvent.data;\n        var type = obj.type;\n        if (type < 0) // sending atom data, initialize\n        {\n            self.atomData = obj.atoms;\n            self.volume = obj.volume;\n            self.ps = new ProteinSurface();  // jshint ignore:line\n        } else {\n            var ps = self.ps;\n            ps.initparm(obj.expandedExtent, (type == 1) ? false : true, self.volume);\n            ps.fillvoxels(self.atomData, obj.extendedAtoms);\n            ps.buildboundary();\n            if (type === 4 || type === 2) {\n                ps.fastdistancemap();\n                ps.boundingatom(false);\n                ps.fillvoxelswaals(self.atomData, obj.extendedAtoms);    \n            }        \n            ps.marchingcube(type);  // jshint ignore:line\n            var VandF = ps.getFacesAndVertices(obj.atomsToShow);\n            self.postMessage(VandF);\n        }\n    };\n    \n}.toString().replace(/(^.*?\\{|\\}$)/g, \"\");\n\n// NOTE: variable replacement is simplified\n// (See: http://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names)\n$3Dmol.workerString += \";\\nfunction _classCallCheck() {};\"; //hack for babel\n$3Dmol.workerString += \";\\n\"+$3Dmol.Vector3.toString();\n$3Dmol.workerString += \";\\n\"+$3Dmol.MarchingCubeInitializer.toString()+\";\\n\\n\";\n$3Dmol.workerString += \";\\n\"+$3Dmol.PointGrid.toString()+\";\\n\";\n$3Dmol.workerString += \";\\nvar ProteinSurface = \"+$3Dmol.ProteinSurface.toString()+\";\\n\";\n//console.log($3Dmol.workerString);\n$3Dmol.SurfaceWorker = window.URL ? window.URL.createObjectURL(new Blob([$3Dmol.workerString],{type: 'text/javascript'})) : undefined;\n", "import { base64ToArray } from \"./utilities\";\nimport { Vector3, Matrix4 } from \"./WebGL/math\";\nimport { VASP } from \"./parsers/VASP\";\nimport { CUBE } from \"./parsers/CUBE\";\nimport { inflate } from \"pako\";\n\n\ninterface VolumeDataOptions {\n    negate?: boolean;\n    normalize?: boolean;\n};\n\n/**\n * $3Dmol.VolumeData stores volumetric data. This includes file parsing\n * functionality.\n *\n * @class\n * @param {string} str - volumetric data\n * @param {string} format - format of supplied data (cube, dx, vasp); append .gz if compressed\n * @param {Object} options - normalize (zero mean, unit variance), negate\n */\nexport class VolumeData {\n\n    unit = {\n        x: 1,\n        y: 1,\n        z: 1\n    }; // scale of each voxel\n    origin = {\n        x: 0,\n        y: 0,\n        z: 0\n    }; // origin (bottom \"left\", not center)\n    size = {\n        x: 0,\n        y: 0,\n        z: 0\n    }; // number of voxels in each direction\n    data = new Float32Array([]); // actual floating point data, arranged\n    // x->y->z\n\n    matrix: any = null; //if set must transform data\n    inversematrix: Matrix4|null = null;\n    dimensionorder: any;\n\n    isbinary = new Set<string>(['ccp4','CCP4']);\n\n    constructor(str: any, format: string, options?: VolumeDataOptions) {\n        format = format.toLowerCase();\n\n        if (/\\.gz$/.test(format)) {\n            //unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                if ((this as any)[format] && this.isbinary.has(format)) {\n                    if (typeof (str) == \"string\") {\n                        //assume base64 encoded\n                        str = base64ToArray(str);\n                    }\n                    str = inflate(str);\n                }\n                else {\n                    str = new TextDecoder(\"utf-8\").decode(inflate(str));\n                }\n            } catch (err) {\n                console.error(err);\n            }\n        }\n\n        if ((this as any)[format]) {\n            if (this.isbinary.has(format) && typeof (str) == \"string\") {\n                str = base64ToArray(str);\n            }\n            (this as any)[format](str);\n        }\n\n        if (options) {\n            if (options.negate) {\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    this.data[i] = -this.data[i];\n                }\n            }\n            if (options.normalize) {\n                var total = 0.0;\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    total += this.data[i];\n                }\n                var mean = total / this.data.length;\n                total = 0;\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    var diff = this.data[i] - mean;\n                    total += diff * diff; //variance is ave of squared difference with mean\n                }\n                var variance = total / this.data.length;\n                //now normalize\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    this.data[i] = (this.data[i] - mean) / variance;\n                }\n            }\n        }\n    }\n\n    /**\n     * @function $3Dmol.VolumeData.getIndex\n     * @param {number} x,y,z - the coordinates\n     * @returns - index into flat array closest to provided coordinate; -1 if invalid\n     */\n    getIndex(x: number, y: number, z: number) {\n\n        if (this.matrix) {\n            //all transformation is done through matrix multiply\n            if (this.inversematrix == null) {\n                this.inversematrix = new Matrix4().getInverse(this.matrix);\n            }\n            var pt = new Vector3(x, y, z);\n            pt = pt.applyMatrix4(this.inversematrix as Matrix4);\n            x = pt.x;\n            y = pt.y;\n            z = pt.z;\n        } else { //use simple origin/unit transform\n            x -= this.origin.x;\n            y -= this.origin.y;\n            z -= this.origin.z;\n\n            x /= this.unit.x;\n            y /= this.unit.y;\n            z /= this.unit.z;\n        }\n        x = Math.round(x);\n        y = Math.round(y);\n        z = Math.round(z);\n\n        if (x < 0 || x >= this.size.x) return -1;\n        if (y < 0 || y >= this.size.y) return -1;\n        if (z < 0 || z >= this.size.z) return -1;\n\n        return x * this.size.y * this.size.z + y * this.size.z + z;\n    };\n\n    /**\n     * @function $3Dmol.VolumeData.getVal\n     * @param {number} x,y,z - the coordinates\n     * @returns - value closest to provided coordinate; zero if coordinate invalid\n     */\n    getVal(x: number, y: number, z: number) {\n        let i = this.getIndex(x, y, z);\n        if (i < 0) return 0;\n        return this.data[i];\n    };\n\n    getCoordinates = function (index: number) {\n\n        var x = index / (this.size.y * this.size.z);\n        var y = index % (this.size.y * this.size.z);\n        var z = index % this.size.z;\n\n        x *= this.unit.x;\n        y *= this.unit.y;\n        z *= this.unit.z;\n\n        x += this.origin.x;\n        y += this.origin.y;\n        z += this.origin.z;\n\n        return { x: x, y: y, z: z };\n    };\n\n    /*\n     * parse vasp data\n     * Essentially this parser converts the CHGCAR data into\n     * cube data. It has been adapted from 'chg2cube.pl' found in\n     * http://theory.cm.utexas.edu/vtsttools/\n     */\n    vasp = function (str: string) {\n\n        var lines = str.replace(/^\\s+/, \"\").split(/[\\n\\r]/);\n\n        var atomicData = VASP(str)[0];\n        var natoms = atomicData.length;\n\n        if (natoms == 0) {\n            console.warn(\"No good formating of CHG or CHGCAR file, not atomic information provided in the file.\");\n            this.data = [];\n            return;\n        }\n\n        // Assume atomic units\n        //    var unittype = \"bohr/hartree\";\n        var l_units = 1.889725992;\n        var e_units = 0.036749309;\n\n        // copied from $3Dmol.Parsers.vasp\n        var convFactor = parseFloat(lines[1]);\n        // This is how Vasp reads in the basis We need the l_units in order to\n        // compute the volume of the cell. Afterwards to obtain the axis for the\n        // voxels we have to remove this unit and divide by the number of voxels in\n        // each dimension\n        var v: string[];\n        v = lines[2].replace(/^\\s+/, \"\").split(/\\s+/);\n        var xVec = new Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n        v = lines[3].replace(/^\\s+/, \"\").split(/\\s+/);\n        var yVec = new Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n        v = lines[4].replace(/^\\s+/, \"\").split(/\\s+/);\n        var zVec = new Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n\n        // correct volume for non-orthognal box (expansion by minors)\n        var vol = xVec.x * (yVec.y * zVec.z - zVec.y * yVec.z) - yVec.x * (xVec.y * zVec.z - zVec.y * xVec.z) + zVec.x * (xVec.y * yVec.z - yVec.y * xVec.z);\n\n        vol = Math.abs(vol) / (Math.pow(l_units, 3));\n        var vol_scale = 1.0 / (vol); //This Only for CHGCAR files\n\n        // We splice the structure information\n        // 2 (header) + 3 (vectors) + 2 (atoms) + 1 (vaspMode) + natoms (coords) + 1 (blank line)\n        lines.splice(0, 2 + 3 + 2 + 1 + natoms + 1);\n\n\n        var lineArr = lines[0].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n\n        var nX = Math.abs(parseFloat(lineArr[0]));\n        var nY = Math.abs(parseFloat(lineArr[1]));\n        var nZ = Math.abs(parseFloat(lineArr[2]));\n\n\n        var origin = this.origin = new Vector3(0, 0, 0);\n\n        this.size = { x: nX, y: nY, z: nZ };\n        this.unit = new Vector3(xVec.x, yVec.y, zVec.z);\n\n        // resize the vectors accordingly\n        xVec = xVec.multiplyScalar(1 / (l_units * nX));\n        yVec = yVec.multiplyScalar(1 / (l_units * nY));\n        zVec = zVec.multiplyScalar(1 / (l_units * nZ));\n\n        if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0\n            || zVec.y != 0) {\n            //need a transformation matrix\n            this.matrix = new Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0, 0, 0, 1);\n            //include translation in matrix\n            this.matrix = this.matrix.multiplyMatrices(this.matrix,\n                new Matrix4().makeTranslation(origin.x, origin.y, origin.z));\n            //all translation and scaling done by matrix, so reset origin and unit\n            this.origin = new Vector3(0, 0, 0);\n            this.unit = new Vector3(1, 1, 1);\n        }\n\n\n        lines.splice(0, 1); // Remove the dimension line\n        var raw = lines.join(\" \");\n\n        raw = raw.replace(/^\\s+/, '');\n        var rawArray = raw.split(/[\\s\\r]+/);\n        rawArray.splice(nX * nY * nZ + 1);\n\n        var preConvertedData = Float32Array.from(rawArray, parseFloat); //We still have to format it to get the density\n\n        for (var i = 0; i < preConvertedData.length; i++) {\n            preConvertedData[i] = preConvertedData[i] * vol_scale * e_units;\n        }\n\n        this.data = preConvertedData;\n    };\n\n    // parse dx data - does not support all features of the file format\n    dx = function (str: string) {\n        var lines = str.split(/[\\n\\r]+/);\n        var m: string[];\n        var recounts = /gridpositions\\s+counts\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/;\n        var reorig = /^origin\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/;\n        var redelta = /^delta\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/;\n        var follows = /data follows/;\n        var i = 0;\n\n        for (i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            if ((m = recounts.exec(line))) {\n                var nX = parseInt(m[1]);\n                var nY = parseInt(m[2]);\n                var nZ = parseInt(m[3]);\n                this.size = { x: nX, y: nY, z: nZ };\n            }\n            else if ((m = redelta.exec(line))) {\n                var xunit = parseFloat(m[1]);\n                if (parseFloat(m[2]) != 0 || parseFloat(m[3]) != 0) {\n                    console.warn(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                }\n                i += 1;\n                line = lines[i];\n                m = redelta.exec(line);\n                if (m == null) {\n                    console.error(\"Parse error in dx delta matrix\");\n                    return;\n                }\n\n                var yunit = parseFloat(m[2]);\n                if (parseFloat(m[1]) != 0 || parseFloat(m[3]) != 0) {\n                    console.warn(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                }\n\n                i += 1;\n                line = lines[i];\n                m = redelta.exec(line);\n                if (m == null) {\n                    console.error(\"Parse error in dx delta matrix\");\n                    return;\n                }\n\n                var zunit = parseFloat(m[3]);\n                if (parseFloat(m[1]) != 0 || parseFloat(m[2]) != 0) {\n                    console.warn(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                }\n                this.unit = new Vector3(xunit, yunit, zunit);\n            }\n            else if ((m = reorig.exec(line))) {\n                var xorig = parseFloat(m[1]);\n                var yorig = parseFloat(m[2]);\n                var zorig = parseFloat(m[3]);\n                this.origin = new Vector3(xorig, yorig, zorig);\n            } else if ((m = follows.exec(line))) {\n                break;\n            }\n        }\n        i += 1;\n        if (!this.size || !this.origin || !this.unit || !this.size) {\n            console.error(\"Error parsing dx format\");\n            return;\n        }\n        var raw = lines.splice(i).join(\" \");\n        var rawArray = raw.split(/[\\s\\r]+/);\n        this.data = Float32Array.from(rawArray, parseFloat);\n    };\n\n    // parse cube data\n    cube(str: string) {\n        var lines = str.split(/\\r?\\n/);\n\n        if (lines.length < 6)\n            return;\n\n        var cryst = CUBE(str, {}).modelData[0].cryst;\n\n        var lineArr = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n\n        var atomsnum = parseFloat(lineArr[0]); //includes sign, which indicates presence of oribital line in header\n        var natoms = Math.abs(atomsnum);\n\n        this.origin = cryst.origin;\n        this.size = cryst.size;\n        this.unit = cryst.unit;\n        this.matrix = cryst.matrix4;\n\n        var headerlines = 6;\n        if (atomsnum < 0) headerlines++; //see: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html\n        var raw = lines.splice(natoms + headerlines).join(\" \");\n        raw = raw.replace(/^\\s+/, '');\n        var rawArray = raw.split(/[\\s\\r]+/);\n        this.data = Float32Array.from(rawArray, parseFloat);\n\n    };\n\n\n\n    //parse cp4 files\n    ccp4(bin: Int8Array) {\n\n        // http://www.ccp4.ac.uk/html/maplib.html#description\n        //code from ngl: https://github.com/arose/ngl/blob/master/js/ngl/parser.js\n        var header:any = {};\n        bin = new Int8Array(bin);\n        var intView = new Int32Array(bin.buffer, 0, 56);\n        var floatView = new Float32Array(bin.buffer, 0, 56);\n        var dv = new DataView(bin.buffer);\n\n\n        // 53  MAP         Character string 'MAP ' to identify file type\n        header.MAP = String.fromCharCode(\n            dv.getUint8(52 * 4), dv.getUint8(52 * 4 + 1),\n            dv.getUint8(52 * 4 + 2), dv.getUint8(52 * 4 + 3)\n        );\n\n        // 54  MACHST      Machine stamp indicating machine type which wrote file\n        //                 17 and 17 for big-endian or 68 and 65 for little-endian\n        header.MACHST = [dv.getUint8(53 * 4), dv.getUint8(53 * 4 + 1)];\n\n        // swap byte order when big endian\n        if (header.MACHST[0] === 17 && header.MACHST[1] === 17) {\n            var n = bin.byteLength;\n            for (var i = 0; i < n; i += 4) {\n                dv.setFloat32(i, dv.getFloat32(i), true);\n            }\n        }\n\n        header.NX = intView[0];  // NC - columns (fastest changing)\n        header.NY = intView[1];  // NR - rows\n        header.NZ = intView[2];  // NS - sections (slowest changing)\n\n        // mode\n        //  0 image : signed 8-bit bytes range -128 to 127\n        //  1 image : 16-bit halfwords\n        //  2 image : 32-bit reals\n        //  3 transform : complex 16-bit integers\n        //  4 transform : complex 32-bit reals\n        //  6 image : unsigned 16-bit range 0 to 65535\n        // 16 image: unsigned char * 3 (for rgb data, non-standard)\n        //\n        // Note: Mode 2 is the normal mode used in the CCP4 programs.\n        //       Other modes than 2 and 0 may NOT WORK\n        header.MODE = intView[3];\n\n        // start\n        header.NXSTART = intView[4];  // NCSTART - first column\n        header.NYSTART = intView[5];  // NRSTART - first row\n        header.NZSTART = intView[6];  // NSSTART - first section\n\n        // intervals\n        header.MX = intView[7];  // intervals along x\n        header.MY = intView[8];  // intervals along y\n        header.MZ = intView[9];  // intervals along z\n\n        // cell length (Angstroms in CCP4)\n        header.xlen = floatView[10];\n        header.ylen = floatView[11];\n        header.zlen = floatView[12];\n\n        // cell angle (Degrees)\n        header.alpha = floatView[13];\n        header.beta = floatView[14];\n        header.gamma = floatView[15];\n\n        // axis correspondence (1,2,3 for X,Y,Z)\n        header.MAPC = intView[16];  // column\n        header.MAPR = intView[17];  // row\n        header.MAPS = intView[18];  // section\n\n        // density statistics\n        header.DMIN = floatView[19];\n        header.DMAX = floatView[20];\n        header.DMEAN = floatView[21];\n\n        // space group number 0 or 1 (default=0)\n        header.ISPG = intView[22];\n\n        // number of bytes used for symmetry data (0 or 80)\n        header.NSYMBT = intView[23];\n\n        // Flag for skew transformation, =0 none, =1 if foll\n        header.LSKFLG = intView[24];\n\n        // 26-34  SKWMAT  Skew matrix S (in order S11, S12, S13, S21 etc) if\n        //                LSKFLG .ne. 0.\n        // 35-37  SKWTRN  Skew translation t if LSKFLG != 0.\n        //                Skew transformation is from standard orthogonal\n        //                coordinate frame (as used for atoms) to orthogonal\n        //                map frame, as Xo(map) = S * (Xo(atoms) - t)\n\n        // 38      future use       (some of these are used by the MSUBSX routines\n        //  .          \"              in MAPBRICK, MAPCONT and FRODO)\n        //  .          \"   (all set to zero by default)\n        //  .          \"\n        // 52          \"\n\n        // 50-52 origin in X,Y,Z used for transforms\n        header.originX = floatView[49];\n        header.originY = floatView[50];\n        header.originZ = floatView[51];\n\n        // 53  MAP         Character string 'MAP ' to identify file type\n        // => see top of this parser\n\n        // 54  MACHST      Machine stamp indicating machine type which wrote file\n        // => see top of this parser\n\n        // Rms deviation of map from mean density\n        header.ARMS = floatView[54];\n\n        // 56      NLABL           Number of labels being used\n        // 57-256  LABEL(20,10)    10  80 character text labels (ie. A4 format)\n\n        //create transformation matrix, code mostly copied from ngl\n        var h = header;\n        var basisX: Array<any> = [\n            h.xlen,\n            0,\n            0\n        ];\n\n        var basisY: Array<any> = [\n            h.ylen * Math.cos(Math.PI / 180.0 * h.gamma),\n            h.ylen * Math.sin(Math.PI / 180.0 * h.gamma),\n            0\n        ];\n\n        var basisZ: Array<any> = [\n            h.zlen * Math.cos(Math.PI / 180.0 * h.beta),\n            h.zlen * (\n                Math.cos(Math.PI / 180.0 * h.alpha)\n                - Math.cos(Math.PI / 180.0 * h.gamma)\n                * Math.cos(Math.PI / 180.0 * h.beta)\n            ) / Math.sin(Math.PI / 180.0 * h.gamma),\n            0\n        ];\n        basisZ[2] = Math.sqrt(\n            h.zlen * h.zlen * Math.sin(Math.PI / 180.0 * h.beta) *\n            Math.sin(Math.PI / 180.0 * h.beta) - basisZ[1] * basisZ[1]\n        );\n\n        var basis: Array<any> = [0, basisX, basisY, basisZ];\n        var nxyz: Array<any> = [0, h.MX, h.MY, h.MZ];\n        var mapcrs: Array<any> = [0, h.MAPC, h.MAPR, h.MAPS];\n\n        this.matrix = new Matrix4();\n\n        this.matrix.set(\n\n            basis[mapcrs[1]][0] / nxyz[mapcrs[1]],\n            basis[mapcrs[2]][0] / nxyz[mapcrs[2]],\n            basis[mapcrs[3]][0] / nxyz[mapcrs[3]],\n            0,\n\n            basis[mapcrs[1]][1] / nxyz[mapcrs[1]],\n            basis[mapcrs[2]][1] / nxyz[mapcrs[2]],\n            basis[mapcrs[3]][1] / nxyz[mapcrs[3]],\n            0,\n\n            basis[mapcrs[1]][2] / nxyz[mapcrs[1]],\n            basis[mapcrs[2]][2] / nxyz[mapcrs[2]],\n            basis[mapcrs[3]][2] / nxyz[mapcrs[3]],\n            0,\n\n            0, 0, 0, 1\n\n        );\n        //include translation in matrix, NXSTART etc are an offset in grid space\n        this.matrix = this.matrix.multiplyMatrices(\n            this.matrix,\n            new Matrix4().makeTranslation(\n                h.NXSTART + h.originX,\n                h.NYSTART + h.originY,\n                h.NZSTART + h.originZ)\n        );\n        //all translation and scaling done by matrix, so reset origin and unit\n        this.origin = new Vector3(0, 0, 0);\n        this.unit = new Vector3(1, 1, 1);\n        this.size = { x: header.NX, y: header.NY, z: header.NZ };\n        this.dimensionorder = [header.MAPC, header.MAPR, header.MAPS];\n        var data = new Float32Array(bin.buffer, 1024 + header.NSYMBT);\n        //data must by (slowest changing) x,y,z (fastest changing)\n\n        var NX = header.NX, NY = header.NY, NZ = header.NZ;\n        this.data = new Float32Array(NX * NY * NZ);\n        for (let i = 0; i < NX; i++) {\n            for (let j = 0; j < NY; j++) {\n                for (let k = 0; k < NZ; k++) {\n                    //should I be concerned that I'm not using mapc?\n                    this.data[((i * NY) + j) * NZ + k] = data[((k * NY) + j) * NX + i];\n                }\n            }\n        }\n\n    };\n};\n", "import { Sphere } from \"./WebGL/shapes\";\nimport { Vector3, Matrix4, XYZ } from \"./WebGL/math\";\nimport { VolumetricMaterial, Mesh, Texture, Object3D, Material } from \"./WebGL\";\nimport { CC } from \"./colors\";\nimport { GLShape } from \"./GLShape\";\nimport { AtomSelectionSpec } from \"specs\";\nimport { GLViewer } from \"GLViewer\";\n\n\n\n/**\n * VolumetricRenderer style specification\n*/\nexport interface VolumetricRendererSpec {\n    /** list of objects containing @color, @opacity and @value properties to specify color per voxel data value */\n    transferfn?: { color: unknown; opacity: unknown; value: unknown }[];\n    /** number of times to sample each voxel approximately (default 5) */\n    subsamples?: number;\n    /**  coordinates around which to include data; use viewer.selectedAtoms() to convert an AtomSelectionSpec to coordinates */\n    coords?: XYZ[];\n    /** selection around which to include data */\n    selection?: AtomSelectionSpec;\n    /** distance around coords to include data [default = 2.0] */\n    seldist?: number; \n};\n\n/**\n * A GLVolumetricRender is a \"shape\" for representing volumetric data as a density distribution.\n *\n * @class\n *\n * @param {VolumeData} data - volumetric data\n * @param {VolumetricRenderSpec} spec - specification of volumetric render\n * @returns {$3Dmol.GLShape}\n */\nexport class GLVolumetricRender {\n\n    static interpolateArray(data: string | any[], fitCount: number) {\n        function linearInterpolate(before: number, after: number, atPoint: number) {\n            return before + (after - before) * atPoint;\n        }\n        var newData = [];\n        var springFactor = (data.length - 1) / (fitCount - 1);\n        newData[0] = data[0]; // for new allocation\n        for (var i = 1; i < fitCount - 1; i++) {\n            var tmp = i * springFactor;\n            var before = Math.floor(tmp);\n            var after = Math.ceil(tmp);\n            var atPoint = tmp - before;\n            newData[i] = linearInterpolate(data[before], data[after], atPoint);\n        }\n        newData[fitCount - 1] = data[data.length - 1]; // for new allocation\n        return newData;\n    }\n\n    hidden = false;\n    boundingSphere = new Sphere();\n    shapePosition: any;\n    renderedShapeObj: any = null;\n    shapeObj: any = null;\n    geo: any;\n    subsamples = 5.0;\n    data: any = null;\n    transferfunctionbuffer: any = [];\n    min: number = 0;\n    max: number = 0;\n    extent: any;\n    maxdepth: number;\n    texmatrix: any;\n    minunit: any;\n\n    constructor(data: { matrix: { elements: any; }; size: XYZ; \n                unit: XYZ; origin: XYZ; data: number[]; getIndex: (arg0: number, arg1: number, arg2: number) => number; }, \n        spec: VolumetricRendererSpec, viewer?: GLViewer) {\n        spec = spec || {};\n        var transferfn = Object.assign([], spec.transferfn);\n        this.subsamples = spec.subsamples || 5.0;\n\n        let TRANSFER_BUFFER_SIZE = 256;\n\n        // arrange points based on position property\n        transferfn.forEach(function (a: { value: any; }) { a.value = parseFloat(a.value); });\n        transferfn.sort(function (a: { value: number; }, b: { value: number; }) { return a.value - b.value; });\n        this.min = transferfn[0].value;\n        if (transferfn.length == 0) transferfn.push(transferfn[0]); //need at least two\n        this.max = transferfn[transferfn.length - 1].value;\n\n        // create and fill an array of interpolated values per 2 colors\n        var pos1, pos2, color1, color2, R, G, B, A, alpha1, alpha2;\n        for (let i = 0; i < transferfn.length - 1; i++) {\n            color1 = CC.color(transferfn[i].color);\n            color2 = CC.color(transferfn[i + 1].color);\n            alpha1 = transferfn[i].opacity;\n            alpha2 = transferfn[i + 1].opacity;\n            pos1 = Math.floor((transferfn[i].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));\n            pos2 = Math.floor((transferfn[i + 1].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));\n            if (pos1 == pos2)\n                continue;\n            R = GLVolumetricRender.interpolateArray([color1.r * 255, color2.r * 255], pos2 - pos1);\n            G = GLVolumetricRender.interpolateArray([color1.g * 255, color2.g * 255], pos2 - pos1);\n            B = GLVolumetricRender.interpolateArray([color1.b * 255, color2.b * 255], pos2 - pos1);\n            A = GLVolumetricRender.interpolateArray([alpha1 * 255, alpha2 * 255], pos2 - pos1);\n\n            for (let j = 0; j < R.length; j++) {\n                this.transferfunctionbuffer.push(R[j]);\n                this.transferfunctionbuffer.push(G[j]);\n                this.transferfunctionbuffer.push(B[j]);\n                this.transferfunctionbuffer.push(A[j]); // opacity will be added later\n            }\n        }\n\n        this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer);\n\n        //need to create transformation matrix that maps model points into\n        //texture space\n        // need extent (bounding box dimensions), maxdepth (box diagonal), \n        // texmatrix (conversion from model to texture coords), minunit,\n        // possibly non-orthnormal basis if matrix\n        if (data.matrix) {\n            //figure out bounding box of transformed grid\n            let start = new Vector3(0, 0, 0);\n            let end = new Vector3(data.size.x, data.size.y, data.size.z);\n            let unit = new Vector3(1, 1, 1);\n\n            start.applyMatrix4(data.matrix);\n            end.applyMatrix4(data.matrix);\n            unit.applyMatrix4(data.matrix).sub(start);\n\n            this.extent = [[start.x, start.y, start.z], [end.x, end.y, end.z]];\n\n            //check all corners, these may not be the farthest apart\n            for (let i = 1; i < 7; i++) {\n                end.x = (i & 1) ? data.size.x : 0;\n                end.y = (i & 2) ? data.size.y : 0;\n                end.z = (i & 4) ? data.size.z : 0;\n                end.applyMatrix4(data.matrix);\n                this.extent[0][0] = Math.min(this.extent[0][0], end.x);\n                this.extent[0][1] = Math.min(this.extent[0][1], end.y);\n                this.extent[0][2] = Math.min(this.extent[0][2], end.z);\n                this.extent[1][0] = Math.max(this.extent[1][0], end.x);\n                this.extent[1][1] = Math.max(this.extent[1][1], end.y);\n                this.extent[1][2] = Math.max(this.extent[1][2], end.z);\n            }\n\n            let xoff = end.x - start.x;\n            let yoff = end.y - start.y;\n            let zoff = end.z - start.z;\n            this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);\n\n            this.minunit = Math.min(Math.min(unit.x, unit.y), unit.z);\n\n            //invert onto grid, then scale by grid dimensions to get\n            //normalized texture coordinates\n            this.texmatrix = new Matrix4().identity().scale({ x: data.size.x, y: data.size.y, z: data.size.z });\n            this.texmatrix = this.texmatrix.multiplyMatrices(data.matrix, this.texmatrix);\n\n            this.texmatrix = this.texmatrix.getInverse(this.texmatrix);\n\n        } else {\n            this.texmatrix = new Matrix4().identity();\n            let xoff = data.unit.x * data.size.x;\n            let yoff = data.unit.y * data.size.y;\n            let zoff = data.unit.z * data.size.z;\n            //scale doesn't apply to the translation vector, so preapply it\n            this.texmatrix.makeTranslation(-data.origin.x / xoff, -data.origin.y / yoff, -data.origin.z / zoff);\n            this.texmatrix.scale({ x: 1.0 / xoff, y: 1.0 / yoff, z: 1.0 / zoff });\n            this.minunit = Math.min(Math.min(data.unit.x, data.unit.y), data.unit.z);\n\n            //need the bounding box so we can intersect with rays\n            this.extent = [[data.origin.x, data.origin.y, data.origin.z],\n            [data.origin.x + xoff, data.origin.y + yoff, data.origin.z + zoff]];\n\n            this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);\n        }\n\n        //use GLShape to construct box\n        var shape = new GLShape({});\n        shape.addBox({\n            corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },\n            dimensions: {\n                w: this.extent[1][0] - this.extent[0][0],\n                h: this.extent[1][1] - this.extent[0][1],\n                d: this.extent[1][2] - this.extent[0][2]\n            }\n        });\n\n        this.geo = shape.finalize();\n        this.boundingSphere.center = new Vector3(\n            (this.extent[0][0] + this.extent[1][0]) / 2.0,\n            (this.extent[0][1] + this.extent[1][1]) / 2.0,\n            (this.extent[0][2] + this.extent[1][2]) / 2.0\n        );\n        this.boundingSphere.radius = this.maxdepth / 2;\n\n        if (spec.coords === undefined && spec.selection !== undefined) {\n            if(viewer) {\n                spec.coords = viewer.selectedAtoms(spec.selection) as XYZ[];\n            } else {\n                console.log('Need to provide viewer to volumetric renderer if selection specified.');\n            }\n        }\n        // volume selectivity based on given coords and distance\n        if (spec.coords !== undefined && spec.seldist !== undefined) {\n            let mask = new Uint8Array(data.data.length);\n            //for each coordinate\n            let d = spec.seldist;\n            let d2 = d * d;\n            for (let i = 0, n = spec.coords.length; i < n; i++) {\n                let c = spec.coords[i];\n                let minx = c.x - d, miny = c.y - d, minz = c.z - d;\n                let maxx = c.x + d, maxy = c.y + d, maxz = c.z + d;\n                if (data.getIndex(minx, miny, minz) >= 0 || data.getIndex(maxx, maxy, maxz) >= 0) {\n                    //bounding box overlaps grid\n                    //iterate over the grid points in the seldist bounding box\n                    //minunit may be inefficient if axes have very different units. oh well.\n                    for (let x = minx; x < maxx; x += this.minunit) {\n                        for (let y = miny; y < maxy; y += this.minunit) {\n                            for (let z = minz; z < maxz; z += this.minunit) {\n                                let idx = data.getIndex(x, y, z);\n                                if (idx >= 0 && !mask[idx]) {\n                                    //if not already masked, check distance\n                                    let distsq = (x - c.x) * (x - c.x) + (y - c.y) * (y - c.y) + (z - c.z) * (z - c.z);\n                                    if (distsq < d2) {\n                                        mask[idx] = 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            //any place mask is zero, make infinite in data\n            for (let i = 0, n = data.data.length; i < n; i++) {\n                if (mask[i] == 0) data.data[i] = Infinity;\n            }\n        }\n        this.data = data;\n    }\n\n    /**\n     * Initialize webgl objects for rendering\n     * @param {Object3D} group\n     *\n     */\n    globj(group: { remove: (arg0: any) => void; add: (arg0: any) => void; }) {\n\n        if (this.renderedShapeObj) {\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n\n        if (this.hidden)\n            return;\n\n        this.shapeObj = new Object3D();\n        var material = null;\n\n        var texture = new Texture(this.data, true);\n        var transfertexture = new Texture(this.transferfunctionbuffer, false);\n        texture.needsUpdate = true;\n        transfertexture.needsUpdate = true;\n        transfertexture.flipY = false;\n\n        material = new VolumetricMaterial({\n            transferfn: transfertexture,\n            transfermin: this.min,\n            transfermax: this.max,\n            map: texture,\n            extent: this.extent,\n            maxdepth: this.maxdepth,\n            texmatrix: this.texmatrix,\n            unit: this.minunit,\n            subsamples: this.subsamples,\n        });\n\n        var mesh = new Mesh(this.geo, (material as Material));\n        this.shapeObj.add(mesh);\n\n        this.renderedShapeObj = this.shapeObj.clone();\n        group.add(this.renderedShapeObj);\n    };\n\n    removegl(group: { remove: (arg0: any) => void; }) {\n        if (this.renderedShapeObj) {\n            // dispose of geos and materials\n            if (this.renderedShapeObj.geometry !== undefined)\n                this.renderedShapeObj.geometry.dispose();\n            if (this.renderedShapeObj.material !== undefined)\n                this.renderedShapeObj.material.dispose();\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        this.shapeObj = null;\n    };\n\n    get position() {\n        return this.boundingSphere.center;\n    }\n\n    get x() {\n        return this.boundingSphere.center.x;\n    }\n    get y() {\n        return this.boundingSphere.center.y;\n    }\n    get z() {\n        return this.boundingSphere.center.z;\n    }\n}\n\n", "import { Object3D } from \"./core\";\nimport { Matrix4, Vector3 } from \"./math\";\n/*\n * Simplified Perspective Camera\n */\n\n/* @constructor */\nexport class Camera extends Object3D {\n  projectionMatrix = new Matrix4();\n  projectionMatrixInverse = new Matrix4();\n  matrixWorldInverse = new Matrix4();\n  right: number;\n  left: number;\n  top: number;\n  bottom: number;\n  ortho: boolean;\n  fov: number;\n  aspect: number;\n  near: number;\n  far: number;\n  z: number;\n  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000, ortho = false) {\n    super();\n\n    this.fov = fov;\n    this.aspect = aspect;\n    this.near = near;\n    this.far = far;\n\n    var center = this.position.z;\n    this.right = center * Math.tan((Math.PI / 180) * fov);\n    this.left = -this.right;\n    this.top = this.right / this.aspect;\n    this.bottom = -this.top;\n\n    this.ortho = !!ortho;\n\n    this.updateProjectionMatrix();\n  }\n\n  lookAt(vector: Vector3) {\n    //Why is the parameter order switched (compared to Object3D)?\n    this.matrix.lookAt(this.position, vector, this.up);\n\n    if (this.rotationAutoUpdate) {\n      if (this.useQuaternion === false && this.rotation instanceof Vector3) {\n        this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n      } else {\n        console.error(\"Unimplemented math operation.\");\n      }\n    }\n  }\n\n  updateProjectionMatrix() {\n    if (this.ortho) {\n      this.projectionMatrix.makeOrthographic(\n        this.left,\n        this.right,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far\n      );\n    } else {\n      this.projectionMatrix.makePerspective(\n        this.fov,\n        this.aspect,\n        this.near,\n        this.far\n      );\n    }\n\n    this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n  }\n}\n", "import { Color, ColorConstructorArg } from '../colors';\n\nexport class Fog {\n  name = \"\";\n  color: Color;\n  near: number;\n  far: number;\n  constructor(hex?:ColorConstructorArg, near = 1, far = 1000) {\n    this.color = new Color(hex);\n    this.near = near;\n    this.far = far;\n  }\n\n  clone() {\n    return new Fog(this.color.getHex(), this.near, this.far);\n  }\n}\n", "/**\n * Simplified webGL renderer\n */\n\nimport { Camera } from \"./Camera\";\nimport { DoubleSide, BackSide } from \"./constants/Sides\";\nimport {\n  UnsignedByteType,\n  RGBAFormat,\n  NearestFilter,\n} from \"./constants/TextureConstants\";\nimport { Light } from \"./core\";\nimport { Color } from \"../colors\";\nimport {\n  MeshOutlineMaterial,\n  SphereImposterOutlineMaterial,\n  StickImposterOutlineMaterial,\n} from \"./materials\";\nimport { Matrix4, Vector3, Matrix3 } from \"./math\";\nimport { Mesh, Line, Sprite } from \"./objects\";\nimport { ShaderLib, ShaderUtils } from \"./shaders\";\nimport { SpritePlugin } from \"./SpritePlugin\";\n\n// share a single offscreen renderer across all Renderers \nvar _offscreen_singleton = null;\nvar _gl_singleton = null;\n\n\nexport class Renderer {\n  row: any;\n  col: any;\n  rows: any;\n  cols: any;\n  context = null;\n  devicePixelRatio = 1.0; //set in setSize\n  domElement: HTMLCanvasElement;\n\n  // scene graph\n  sortObjects = true;\n  autoUpdateObjects = true;\n  autoUpdateScene = true;\n\n  // info\n  info = {\n    memory: {\n      programs: 0,\n      geometries: 0,\n      textures: 0,\n    },\n    render: {\n      calls: 0,\n      vertices: 0,\n      faces: 0,\n      points: 0,\n    },\n  };\n\n  // webgl rednering context\n  private _gl: WebGLRenderingContext | WebGL2RenderingContext;\n  private _offscreen: OffscreenCanvas = null;\n  private _bitmap: ImageBitmapRenderingContext = null;\n  // internal properties\n  private _programs = [];\n  private _programs_counter = 0;\n  private _webglversion = 1;\n  // internal state cache\n  private _currentProgram = null;\n  private _currentMaterialId = -1;\n  private _currentGeometryGroupHash = null;\n  private _currentCamera = null;\n  private _geometryGroupCounter = 0;\n  // GL state cache\n  private _oldDoubleSided = -1 as number | boolean;\n  private _oldFlipSided = -1 as number | boolean;\n  private _oldDepthTest = -1;\n  private _oldDepthWrite = -1;\n  private _oldPolygonOffset = null;\n  private _oldLineWidth = null;\n  private _viewportWidth = 0;\n  private _viewportHeight = 0;\n  private _currentWidth = 0;\n  private _currentHeight = 0;\n  private _enabledAttributes = {};\n  // camera matrices cache\n  private _vector3 = new Vector3();\n  private _worldInverse = new Matrix4();\n  private _projInverse = new Matrix4();\n  private _textureMatrix = new Matrix4();\n  private _fullProjModelMatrix = new Matrix4();\n  private _fullProjModelMatrixInv = new Matrix4();\n  // light arrays cach\n  private _direction = new Vector3();\n  private _lightsNeedUpdate = true;\n  private _lights = {\n    ambient: [0, 0, 0],\n    directional: {\n      length: 0,\n      colors: [],\n      positions: [],\n    },\n    point: {\n      length: 0,\n      colors: [],\n      positions: [],\n      distances: [],\n    },\n    spot: {\n      length: 0,\n      colors: [],\n      positions: [],\n      distances: [],\n      directions: [],\n      anglesCos: [],\n      exponents: [],\n    },\n    hemi: {\n      length: 0,\n      skyColors: [],\n      groundColors: [],\n      positions: [],\n    },\n  };\n\n  sprites = new SpritePlugin();\n\n  //screensshader related variables\n  private _screenshader = null;\n  private _AOshader = null;\n  private _blurshader = null;\n  private _vertexattribpos = null;\n  private _aovertexattribpos = null;\n  private _blurvertexattribpos = null;\n  private _screenQuadVBO = null;\n\n  //framebuffer variables\n  private _fb = null;\n  private _targetTexture = null;\n  private _depthTexture = null;\n  private _shadingTexture = null;\n  private _scratchTexture = null;\n  private _canvas: any;\n  private _precision: any;\n  private _alpha: any;\n  private _premultipliedAlpha: any;\n  private _antialias: any;\n  private _upscale: boolean | null = null;\n  private _preserveDrawingBuffer: any;\n  private _clearColor: Color;\n  private _clearAlpha: any;\n  private _outlineMaterial: MeshOutlineMaterial;\n  private _outlineSphereImposterMaterial: SphereImposterOutlineMaterial;\n  private _outlineStickImposterMaterial: StickImposterOutlineMaterial;\n  private _outlineEnabled: boolean;\n  private _AOEnabled: boolean;\n  private _AOstrength: number = 1.0;\n  private _AOradius: number = 5.0;\n  private _extInstanced: any;\n  private _extFragDepth: ReturnType<WebGL2RenderingContext[\"getExtension\"]>;\n  private _extFloatLinear: ReturnType<WebGL2RenderingContext[\"getExtension\"]>;\n  private _extColorBufferFloat: ReturnType<WebGL2RenderingContext[\"getExtension\"]>;\n\n  private SHADE_TEXTURE: number = 3;\n\n  constructor(parameters) {\n    parameters = parameters || {};\n    this.row = parameters.row;\n    this.col = parameters.col;\n    this.rows = parameters.rows;\n    this.cols = parameters.cols;\n    this._canvas =\n      parameters.canvas !== undefined\n        ? parameters.canvas\n        : document.createElement(\"canvas\");\n    this._precision =\n      parameters.precision !== undefined ? parameters.precision : \"highp\";\n    this._alpha = parameters.alpha !== undefined ? parameters.alpha : true;\n    this._premultipliedAlpha =\n      parameters.premultipliedAlpha !== undefined\n        ? parameters.premultipliedAlpha\n        : true;\n    this._antialias = parameters.antialias !== undefined ? parameters.antialias : false;\n    this._upscale = parameters.upscale !== undefined ? parameters.upscale : this._antialias;\n\n    this._preserveDrawingBuffer =\n      parameters.preserveDrawingBuffer !== undefined\n        ? parameters.preserveDrawingBuffer\n        : false;\n    this._clearColor =\n      parameters.clearColor !== undefined\n        ? new Color(parameters.clearColor)\n        : new Color(0x000000);\n    this._clearAlpha =\n      parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\n    this._outlineMaterial = new MeshOutlineMaterial(parameters.outline);\n    this._outlineSphereImposterMaterial = new SphereImposterOutlineMaterial(\n      parameters.outline\n    );\n    this._outlineStickImposterMaterial = new StickImposterOutlineMaterial(\n      parameters.outline\n    );\n    this._outlineEnabled = !!parameters.outline;\n    this._AOEnabled = !!parameters.ambientOcclusion;\n    if (parameters.ambientOcclusion && typeof (parameters.ambientOcclusion.strength) !== 'undefined') {\n      this._AOstrength = parseFloat(parameters.ambientOcclusion.strength);\n    }\n    if (this._AOstrength == 0) {\n      this._AOEnabled = false;\n    }\n    if (parameters.ambientOcclusion && typeof (parameters.ambientOcclusion.radius) !== 'undefined') {\n      this._AOradius = parseFloat(parameters.ambientOcclusion.radius);\n    }\n\n    this.domElement = this._canvas;\n    this._canvas.id = parameters.id;\n\n    if (parameters.containerWidth == 0 || parameters.containerHeight == 0) {\n      return; //start lost\n    }\n    this.initGL();\n    this.setDefaultGLState();\n\n    this.context = this._gl;\n    if (this.isWebGL1()) {\n      this._extInstanced = this._gl.getExtension(\"ANGLE_instanced_arrays\");\n    } else { //no longer an extension, wrap\n      this._extInstanced = {\n        vertexAttribDivisorANGLE: (this._gl as WebGL2RenderingContext).vertexAttribDivisor.bind(this._gl),\n        drawElementsInstancedANGLE: (this._gl as WebGL2RenderingContext).drawElementsInstanced.bind(this._gl),\n      };\n    }\n    this._extFragDepth = this._gl.getExtension(\"EXT_frag_depth\");\n    this._extFloatLinear = this._gl.getExtension(\"OES_texture_float_linear\");\n    this._extColorBufferFloat = this._gl.getExtension(\"EXT_color_buffer_float\");\n\n    this.sprites.init(this);\n  }\n\n  // API\n\n  supportedExtensions() {\n    return {\n      supportsAIA: Boolean(this._extInstanced),\n      supportsImposters: Boolean(this._extFragDepth) || !this.isWebGL1(),\n      regen: false\n    };\n  }\n\n  getContext() {\n    return this._gl;\n  }\n\n  getCanvas() {\n    return this._canvas;\n  }\n\n  isLost() {\n    return this._gl == null || this._gl.isContextLost();\n  }\n\n  getPrecision() {\n    return this._precision;\n  }\n\n  setClearColorHex(hex, alpha) {\n    this._clearColor.setHex(hex);\n    this._clearAlpha = alpha;\n    if (!this.isLost()) {\n      this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n    }\n  }\n\n  enableOutline(parameters) {\n    this._outlineMaterial = new MeshOutlineMaterial(parameters);\n    this._outlineSphereImposterMaterial = new SphereImposterOutlineMaterial(\n      parameters\n    );\n    this._outlineStickImposterMaterial = new StickImposterOutlineMaterial(\n      parameters\n    );\n    this._outlineEnabled = true;\n  }\n\n  disableOutline() {\n    this._outlineEnabled = false;\n  }\n\n  enableAmbientOcclusion(parameters) {\n    if (parameters) {\n      if (parameters.strength) this._AOstrength = parameters.strength;\n      if (parameters.scale) this._AOradius = parameters.scale;\n    }\n    this._AOEnabled = this._AOstrength > 0;\n  }\n\n  disableAmbientOcclusion() {\n    this._AOEnabled = false;\n  }\n\n  setViewport() {\n    if (this._offscreen) {\n      //set viewport is called before every render, so setup offscreen size here\n      this._offscreen.width = this._canvas.width;\n      this._offscreen.height = this._canvas.height;\n    }\n    if (\n      this.rows != undefined &&\n      this.cols != undefined &&\n      this.row != undefined &&\n      this.col != undefined\n    ) {\n      //note that drawingBuffer may be smaller than the requested width\n      //for large canvases\n      if(!this.isLost()) {\n        var wid = this._gl.drawingBufferWidth / this.cols;\n        var hei = this._gl.drawingBufferHeight / this.rows;            \n        this._viewportWidth = wid;\n        this._viewportHeight = hei;\n        this._gl.enable(this._gl.SCISSOR_TEST);\n        this._gl.scissor(wid * this.col, hei * this.row, wid, hei);\n        this._gl.viewport(wid * this.col, hei * this.row, wid, hei);\n      }\n    }\n  }\n\n  setSize(width, height) {\n    //zooming (in the browser) changes the pixel ratio and width/height\n    this.devicePixelRatio =\n      window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;\n    //with antialiasing on, render at double rsolution to eliminate jaggies\n    //don't do it with high resolution displays\n    if (this._upscale && this.devicePixelRatio < 2.0) this.devicePixelRatio = 2.0;\n    this._canvas.width = width * this.devicePixelRatio;\n    this._canvas.height = height * this.devicePixelRatio;\n    this._canvas.style.width = width + \"px\";\n    this._canvas.style.height = height + \"px\";\n\n    if (\n      this.rows != undefined &&\n      this.cols != undefined &&\n      this.row != undefined &&\n      this.col != undefined\n    ) {\n      if (!this.isLost()) {\n        this._viewportWidth = this._gl.drawingBufferWidth /this.cols;\n        this._viewportHeight = this._gl.drawingBufferHeight/this.rows;\n      }\n\n      this.setViewport();\n    } else {\n      this._viewportWidth = this._canvas.width;\n      this._viewportHeight = this._canvas.height;\n\n      if (!this.isLost()) {\n        this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);\n      }\n    }\n\n    this.initFrameBuffer();\n  }\n\n  clear(color, depth, stencil) {\n    var bits = 0;\n    if (color === undefined || color) bits |= this._gl.COLOR_BUFFER_BIT;\n    if (depth === undefined || depth) bits |= this._gl.DEPTH_BUFFER_BIT;\n    if (stencil === undefined || stencil) bits |= this._gl.STENCIL_BUFFER_BIT;\n    this._gl.clear(bits);\n  }\n\n  setMaterialFaces(material, reflected) {\n    var doubleSided = material.side === DoubleSide;\n    var flipSided = material.side === BackSide;\n\n    if (!material.imposter)\n      // Ignore reflection with imposters\n      flipSided = reflected ? !flipSided : flipSided;\n\n    if (this._oldDoubleSided !== doubleSided) {\n      if (doubleSided) {\n        this._gl.disable(this._gl.CULL_FACE);\n      } else {\n        this._gl.enable(this._gl.CULL_FACE);\n      }\n\n      this._oldDoubleSided = doubleSided;\n    }\n\n    if (this._oldFlipSided !== flipSided) {\n      if (flipSided) {\n        this._gl.frontFace(this._gl.CW);\n      } else {\n        this._gl.frontFace(this._gl.CCW);\n      }\n\n      this._oldFlipSided = flipSided;\n    }\n\n    this._gl.cullFace(this._gl.BACK);\n  }\n\n  setDepthTest(depthTest) {\n    if (this._oldDepthTest !== depthTest) {\n      if (depthTest) {\n        this._gl.enable(this._gl.DEPTH_TEST);\n      } else {\n        this._gl.disable(this._gl.DEPTH_TEST);\n      }\n\n      this._oldDepthTest = depthTest;\n    }\n  }\n\n  setDepthWrite(depthWrite) {\n    if (this._oldDepthWrite !== depthWrite) {\n      this._gl.depthMask(depthWrite);\n      this._oldDepthWrite = depthWrite;\n    }\n  }\n\n  setBlending(blending) {\n    if (!blending) {\n      this._gl.disable(this._gl.BLEND);\n    } else {\n      this._gl.enable(this._gl.BLEND);\n      this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD);\n      this._gl.blendFuncSeparate(\n        this._gl.SRC_ALPHA,\n        this._gl.ONE_MINUS_SRC_ALPHA,\n        this._gl.ONE,\n        this._gl.ONE_MINUS_SRC_ALPHA\n      );\n    }\n  }\n\n  // TODO: need to set up shader attributes and uniforms as attributes on\n  // material object after attaching prgm\n  // We need to attach appropriate uniform variables to material after shaders\n  // have been chosen\n  initMaterial(material, lights, fog, objects) {\n    material.addEventListener(\"dispose\", this.onMaterialDispose.bind(this));\n\n    var parameters, shaderID;\n\n    shaderID = material.shaderID;\n\n    if (shaderID) {\n      var shader = ShaderLib[shaderID];\n      material.vertexShader = shader.vertexShader;\n      material.fragmentShader = shader.fragmentShader;\n      material.uniforms = ShaderUtils.clone(shader.uniforms);\n      // TODO: set material uniforms to shader uniform variables\n\n      if (material.shaded) {\n        material.makeShaded(this.SHADE_TEXTURE);\n      }\n    }\n\n    parameters = {\n      wireframe: material.wireframe,\n      fragdepth: material.imposter,\n      volumetric: material.volumetric,\n      shaded: material.shaded\n    };\n\n    material.program = this.buildProgram(\n      material.fragmentShader,\n      material.vertexShader,\n      material.uniforms,\n      parameters\n    );\n  }\n\n  renderBuffer(camera, lights, fog, material, geometryGroup, object) {\n    if (!material.visible) return;\n\n    var program, attributes;\n\n    // Sets up proper vertex and fragment shaders and attaches them to webGL\n    // program\n    // Also sets appropriate uniform variables\n    program = this.setProgram(camera, lights, fog, material, object, this);\n    if (!program) return;\n\n    attributes = program.attributes;\n\n    var updateBuffers = false,\n      wireframeBit = material.wireframe ? 1 : 0,\n      geometryGroupHash =\n        geometryGroup.id * 0xffffff + program.id * 2 + wireframeBit;\n\n    if (geometryGroupHash !== this._currentGeometryGroupHash) {\n      this._currentGeometryGroupHash = geometryGroupHash;\n      updateBuffers = true;\n    }\n\n    // rebind shader attributes to appropriate (and already initialized) gl\n    // buffers\n    if (updateBuffers) {\n      this.disableAttributes();\n\n      // Vertices\n      if (attributes.position >= 0) {\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n        this.enableAttribute(attributes.position);\n        this._gl.vertexAttribPointer(attributes.position, 3, this._gl.FLOAT, false, 0, 0);\n      }\n\n      // Colors\n      if (attributes.color >= 0) {\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n        this.enableAttribute(attributes.color);\n        this._gl.vertexAttribPointer(attributes.color, 3, this._gl.FLOAT, false, 0, 0);\n      }\n\n      // Normals\n      if (attributes.normal >= 0) {\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n        this.enableAttribute(attributes.normal);\n        this._gl.vertexAttribPointer(attributes.normal, 3, this._gl.FLOAT, false, 0, 0);\n      }\n\n      // Offsets (Instanced only)\n      if (attributes.offset >= 0) {\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);\n        this.enableAttribute(attributes.offset);\n        this._gl.vertexAttribPointer(attributes.offset, 3, this._gl.FLOAT, false, 0, 0);\n      }\n\n      // Radii (Instanced only)\n      if (attributes.radius >= 0) {\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);\n        this.enableAttribute(attributes.radius);\n        this._gl.vertexAttribPointer(attributes.radius, 1, this._gl.FLOAT, false, 0, 0);\n      }\n    }\n\n    // Render\n    var faceCount, lineCount;\n    // lambert shaders - draw triangles\n    // TODO: make sure geometryGroup's face count is setup correctly\n    if (object instanceof Mesh) {\n      if (material.shaderID === \"instanced\") {\n        var sphereGeometryGroup = material.sphere.geometryGroups[0];\n        if (updateBuffers) {\n          this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n          this._gl.bufferData(\n            this._gl.ARRAY_BUFFER,\n            sphereGeometryGroup.vertexArray,\n            this._gl.STATIC_DRAW\n          );\n          this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n          this._gl.bufferData(\n            this._gl.ARRAY_BUFFER,\n            sphereGeometryGroup.normalArray,\n            this._gl.STATIC_DRAW\n          );\n          this._gl.bindBuffer(\n            this._gl.ELEMENT_ARRAY_BUFFER,\n            geometryGroup.__webglFaceBuffer\n          );\n          this._gl.bufferData(\n            this._gl.ELEMENT_ARRAY_BUFFER,\n            sphereGeometryGroup.faceArray,\n            this._gl.STATIC_DRAW\n          );\n        }\n\n        faceCount = sphereGeometryGroup.faceidx;\n\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 1);\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 1);\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 1);\n\n        this._extInstanced.drawElementsInstancedANGLE(\n          this._gl.TRIANGLES,\n          faceCount,\n          this._gl.UNSIGNED_SHORT,\n          0,\n          geometryGroup.radiusArray.length\n        );\n\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 0);\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 0);\n        this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 0);\n      } else if (material.wireframe) {\n        lineCount = geometryGroup.lineidx;\n        this.setLineWidth(material.wireframeLinewidth);\n\n        if (updateBuffers)\n          this._gl.bindBuffer(\n            this._gl.ELEMENT_ARRAY_BUFFER,\n            geometryGroup.__webglLineBuffer\n          );\n\n        this._gl.drawElements(this._gl.LINES, lineCount, this._gl.UNSIGNED_SHORT, 0);\n      } else {\n        faceCount = geometryGroup.faceidx;\n\n        if (updateBuffers)\n          this._gl.bindBuffer(\n            this._gl.ELEMENT_ARRAY_BUFFER,\n            geometryGroup.__webglFaceBuffer\n          );\n        this._gl.drawElements(this._gl.TRIANGLES, faceCount, this._gl.UNSIGNED_SHORT, 0);\n      }\n\n      this.info.render.calls++;\n      this.info.render.vertices += faceCount;\n      this.info.render.faces += faceCount / 3;\n    }\n\n    // basic shaders - draw lines\n    else if (object instanceof Line) {\n      lineCount = geometryGroup.vertices;\n\n      this.setLineWidth(material.linewidth);\n      this._gl.drawArrays(this._gl.LINES, 0, lineCount);\n\n      this.info.render.calls++;\n    }\n  }\n\n  /* clear out the shading textures */\n  clearShading() {\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._shadingTexture,\n      0\n    );\n    this.clear(false, true, false);\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._depthTexture,\n      0\n    );\n  }\n\n  /* Setup the shading buffer to reflect desired shading (ambient occlusion) values.\n    Only the matching object with materialType are considered. */\n  setShading(scene, camera, materialType) {\n    //identify all matching objects\n    let lights = scene.__lights;\n    let fog = scene.fog;\n    let renderList = [];\n\n    for (let i = 0, il = scene.__webglObjects.length; i < il; i++) {\n      let webglObject = scene.__webglObjects[i];\n\n      if (webglObject.render && webglObject[materialType]) {\n        renderList.push(webglObject);\n      }\n    }\n\n    if (renderList.length == 0) return;\n\n    //setup shading texture as depth buffer\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._shadingTexture,\n      0\n    );\n\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.COLOR_ATTACHMENT0,\n      this._gl.TEXTURE_2D,\n      null, //don't write colors (can we do this?)\n      0\n    );\n\n    //calculate depth map\n    this.renderObjects(scene.__webglObjects, true, materialType + \"Depth\",\n      camera, lights, fog, false);\n\n    //detach so we can read and attach scratch\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._scratchTexture,\n      0\n    );\n    this.clear(false, true, false);\n\n    //perform AO calculation from depth map to scratch buffer\n\n    // set screen shader and use it\n    this._gl.useProgram(this._AOshader);\n    this._currentProgram = this._AOshader;\n    // disable depth test\n    this.setDepthTest(-1);\n    this.setDepthWrite(-1);\n\n    let p_uniforms = this._AOshader.uniforms;\n    this._gl.uniform1f(p_uniforms.total_strength, this._AOstrength);\n    this._gl.uniform1f(p_uniforms.radius, this._AOradius);\n\n    //setup full projection matrix from model to screen and inverted\n    //use first object\n    this._fullProjModelMatrix = new Matrix4();\n    this._fullProjModelMatrixInv = new Matrix4();\n    let object = renderList[0].object;\n    this._fullProjModelMatrix.multiplyMatrices(camera.projectionMatrix, object._modelViewMatrix);\n    this._fullProjModelMatrixInv.getInverse(this._fullProjModelMatrix);\n    this._gl.uniformMatrix4fv(\n      p_uniforms.projectionMatrix,\n      false,\n      this._fullProjModelMatrix.elements\n    );\n\n    this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._fullProjModelMatrixInv.elements);\n\n\n    // bind vertexarray buffer and texture\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n    this._gl.enableVertexAttribArray(this._aovertexattribpos);\n    this._gl.vertexAttribPointer(this._aovertexattribpos, 2, this._gl.FLOAT, false, 0, 0);\n\n    this._gl.activeTexture(this._gl.TEXTURE0);\n    this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);\n\n    // Draw 6 vertexes => 2 triangles:\n    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\n\n\n    //perform blur from scratch to shading\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._shadingTexture,\n      0\n    );\n    this.clear(false, true, false);\n\n    this._gl.useProgram(this._blurshader);\n    this._currentProgram = this._blurshader;\n    this.setDepthTest(-1);\n    this.setDepthWrite(-1);\n\n\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n    this._gl.enableVertexAttribArray(this._blurvertexattribpos);\n    this._gl.vertexAttribPointer(this._blurvertexattribpos, 2, this._gl.FLOAT, false, 0, 0);\n\n    this._gl.activeTexture(this._gl.TEXTURE0);\n    this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture);\n\n    // Draw 6 vertexes => 2 triangles:\n    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\n\n    //restore original depth, color\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.COLOR_ATTACHMENT0,\n      this._gl.TEXTURE_2D,\n      this._targetTexture,\n      0\n    );\n\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._depthTexture,\n      0\n    );\n\n  }\n\n  render(scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error(\"Renderer.render: camera is not an instance of Camera.\");\n      return;\n    }\n\n    var i,\n      il,\n      webglObject,\n      object,\n      renderList,\n      lights = scene.__lights,\n      fog = scene.fog;\n\n    // reset caching for this frame\n\n    this._currentMaterialId = -1;\n    this._lightsNeedUpdate = true;\n\n    // update scene graph\n\n    if (this.autoUpdateScene) scene.updateMatrixWorld();\n\n    // update camera matrices\n    // Pretty sure camera's parent is always going to be undefined for our\n    // purposes...\n    if (camera.parent === undefined) camera.updateMatrixWorld();\n\n    camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n\n    if (this.isLost()) {\n      return;\n    }\n    // update WebGL objects\n\n    if (this.autoUpdateObjects) this.initWebGLObjects(scene);\n\n    this.info.render.calls = 0;\n    this.info.render.vertices = 0;\n    this.info.render.faces = 0;\n    this.info.render.points = 0;\n\n    this._currentWidth = this._viewportWidth;\n    this._currentHeight = this._viewportHeight;\n\n    this.setViewport();\n    this.setFrameBuffer();\n\n    this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n    this.clear(true, true, true);\n\n    // set matrices for regular objects (frustum culled)\n\n    renderList = scene.__webglObjects;\n    let hasvolumetric = false;\n    let hasAO = this._AOEnabled;\n    for (i = 0, il = renderList.length; i < il; i++) {\n      webglObject = renderList[i];\n      object = webglObject.object;\n\n      webglObject.render = false;\n\n      if (object.visible) {\n        this.setupMatrices(object, camera);\n        this.unrollBufferMaterial(webglObject);\n        webglObject.render = true;\n        if (webglObject.volumetric) hasvolumetric = true;\n        if (webglObject.hasAO) hasAO = true;\n      }\n    }\n\n    // set matrices for immediate objects\n\n    // opaque pass (front-to-back order)\n\n    this.setBlending(false);\n\n    if (hasAO) {\n      this.setShading(scene, camera, \"opaque\");\n    }\n\n    this.renderObjects(scene.__webglObjects, true, \"opaque\", camera, lights, fog, false);\n\n    if (hasAO) {\n      this.clearShading();\n    }\n\n    // Render embedded labels (sprites)\n    this.renderSprites(scene, camera, false);\n\n    // prime depth buffer with transparent objects\n    this.renderObjects(scene.__webglObjects, true, \"transparentDepth\", camera, lights, fog, true);\n\n    // transparent pass (back-to-front order)\n    this.renderObjects(scene.__webglObjects, false, \"transparent\", camera, lights, fog, true);\n\n    //volumetric is separate\n    if (hasvolumetric && this._fb) {\n      //disconnect depth texture from framebuffer so we can read it\n      this._gl.framebufferTexture2D(\n        this._gl.FRAMEBUFFER,\n        this._gl.DEPTH_ATTACHMENT,\n        this._gl.TEXTURE_2D,\n        null,\n        0\n      );\n\n      this.renderObjects(scene.__webglObjects, false, \"volumetric\",\n        camera, lights, fog, true);\n    }\n\n    this.renderFrameBuffertoScreen();\n    this.setDepthTest(true);\n    this.setDepthWrite(true);\n\n    // Render floating labels (sprites)\n    this.renderSprites(scene, camera, true);\n\n    //if using offscreen render, copy final image\n    if (this._bitmap) {\n      const bitmap = this._offscreen.transferToImageBitmap();\n      this._bitmap.transferFromImageBitmap(bitmap);\n      bitmap.close();\n    }\n  }\n\n\n  //setup framebuffer for drawing into, assumes buffers already allocated\n  setFrameBuffer() {\n    if (this.isWebGL1() || !this._fb) return;\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    //when using framebuffer, always draw from origin, will shift the viewport when we render\n    this._gl.enable(this._gl.SCISSOR_TEST);\n    this._gl.scissor(0, 0, width, height);\n    this._gl.viewport(0, 0, width, height);\n\n    //color texture\n    this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);\n    this._gl.texImage2D(\n      this._gl.TEXTURE_2D,\n      0,\n      this._gl.RGBA,\n      width,\n      height,\n      0,\n      this._gl.RGBA,\n      this._gl.UNSIGNED_BYTE,\n      null\n    );\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n\n    //depth texture\n    this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);\n    this._gl.texImage2D(\n      this._gl.TEXTURE_2D,\n      0,\n      (this._gl as WebGL2RenderingContext).DEPTH_COMPONENT32F,\n      width,\n      height,\n      0,\n      this._gl.DEPTH_COMPONENT,\n      this._gl.FLOAT,\n      null\n    );\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n\n    //shading texture - for AO and maybe eventually shadows? I don't like shadows\n    if (this._shadingTexture) {\n      //for whatever reason, chrome seems to require this manual memory management\n      //for these textures, at least in the auto tests webpage where many viewers are being created/destroyed\n      this._gl.deleteTexture(this._shadingTexture);\n      this._shadingTexture = this._gl.createTexture();\n      this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);\n      this._gl.texImage2D(\n        this._gl.TEXTURE_2D,\n        0,\n        (this._gl as WebGL2RenderingContext).DEPTH_COMPONENT32F,\n        width,\n        height,\n        0,\n        this._gl.DEPTH_COMPONENT,\n        this._gl.FLOAT,\n        null\n      );\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n\n      //scratch texture, needed by AO to do blur\n      this._gl.deleteTexture(this._scratchTexture);\n      this._scratchTexture = this._gl.createTexture();\n      this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture);\n      this._gl.texImage2D(\n        this._gl.TEXTURE_2D,\n        0,\n        (this._gl as WebGL2RenderingContext).DEPTH_COMPONENT32F,\n        width,\n        height,\n        0,\n        this._gl.DEPTH_COMPONENT,\n        this._gl.FLOAT,\n        null\n      );\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n\n    }\n    //bind fb\n    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb);\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.COLOR_ATTACHMENT0,\n      this._gl.TEXTURE_2D,\n      this._targetTexture,\n      0\n    );\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._shadingTexture,\n      0\n    );\n    this._gl.clearDepth(1);\n    this._gl.clear(this._gl.DEPTH_BUFFER_BIT);  //shading all ones\n\n    this._gl.framebufferTexture2D(\n      this._gl.FRAMEBUFFER,\n      this._gl.DEPTH_ATTACHMENT,\n      this._gl.TEXTURE_2D,\n      this._depthTexture,\n      0\n    );\n  }\n\n  //allocate buffers for framebuffer, needs to be called with every resize\n  initFrameBuffer() {\n    // only needed/works with webgl2\n    if (this.isWebGL1()) return;\n\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    //when using framebuffer, always draw from origin, will shift the viewport when we render\n    this._gl.enable(this._gl.SCISSOR_TEST);\n    this._gl.scissor(0, 0, width, height);\n    this._gl.viewport(0, 0, width, height);\n\n    //create textures and frame buffer, will be initialized in setFrameBuffer\n    this._targetTexture = this._gl.createTexture();\n    this._depthTexture = this._gl.createTexture();\n    this._shadingTexture = this._gl.createTexture();\n    this._scratchTexture = this._gl.createTexture();\n    this._fb = this._gl.createFramebuffer();\n\n    // build screenshader\n    var screenshader = this._antialias ? ShaderLib.screenaa : ShaderLib.screen;\n\n    this._screenshader = this.buildProgram(\n      screenshader.fragmentShader,\n      screenshader.vertexShader,\n      screenshader.uniforms,\n      {}\n    );\n    this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, \"vertexPosition\");\n    // create the vertex array and attrib array for the full screenquad\n    var verts = [\n      // First triangle:\n      1.0, 1.0, -1.0, 1.0, -1.0, -1.0,\n      // Second triangle:\n      -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,\n    ];\n    this._screenQuadVBO = this._gl.createBuffer();\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n    this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(verts), this._gl.STATIC_DRAW);\n\n    // build aoshader\n    let aoshader = ShaderLib.ssao;\n\n    this._AOshader = this.buildProgram(\n      aoshader.fragmentShader,\n      aoshader.vertexShader,\n      aoshader.uniforms,\n      {}\n    );\n    this._aovertexattribpos = this._gl.getAttribLocation(this._AOshader, \"vertexPosition\");\n    // create the vertex array and attrib array for the full screenquad\n\n    //blur shader\n    let bshader = ShaderLib.blur;\n\n    this._blurshader = this.buildProgram(\n      bshader.fragmentShader,\n      bshader.vertexShader,\n      bshader.uniforms,\n      {}\n    );\n    this._blurvertexattribpos = this._gl.getAttribLocation(this._blurshader, \"vertexPosition\");\n\n  }\n\n  renderFrameBuffertoScreen() {\n    // only needed/works with webgl2\n    if (this.isWebGL1() || this._fb === null) return;\n\n    this.setViewport(); //draw texture in correct viewport\n\n    // bind default framebuffer\n    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);\n    this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\n    this._gl.frontFace(this._gl.CCW);\n    this._gl.cullFace(this._gl.BACK);\n\n    // set screen shader and use it\n    this._gl.useProgram(this._screenshader);\n    this._currentProgram = this._screenshader;\n    // disable depth test\n    this.setDepthTest(-1);\n    this.setDepthWrite(-1);\n\n    // bind vertexarray buffer and texture\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n    this._gl.enableVertexAttribArray(this._vertexattribpos);\n    this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, false, 0, 0);\n\n    this._gl.activeTexture(this._gl.TEXTURE0);\n    this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);\n\n    // Draw 6 vertexes => 2 triangles:\n    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\n  }\n\n  initWebGLObjects(scene) {\n    if (!scene.__webglObjects) {\n      scene.__webglObjects = [];\n      scene.__webglObjectsImmediate = [];\n      scene.__webglSprites = [];\n      scene.__webglFlares = [];\n    }\n\n    // Add objects; this sets up buffers for each geometryGroup\n    if (scene.__objectsAdded.length) {\n      while (scene.__objectsAdded.length) {\n        this.addObject(scene.__objectsAdded[0], scene);\n        scene.__objectsAdded.splice(0, 1);\n      }\n\n      // Force buffer update during render\n      // Hackish fix for initial cartoon-render-then-transparent-surface\n      // bug\n      this._currentGeometryGroupHash = -1;\n    }\n\n    while (scene.__objectsRemoved.length) {\n      this.removeObject(scene.__objectsRemoved[0], scene);\n      scene.__objectsRemoved.splice(0, 1);\n    }\n\n    // update must be called after objects adding / removal\n    // This sends typed arrays to GL buffers for each geometryGroup\n    for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {\n      this.updateObject(scene.__webglObjects[o].object);\n    }\n  }\n\n  getYRatio() {\n    if (this.rows !== undefined && this.row !== undefined) return this.rows;\n    return 1;\n  }\n\n  getXRatio() {\n    if (this.cols !== undefined && this.col !== undefined) return this.cols;\n    return 1;\n  }\n\n  getAspect(width, height) {\n    if (width == undefined || height == undefined) {\n      width = this._canvas.width;\n      height = this._canvas.height;\n    }\n    var aspect = width / height;\n    if (\n      this.rows != undefined &&\n      this.cols != undefined &&\n      this.row != undefined &&\n      this.col != undefined\n    ) {\n      var wid = width / this.cols;\n      var hei = height / this.rows;\n      aspect = wid / hei;\n    }\n    return aspect;\n  }\n\n  setTexture(texture, slot, is3D) {\n    if (texture.needsUpdate) {\n      if (!texture.__webglInit) {\n        texture.__webglInit = true;\n        texture.addEventListener(\"dispose\", this.onTextureDispose.bind(this));\n        texture.__webglTexture = this._gl.createTexture();\n        this.info.memory.textures++;\n      }\n\n      this._gl.activeTexture(this._gl.TEXTURE0 + slot);\n      var gltextureType = is3D ? (this._gl as WebGL2RenderingContext).TEXTURE_3D : this._gl.TEXTURE_2D;\n      this._gl.bindTexture(gltextureType, texture.__webglTexture);\n      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n      this._gl.pixelStorei(\n        this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\n        texture.premultiplyAlpha\n      );\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n      this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, texture.unpackAlignment);\n\n      var glFormat = this.paramToGL(texture.format),\n        glType = this.paramToGL(texture.type);\n\n      if (!is3D) {\n        var image = texture.image;\n        var width = image.width; //might not be defined\n        var height = image.height;\n        if (typeof width === \"undefined\") {\n          //if no width,\n          width = image.length;\n          if (glFormat == this._gl.RGBA) {\n            width /= 4; //each element takes up 4 bytes\n          }\n          height = 1;\n        }\n        this.setTextureParameters(this._gl.TEXTURE_2D, texture);\n        if (!this.isWebGL1()) {\n          //webgl2\n          this._gl.texImage2D(\n            this._gl.TEXTURE_2D,\n            0,\n            glFormat,\n            width,\n            height,\n            0,\n            glFormat,\n            glType,\n            texture.image\n          );\n        } else {\n          this._gl.texImage2D(\n            this._gl.TEXTURE_2D,\n            0,\n            glFormat,\n            glFormat,\n            glType,\n            texture.image\n          );\n        }\n      } else {\n        //3D\n        this.setTextureParameters((this._gl as WebGL2RenderingContext).TEXTURE_3D, texture);\n        (this._gl as WebGL2RenderingContext).texImage3D(\n          (this._gl as WebGL2RenderingContext).TEXTURE_3D,\n          0,\n          (this._gl as WebGL2RenderingContext).R32F,\n          texture.image.size.z,\n          texture.image.size.y,\n          texture.image.size.x,\n          0,\n          (this._gl as WebGL2RenderingContext).RED,\n          this._gl.FLOAT,\n          texture.image.data\n        );\n      }\n\n      texture.needsUpdate = false;\n\n      if (texture.onUpdate) texture.onUpdate();\n    } else {\n      this._gl.activeTexture(this._gl.TEXTURE0 + slot);\n      if (is3D) this._gl.bindTexture((this._gl as WebGL2RenderingContext).TEXTURE_3D, texture.__webglTexture);\n      else this._gl.bindTexture(this._gl.TEXTURE_2D, texture.__webglTexture);\n    }\n  }\n\n  supportsVolumetric() {\n    return !this.isWebGL1();\n  }\n\n  private enableAttribute(attribute) {\n    if (!this._enabledAttributes[attribute]) {\n      this._gl.enableVertexAttribArray(attribute);\n      this._enabledAttributes[attribute] = true;\n    }\n  }\n\n  private disableAttributes() {\n    for (let attribute in this._enabledAttributes) {\n      if (this._enabledAttributes[attribute]) {\n        this._gl.disableVertexAttribArray(attribute as any);\n        this._enabledAttributes[attribute] = false;\n      }\n    }\n  }\n\n  private setPolygonOffset(polygonOffset, offsetFactor, offsetUnits) {\n    if (this._oldPolygonOffset !== polygonOffset) {\n      if (polygonOffset) this._gl.enable(this._gl.POLYGON_OFFSET_FILL);\n      else this._gl.disable(this._gl.POLYGON_OFFSET_FILL);\n    }\n  }\n\n  private setLineWidth(width: number) {\n    if (width !== this._oldLineWidth) {\n      this._gl.lineWidth(width);\n      this._oldLineWidth = width;\n    }\n  }\n\n  private deallocateGeometry(geometry) {\n    geometry.__webglInit = undefined;\n\n    if (geometry.__webglVertexBuffer !== undefined)\n      this._gl.deleteBuffer(geometry.__webglVertexBuffer);\n\n    if (geometry.__webglColorBuffer !== undefined)\n      this._gl.deleteBuffer(geometry.__webglColorBuffer);\n\n    if (geometry.geometryGroups !== undefined) {\n      for (var g = 0, gl = geometry.groups; g < gl; g++) {\n        var geometryGroup = geometry.geometryGroups[g];\n\n        if (geometryGroup.__webglVertexBuffer !== undefined)\n          this._gl.deleteBuffer(geometryGroup.__webglVertexBuffer);\n\n        if (geometryGroup.__webglColorBuffer !== undefined)\n          this._gl.deleteBuffer(geometryGroup.__webglColorBuffer);\n\n        if (geometryGroup.__webglNormalBuffer !== undefined)\n          this._gl.deleteBuffer(geometryGroup.__webglNormalBuffer);\n\n        if (geometryGroup.__webglFaceBuffer !== undefined)\n          this._gl.deleteBuffer(geometryGroup.__webglFaceBuffer);\n\n        if (geometryGroup.__webglLineBuffer !== undefined)\n          this._gl.deleteBuffer(geometryGroup.__webglLineBuffer);\n      }\n    }\n  }\n\n  private deallocateMaterial(material) {\n    var program = material.program;\n\n    if (program === undefined) return;\n\n    material.program = undefined;\n\n    // only deallocate GL program if this was the last use of shared program\n    // assumed there is only single copy of any program in the _programs\n    // list\n    // (that's how it's constructed)\n\n    var i, il, programInfo;\n    var deleteProgram = false;\n\n    for (i = 0, il = this._programs.length; i < il; i++) {\n      programInfo = this._programs[i];\n\n      if (programInfo.program === program) {\n        programInfo.usedTimes--;\n\n        if (programInfo.usedTimes === 0) {\n          deleteProgram = true;\n        }\n\n        break;\n      }\n    }\n\n    if (deleteProgram === true) {\n      // avoid using array.splice, this is costlier than creating new\n      // array from scratch\n\n      var newPrograms = [];\n\n      for (i = 0, il = this._programs.length; i < il; i++) {\n        programInfo = this._programs[i];\n\n        if (programInfo.program !== program) {\n          newPrograms.push(programInfo);\n        }\n      }\n\n      this._programs = newPrograms;\n\n      this._gl.deleteProgram(program);\n\n      this.info.memory.programs--;\n    }\n  }\n\n  private deallocateTexture(texture) {\n    if (texture.image && texture.image.__webglTextureCube) {\n      // cube texture\n\n      this._gl.deleteTexture(texture.image.__webglTextureCube);\n    } else {\n      // 2D texture\n\n      if (!texture.__webglInit) return;\n\n      texture.__webglInit = false;\n      this._gl.deleteTexture(texture.__webglTexture);\n    }\n  }\n\n  private onGeometryDispose(event) {\n    var geometry = event.target;\n    geometry.removeEventListener(\"dispose\", this.onGeometryDispose);\n\n    this.deallocateGeometry(geometry);\n\n    this.info.memory.geometries--;\n  }\n\n  private onTextureDispose(event) {\n    var texture = event.target;\n\n    texture.removeEventListener(\"dispose\", this.onTextureDispose);\n\n    this.deallocateTexture(texture);\n\n    this.info.memory.textures--;\n  }\n\n  private onMaterialDispose(event) {\n    var material = event.target;\n    material.removeEventListener(\"dispose\", this.onMaterialDispose);\n\n    this.deallocateMaterial(material);\n  }\n\n  // Compile and return shader\n  private getShader(type, str) {\n    var shader;\n\n    if (!this.isWebGL1() && !str.startsWith(\"#version\")) {\n      //convert webgl1 to webgl2, unless a version is already explicit\n      str = str.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n      if (type == \"fragment\") {\n        str = str.replace(/varying/g, \"in\");\n      } else {\n        str = str.replace(/varying/g, \"out\");\n      }\n      str = str.replace(/attribute/g, \"in\");\n      str = str.replace(/texture2D/g, \"texture\");\n      str = str.replace(/\\/\\/DEFINEFRAGCOLOR/g, \"out vec4 glFragColor;\");\n      str = str.replace(/gl_FragColor/g, \"glFragColor\");\n      str = \"#version 300 es\\n\" + str;\n    }\n    if (type === \"fragment\") shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);\n    else if (type === \"vertex\") shader = this._gl.createShader(this._gl.VERTEX_SHADER);\n\n    if (shader == null) return null;\n\n    this._gl.shaderSource(shader, str);\n    this._gl.compileShader(shader);\n\n    if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {\n      console.error(this._gl.getShaderInfoLog(shader));\n      console.error(\"could not initialize shader\");\n      return null;\n    }\n\n    return shader;\n  }\n\n  // Compile appropriate shaders (if necessary) from source code and attach to\n  // gl program.\n  private buildProgram(fragmentShader, vertexShader, uniforms, parameters) {\n    var p, pl, program, code;\n    var chunks = [];\n\n    chunks.push(fragmentShader);\n    chunks.push(vertexShader);\n\n    for (p in parameters) {\n      chunks.push(p);\n      chunks.push(parameters[p]);\n    }\n\n    code = chunks.join();\n\n    // check if program has already been compiled\n\n    for (p = 0, pl = this._programs.length; p < pl; p++) {\n      var programInfo = this._programs[p];\n\n      if (programInfo.code === code) {\n        programInfo.usedTimes++;\n\n        return programInfo.program;\n      }\n    }\n\n    // check if program requires webgl2\n    if (this.isWebGL1()) {\n      if (parameters.volumetric)\n        throw new Error(\n          \"Volumetric rendering requires webgl2 which is not supported by your hardware.\"\n        );\n    }\n\n    // Set up new program and compile shaders\n    program = this._gl.createProgram();\n    if (program == null) return null;\n\n    // set up precision\n    var precision = this._precision;\n    var prefix = \"precision \" + precision + \" float;\";\n\n    var prefix_vertex = [\n      parameters.volumetric ? \"#version 300 es\" : \"\",\n      prefix,\n    ].join(\"\\n\");\n\n    var prefix_fragment = [\n      parameters.volumetric ? \"#version 300 es\" : \"\",\n      parameters.fragdepth && this.isWebGL1()\n        ? \"#extension GL_EXT_frag_depth: enable\"\n        : \"\",\n      parameters.shaded ? \"#define SHADED 1\" : \"\",\n      parameters.wireframe ? \"#define WIREFRAME 1\" : \"\",\n      prefix,\n    ].join(\"\\n\");\n\n    var glFragmentShader = this.getShader(\n      \"fragment\",\n      prefix_fragment + fragmentShader\n    );\n    var glVertexShader = this.getShader(\"vertex\", prefix_vertex + vertexShader);\n\n    if (glVertexShader != null) this._gl.attachShader(program, glVertexShader);\n    if (glFragmentShader != null) this._gl.attachShader(program, glFragmentShader);\n\n    this._gl.linkProgram(program);\n\n    if (!this._gl.getProgramParameter(program, this._gl.LINK_STATUS))\n      console.error(\"Could not initialize shader\");\n\n    // gather and cache uniform variables and attributes\n\n    program.uniforms = {};\n    program.attributes = {};\n\n    var identifiers, u, i;\n\n    // uniform vars\n    identifiers = [\n      \"viewMatrix\",\n      \"modelViewMatrix\",\n      \"projectionMatrix\",\n      \"normalMatrix\",\n      \"vWidth\",\n      \"vHeight\"\n    ];\n\n    // custom uniform vars\n    for (u in uniforms) identifiers.push(u);\n\n    for (i = 0; i < identifiers.length; i++) {\n      var uniformVar = identifiers[i];\n      program.uniforms[uniformVar] = this._gl.getUniformLocation(\n        program,\n        uniformVar\n      );\n    }\n\n    // attributes\n    identifiers = [\n      \"position\",\n      \"normal\",\n      \"color\",\n      \"lineDistance\",\n      \"offset\",\n      \"radius\",\n    ];\n\n    /*\n     * for (a in attributes) identifiers.push(a);\n     */\n\n    for (i = 0; i < identifiers.length; i++) {\n      var attributeVar = identifiers[i];\n      program.attributes[attributeVar] = this._gl.getAttribLocation(\n        program,\n        attributeVar\n      );\n    }\n\n    program.id = this._programs_counter++;\n    this._programs.push({\n      program: program,\n      code: code,\n      usedTimes: 1,\n    });\n    this.info.memory.programs = this._programs.length;\n\n    return program;\n  }\n\n  private setProgram(camera, lights, fog, material, object, renderer) {\n    if (material.needsUpdate) {\n      if (material.program) this.deallocateMaterial(material);\n\n      this.initMaterial(material, lights, fog, object);\n      material.needsUpdate = false;\n    }\n    if (material.program == null) return null;\n\n    var refreshMaterial = false;\n\n    // p_uniforms: uniformVarName => uniformLocation\n    // m_uniforms: uniformVarName => uniformJsVal\n    var program = material.program,\n      p_uniforms = program.uniforms,\n      m_uniforms = material.uniforms;\n\n    if (program != this._currentProgram) {\n      this._gl.useProgram(program);\n      this._currentProgram = program;\n\n      refreshMaterial = true;\n    }\n\n    if (material.id != this._currentMaterialId) {\n      this._currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n\n    if (camera != this._currentCamera) {\n      this._currentCamera = camera;\n      refreshMaterial = true;\n    }\n\n    if (p_uniforms.projectionMatrix) {\n      this._gl.uniformMatrix4fv(\n        p_uniforms.projectionMatrix,\n        false,\n        camera.projectionMatrix.elements\n      );\n    }\n\n    if (p_uniforms.modelViewMatrix) {\n      this._gl.uniformMatrix4fv(\n        p_uniforms.modelViewMatrix,\n        false,\n        object._modelViewMatrix.elements\n      );\n    }\n\n    if (p_uniforms.normalMatrix) {\n      this._gl.uniformMatrix3fv(\n        p_uniforms.normalMatrix,\n        false,\n        object._normalMatrix.elements\n      );\n    }\n\n    if (p_uniforms.projinv) {\n      this._projInverse.getInverse(camera.projectionMatrix);\n      this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._projInverse.elements);\n    }\n\n    if (p_uniforms.viewMatrix) {\n      this._gl.uniformMatrix4fv(\n        p_uniforms.viewMatrix,\n        false,\n        camera.matrixWorldInverse.elements\n      );\n    }\n\n    if (p_uniforms.vWidth) {\n      this._gl.uniform1f(p_uniforms.vWidth, this._viewportWidth);\n    }\n    if (p_uniforms.vHeight) {\n      this._gl.uniform1f(p_uniforms.vHeight, this._viewportHeight);\n    }\n    // Send projection matrix to uniform variable in shader\n    if (refreshMaterial) {\n      // Load projection, model-view matrices for perspective\n\n      // Set up correct fog uniform vals\n      m_uniforms.fogColor.value = fog.color;\n      m_uniforms.fogNear.value = fog.near;\n      m_uniforms.fogFar.value = fog.far;\n\n      // Set up lights for lambert shader\n      if (\n        material.shaderID.startsWith(\"lambert\") ||\n        material.shaderID === \"instanced\" ||\n        material.shaderID.endsWith(\"imposter\")\n      ) {\n        // load view and normal matrices for directional and object\n        // lighting\n\n        if (this._lightsNeedUpdate) {\n          this.setupLights(program, lights);\n          this._lightsNeedUpdate = false;\n        }\n\n        // Set up correct light uniform var vals\n        m_uniforms.directionalLightColor.value = this._lights.directional.colors;\n        m_uniforms.directionalLightDirection.value =\n          this._lights.directional.positions;\n      } else if (material.shaderID.endsWith(\"outline\")) {\n        m_uniforms.outlineColor.value = material.outlineColor;\n        m_uniforms.outlineWidth.value = material.outlineWidth;\n        m_uniforms.outlinePushback.value = material.outlinePushback;\n        m_uniforms.outlineMaxPixels.value = material.outlineMaxPixels * this.devicePixelRatio;\n      } else if (material.shaderID === \"volumetric\") {\n        //need a matrix that maps back from model coordinates to texture coordinates\n        //  textureMat*modelInv*position\n        object._modelViewMatrix.getScale(this._direction); //scale factor of conversion\n        this._worldInverse.getInverse(object._modelViewMatrix);\n        this._projInverse.getInverse(camera.projectionMatrix);\n        this._textureMatrix.multiplyMatrices(\n          object.material.texmatrix,\n          this._worldInverse\n        );\n        this._gl.uniformMatrix4fv(\n          p_uniforms.textmat,\n          false,\n          this._textureMatrix.elements\n        );\n        this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._projInverse.elements);\n\n        //  need the resolution (step size of ray in viewer coordinates)\n        let invscale = Math.min(\n          Math.min(this._direction.x, this._direction.y),\n          this._direction.z\n        );\n        m_uniforms.step.value = object.material.unit * invscale;\n        m_uniforms.maxdepth.value = object.material.maxdepth * invscale;\n        m_uniforms.transfermax.value = object.material.transfermax;\n        m_uniforms.transfermin.value = object.material.transfermin;\n        m_uniforms.subsamples.value = object.material.subsamples;\n\n        renderer.setTexture(object.material.transferfn, 4, false);\n        renderer.setTexture(object.material.map, 3, true);\n        //depth texture from the renderbuffer, for volumetric integration with surfaces\n        this._gl.activeTexture(this._gl.TEXTURE5);\n        this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);\n      }\n\n      // opacity, diffuse, emissive, etc\n      m_uniforms.opacity.value = material.opacity;\n\n      // Load any other material specific uniform variables to gl shaders\n      this.loadMaterialUniforms(p_uniforms, m_uniforms);\n    }\n\n    if (m_uniforms.shading) {\n      if (m_uniforms.shading.value == 3) {\n        this._gl.activeTexture(this._gl.TEXTURE0 + this.SHADE_TEXTURE);\n        this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture);\n      } else {\n        console.error(\"Invalid shading textures.\");\n      }\n    }\n\n    return program;\n  }\n\n  private loadMaterialUniforms(p_uniforms, m_uniforms) {\n    var uniformVar, type, uniformVal, uniformLoc;\n\n    for (uniformVar in m_uniforms) {\n      if (!p_uniforms[uniformVar]) continue;\n\n      type = m_uniforms[uniformVar].type;\n      uniformVal = m_uniforms[uniformVar].value;\n      uniformLoc = p_uniforms[uniformVar];\n\n      // single float\n      if (type === \"f\") this._gl.uniform1f(uniformLoc, uniformVal);\n      // single integer\n      else if (type === \"i\") this._gl.uniform1i(uniformLoc, uniformVal);\n      // array of floats\n      else if (type === \"fv\") this._gl.uniform3fv(uniformLoc, uniformVal);\n      // color - r,g,b floats\n      else if (type === \"c\")\n        this._gl.uniform3f(uniformLoc, uniformVal.r, uniformVal.g, uniformVal.b);\n      else if (type === \"f4\")\n        this._gl.uniform4f(\n          uniformLoc,\n          uniformVal[0],\n          uniformVal[1],\n          uniformVal[2],\n          uniformVal[3]\n        );\n    }\n  }\n\n  // Objects adding\n\n  private addObject(object, scene) {\n    var g, gl, geometry, geometryGroup;\n\n    if (!object.__webglInit) {\n      object.__webglInit = true;\n\n      object._modelViewMatrix = new Matrix4();\n      object._normalMatrix = new Matrix3();\n\n      if (\n        object.geometry !== undefined &&\n        object.geometry.__webglInit === undefined\n      ) {\n        object.geometry.__webglInit = true;\n        object.geometry.addEventListener(\"dispose\", this.onGeometryDispose.bind(this));\n      }\n\n      if (object instanceof Mesh || object instanceof Line) {\n        geometry = object.geometry;\n\n        for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n          geometryGroup = geometry.geometryGroups[g];\n\n          geometryGroup.id = this._geometryGroupCounter++;\n\n          // initialise VBO on the first access\n\n          if (!geometryGroup.__webglVertexBuffer) {\n            if (object instanceof Mesh) {\n              this.createMeshBuffers(geometryGroup);\n              geometry.elementsNeedUpdate = true;\n              geometry.normalsNeedUpdate = true;\n            } else if (object instanceof Line) this.createLineBuffers(geometryGroup);\n\n            geometry.verticesNeedUpdate = true;\n            geometry.colorsNeedUpdate = true;\n          }\n        }\n      }\n    }\n\n    if (!object.__webglActive) {\n      if (object instanceof Mesh || object instanceof Line) {\n        geometry = object.geometry;\n\n        for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n          geometryGroup = geometry.geometryGroups[g];\n\n          this.addBuffer(scene.__webglObjects, geometryGroup, object);\n        }\n      }\n\n      // Sprite\n      else if (object instanceof Sprite) scene.__webglSprites.push(object);\n\n      object.__webglActive = true;\n    }\n  }\n\n  private updateObject(object) {\n    var geometry = object.geometry,\n      geometryGroup;\n\n    if (object instanceof Mesh || object instanceof Line) {\n      for (var g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n        geometryGroup = geometry.geometryGroups[g];\n\n        if (\n          geometry.verticesNeedUpdate ||\n          geometry.elementsNeedUpdate ||\n          geometry.colorsNeedUpdate ||\n          geometry.normalsNeedUpdate\n        ) {\n          this.setBuffers(geometryGroup, this._gl.STATIC_DRAW);\n        }\n      }\n\n      geometry.verticesNeedUpdate = false;\n      geometry.elementsNeedUpdate = false;\n      geometry.normalsNeedUpdate = false;\n      geometry.colorsNeedUpdate = false;\n\n      geometry.buffersNeedUpdate = false;\n    }\n  }\n\n  private removeObject(object, scene) {\n    if (object instanceof Mesh || object instanceof Line)\n      this.removeInstances(scene.__webglObjects, object);\n    else if (object instanceof Sprite)\n      this.removeInstancesDirect(scene.__webglSprites, object);\n\n    object.__webglActive = false;\n  }\n\n  private removeInstances(objList, object) {\n    for (var o = objList.length - 1; o >= 0; --o) {\n      if (objList[o].object === object) objList.splice(o, 1);\n    }\n  }\n\n  private removeInstancesDirect(objList, object) {\n    for (var o = objList.length - 1; o >= 0; --o) {\n      if (objList[o] === object) objList.splice(o, 1);\n    }\n  }\n\n  private unrollBufferMaterial(globject) {\n    var object = globject.object;\n    var material = object.material;\n\n    if (material.volumetric) {\n      globject.opaque = null;\n      globject.transparent = null;\n      globject.volumetric = material;\n    } else if (material.transparent) {\n      globject.opaque = null;\n      globject.volumetric = null;\n      globject.transparent = material;\n      if (!material.wireframe) {\n        let blankMaterial = material.clone();\n        blankMaterial.opacity = 0.0;\n        globject.transparentDepth = blankMaterial;\n      }\n    } else {\n      globject.opaque = material;\n      globject.transparent = null;\n      globject.volumetric = null;\n      if (!material.wireframe) {\n        let blankMaterial = material.clone();\n        blankMaterial.opacity = 0.0;\n        globject.opaqueDepth = blankMaterial;\n      }\n      if (material.hasAO) {\n        globject.hasAO = true;\n      }\n      if (this._AOEnabled || globject.hasAO) {\n        globject.opaqueShaded = material.clone();\n        globject.opaqueShaded.shaded = true;\n      }\n\n    }\n  }\n\n  private setBuffers(geometryGroup, hint) {\n    var vertexArray = geometryGroup.vertexArray;\n    var colorArray = geometryGroup.colorArray;\n\n    // offset buffers\n    if (geometryGroup.__webglOffsetBuffer !== undefined) {\n      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);\n    } else {\n      //normal, non-instanced case\n      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);\n    }\n    // color buffers\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n    this._gl.bufferData(this._gl.ARRAY_BUFFER, colorArray, hint);\n\n    // normal buffers\n    if (\n      geometryGroup.normalArray &&\n      geometryGroup.__webglNormalBuffer !== undefined\n    ) {\n      var normalArray = geometryGroup.normalArray;\n      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, normalArray, hint);\n    }\n\n    // radius buffers\n    if (\n      geometryGroup.radiusArray &&\n      geometryGroup.__webglRadiusBuffer !== undefined\n    ) {\n      this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, geometryGroup.radiusArray, hint);\n    }\n\n    // face (index) buffers\n    if (\n      geometryGroup.faceArray &&\n      geometryGroup.__webglFaceBuffer !== undefined\n    ) {\n      var faceArray = geometryGroup.faceArray;\n      this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n      this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);\n    }\n\n    // line (index) buffers (for wireframe)\n    if (\n      geometryGroup.lineArray &&\n      geometryGroup.__webglLineBuffer !== undefined\n    ) {\n      var lineArray = geometryGroup.lineArray;\n      this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);\n      this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);\n    }\n  }\n\n  // Creates appropriate gl buffers for geometry chunk\n  // TODO: do we need line buffer for mesh objects?\n  // Also, can we integrate this with createLineBuffers?\n  private createMeshBuffers(geometryGroup) {\n    if (geometryGroup.radiusArray) {\n      geometryGroup.__webglRadiusBuffer = this._gl.createBuffer();\n    }\n    if (geometryGroup.useOffset) {\n      geometryGroup.__webglOffsetBuffer = this._gl.createBuffer();\n    }\n    geometryGroup.__webglVertexBuffer = this._gl.createBuffer();\n    geometryGroup.__webglNormalBuffer = this._gl.createBuffer();\n    geometryGroup.__webglColorBuffer = this._gl.createBuffer();\n\n    geometryGroup.__webglFaceBuffer = this._gl.createBuffer();\n    geometryGroup.__webglLineBuffer = this._gl.createBuffer();\n\n    this.info.memory.geometries++;\n  }\n\n  private createLineBuffers(geometry) {\n    geometry.__webglVertexBuffer = this._gl.createBuffer();\n    geometry.__webglColorBuffer = this._gl.createBuffer();\n\n    this.info.memory.geometries++;\n  }\n\n  private addBuffer(objlist, buffer, object) {\n    objlist.push({\n      buffer: buffer,\n      object: object,\n      opaque: null,\n      transparent: null,\n    });\n  }\n\n  private setupMatrices(object, camera) {\n    object._modelViewMatrix.multiplyMatrices(\n      camera.matrixWorldInverse,\n      object.matrixWorld\n    );\n\n    object._normalMatrix.getInverse(object._modelViewMatrix);\n    object._normalMatrix.transpose();\n  }\n\n  // Fallback filters for non-power-of-2 textures\n  private filterFallback(filter) {\n    return this._gl.LINEAR;\n  }\n\n  private setTextureParameters(textureType, texture) {\n    if (textureType == this._gl.TEXTURE_2D) {\n      this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(\n        textureType,\n        this._gl.TEXTURE_MAG_FILTER,\n        this.filterFallback(texture.magFilter)\n      );\n      this._gl.texParameteri(\n        textureType,\n        this._gl.TEXTURE_MIN_FILTER,\n        this.filterFallback(texture.minFilter)\n      );\n    } else {\n      // 3Dtexture\n      this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n      this._gl.texParameteri(textureType, (this._gl as WebGL2RenderingContext).TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE);\n\n      if (this._extColorBufferFloat && this._extFloatLinear) {\n        //linear interpolation isn't supported by default (despite being the default??)\n        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n      } else {\n        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n      }\n    }\n  }\n\n  // Map constants to WebGL constants\n\n  private paramToGL(p) {\n    if (p === UnsignedByteType) return this._gl.UNSIGNED_BYTE;\n    if (p === RGBAFormat) return this._gl.RGBA;\n    if (p === NearestFilter) return this._gl.NEAREST;\n\n    return 0;\n  }\n\n  private setupLights(program, lights) {\n    var l,\n      ll,\n      light,\n      r = 0,\n      g = 0,\n      b = 0,\n      color,\n      intensity,\n      zlights = this._lights,\n      dirColors = zlights.directional.colors,\n      dirPositions = zlights.directional.positions,\n      dirLength = 0,\n      dirOffset = 0;\n\n    for (l = 0, ll = lights.length; l < ll; l++) {\n      light = lights[l];\n\n      color = light.color;\n      intensity = light.intensity;\n\n      if (light instanceof Light) {\n\n        this._direction.getPositionFromMatrix(light.matrixWorld);\n        this._vector3.getPositionFromMatrix(light.target.matrixWorld);\n        this._direction.sub(this._vector3);\n        this._direction.normalize();\n\n        if (this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)\n          continue;\n\n        dirPositions[dirOffset] = this._direction.x;\n        dirPositions[dirOffset + 1] = this._direction.y;\n        dirPositions[dirOffset + 2] = this._direction.z;\n\n        dirColors[dirOffset] = color.r * intensity;\n        dirColors[dirOffset + 1] = color.g * intensity;\n        dirColors[dirOffset + 2] = color.b * intensity;\n\n        dirOffset += 3;\n\n        dirLength++;\n      }\n    }\n\n    zlights.ambient[0] = r;\n    zlights.ambient[1] = g;\n    zlights.ambient[2] = b;\n    zlights.directional.length = dirLength;\n  }\n\n  private initGL() {\n\n    try {\n      //safari and firefox do not seem to respect alpha in transferFromImageBitmap\n      //and so can't use offscreen canvas with grids\n      //I tried using drawImage with a 2d canvas and it worked but was noticeably laggy\n      if (OffscreenCanvas && !(this.rows != undefined &&\n        this.cols != undefined && this.row != undefined &&\n        this.col != undefined)) {\n        if (_gl_singleton == null || _gl_singleton.isContextLost()) {\n          _offscreen_singleton = new OffscreenCanvas(this._canvas.width, this._canvas.height);\n          _gl_singleton = _offscreen_singleton.getContext(\"webgl2\", {\n            alpha: true,\n            premultipliedAlpha: this._premultipliedAlpha,\n            antialias: this._antialias,\n            preserveDrawingBuffer: this._preserveDrawingBuffer,\n          }) as WebGL2RenderingContext;\n        }\n        this._offscreen = _offscreen_singleton;\n        this._gl = _gl_singleton;\n        this._bitmap = this._canvas.getContext(\"bitmaprenderer\", {\n          alpha: true\n        });\n\n      } else {\n        if (\n          !(this._gl = this._canvas.getContext(\"webgl2\", {\n            alpha: this._alpha,\n            premultipliedAlpha: this._premultipliedAlpha,\n            antialias: this._antialias,\n            preserveDrawingBuffer: this._preserveDrawingBuffer,\n          }))\n        ) {\n          if (\n            !(this._gl = this._canvas.getContext(\"experimental-webgl\", {\n              alpha: this._alpha,\n              premultipliedAlpha: this._premultipliedAlpha,\n              antialias: this._antialias,\n              preserveDrawingBuffer: this._preserveDrawingBuffer,\n            }))\n          ) {\n            if (\n              !(this._gl = this._canvas.getContext(\"webgl\", {\n                alpha: this._alpha,\n                premultipliedAlpha: this._premultipliedAlpha,\n                antialias: this._antialias,\n                preserveDrawingBuffer: this._preserveDrawingBuffer,\n              }))\n            ) {\n              throw \"Error creating WebGL context.\";\n            }\n          }\n        }\n      }\n      var vers = this._gl.getParameter(this._gl.VERSION);\n      this._webglversion = parseInt(vers[6]);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  private isWebGL1() {\n    return this._webglversion == 1;\n  }\n\n  private setDefaultGLState() {\n    this._gl.clearDepth(1);\n    this._gl.clearStencil(0);\n\n    this._gl.enable(this._gl.DEPTH_TEST);\n    this._gl.depthFunc(this._gl.LEQUAL);\n\n    this._gl.frontFace(this._gl.CCW);\n    this._gl.cullFace(this._gl.BACK);\n    this._gl.enable(this._gl.CULL_FACE);\n\n    this._gl.enable(this._gl.BLEND);\n    this._gl.blendEquation(this._gl.FUNC_ADD);\n    this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);\n\n    this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n  }\n\n  // rendering\n  private renderObjects(\n    renderList,\n    reverse,\n    materialType,\n    camera,\n    lights,\n    fog,\n    useBlending\n  ) {\n    var webglObject, object, buffer, material, start, end, delta;\n\n    // Forward or backward render\n\n\n    if (reverse) {\n      start = renderList.length - 1;\n      end = -1;\n      delta = -1;\n    } else {\n      start = 0;\n      end = renderList.length;\n      delta = 1;\n    }\n\n    for (var i = start; i !== end; i += delta) {\n      webglObject = renderList[i];\n\n      if (webglObject.render) {\n        object = webglObject.object;\n        buffer = webglObject.buffer;\n        material = webglObject[materialType];\n\n        //convert to AO if needed\n        if ((webglObject.hasAO || this._AOEnabled) &&\n          webglObject[materialType + \"Shaded\"]) {\n          material = webglObject[materialType + \"Shaded\"];\n        }\n        if (!material) continue;\n\n        this.setBlending(useBlending);\n\n        this.setDepthTest(material.depthTest);\n        this.setDepthWrite(material.depthWrite);\n        this.setPolygonOffset(\n          material.polygonOffset,\n          material.polygonOffsetFactor,\n          material.polygonOffsetUnits\n        );\n\n        var reflected = object._modelViewMatrix.isReflected();\n\n        this.setMaterialFaces(material, reflected);\n\n        this.renderBuffer(camera, lights, fog, material, buffer, object);\n\n        if ((this._outlineEnabled || material.outline) &&\n          !material.wireframe &&\n          material.shaderID !== \"basic\" &&\n          material.opacity !== 0.0) {\n          let outmat: any = this._outlineMaterial;\n          if (material.shaderID == \"sphereimposter\") {\n            outmat = this._outlineSphereImposterMaterial;\n          } else if (material.shaderID == \"stickimposter\") {\n            outmat = this._outlineStickImposterMaterial;\n          }\n\n          this.renderBuffer(\n            camera,\n            lights,\n            fog,\n            outmat,\n            buffer,\n            object\n          );\n        }\n      }\n    }\n  }\n\n  private renderSprites(scene, camera, inFront) {\n    // Reset state once regardless\n    // This should also fix cartoon render bug (after transparent surface\n    // render)\n\n    this._currentGeometryGroupHash = -1;\n    this._currentProgram = null;\n    this._currentCamera = null;\n    this._oldDepthWrite = -1;\n    this._oldDepthTest = -1;\n    this._oldDoubleSided = -1;\n    this._currentMaterialId = -1;\n    this._oldFlipSided = -1;\n    this._lightsNeedUpdate = true;\n\n    this.sprites.render(scene, camera, this._currentWidth, this._currentHeight, inFront);\n\n    // Reset state a\n    this._currentGeometryGroupHash = -1;\n    this._currentProgram = null;\n    this._currentCamera = null;\n    this._oldDepthWrite = -1;\n    this._oldDepthTest = -1;\n    this._oldDoubleSided = -1;\n    this._currentMaterialId = -1;\n    this._oldFlipSided = -1;\n  }\n}\n", "import { Fog } from \"./Fog\";\nimport type { Camera } from \"./Camera\";\nimport { Scene } from \"./core\";\n//Render plugins go here\nimport { Sprite } from \"./objects/Sprite\";\nimport { ShaderLib } from \"./shaders/index\";\nimport { Shader } from './shaders/ShaderType';\n\nexport type Nullable<T> = T | null;\nexport type NullableWebGLUniformLocation = Nullable<WebGLUniformLocation>;\n\nexport type UniformsValueType = {\n  uvOffset: NullableWebGLUniformLocation;\n  uvScale: NullableWebGLUniformLocation;\n  rotation: NullableWebGLUniformLocation;\n  scale: NullableWebGLUniformLocation;\n  alignment: NullableWebGLUniformLocation;\n  color: NullableWebGLUniformLocation;\n  map: NullableWebGLUniformLocation;\n  opacity: NullableWebGLUniformLocation;\n  useScreenCoordinates: NullableWebGLUniformLocation;\n  screenPosition: NullableWebGLUniformLocation;\n  modelViewMatrix: NullableWebGLUniformLocation;\n  projectionMatrix: NullableWebGLUniformLocation;\n  fogNear: NullableWebGLUniformLocation;\n  fogFar: NullableWebGLUniformLocation;\n  fogColor: NullableWebGLUniformLocation;\n  alphaTest: NullableWebGLUniformLocation;\n};\n\nexport type SpriteMeta = {\n  vertices: Nullable<Float32Array>;\n  faces: Nullable<Uint16Array>;\n  vertexBuffer: Nullable<WebGLBuffer>;\n  elementBuffer: Nullable<WebGLBuffer>;\n  program: Nullable<WebGLProgram>;\n  attributes: Record<string, number>;\n  uniforms: Nullable<UniformsValueType>;\n};\n\n/*\n * Sprite render plugin\n */\nexport class SpritePlugin {\n  private gl?: WebGLRenderingContext;\n  private renderer: any;\n  private precision?: number;\n  private sprite: SpriteMeta = {\n    vertices: null,\n    faces: null,\n    vertexBuffer: null,\n    elementBuffer: null,\n    program: null,\n    attributes: {},\n    uniforms: null,\n  };\n  sprites?: Sprite[];\n\n  init(renderer: any) {\n    this.gl = renderer.context as WebGLRenderingContext;\n    this.renderer = renderer;\n\n    this.precision = renderer.getPrecision();\n\n    this.sprite.vertices = new Float32Array(8 + 8);\n    this.sprite.faces = new Uint16Array(6);\n\n    var i = 0;\n\n    this.sprite.vertices[i++] = -1;\n    this.sprite.vertices[i++] = -1; // vertex 0\n    this.sprite.vertices[i++] = 0;\n    this.sprite.vertices[i++] = 0; // uv 0\n\n    this.sprite.vertices[i++] = 1;\n    this.sprite.vertices[i++] = -1; // vertex 1\n    this.sprite.vertices[i++] = 1;\n    this.sprite.vertices[i++] = 0; // uv 1\n\n    this.sprite.vertices[i++] = 1;\n    this.sprite.vertices[i++] = 1; // vertex 2\n    this.sprite.vertices[i++] = 1;\n    this.sprite.vertices[i++] = 1; // uv 2\n\n    this.sprite.vertices[i++] = -1;\n    this.sprite.vertices[i++] = 1; // vertex 3\n    this.sprite.vertices[i++] = 0;\n    this.sprite.vertices[i++] = 1; // uv 3\n\n    i = 0;\n\n    this.sprite.faces[i++] = 0;\n    this.sprite.faces[i++] = 1;\n    this.sprite.faces[i++] = 2;\n    this.sprite.faces[i++] = 0;\n    this.sprite.faces[i++] = 2;\n    this.sprite.faces[i++] = 3;\n\n    this.sprite.vertexBuffer = this.gl.createBuffer();\n    this.sprite.elementBuffer = this.gl.createBuffer();\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      this.sprite.vertices,\n      this.gl.STATIC_DRAW\n    );\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);\n    this.gl.bufferData(\n      this.gl.ELEMENT_ARRAY_BUFFER,\n      this.sprite.faces,\n      this.gl.STATIC_DRAW\n    );\n\n    this.sprite.program = this.createProgram(\n      ShaderLib.sprite,\n      this.precision || 1 /** added default to single precision */\n    );\n\n    this.sprite.attributes = {};\n    const uniforms = {} as Partial<UniformsValueType>;\n\n    this.sprite.attributes.position = this.gl.getAttribLocation(\n      this.sprite.program,\n      \"position\"\n    );\n    this.sprite.attributes.uv = this.gl.getAttribLocation(\n      this.sprite.program,\n      \"uv\"\n    );\n\n    uniforms.uvOffset = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"uvOffset\"\n    );\n    uniforms.uvScale = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"uvScale\"\n    );\n    uniforms.rotation = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"rotation\"\n    );\n    uniforms.scale = this.gl.getUniformLocation(this.sprite.program, \"scale\");\n    uniforms.alignment = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"alignment\"\n    );\n    uniforms.color = this.gl.getUniformLocation(this.sprite.program, \"color\");\n    uniforms.map = this.gl.getUniformLocation(this.sprite.program, \"map\");\n    uniforms.opacity = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"opacity\"\n    );\n    uniforms.useScreenCoordinates = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"useScreenCoordinates\"\n    );\n    uniforms.screenPosition = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"screenPosition\"\n    );\n    uniforms.modelViewMatrix = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"modelViewMatrix\"\n    );\n    uniforms.projectionMatrix = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"projectionMatrix\"\n    );\n    uniforms.fogNear = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"fogNear\"\n    );\n    uniforms.fogFar = this.gl.getUniformLocation(this.sprite.program, \"fogFar\");\n    uniforms.fogColor = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"fogColor\"\n    );\n    uniforms.alphaTest = this.gl.getUniformLocation(\n      this.sprite.program,\n      \"alphaTest\"\n    );\n\n    this.sprite.uniforms = uniforms as UniformsValueType;\n  }\n\n  render(\n    scene: Scene,\n    camera: Camera,\n    viewportWidth: number,\n    viewportHeight: number,\n    inFront?: boolean\n  ) {\n    if (!this.gl) throw new Error(\"WebGLRenderer not initialized\");\n    let sprites: unknown[] = [];\n    scene?.__webglSprites?.forEach((sprite) => {\n      //depthTest is false for inFront labels\n      if (inFront && sprite.material.depthTest == false) {\n        sprites.push(sprite);\n      } else if (!inFront && sprite.material.depthTest) {\n        sprites.push(sprite);\n      }      \n    });\n\n    let nSprites = sprites.length;\n\n    if (!nSprites) return;\n\n    const attributes = this.sprite.attributes;\n    const uniforms = this.sprite.uniforms;\n\n    if (!uniforms) throw new Error(\"Uniforms not defined\");\n\n    var halfViewportWidth = viewportWidth * 0.5,\n      halfViewportHeight = viewportHeight * 0.5;\n\n    // setup gl\n\n    this.gl.useProgram(this.sprite.program);\n\n    this.gl.enableVertexAttribArray(attributes.position);\n    this.gl.enableVertexAttribArray(attributes.uv);\n\n    this.gl.disable(this.gl.CULL_FACE);\n    this.gl.enable(this.gl.BLEND);\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);\n    this.gl.vertexAttribPointer(\n      attributes.position,\n      2,\n      this.gl.FLOAT,\n      false,\n      2 * 8,\n      0\n    );\n    this.gl.vertexAttribPointer(\n      attributes.uv,\n      2,\n      this.gl.FLOAT,\n      false,\n      2 * 8,\n      8\n    );\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);\n\n    this.gl.uniformMatrix4fv(\n      uniforms.projectionMatrix,\n      false,\n      camera.projectionMatrix.elements\n    );\n\n    this.gl.activeTexture(this.gl.TEXTURE0);\n    this.gl.uniform1i(uniforms.map, 0);\n\n    var fog = scene.fog as Fog;\n\n    if (fog) {\n      this.gl.uniform3f(\n        uniforms.fogColor,\n        fog.color.r,\n        fog.color.g,\n        fog.color.b\n      );\n\n      this.gl.uniform1f(uniforms.fogNear, fog.near);\n      this.gl.uniform1f(uniforms.fogFar, fog.far);\n    } else {\n      this.gl.uniform1f(uniforms.fogNear, 0);\n      this.gl.uniform1f(uniforms.fogFar, 0);\n    }\n\n    // update positions and sort\n\n    var i;\n    let sprite: Sprite;\n    let material;\n    let size;\n    let scale: number[] = [];\n\n    for (i = 0; i < nSprites; i++) {\n      sprite = sprites[i] as Sprite;\n      material = sprite.material;\n      if (!material) continue;\n      if (material.depthTest == false && !inFront) continue;\n\n      if (!sprite.visible || material.opacity === 0) continue;\n\n      if (!material.useScreenCoordinates) {\n        sprite._modelViewMatrix.multiplyMatrices(\n          camera.matrixWorldInverse,\n          sprite.matrixWorld\n        );\n        sprite.z = -sprite._modelViewMatrix.elements[14];\n      } else {\n        sprite.z = -sprite.position.z;\n      }\n    }\n\n    sprites.sort(painterSortStable);\n\n    // render all sprites\n    for (i = 0; i < nSprites; i++) {\n      sprite = sprites[i] as Sprite;\n      material = sprite.material;\n      if (!material) continue;\n      if (!sprite.visible || material.opacity === 0) continue;\n\n      if (material.map && material.map.image && material.map.image.width) {\n        this.gl.uniform1f(uniforms?.alphaTest || null, material.alphaTest);\n        var w = material.map.image.width;\n        var h = material.map.image.height;\n\n        scale[0] = (w * this.renderer.devicePixelRatio) / viewportWidth;\n        scale[1] = (h * this.renderer.devicePixelRatio) / viewportHeight;\n\n        if (material.useScreenCoordinates === true) {\n          this.gl.uniform1i(uniforms.useScreenCoordinates, 1);\n          this.gl.uniform3f(\n            uniforms.screenPosition,\n            (sprite.position.x * this.renderer.devicePixelRatio -\n              halfViewportWidth) /\n            halfViewportWidth,\n            (halfViewportHeight -\n              sprite.position.y * this.renderer.devicePixelRatio) /\n            halfViewportHeight,\n            Math.max(0, Math.min(1, sprite.position.z))\n          );\n        } else {\n          this.gl.uniform1i(uniforms.useScreenCoordinates, 0);\n          this.gl.uniformMatrix4fv(\n            uniforms.modelViewMatrix,\n            false,\n            sprite._modelViewMatrix.elements\n          );\n        }\n\n        size = 1 / (material.scaleByViewport ? viewportHeight : 1);\n\n        scale[0] *= size * sprite.scale.x;\n        scale[1] *= size * sprite.scale.y;\n\n        let alignx = material?.alignment?.x,\n          aligny = material?.alignment?.y;\n        if (material.screenOffset) {\n          //adjust alignment offset by screenOffset adjusted to sprite coords\n          alignx = (alignx || 0) + (2.0 * material.screenOffset.x) / w;\n          aligny = (aligny || 0) + (2.0 * material.screenOffset.y) / h;\n        }\n\n        this.gl.uniform2f(\n          uniforms.uvScale,\n          material?.uvScale?.x || 1,\n          material?.uvScale?.y || 1\n        );\n        this.gl.uniform2f(\n          uniforms.uvOffset,\n          material?.uvOffset?.x || 0,\n          material?.uvOffset?.y || 0\n        );\n        this.gl.uniform2f(uniforms.alignment, alignx || 0, aligny || 0);\n\n        this.gl.uniform1f(uniforms.opacity, material.opacity);\n        this.gl.uniform3f(\n          uniforms.color,\n          material?.color?.r || 0,\n          material?.color?.g || 0,\n          material?.color?.b || 0\n        );\n\n        this.gl.uniform1f(uniforms.rotation, sprite.rotation as number);\n        this.gl.uniform2fv(uniforms.scale, scale);\n\n        //this.renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n        this.renderer.setDepthTest(material.depthTest);\n        this.renderer.setDepthWrite(material.depthWrite);\n        this.renderer.setTexture(material.map, 0);\n\n        this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\n      }\n    }\n\n    // restore gl\n    this.gl.enable(this.gl.CULL_FACE);\n  }\n\n  private createProgram(shader: Shader, precision: number): WebGLProgram {\n    if (!this.gl) throw new Error(\"WebGL Rendering context not found\");\n    var program = this.gl.createProgram();\n\n    if (!program) throw new Error(\"Error creating webgl program\");\n\n    var fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    var vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n\n    if (!fragmentShader)\n      throw new Error(\n        \"Unable to create fragment shader SpritePlugin.createProgram\"\n      );\n    if (!vertexShader)\n      throw new Error(\n        \"Unable to create vertex shader SpritePlugin.createProgram\"\n      );\n\n    var prefix = \"precision \" + precision + \" float;\\n\";\n\n    this.gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);\n    this.gl.shaderSource(vertexShader, prefix + shader.vertexShader);\n\n    this.gl.compileShader(fragmentShader);\n    this.gl.compileShader(vertexShader);\n\n    if (\n      !this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS) ||\n      !this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)\n    ) {\n      throw new Error(`Error compiling shader: \n      ${this.gl.getShaderInfoLog(fragmentShader)} \n      ${this.gl.getShaderInfoLog(vertexShader)}`);\n    }\n\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.attachShader(program, vertexShader);\n\n    this.gl.linkProgram(program);\n\n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS))\n      console.error(\"Could not initialize shader\");\n\n    return program;\n  }\n}\nfunction painterSortStable(a: any, b: any): number {\n  if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return b.id - a.id;\n  }\n}\n", "export enum Coloring {\n  // colors\n  NoColors = 0,\n  FaceColors = 1,\n  VertexColors = 2,\n}", "export enum Shading {\n  // shading\n  NoShading = 0,\n  FlatShading = 1,\n  SmoothShading = 2,\n}", "// sides - not an enum for backwards compat\nexport const FrontSide = 0;\nexport const BackSide = 1;\nexport const DoubleSide = 2;", "//Alignment for Sprites\n\nimport { Vector2 } from \"../math\";\n\nexport const SpriteAlignment = {\n    topLeft: new Vector2(1, -1),\n    topCenter: new Vector2(0, -1),\n    topRight: new Vector2(-1, -1),\n    centerLeft: new Vector2(1, 0),\n    center: new Vector2(0, 0),\n    centerRight: new Vector2(-1, 0),\n    bottomLeft: new Vector2(1, 1),\n    bottomCenter: new Vector2(0, 1),\n    bottomRight: new Vector2(-1, 1)\n}\n", "// wrapping modes\nexport const ClampToEdgeWrapping = 1001;\n\n//Filters\nexport const LinearFilter = 1006;\nexport const NearestFilter = 1007;\nexport const LinearMipMapLinearFilter = 1008;\n\n//Data types\nexport const UnsignedByteType = 1009;\nexport const FloatType = 1010;\n\n//Pixel formats\nexport const RGBAFormat = 1021;\nexport const RFormat = 1022;\nexport const R32Format = 1023;", "//Texture constants\n//TODO: Which of these do I need (since I only use textures to display label sprites) ?\nexport enum TextureOperations {\n  MultiplyOperation = 0,\n  MixOperation = 1,\n  AddOperation = 2,\n}", "export * from \"./Coloring\";\nexport * from \"./Sides\";\nexport * from \"./Shading\";\nexport * from \"./SpriteAlignment\";\nexport * from \"./TextureConstants\";\nexport * from \"./TextureOperations\";\nexport * from \"./TextureConstants\";", "//Event Handling\nexport class EventDispatcher {\n  listeners = {} as Record<string, Array<(event: any) => void>>;\n\n  dispatchEvent(event: any) {\n    var listenerArray = this.listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      event.target = this;\n\n      for (var i = 0, l = listenerArray.length; i < l; i++)\n        listenerArray[i].call(this, event);\n    }\n  }\n\n  removeEventListener(type: string, listener?: (event: any) => void) {\n    if (!listener) {\n      this.listeners[type] = [];\n    } else {\n      var index = this.listeners[type].indexOf(listener);\n      if (index !== -1) this.listeners[type].splice(index, 1);\n    }\n  }\n\n  addEventListener(type: string, listener: (event: any) => void) {\n    if (this.listeners[type] === undefined) this.listeners[type] = [];\n\n    if (this.listeners[type].indexOf(listener) === -1)\n      this.listeners[type].push(listener);\n  }\n}\n", "import type { Material } from './../materials/Material';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial';\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport { Vector3 } from \"../math\";\nimport { CC, Color } from \"../../colors\";\nimport { AtomSpec } from 'specs';\nconst BUFFERSIZE = 65535; //limited to 16bit indices\nexport class GeometryGroup {\n  id: number;\n  vertexArray: Float32Array | null = null;\n  colorArray: Float32Array | null = null;\n  normalArray: Float32Array | null = null;\n  radiusArray: Float32Array | null = null;\n  faceArray: Uint16Array | null = null;\n  lineArray: Uint16Array | null = null;\n  atomArray: Array<AtomSpec> = Array<AtomSpec>();\n  vertices: number = 0;\n  faceidx: number = 0;\n  lineidx: number = 0;\n  __inittedArrays = false;\n  useOffset: unknown;\n\n  constructor(id = 0) {\n    this.id = id;\n  }\n\n  public setColor(color: Color | number): void {\n    //apply constant color\n    var v = this.vertexArray;\n    var c = this.colorArray;\n    if (!v) throw new Error(\"vertex array not initialized\");\n    if (!c) throw new Error(\"color array not initialized\");\n\n    let col = CC.color(color);\n    for (var i = 0; i < v.length; i += 3) {\n      c[i] = col.r;\n      c[i + 1] = col.g;\n      c[i + 2] = col.b;\n    }\n  }\n\n  setColors(setcolor: (x: number, y: number, z: number) => Color | number): void {\n    //apply a function that takes the vertex coordinate and returns a color\n    var v = this.vertexArray;\n    var c = this.colorArray;\n    if (!v) throw new Error(\"vertex array not initialized\");\n    if (!c) throw new Error(\"color array not initialized\");\n    if (v.length != c.length) {\n      console.log(\"Cannot re-color geometry group due to mismatched lengths.\");\n      return;\n    }\n    for (var i = 0; i < v.length; i += 3) {\n      var col = setcolor(v[i], v[i + 1], v[i + 2]);\n      if (!(col instanceof Color)) {\n        col = CC.color(col);\n      }\n      c[i] = col.r;\n      c[i + 1] = col.g;\n      c[i + 2] = col.b;\n    }\n  }\n\n  getNumVertices(): number {\n    return this.vertices;\n  }\n\n  getVertices() {\n    return this.vertexArray;\n  }\n\n  getCentroid() {\n    if (!this.vertexArray) throw new Error(\"vertex array not initialized\");\n    var centroid = new Vector3();\n    var offset: number, x: number, y: number, z: number;\n\n    for (var i = 0; i < this.vertices; ++i) {\n      offset = i * 3;\n\n      x = this.vertexArray[offset];\n      y = this.vertexArray[offset + 1];\n      z = this.vertexArray[offset + 2];\n\n      centroid.x += x;\n      centroid.y += y;\n      centroid.z += z;\n    }\n\n    //divideScalar checks for 0 denom\n    centroid.divideScalar(this.vertices);\n\n    return centroid;\n  }\n\n  //setup normals - vertex and face array must exist\n  setNormals(): void {\n    var faces = this.faceArray;\n    var verts = this.vertexArray;\n    var norms = this.normalArray;\n\n    if (!this.vertices || !this.faceidx) return;\n    if (!faces) throw new Error(\"face array not initialized\");\n    if (!verts) throw new Error(\"vertex array not initialized\");\n    if (!norms) throw new Error(\"normal array not initialized\");\n\n    //vertex indices\n    var a: number,\n      b: number,\n      c: number,\n      //and actual vertices\n      vA: Vector3,\n      vB: Vector3,\n      vC: Vector3,\n      norm: { normalize: () => void; x: number; y: number; z: number; };\n\n    for (var i = 0; i < faces.length / 3; ++i) {\n      a = faces[i * 3] * 3;\n      b = faces[i * 3 + 1] * 3;\n      c = faces[i * 3 + 2] * 3;\n\n      vA = new Vector3(verts[a], verts[a + 1], verts[a + 2]);\n      vB = new Vector3(verts[b], verts[b + 1], verts[b + 2]);\n      vC = new Vector3(verts[c], verts[c + 1], verts[c + 2]);\n\n      vA.subVectors(vA, vB);\n      vC.subVectors(vC, vB);\n      vC.cross(vA);\n\n      //face normal\n      norm = vC;\n      norm.normalize();\n\n      norms[a] += norm.x;\n      norms[b] += norm.x;\n      norms[c] += norm.x;\n      norms[a + 1] += norm.y;\n      norms[b + 1] += norm.y;\n      norms[c + 1] += norm.y;\n      norms[a + 2] += norm.z;\n      norms[b + 2] += norm.z;\n      norms[c + 2] += norm.z;\n    }\n  }\n\n  /* sets line index array from face arr\n  Note - assumes all faces are triangles (i.e. there will\n  be an extra diagonal for four-sided faces - user should\n  specify linearr for custom shape generation to show wireframe squares\n  as rectangles rather than two triangles) */\n  setLineIndices() {\n    if (!this.faceidx) return;\n\n    if (\n      this.lineArray &&\n      this.lineArray.length == this.faceidx * 2 &&\n      this.lineidx == this.faceidx * 2\n    )\n      return; //assume already computed\n\n    var faceArr = this.faceArray,\n      lineArr = (this.lineArray = new Uint16Array(this.faceidx * 2));\n    this.lineidx = this.faceidx * 2;\n\n    if (!faceArr) throw new Error(\"face array not initialized\");\n\n    for (var i = 0; i < this.faceidx / 3; ++i) {\n      var faceoffset = i * 3;\n      var lineoffset = faceoffset * 2;\n      var a = faceArr[faceoffset],\n        b = faceArr[faceoffset + 1],\n        c = faceArr[faceoffset + 2];\n\n      lineArr[lineoffset] = a;\n      lineArr[lineoffset + 1] = b;\n      lineArr[lineoffset + 2] = a;\n      lineArr[lineoffset + 3] = c;\n      lineArr[lineoffset + 4] = b;\n      lineArr[lineoffset + 5] = c;\n    }\n  }\n\n  vrml(indent: string, material?: Material) {\n    var ret = \"\";\n    ret +=\n      indent +\n      \"Shape {\\n\" +\n      indent +\n      \" appearance Appearance {\\n\" +\n      indent +\n      \"  material Material {\\n\" +\n      indent +\n      \"   diffuseColor \" +\n      material?.color?.r +\n      \" \" +\n      material?.color?.g +\n      \" \" +\n      material?.color?.b +\n      \"\\n\";\n    if (material.wireframe && this.colorArray) {\n      //per vertex colors don't seem to work\n      let c = this.colorArray;\n      ret += indent + \"    emissiveColor \" + c[0] + \" \" + c[1] + \" \" + c[2] + \"\\n\";\n    }\n    if (material?.transparent) {\n      ret += indent + \"   transparency \" + (1.0 - material.opacity) + \"\\n\";\n    }\n    ret += indent + \"  }\\n\"; //material\n    ret += indent + \" }\\n\"; //appearance\n\n    var oldindent = indent;\n    indent += \" \"; //inshape\n    if (material instanceof LineBasicMaterial || material.wireframe) {\n      ret +=\n        indent +\n        \"geometry IndexedLineSet {\\n\" +\n        indent +\n        \" colorPerVertex TRUE\\n\" +\n        indent +\n        \" coord Coordinate {\\n\" +\n        indent +\n        \"  point [\\n\";\n      let x: string | number, y: string | number, z: string | number;\n      for (let i = 0; i < this.vertices; ++i) {\n        let offset = i * 3;\n        x = this.vertexArray?.[offset];\n        y = this.vertexArray?.[offset + 1];\n        z = this.vertexArray?.[offset + 2];\n        ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n      }\n      ret += indent + \"  ]\\n\";\n      ret += indent + \" }\\n\"; //end coordinate\n\n      if (this.colorArray && !material.wireframe) {\n        ret += indent + \" color Color {\\n\" + indent + \"  color [\\n\";\n        for (let i = 0; i < this.vertices; ++i) {\n          let offset = i * 3;\n          x = this.colorArray[offset];\n          y = this.colorArray[offset + 1];\n          z = this.colorArray[offset + 2];\n          ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n        }\n        ret += indent + \"  ]\\n\";\n        ret += indent + \" }\\n\"; //end color\n      }\n\n      ret += indent + \" coordIndex [\\n\";\n      if(material.wireframe && this.faceArray) {\n        for (let i = 0; i < this.faceidx; i += 3) {\n          x = this.faceArray?.[i];\n          y = this.faceArray?.[i + 1];\n          z = this.faceArray?.[i + 2];\n          ret += indent + \"  \" + x + \", \" + y + \", \" + z + \", -1,\\n\";\n        }\n      }  else {\n        for (let i = 0; i < this.vertices-1; i += 2) {\n          ret += indent + \"  \" + i + \", \" + (i + 1) + \", -1,\\n\";\n        }\n      }\n      ret += indent + \" ]\\n\";\n      ret += indent + \"}\\n\"; //geometry\n    } else {\n      //faces\n      ret +=\n        indent +\n        \"geometry IndexedFaceSet {\\n\" +\n        indent +\n        \" colorPerVertex TRUE\\n\" +\n        indent +\n        \" normalPerVertex TRUE\\n\" +\n        indent +\n        \" solid FALSE\\n\";\n\n      //vertices\n      ret += indent + \" coord Coordinate {\\n\" + indent + \"  point [\\n\";\n      let x: string | number, y: string | number, z: string | number;\n      for (let i = 0; i < this.vertices; ++i) {\n        let offset = i * 3;\n        x = this.vertexArray?.[offset];\n        y = this.vertexArray?.[offset + 1];\n        z = this.vertexArray?.[offset + 2];\n        ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n      }\n      ret += indent + \"  ]\\n\";\n      ret += indent + \" }\\n\"; //end coordinate\n\n      //normals\n      ret += indent + \" normal Normal {\\n\" + indent + \"  vector [\\n\";\n      for (let i = 0; i < this.vertices; ++i) {\n        let offset = i * 3;\n        x = this.normalArray?.[offset];\n        y = this.normalArray?.[offset + 1];\n        z = this.normalArray?.[offset + 2];\n        ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n      }\n      ret += indent + \"  ]\\n\";\n      ret += indent + \" }\\n\"; //end normal\n\n      //colors\n      if (this.colorArray) {\n        ret += indent + \" color Color {\\n\" + indent + \"  color [\\n\";\n        for (let i = 0; i < this.vertices; ++i) {\n          let offset = i * 3;\n          x = this.colorArray[offset];\n          y = this.colorArray[offset + 1];\n          z = this.colorArray[offset + 2];\n          ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n        }\n        ret += indent + \"  ]\\n\";\n        ret += indent + \" }\\n\"; //end color\n      }\n\n      //faces\n      ret += indent + \" coordIndex [\\n\";\n      for (let i = 0; i < this.faceidx; i += 3) {\n        x = this.faceArray?.[i];\n        y = this.faceArray?.[i + 1];\n        z = this.faceArray?.[i + 2];\n        ret += indent + \"  \" + x + \", \" + y + \", \" + z + \", -1,\\n\";\n      }\n      ret += indent + \" ]\\n\"; //end faces\n      ret += indent + \"}\\n\"; //geometry\n    }\n\n    ret += oldindent + \"}\"; //shape\n    return ret;\n  }\n\n  truncateArrayBuffers(mesh = true, reallocatemem = false) {\n\n    var vertexArr = this.vertexArray,\n      colorArr = this.colorArray,\n      normalArr = this.normalArray,\n      faceArr = this.faceArray,\n      lineArr = this.lineArray,\n      radiusArr = this.radiusArray;\n\n    //subarray to avoid copying and reallocating memory\n    this.vertexArray = vertexArr?.subarray(0, this.vertices * 3) || null;\n    this.colorArray = colorArr?.subarray(0, this.vertices * 3) || null;\n\n    if (mesh) {\n      this.normalArray = normalArr?.subarray(0, this.vertices * 3) || null;\n      this.faceArray = faceArr?.subarray(0, this.faceidx) || null;\n\n      if (this.lineidx > 0)\n        //not always set so reclaim memory\n        this.lineArray = lineArr?.subarray(0, this.lineidx) || null;\n      else this.lineArray = new Uint16Array(0);\n    } else {\n      this.normalArray = new Float32Array(0);\n      this.faceArray = new Uint16Array(0);\n      this.lineArray = new Uint16Array(0);\n    }\n    if (radiusArr) {\n      this.radiusArray = radiusArr.subarray(0, this.vertices);\n    }\n\n    if (reallocatemem) {\n      //actually copy smaller arrays to save memory\n      if (this.normalArray)\n        this.normalArray = new Float32Array(this.normalArray);\n      if (this.faceArray) this.faceArray = new Uint16Array(this.faceArray);\n      if (this.lineArray) this.lineArray = new Uint16Array(this.lineArray);\n      if (this.vertexArray)\n        this.vertexArray = new Float32Array(this.vertexArray);\n      if (this.colorArray) this.colorArray = new Float32Array(this.colorArray);\n      if (this.radiusArray)\n        this.radiusArray = new Float32Array(this.radiusArray);\n    }\n    this.__inittedArrays = true;\n  }\n}\n \nexport class Geometry extends EventDispatcher {\n  id: number;\n  name: string = \"\";\n  hasTangents: boolean =  false;\n  dynamic: boolean = true; // the intermediate typed arrays will be deleted when set to false;\n  radii: boolean;\n  mesh: boolean;\n  offset: boolean;\n  verticesNeedUpdate: boolean = false;\n  elementsNeedUpdate: boolean = false;\n  normalsNeedUpdate: boolean = false;\n  colorsNeedUpdate: boolean = false;\n  buffersNeedUpdate: boolean = false;\n  imposter: boolean = false;\n  instanced: boolean = false;\n  geometryGroups: GeometryGroup[] = [];\n  groups: number = 0;\n  sphereGeometry?: Geometry;\n  drawnCaps?: any;\n  \n  constructor(mesh = false, radii = false, offset = false) {\n    super();\n    this.id = GeometryIDCount++;\n    this.mesh = mesh; // Does this geometry represent a mesh (i.e. do we need Face/Line index buffers?)\n    this.radii = radii;\n    this.offset = offset; //offset buffer used for instancing\n  }\n\n  //Get geometry group to accomodate addVertices new vertices - create\n  // new group if necessary\n  updateGeoGroup(addVertices = 0): GeometryGroup {\n    var retGroup =\n      this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;\n\n    if (\n      !retGroup ||\n      retGroup.vertices + addVertices > (retGroup?.vertexArray?.length || 0) / 3\n    )\n      retGroup = this.addGeoGroup();\n\n    return retGroup;\n  }\n\n  //return comma separated list of IndexedFace (or Line) sets from geometry groups\n  vrml(indent: string, material?: Material): string {\n    var ret = \"\";\n    var len = this.geometryGroups.length;\n    for (var g = 0; g < len; g++) {\n      var geoGroup = this.geometryGroups[g];\n      ret += geoGroup.vrml(indent, material) + \",\\n\";\n    }\n    return ret;\n  }\n\n  addGeoGroup() {\n    var ret = new GeometryGroup(this.geometryGroups.length);\n    this.geometryGroups.push(ret);\n    this.groups = this.geometryGroups.length;\n  \n    ret.vertexArray = new Float32Array(BUFFERSIZE * 3);\n    ret.colorArray = new Float32Array(BUFFERSIZE * 3);\n  \n    //TODO: instantiating uint arrays according to max number of vertices\n    // is dangerous, since there exists the possibility that there will be\n    // more face or line indices than vertex points - but so far that doesn't\n    // seem to be the case for any of the renders\n    if (this.mesh) {\n      ret.normalArray = new Float32Array(BUFFERSIZE * 3);\n      ret.faceArray = new Uint16Array(BUFFERSIZE * 6);\n      ret.lineArray = new Uint16Array(BUFFERSIZE * 6);\n    }\n    if (this.radii) {\n      ret.radiusArray = new Float32Array(BUFFERSIZE);\n    }\n    ret.useOffset = this.offset;\n  \n    return ret;\n  }\n\n  setUpNormals(...args: Parameters<GeometryGroup[\"setNormals\"]>) {\n    for (var g = 0; g < this.groups; g++) {\n      var geoGroup = this.geometryGroups[g];\n\n      geoGroup.setNormals(...args);\n    }\n  }\n\n  setColors(...setcolor: Parameters<GeometryGroup[\"setColors\"]>): void {\n    var len = this.geometryGroups.length;\n    for (var g = 0; g < len; g++) {\n      var geoGroup = this.geometryGroups[g];\n      geoGroup.setColors(...setcolor);\n    }\n  }\n\n  setColor(...setcolor: Parameters<GeometryGroup[\"setColor\"]>): void {\n    let len = this.geometryGroups.length;\n    for (var g = 0; g < len; g++) {\n      var geoGroup = this.geometryGroups[g];\n      geoGroup.setColor(...setcolor);\n    }\n  }\n\n  setUpWireframe(...lineIndexArgs: Parameters<GeometryGroup[\"setLineIndices\"]>) {\n    let len = this.geometryGroups.length;\n    for (var g = 0; g < len; g++) {\n      var geoGroup = this.geometryGroups[g];\n\n      geoGroup.setLineIndices(...lineIndexArgs);\n    }\n  }\n\n  //After vertices, colors, etc are collected in regular or typed arrays,\n  //  create typed arrays from regular arrays if they don't already exist,\n  initTypedArrays() {\n    for (var g = 0; g < this.groups; g++) {\n      var group = this.geometryGroups[g];\n\n      if (group.__inittedArrays === true) continue;\n\n      //do not actually reallocate smaller memory here because\n      //of the performance hit - if you know your geometry is small,\n      //truncate manually with the second parameter true\n      group.truncateArrayBuffers(this.mesh, false);\n    }\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n\n  get vertices (): number {\n    var vertices = 0;\n    for (var g = 0; g < this.groups; g++)\n      vertices += this.geometryGroups[g].vertices;\n\n    return vertices;\n  }\n}\n\nexport let GeometryIDCount = 0;", "import type { Material } from './../materials/Material';\nimport { Matrix4, Quaternion, Vector3 } from \"../math\";\nimport type { Geometry } from './Geometry';\nimport type { Fog } from '../Fog';\nimport { Color, ColorConstructorArg } from \"../../colors\";\nimport { Sprite } from 'WebGL/objects';\n\nexport let Object3DIDCount = 0;\n// Object3D base constructor function\nexport class Object3D {\n  id = Object3DIDCount++;\n  name = \"\";\n  parent?: Object3D;\n  children: Array<Object3D> = [];\n  position = new Vector3();\n  rotation: Vector3 | number = new Vector3();\n  matrix = new Matrix4();\n  matrixWorld = new Matrix4();\n  quaternion = new Quaternion();\n  eulerOrder = \"XYZ\";\n  up = new Vector3(0, 1, 0);\n  scale = new Vector3(1, 1, 1);\n  matrixAutoUpdate = true;\n  matrixWorldNeedsUpdate = true;\n  rotationAutoUpdate = true;\n  useQuaternion = false;\n  visible = true;\n  geometry?: Geometry;\n  material?: Material;\n\n  lookAt(vector: Vector3) {\n    this.matrix.lookAt(vector, this.position, this.up);\n    if (this.rotationAutoUpdate) {\n      if (this.useQuaternion === true)\n        console.error(\"Unimplemented math operation.\");\n      else if (this.rotation instanceof Vector3)\n        this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n    }\n  }\n\n  //add child object\n  add<T extends Object3D>(object: T): void {\n    if (object === (this as Object3D)) {\n      console.error(\"Can't add $3Dmol.Object3D to itself\");\n      return;\n    }\n\n    object.parent = this;\n    this.children.push(object);\n\n    //add to the scene (i.e. follow up this instance's parents until reach the top)\n\n    var scene = this as Object3D;\n\n    while (scene.parent !== undefined) scene = scene.parent;\n\n    if (scene !== undefined && scene instanceof Scene)\n      scene.__addObject(object);\n  }\n\n  remove<T extends Object3D>(object: T): void {\n    var index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = undefined;\n      this.children.splice(index, 1);\n\n      //Remove from scene\n\n      var scene = this as Object3D;\n\n      while (scene.parent !== undefined) scene = scene.parent;\n\n      if (scene !== undefined && scene instanceof Scene)\n        scene.__removeObject(object);\n    }\n  }\n\n  //convert to vrml\n  vrml(indent?: string) {\n    //attempt to pretty print\n    if (!indent) indent = \" \";\n    //all objects have a transformation (usually identity)\n    //not quite sure if getting rotation right here..\n    var theta = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w);\n    var x = 0,\n      y = 0,\n      z = 0;\n    if (theta != 0) {\n      let st = Math.sin(theta / 2);\n      x = this.quaternion.x / st;\n      y = this.quaternion.y / st;\n      z = this.quaternion.z / st;\n    }\n    var ret =\n      indent +\n      \"Transform {\\n\" +\n      indent +\n      \" center \" +\n      this.position.x +\n      \" \" +\n      this.position.y +\n      \" \" +\n      this.position.z +\n      \"\\n\" +\n      indent +\n      \" rotation \" +\n      x +\n      \" \" +\n      y +\n      \" \" +\n      z +\n      \" \" +\n      theta +\n      \"\\n\" +\n      indent +\n      \" children [\\n\";\n\n    if (this.geometry) {\n      ret += this.geometry.vrml(indent, this.material);\n    }\n    for (var i = 0; i < this.children.length; i++) {\n      ret += this.children[i].vrml(indent + \" \") + \",\\n\";\n    }\n    ret += \" ]\\n\";\n    ret += \"}\";\n    return ret;\n  }\n\n  updateMatrix() {\n    this.matrix.setPosition(this.position);\n\n    if (this.useQuaternion === false && this.rotation instanceof Vector3) {\n      this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder);\n    } else {\n      this.matrix.setRotationFromQuaternion(this.quaternion);\n    }\n\n    //TODO: Do I need this??\n    if (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1)\n      this.matrix.scale(this.scale);\n\n    this.matrixWorldNeedsUpdate = true;\n  }\n\n  updateMatrixWorld(force?: boolean) {\n    if (this.matrixAutoUpdate === true) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate === true || force === true) {\n      if (this.parent === undefined) this.matrixWorld.copy(this.matrix);\n      else\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    }\n\n    this.matrixWorldNeedsUpdate = false;\n\n    //Update matrices of all children\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].updateMatrixWorld(true);\n    }\n  }\n\n  clone(object?: Object3D): Object3D {\n    if (object === undefined) object = new Object3D();\n\n    object.name = this.name;\n\n    object.up.copy(this.up);\n    object.position.copy(this.position);\n    if (\n      object.rotation instanceof Vector3 &&\n      this.rotation instanceof Vector3\n    ) {\n      object.rotation.copy(this.rotation);\n    } else {\n      object.rotation = this.rotation;\n    }\n    object.eulerOrder = this.eulerOrder;\n    object.scale.copy(this.scale);\n\n    object.rotationAutoUpdate = this.rotationAutoUpdate;\n    object.matrix.copy(this.matrix);\n    object.matrixWorld.copy(this.matrixWorld);\n    object.quaternion.copy(this.quaternion);\n    object.matrixAutoUpdate = this.matrixAutoUpdate;\n    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\n    object.useQuaternion = this.useQuaternion;\n\n    object.visible = this.visible;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      object.add(child.clone());\n    }\n\n    return object;\n  }\n\n  setVisible(val: boolean): void {\n    //recursively set visibility\n    this.visible = val;\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.setVisible(val);\n    }\n  }\n}\n\n\n/*\n * Scene class\n */\n/* @constructor */\nexport class Scene extends Object3D {\n  fog: Fog | null = null;\n  //may not need...\n  overrideMaterial: Material | null = null;\n  matrixAutoUpdate = false;\n  __objects = [] as Object3D[];\n  __lights = [] as Light[];\n  __objectsAdded = [] as Object3D[];\n  __objectsRemoved = [] as Object3D[];\n  __webglSprites: Sprite[];\n\n  __addObject<T extends Object3D>(object: T) {\n    //Directional Lighting\n    if (object instanceof Light) {\n      if (this.__lights.indexOf(object as unknown as Light) === -1) this.__lights.push(object as unknown as Light);\n\n      //TODO: Do I need this??\n      if ((object as unknown as Light).target && (object as unknown as Light).target.parent === undefined)\n        this.add((object as unknown as Light).target);\n    }\n\n    //Rotation group\n    else {\n      if (this.__objects.indexOf(object) === -1) {\n        this.__objects.push(object);\n        this.__objectsAdded.push(object);\n\n        //Check if previously removed\n\n        var idx = this.__objectsRemoved.indexOf(object);\n\n        if (idx !== -1) this.__objectsRemoved.splice(idx, 1);\n      }\n    }\n\n    //Add object's children\n\n    for (var i = 0; i < object.children.length; i++)\n      this.__addObject(object.children[i]);\n  }\n\n  __removeObject<T extends Object3D>(object: T) {\n    var idx: number;\n    if (object instanceof Light) {\n      idx = this.__lights.indexOf(object as unknown as Light);\n\n      if (idx !== -1) this.__lights.splice(idx, 1);\n    }\n\n    //Object3D\n    else {\n      idx = this.__objects.indexOf(object);\n\n      if (idx !== -1) {\n        this.__objects.splice(idx, 1);\n        this.__objectsRemoved.push(object);\n\n        //Check if previously added\n\n        var ai = this.__objectsAdded.indexOf(object);\n\n        if (ai !== -1) this.__objectsAdded.splice(idx, 1);\n      }\n    }\n\n    //Remove object's children\n    for (var i = 0; i < object.children.length; i++)\n      this.__removeObject(object.children[i]);\n  }\n}\n\n\nexport class Light extends Object3D {\n  color: Color;\n  intensity: any;\n  position = new Vector3(0, 1, 0);\n  target = new Object3D();\n  castShadow = false;\n  onlyShadow = false;\n  constructor(hex?: ColorConstructorArg, intensity: number = 1) {\n    super();\n    this.color = new Color(hex);\n    this.intensity = intensity;\n  }\n}\n", "import type { Vector3 } from '../math';\nimport type { Camera } from '../Camera';\nimport { Matrix4 } from '../math';\n\nconst viewProjectionMatrix = new Matrix4();\n\n//$3Dmol Projection \nexport class Projector {\n  static unprojectVector(vector: Vector3, camera: Camera) {\n    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n    viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);\n    return vector.applyProjection(viewProjectionMatrix);\n\n  };\n\n  static projectVector(vector: Vector3, camera: Camera) {\n    camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n    viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    return vector.applyProjection(viewProjectionMatrix);\n  };\n\n  projectVector(vector: Vector3, camera: Camera) {\n    return Projector.projectVector(vector, camera);\n  }\n\n  unprojectVector(vector: Vector3, camera: Camera) {\n    return Projector.unprojectVector(vector, camera);\n  }\n}", "import type { Camera } from '../Camera';\nimport { Ray, Matrix4, Vector3 } from \"../math\";\nimport { Sphere, Cylinder, Triangle } from \"../shapes\";\n\nconst descSort = (a: { distance: number; }, b: { distance: number; }) => {\n  return a.distance - b.distance;\n};\n\nconst viewProjectionMatrix = new Matrix4();\n\nexport class Raycaster {\n  ray: Ray;\n  near: number;\n  far: number;\n  precision = 0.0001;\n  linePrecision = 0.2;\n  constructor(origin: Vector3 | undefined, direction: Vector3 | undefined, far?: number, near?: number) {\n    this.ray = new Ray(origin, direction);\n\n    if (this.ray.direction.lengthSq() > 0) this.ray.direction.normalize();\n\n    this.near = near || 0;\n    this.far = far || Infinity;\n  }\n\n  set(origin: Vector3, direction: Vector3): void {\n    this.ray.set(origin, direction);\n  }\n\n  setFromCamera(coords: { x: any; y: any; z: any; }, camera: Camera): void {\n    if (!camera.ortho) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, coords.z);\n\n      camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n      viewProjectionMatrix.multiplyMatrices(\n        camera.matrixWorld,\n        camera.projectionMatrixInverse\n      );\n      this.ray.direction.applyProjection(viewProjectionMatrix);\n      this.ray.direction.sub(this.ray.origin).normalize();\n    } else {\n      this.ray.origin\n        .set(\n          coords.x,\n          coords.y,\n          (camera.near + camera.far) / (camera.near - camera.far)\n        )\n        .unproject(camera);\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n    }\n  }\n\n  intersectObjects(group: any, objects: string | any[]) {\n    var intersects: any[] = [];\n  \n    for (var i = 0, l = objects.length; i < l; i++)\n      intersectObject(group, objects[i], this, intersects);\n  \n    intersects.sort(descSort);\n  \n    return intersects;\n  }\n}\n\n// [-1, 1]\nconst clamp = (x: number): number => {\n  return Math.min(Math.max(x, -1), 1);\n};\n\nvar sphere = new Sphere();\nvar cylinder = new Cylinder();\nvar triangle = new Triangle();\nvar w_0 = new Vector3(); // for cylinders, cylinder.c1 - ray.origin\nvar v1 = new Vector3(); // all purpose local vector\nvar v2 = new Vector3();\nvar v3 = new Vector3();\nvar matrixPosition = new Vector3();\n\n//object is a Sphere or (Bounding) Box\nexport function intersectObject(group: { matrixWorld: Matrix4; }, clickable: { hidden?: boolean; intersectionShape: any; boundingSphere: Sphere | undefined; }, raycaster: Raycaster, intersects: any[]) {\n  matrixPosition.getPositionFromMatrix(group.matrixWorld);\n\n  if (clickable.intersectionShape === undefined) return intersects;\n  if (clickable.hidden) return intersects;\n  var intersectionShape = clickable.intersectionShape;\n  var precision = raycaster.linePrecision;\n  precision *= group.matrixWorld.getMaxScaleOnAxis();\n  var precisionSq = precision * precision;\n\n  //Check for intersection with clickable's bounding sphere, if it exists\n  if (\n    clickable.boundingSphere !== undefined &&\n    clickable.boundingSphere instanceof Sphere\n  ) {\n    sphere.copy(clickable.boundingSphere);\n    sphere.applyMatrix4(group.matrixWorld);\n    if (!raycaster.ray.isIntersectionSphere(sphere)) {\n      return intersects;\n    }\n  }\n\n  //Iterate through intersection objects\n  var i: number,\n    il: number,\n    norm: Vector3,\n    normProj: number,\n    cylProj: number,\n    rayProj: number,\n    distance: number,\n    closestDistSq: number,\n    denom: number,\n    discriminant: number,\n    s: number,\n    t: number,\n    s_c: number,\n    t_c: number;\n  //triangle faces\n  for (i = 0, il = intersectionShape.triangle.length; i < il; i++) {\n    if (intersectionShape.triangle[i] instanceof Triangle) {\n      triangle.copy(intersectionShape.triangle[i]);\n      triangle.applyMatrix4(group.matrixWorld);\n\n      norm = triangle.getNormal();\n\n      normProj = raycaster.ray.direction.dot(norm);\n\n      //face culling\n      if (normProj >= 0) continue;\n\n      w_0.subVectors(triangle.a, raycaster.ray.origin);\n\n      distance = norm.dot(w_0) / normProj;\n\n      if (distance < 0) continue;\n\n      //intersects with plane, check if P inside triangle\n      v1.copy(raycaster.ray.direction)\n        .multiplyScalar(distance)\n        .add(raycaster.ray.origin);\n      v1.sub(triangle.a); // from pt a to intersection point P\n\n      v2.copy(triangle.b).sub(triangle.a); // from pt a to b\n      v3.copy(triangle.c).sub(triangle.a); // from pt a to c\n      var b_dot_c = v2.dot(v3);\n      var b_sq = v2.lengthSq();\n      var c_sq = v3.lengthSq();\n\n      // P = A + s(v2) + t(v3), inside trianle if 0 <= s, t <=1  and (s + t) <=0\n\n      t =\n        (b_sq * v1.dot(v3) - b_dot_c * v1.dot(v2)) /\n        (b_sq * c_sq - b_dot_c * b_dot_c);\n\n      if (t < 0 || t > 1) continue;\n\n      s = (v1.dot(v2) - t * b_dot_c) / b_sq;\n\n      if (s < 0 || s > 1 || s + t > 1) continue;\n      else {\n        intersects.push({ clickable: clickable, distance: distance });\n      }\n    }\n  }\n  //cylinders\n  for (i = 0, il = intersectionShape.cylinder.length; i < il; i++) {\n    if (intersectionShape.cylinder[i] instanceof Cylinder) {\n      cylinder.copy(intersectionShape.cylinder[i]);\n      cylinder.applyMatrix4(group.matrixWorld);\n\n      w_0.subVectors(cylinder.c1, raycaster.ray.origin);\n\n      cylProj = w_0.dot(cylinder.direction); // Dela\n      rayProj = w_0.dot(raycaster.ray.direction); // Epsilon\n\n      normProj = clamp(raycaster.ray.direction.dot(cylinder.direction)); // Beta\n\n      denom = 1 - normProj * normProj;\n\n      if (denom === 0.0) continue;\n\n      s_c = (normProj * rayProj - cylProj) / denom;\n      t_c = (rayProj - normProj * cylProj) / denom;\n\n      v1.copy(cylinder.direction).multiplyScalar(s_c).add(cylinder.c1); // Q_c\n      v2.copy(raycaster.ray.direction)\n        .multiplyScalar(t_c)\n        .add(raycaster.ray.origin); // P_c\n\n      closestDistSq = v3.subVectors(v1, v2).lengthSq();\n      var radiusSq = cylinder.radius * cylinder.radius;\n\n      //Smoothing?\n      //if (closestDistSq > radiusSq) radiusSq += precisionSq;\n\n      // closest distance between ray and cylinder axis not greater than cylinder radius;\n      // might intersect this cylinder between atom and bond midpoint\n      if (closestDistSq <= radiusSq) {\n        //Find points where ray intersects sides of cylinder\n        discriminant =\n          (normProj * cylProj - rayProj) * (normProj * cylProj - rayProj) -\n          denom * (w_0.lengthSq() - cylProj * cylProj - radiusSq);\n\n        // ray tangent to cylinder?\n        if (discriminant <= 0) t = distance = Math.sqrt(closestDistSq);\n        else\n          t = distance =\n            (rayProj - normProj * cylProj - Math.sqrt(discriminant)) / denom;\n\n        //find closest intersection point; make sure it's between atom's position and cylinder midpoint\n\n        s = normProj * t - cylProj;\n\n        //does not intersect cylinder between atom and midpoint,\n        // or intersects cylinder behind camera\n        if (s < 0 || s * s > cylinder.lengthSq() || t < 0) continue;\n        else intersects.push({ clickable: clickable, distance: distance });\n      }\n    }\n  }\n  //lines\n  for (i = 0, il = intersectionShape.line.length; i < il; i += 2) {\n    v1.copy(intersectionShape.line[i]);\n    v1.applyMatrix4(group.matrixWorld);\n    v2.copy(intersectionShape.line[i + 1]);\n    v2.applyMatrix4(group.matrixWorld);\n\n    v3.subVectors(v2, v1);\n    var bondLengthSq = v3.lengthSq();\n    v3.normalize();\n\n    w_0.subVectors(v1, raycaster.ray.origin);\n\n    var lineProj = w_0.dot(v3);\n    rayProj = w_0.dot(raycaster.ray.direction);\n\n    normProj = clamp(raycaster.ray.direction.dot(v3));\n\n    denom = 1 - normProj * normProj;\n\n    if (denom === 0.0) continue;\n\n    s_c = (normProj * rayProj - lineProj) / denom;\n    t_c = (rayProj - normProj * lineProj) / denom;\n\n    v1.add(v3.multiplyScalar(s_c)); // Q_c\n    v2.copy(raycaster.ray.direction)\n      .multiplyScalar(t_c)\n      .add(raycaster.ray.origin); // P_c\n\n    closestDistSq = v3.subVectors(v2, v1).lengthSq();\n\n    if (closestDistSq < precisionSq && s_c * s_c < bondLengthSq)\n      intersects.push({ clickable: clickable, distance: t_c });\n  }\n  for (i = 0, il = intersectionShape.sphere.length; i < il; i++) {\n    //sphere\n    if (intersectionShape.sphere[i] instanceof Sphere) {\n      sphere.copy(intersectionShape.sphere[i]);\n      sphere.applyMatrix4(group.matrixWorld);\n\n      if (raycaster.ray.isIntersectionSphere(sphere)) {\n        v1.subVectors(sphere.center, raycaster.ray.origin);\n\n        //distance from ray origin to point on the ray normal to sphere's center\n        //must be less than sphere's radius (since ray intersects sphere)\n        var distanceToCenter = v1.dot(raycaster.ray.direction);\n\n        discriminant =\n          distanceToCenter * distanceToCenter -\n          (v1.lengthSq() - sphere.radius * sphere.radius);\n\n        //Don't select if sphere center behind camera\n        if (distanceToCenter < 0) return intersects;\n\n        //ray tangent to sphere?\n        if (discriminant <= 0) distance = distanceToCenter;\n        //This is reversed if sphere is closer than ray origin.  Do we have\n        //to worry about handling that case?\n        else distance = distanceToCenter - Math.sqrt(discriminant);\n\n        intersects.push({ clickable: clickable, distance: distance });\n      }\n    }\n  }\n  return intersects;\n};\n", "//Texture\n//We really only create textures from 2d rendering contexts (to display text labels)\n//edit: we can now create 3dtextures using volumetric data\n\nimport {\n  ClampToEdgeWrapping,\n  RFormat,\n  FloatType,\n  NearestFilter,\n  RGBAFormat,\n  UnsignedByteType,\n  LinearFilter,\n  LinearMipMapLinearFilter,\n} from \"../constants/TextureConstants\";\nimport { Vector2 } from \"../math\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport { UVMapping } from \"./UVMapping\";\n\n/* @constructor */\nexport class Texture extends EventDispatcher {\n  id: number;\n  name: string;\n  image: any;\n  mapping: any;\n  wrapS: number;\n  wrapT: number;\n  anisotropy: number;\n  format: number;\n  type: number;\n  premultiplyAlpha: boolean;\n  flipY: boolean;\n  unpackAlignment: number;\n  magFilter: number;\n  minFilter: number;\n  offset: any;\n  repeat: any;\n  needsUpdate: boolean;\n  onUpdate: null;\n  constructor(image?: any, is3D?: boolean) {\n    super();\n\n    this.id = TextureIdCount++;\n\n    this.name = \"\";\n\n    this.image = image;\n\n    this.mapping = new UVMapping();\n\n    this.wrapS = ClampToEdgeWrapping;\n    this.wrapT = ClampToEdgeWrapping;\n\n    this.anisotropy = 1;\n\n    if (is3D) {\n      this.format = RFormat;\n      this.type = FloatType;\n\n      this.premultiplyAlpha = false;\n      this.flipY = false;\n\n      this.unpackAlignment = 1;\n\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n    } else {\n      this.format = RGBAFormat;\n      this.type = UnsignedByteType;\n\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n\n      this.magFilter = LinearFilter;\n      this.minFilter = LinearMipMapLinearFilter;\n    }\n\n    this.needsUpdate = false;\n    this.onUpdate = null;\n  }\n\n  clone(texture = new Texture()): Texture {\n\n    texture.image = this.image;\n\n    texture.mapping = this.mapping;\n\n    texture.wrapS = this.wrapS;\n    texture.wrapT = this.wrapT;\n\n    texture.magFilter = this.magFilter;\n    texture.minFilter = this.minFilter;\n\n    texture.anisotropy = this.anisotropy;\n\n    texture.format = this.format;\n    texture.type = this.type;\n\n    texture.offset.copy(this.offset);\n    texture.repeat.copy(this.repeat);\n\n    texture.premultiplyAlpha = this.premultiplyAlpha;\n    texture.flipY = this.flipY;\n    texture.unpackAlignment = this.unpackAlignment;\n\n    return texture;\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\nexport let TextureIdCount = 0;\n", "// mapping modes\nexport class UVMapping {};", "export * from \"./EventDispatcher\";\nexport * from \"./Geometry\";\nexport * from \"./Object3D\";\nexport * from \"./Projector\";  \nexport * from \"./Raycaster\";\nexport * from \"./Texture\";\nexport * from \"./UVMapping\";", "export * from \"./constants\"\nexport * from \"./core\"\nexport * from \"./materials\"\nexport * from \"./math\"\nexport * from \"./objects\"\nexport * from \"./shaders\"\nexport * from \"./shapes\"\nexport * from \"./Camera\"\nexport * from \"./Fog\"\nexport * from \"./Renderer\"\nexport * from \"./SpritePlugin\"\n", "import { Coloring } from \"./../constants/Coloring\";\nimport { Shading } from \"./../constants/Shading\";\nimport { Color } from \"../../colors\";\nimport { Vector3 } from \"../math\";\nimport { Material } from \"./Material\";\n//Imposter material\n/* @constructor */\nexport class ImposterMaterial extends Material {\n  combine: any;\n  morphTargets: any;\n  morphNormals: any;\n  color = new Color(0xffffff);\n  ambient = new Color(0xfffff);\n  emissive = new Color(0x000000);\n  imposter = true;\n\n  //TODO: Which of these instance variables do I really need?\n  wrapAround = false;\n  wrapRGB = new Vector3(1, 1, 1);\n  map = undefined;\n  lightMap = null;\n  specularMap = null;\n  envMap = null;\n  reflectivity = 1;\n  refractionRatio = 0.98;\n  fog = true;\n  wireframe = false;\n  wireframeLinewidth = 1;\n  wireframeLinecap = \"round\";\n  wireframeLinejoin = \"round\";\n  shading = Shading.SmoothShading;\n  shaderID = null as string | null;\n  vertexColors = Coloring.NoColors;\n  skinning = false;\n  constructor(parameters?: any) {\n    super();\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new ImposterMaterial() as T): T {\n    super.clone.call(this, material);\n\n    material.color.copy(this.color);\n    material.ambient.copy(this.ambient);\n    material.emissive.copy(this.emissive);\n\n    material.wrapAround = this.wrapAround;\n    material.wrapRGB.copy(this.wrapRGB);\n\n    material.map = this.map;\n\n    material.lightMap = this.lightMap;\n\n    material.specularMap = this.specularMap;\n\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n\n    material.fog = this.fog;\n\n    material.shading = this.shading;\n    material.shaderID = this.shaderID;\n    material.vertexColors = this.vertexColors;\n\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n\n    return material;\n  }\n}\n", "import { Coloring } from \"../constants/Coloring\";\nimport { Shading } from \"../constants/Shading\";\nimport { Color } from \"../../colors\";\nimport { Vector3 } from \"../math\";\nimport { Material } from \"./Material\";\n\nexport class InstancedMaterial extends Material {\n  combine: any;\n  morphTargets: any;\n  morphNormals: any;\n\n  color = new Color(0xffffff);\n  ambient = new Color(0xfffff);\n  emissive = new Color(0x000000);\n\n  //TODO: Which of these instance variables do I really need?\n  wrapAround = false;\n  wrapRGB = new Vector3(1, 1, 1);\n  map = undefined;\n  lightMap = null;\n  specularMap = null;\n  envMap = null;\n  reflectivity = 1;\n  refractionRatio = 0.98;\n  fog = true;\n  wireframe = false;\n  wireframeLinewidth = 1;\n  wireframeLinecap = \"round\";\n  wireframeLinejoin = \"round\";\n  shading = Shading.SmoothShading;\n  shaderID = \"instanced\";\n  vertexColors = Coloring.NoColors;\n  skinning = false;\n  sphere = null;\n  constructor(parameters?: any) {\n    super();\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new InstancedMaterial() as T): T {\n    super.clone.call(this, material as T);\n\n    material.color.copy(this.color);\n    material.ambient.copy(this.ambient);\n    material.emissive.copy(this.emissive);\n\n    material.wrapAround = this.wrapAround;\n    material.wrapRGB.copy(this.wrapRGB);\n\n    material.map = this.map;\n\n    material.lightMap = this.lightMap;\n\n    material.specularMap = this.specularMap;\n\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n\n    material.fog = this.fog;\n\n    material.shading = this.shading;\n    material.shaderID = this.shaderID;\n    material.vertexColors = this.vertexColors;\n\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n\n    material.sphere = this.sphere;\n\n    return material;\n  }\n}\n", "import { Color } from \"../../colors\";\nimport { Material } from \"./Material\";\n//Line basic material\n/* @constructor */\nexport class LineBasicMaterial extends Material {\n  color = new Color(0xffffff);\n  linewidth = 1;\n  linecap = \"round\";\n  linejoin = \"round\";\n  vertexColors = false;\n  fog = true;\n  shaderID = \"basic\";\n  constructor(parameters?: any) {\n    super();\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new LineBasicMaterial() as T): T {\n\n    super.clone.call(this, material);\n\n    material.color.copy(this.color);\n    return material as T;\n  }\n}\n", "import {FrontSide}  from \"../constants/Sides\";\nimport { EventDispatcher } from \"../core\";\nimport type { Texture } from \"../core\";\nimport { Vector2, Vector3 } from \"../math\";\nimport { Color } from \"../../colors\";\n/*\n * Line and Mesh material types\n * @constructor\n */\nexport class Material extends EventDispatcher {\n  id = MaterialIdCount++;\n  name = \"\";\n  overdraw: any;\n  color?: Color;\n  map?: Texture;\n  useScreenCoordinates?: boolean;\n  alignment?: Vector2;\n  screenOffset?: Vector2;\n  uvScale?: Vector2;\n  uvOffset?: Vector2;\n  scaleByViewport?: boolean;\n  fog?: unknown;\n  uniforms?: any;\n\n  side = FrontSide;\n  opacity = 1;\n  transparent = false;\n  depthTest = true;\n  depthWrite = true;\n  polygonOffset = false;\n  polygonOffsetFactor = 0;\n  polygonOffsetUnits = 0;\n  alphaTest = 0;\n  visible = true;\n  needsUpdate = true;\n  outline = false;\n  wireframe = false;\n  shaded = false;\n\n  setValues(\n    values: Partial<Record<keyof Material, any>> = {} as any\n  ) {\n    if (values === undefined) return;\n\n    for (var key in values) {\n      var newValue: Material[keyof Material] = values[key as keyof Material];\n\n      if (newValue === undefined) {\n        console.warn(\"$3Dmol.Material: '\" + key + \"' parameter is undefined.\");\n        continue;\n      }\n\n      if (key in this) {\n        var currentValue = this[key as keyof Material];\n\n        if (currentValue instanceof Color && newValue instanceof Color) {\n          currentValue.copy(newValue);\n        } else if (currentValue instanceof Color) {\n          currentValue.set(newValue as unknown as Color);\n        } else if (\n          currentValue instanceof Vector3 &&\n          newValue instanceof Vector3\n        ) {\n          currentValue.copy(newValue);\n        } else {\n          (this as any)[key] = newValue;\n        }\n      }\n    }\n  }\n\n  //TODO: might want to look into blending equations\n  clone<T extends this>(material = new Material() as T): T {\n    material.name = this.name;\n\n    material.side = this.side;\n\n    material.opacity = this.opacity;\n    material.transparent = this.transparent;\n\n    material.depthTest = this.depthTest;\n    material.depthWrite = this.depthWrite;\n\n    material.polygonOffset = this.polygonOffset;\n    material.polygonOffsetFactor = this.polygonOffsetFactor;\n    material.polygonOffsetUnits = this.polygonOffsetUnits;\n\n    material.alphaTest = this.alphaTest;\n\n    material.overdraw = this.overdraw;\n\n    material.visible = this.visible;\n\n    return material;\n  }\n\n  makeShaded(sTex: number) {\n    this.shaded = true;\n    if(this.uniforms) {\n      this.uniforms.shading = { type: 'i', value: sTex };\n      this.uniforms.vWidth = { type: 'f', value: 1.0 };\n      this.uniforms.vHeight = { type: 'f', value: 1.0 };\n    }\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\n\nexport let MaterialIdCount = 0;\n", "import { DoubleSide } from \"./../constants/Sides\";\nimport { MeshLambertMaterial } from \"./MeshLambertMaterial\";\n//Double sided Mesh Lambert material\n/* @constructor */\nexport class MeshDoubleLambertMaterial extends MeshLambertMaterial {\n  shaderID = \"lambertdouble\";\n  side = DoubleSide;\n  outline = false;\n  \n  constructor(parameters?: any) {\n    super(parameters);\n  }\n\n  clone<T extends this>(material: T = new MeshDoubleLambertMaterial() as T): T {\n    super.clone.call(this, material);\n    return material;\n  }\n}\n", "import { Coloring } from \"./../constants/Coloring\";\nimport { Shading } from \"./../constants/Shading\";\nimport { Material } from \"./Material\";\n//Mesh Lambert material\n\nimport { Color } from \"../../colors\";\nimport { Vector3 } from \"../math\";\n\n/* @constructor */\nexport class MeshLambertMaterial extends Material {\n  combine: any;\n  morphTargets: any;\n  morphNormals: any;\n\n  color = new Color(0xffffff);\n  ambient = new Color(0xfffff);\n  emissive = new Color(0x000000);\n\n  //TODO: Which of these instance variables do I really need?\n  wrapAround = false;\n  wrapRGB = new Vector3(1, 1, 1);\n  map = undefined;\n  lightMap = null;\n  specularMap = null;\n  envMap = null;\n  reflectivity = 1;\n  refractionRatio = 0.98;\n  fog = true;\n  wireframe = false;\n  wireframeLinewidth = 1;\n  wireframeLinecap = \"round\";\n  wireframeLinejoin = \"round\";\n  shading = Shading.SmoothShading;\n  shaderID = \"lambert\";\n  vertexColors = Coloring.NoColors;\n  skinning = false;\n\n  voldata:any;\n  volscheme:any;\n\n  constructor(parameters?: any) {\n    super();\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new MeshLambertMaterial() as T): T {\n    super.clone.call(this, material);\n\n    material.color.copy(this.color);\n    material.ambient.copy(this.ambient);\n    material.emissive.copy(this.emissive);\n\n    material.wrapAround = this.wrapAround;\n    material.wrapRGB.copy(this.wrapRGB);\n\n    material.map = this.map;\n\n    material.lightMap = this.lightMap;\n\n    material.specularMap = this.specularMap;\n\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n\n    material.fog = this.fog;\n\n    material.shading = this.shading;\n    material.shaderID = this.shaderID;\n    material.vertexColors = this.vertexColors;\n\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n\n    return material as T;\n  }\n}\n", "import { CC, Color } from \"../../colors\";\nimport { Material } from \"./Material\";\n//Outlined Mesh Lamert material\n/* @constructor */\nexport class MeshOutlineMaterial extends Material {\n  fog: boolean;\n  shaderID: string;\n  wireframe: boolean;\n  outlineColor: any;\n  outlineWidth: number;\n  outlinePushback: number;\n  outlineMaxPixels: number;\n\n  constructor(parameters?: any) {\n    super();\n    parameters = parameters || {};\n    this.fog = true;\n    this.shaderID = \"outline\";\n    this.wireframe = false;\n    this.outlineColor = CC.color(parameters.color || new Color(0.0, 0.0, 0.0));\n    this.outlineWidth = parameters.width || 0.1;\n    this.outlinePushback = parameters.pushback || 1.0;\n    this.outlineMaxPixels = parameters.maxpixels || 0.0;\n  }\n  clone<T extends this>(material: T = new MeshOutlineMaterial() as T): T {\n    super.clone.call(this, material);\n    material.fog = this.fog;\n    material.shaderID = this.shaderID;\n    material.wireframe = this.wireframe;\n    material.outlineColor = this.outlineColor;\n    material.outlineWidth = this.outlineWidth;\n    material.outlinePushback = this.outlinePushback;\n    material.outlineMaxPixels = this.outlineMaxPixels;\n    return material;\n  }\n}\n", "import { ImposterMaterial } from \"./ImposterMaterial\";\n\nexport class SphereImposterMaterial extends ImposterMaterial {\n  shaderID = \"sphereimposter\";\n  constructor(parameters?: any) {\n    super(parameters);\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new SphereImposterMaterial() as T): T {\n    super.clone.call(this, material);\n    return material;\n  }\n}\n", "import { CC, Color } from \"../../colors\";\nimport { ImposterMaterial } from \"./ImposterMaterial\";\n\nexport class SphereImposterOutlineMaterial extends ImposterMaterial {\n  outlineColor: Color;\n  outlineWidth: number;\n  outlinePushback: number;\n  outlineMaxPixels: number;\n  \n  constructor(parameters?: any) {\n    super(parameters);\n    parameters = parameters || {};\n\n    this.shaderID = \"sphereimposteroutline\";\n    this.outlineColor = CC.color(parameters.color || new Color(0.0, 0.0, 0.0));\n    this.outlineWidth = parameters.width || 0.1;\n    this.outlinePushback = parameters.pushback || 1.0;\n    this.outlineMaxPixels = parameters.maxpixels || 0.0;\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material: T = new SphereImposterOutlineMaterial() as T): T {\n    super.clone.call(this, material);\n    material.outlineColor = this.outlineColor;\n    material.outlineWidth = this.outlineWidth;\n    material.outlinePushback = this.outlinePushback;\n    material.outlineMaxPixels = this.outlineMaxPixels;\n    return material;\n  }\n}\n", "import { SpriteAlignment } from \"../constants/SpriteAlignment\";\nimport { Texture } from \"../core/Texture\";\nimport { Color } from \"../../colors\";\nimport { Vector2 } from \"../math\";\nimport { Material } from \"./Material\";\nexport class SpriteMaterial extends Material {\n  sizeAttenuation: boolean;\n  screenOffset: any;\n  scaleByViewPort: boolean;\n  alignment: any;\n  scaleByViewport: any;\n\n  color = new Color(0xffffff);\n  map = new Texture();\n  useScreenCoordinates = true;\n  fog = false; // use scene fog\n  uvOffset = new Vector2(0, 0);\n  uvScale = new Vector2(1, 1);\n  \n  constructor(parameters?: any) {\n    super();\n    this.depthTest = !this.useScreenCoordinates;\n    this.sizeAttenuation = !this.useScreenCoordinates;\n    this.screenOffset = this.screenOffset;\n    this.scaleByViewPort = !this.sizeAttenuation;\n    this.alignment = SpriteAlignment.center.clone();\n\n    this.setValues(parameters);\n\n    parameters = parameters || {};\n\n    if (parameters.depthTest === undefined)\n      this.depthTest = !this.useScreenCoordinates;\n    if (parameters.sizeAttenuation === undefined)\n      this.sizeAttenuation = !this.useScreenCoordinates;\n    if (parameters.scaleByViewPort === undefined)\n      this.scaleByViewPort = !this.sizeAttenuation;\n  }\n\n  clone<T extends this>(material = new SpriteMaterial() as T): T {\n    super.clone.call(this, material);\n\n    material.color.copy(this.color);\n    material.map = this.map;\n\n    material.useScreenCoordinates = this.useScreenCoordinates;\n    material.screenOffset = this.screenOffset;\n    material.sizeAttenuation = this.sizeAttenuation;\n    material.scaleByViewport = this.scaleByViewPort;\n    material.alignment.copy(this.alignment);\n\n    material.uvOffset.copy(this.uvOffset);\n\n    return material;\n  }\n}\n", "import { ImposterMaterial } from \"./ImposterMaterial\";\nexport class StickImposterMaterial extends ImposterMaterial {\n  shaderID = \"stickimposter\";\n\n  constructor(parameters?: any) {\n    super(parameters);\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material = new StickImposterMaterial() as T): T {\n    super.clone.call(this, material);\n    return material;\n  }\n}\n", "import { CC, Color, ColorSpec } from \"../../colors\";\nimport { ImposterMaterial } from \"./ImposterMaterial\";\nexport class StickImposterOutlineMaterial extends ImposterMaterial {\n  shaderID = \"stickimposteroutline\";\n  outlineColor = new Color(0.0, 0.0, 0.0);\n  outlineWidth = 0.1;\n  outlinePushback = 1.0;\n  outlineMaxPixels = 0.0;\n\n  constructor(\n    parameters: Record<keyof StickImposterOutlineMaterial, unknown> & {\n      width?: number;\n      pushback?: number;\n      maxpixels?: number;\n    } = {} as any\n  ) {\n    super(parameters);\n    if (parameters.color) this.outlineColor = CC.color(parameters.color as ColorSpec);\n    if (parameters.width) this.outlineWidth = parameters.width as number;\n    if (parameters.pushback)\n      this.outlinePushback = parameters.pushback as number;\n    if (parameters.maxpixels)\n      this.outlineMaxPixels = parameters.maxpixels;\n\n    this.setValues(parameters);\n  }\n\n  clone<T extends this>(material = new StickImposterOutlineMaterial() as T): T {\n    super.clone.call(this, material);\n    material.outlineColor = this.outlineColor;\n    material.outlineWidth = this.outlineWidth;\n    material.outlinePushback = this.outlinePushback;\n    material.outlineMaxPixels = this.outlineMaxPixels;\n    return material;\n  }\n}\n", "//Volumetric material\n\nimport { FrontSide } from \"../constants/Sides\";\nimport { Color } from \"../../colors\";\nimport { Material } from \"./Material\";\n\n/* @constructor */\nexport class VolumetricMaterial extends Material {\n  transparent = false;\n  volumetric = true;\n  color = new Color(0xffffff);\n  transferfn = null;\n  map = undefined;\n  extent = [];\n  maxdepth = 100.0;\n  unit = 0;\n  texmatrix = null;\n  transfermin = -1.0;\n  transfermax = 1.0;\n  subsamples = 5.0;\n  shaderID = \"volumetric\";\n  side = FrontSide;\n\n  constructor(parameters?: any) {\n    super();\n    // this.fog = true; // TODO: to integrate the new shader with the fog stuff\n    this.setValues(parameters);\n  }\n  clone<T extends this>(material = new VolumetricMaterial() as T): T {\n    super.clone.call(this, material);\n    material.transparent = this.transparent;\n    material.volumetric = this.volumetric;\n    material.color = this.color;\n    material.transferfn = this.transferfn;\n    material.map = this.map;\n    material.extent = this.extent;\n    material.maxdepth = this.maxdepth;\n    material.unit = this.unit;\n    material.texmatrix = this.texmatrix;\n    material.transfermin = this.transfermin;\n    material.transfermax = this.transfermax;\n    material.subsamples = this.subsamples;\n    material.shaderID = this.shaderID;\n    material.side = this.side;\n    return material;\n  }\n}\n", "export * from \"./ImposterMaterial\"\nexport * from \"./InstancedMaterial\"\nexport * from \"./LineBasicMaterial\"\nexport * from \"./Material\"\nexport * from \"./MeshDoubleLambertMaterial\"\nexport * from \"./MeshLambertMaterial\"\nexport * from \"./MeshOutlineMaterial\"\nexport * from \"./SphereImposterMaterial\"\nexport * from \"./SphereImposterOutlineMaterial\"\nexport * from \"./SpriteMaterial\"\nexport * from \"./StickImposterMaterial\"\nexport * from \"./StickImposterOutlineMaterial\"\nexport * from \"./VolumetricMaterial\"", "// Quaternion\nexport interface Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/** @class \n *  @subcategory  Math\n * */ \nexport class Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n  constructor(x?: number, y?: number, z?: number, w?: number) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n    this.w = w !== undefined ? w : 1;\n  }\n\n  set(x: number, y: number, z: number, w: number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n\n    return this;\n  }\n\n  copy(q: Quaternion) {\n    this.x = q.x;\n    this.y = q.y;\n    this.z = q.z;\n    this.w = q.w;\n\n    return this;\n  }\n\n  conjugate() {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n\n    return this;\n  }\n\n  inverse() {\n    return this.conjugate().normalize();\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n\n  lengthxyz() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  normalize() {\n    let l = this.length();\n\n    if (l === 0) {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 1;\n    } else {\n      l = 1 / l;\n\n      this.x *= l;\n      this.y *= l;\n      this.z *= l;\n      this.w *= l;\n    }\n\n    return this;\n  }\n\n  multiply(q: any) {\n    return this.multiplyQuaternions(this, q);\n  }\n\n  multiplyScalar(s: number) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    this.w *= s;\n    return this;\n  }\n\n  multiplyQuaternions(a: Quaternion, b: Quaternion) {\n    const qax = a.x;\n    const qay = a.y;\n    const qaz = a.z;\n    const qaw = a.w;\n    const qbx = b.x;\n    const qby = b.y;\n    const qbz = b.z;\n    const qbw = b.w;\n\n    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    return this;\n  }\n\n  sub(q: Quaternion) {\n    this.x -= q.x;\n    this.y -= q.y;\n    this.z -= q.z;\n    this.w -= q.w;\n    return this;\n  }\n\n  clone() {\n    return new Quaternion(this.x, this.y, this.z, this.w);\n  }\n\n  setFromEuler(e: Quaternion) {\n    const c1 = Math.cos(e.x / 2);\n    const c2 = Math.cos(e.y / 2);\n    const c3 = Math.cos(e.z / 2);\n    const s1 = Math.sin(e.x / 2);\n    const s2 = Math.sin(e.y / 2);\n    const s3 = Math.sin(e.z / 2);\n\n    this.x = s1 * c2 * c3 + c1 * s2 * s3;\n    this.y = c1 * s2 * c3 - s1 * c2 * s3;\n    this.z = c1 * c2 * s3 + s1 * s2 * c3;\n    this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    return this;\n  }\n}", "/** @class \n *  @subcategory  Math\n * */ \nexport class Vector2 {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n      this.x = x || 0.0;\n      this.y = y || 0.0;\n    }\n  \n    set(x: any, y: any) {\n      this.x = x;\n      this.y = y;\n  \n      return this;\n    }\n  \n    subVectors(a: { x: number; y: number; }, b: { x: number; y: number; }) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n  \n      return this;\n    }\n  \n    copy(v: { x: any; y: any; }) {\n      this.x = v.x;\n      this.y = v.y;\n  \n      return this;\n    }\n  \n    clone() {\n      return new Vector2(this.x, this.y);\n    }\n  }", "export * from \"./Quaternion\";\nexport * from \"./Vector2\";\nexport * from \"./utils/clamp\";\nexport * from \"./utils/conversionMatrix3\";\nexport * from \"./utils/degToRad\";\nexport * from \"./math\"\n", "import { Quaternion } from \"./Quaternion\";\nimport { degToRad } from \"./utils/degToRad\";\nimport { clamp } from \"./utils/clamp\";\nimport { Sphere } from \"../shapes\";\n\nvar mRotation: Matrix4;\nvar mScale: Matrix4;\nvar x: Vector3;\nvar y: Vector3;\nvar z: Vector3;\n\n/** @class \n *  @subcategory  Math\n * */ \nexport class Matrix4 {\n  elements: Float32Array;\n  constructor(n11: Array<number>);\n  constructor(\n    n11?: number,\n    n12?: number,\n    n13?: number,\n    n14?: number,\n    n21?: number,\n    n22?: number,\n    n23?: number,\n    n24?: number,\n    n31?: number,\n    n32?: number,\n    n33?: number,\n    n34?: number,\n    n41?: number,\n    n42?: number,\n    n43?: number,\n    n44?: number\n  );\n  constructor(\n    n11: Array<number> | number = 1,\n    n12: number = 0,\n    n13: number = 0,\n    n14: number = 0,\n    n21: number = 0,\n    n22: number = 1,\n    n23: number = 0,\n    n24: number = 0,\n    n31: number = 0,\n    n32: number = 0,\n    n33: number = 1,\n    n34: number = 0,\n    n41: number = 0,\n    n42: number = 0,\n    n43: number = 0,\n    n44: number = 1\n  ) {\n    if (typeof n11 !== \"undefined\" && typeof n11 !== \"number\") {\n      // passing list like initialization\n      this.elements = new Float32Array(n11);\n    } else {\n      this.elements = new Float32Array(16);\n      this.elements[0] = n11;\n      this.elements[4] = n12;\n      this.elements[8] = n13;\n      this.elements[12] = n14;\n      this.elements[1] = n21;\n      this.elements[5] = n22;\n      this.elements[9] = n23;\n      this.elements[13] = n24;\n      this.elements[2] = n31;\n      this.elements[6] = n32;\n      this.elements[10] = n33;\n      this.elements[14] = n34;\n      this.elements[3] = n41;\n      this.elements[7] = n42;\n      this.elements[11] = n43;\n      this.elements[15] = n44;\n    }\n  }\n\n  // eslint-disable-next-line no-unused-vars, class-methods-use-this\n  makeScale(x: any, y: any, z: any) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  set(\n    n11: number,\n    n12: number,\n    n13: number,\n    n14: number,\n    n21: number,\n    n22: number,\n    n23: number,\n    n24: number,\n    n31: number,\n    n32: number,\n    n33: number,\n    n34: number,\n    n41: number,\n    n42: number,\n    n43: number,\n    n44: number\n  ) {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  copy(m: { elements: any }) {\n    const me = m.elements;\n\n    this.set(\n      me[0],\n      me[4],\n      me[8],\n      me[12],\n      me[1],\n      me[5],\n      me[9],\n      me[13],\n      me[2],\n      me[6],\n      me[10],\n      me[14],\n      me[3],\n      me[7],\n      me[11],\n      me[15]\n    );\n\n    return this;\n  }\n\n  matrix3FromTopLeft() {\n    const te = this.elements;\n    return new Matrix3(\n      te[0],\n      te[4],\n      te[8],\n      te[1],\n      te[5],\n      te[9],\n      te[2],\n      te[6],\n      te[10]\n    );\n  }\n\n  setRotationFromEuler(v: Vector3, order?: string) {\n    const te = this.elements;\n\n    const { x, y, z } = v;\n    const a = Math.cos(x);\n    const b = Math.sin(x);\n    const c = Math.cos(y);\n    const d = Math.sin(y);\n    const e = Math.cos(z);\n    const f = Math.sin(z);\n\n    if (order === undefined || order === \"XYZ\") {\n      const ae = a * e;\n      const af = a * f;\n      const be = b * e;\n      const bf = b * f;\n\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else\n      console.error(`Error with matrix4 setRotationFromEuler. Order: ${order}`);\n\n    return this;\n  }\n\n  setRotationFromQuaternion(q: Quaternion) {\n    const te = this.elements;\n\n    const { x, y, z, w } = q;\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const xy = x * y2;\n    const xz = x * z2;\n    const yy = y * y2;\n    const yz = y * z2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n\n    te[0] = 1 - (yy + zz);\n    te[4] = xy - wz;\n    te[8] = xz + wy;\n\n    te[1] = xy + wz;\n    te[5] = 1 - (xx + zz);\n    te[9] = yz - wx;\n\n    te[2] = xz - wy;\n    te[6] = yz + wx;\n    te[10] = 1 - (xx + yy);\n\n    return this;\n  }\n\n  multiplyMatrices(a: { elements: any }, b: Matrix4) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n\n    const a11 = ae[0];\n    const a12 = ae[4];\n    const a13 = ae[8];\n    const a14 = ae[12];\n    const a21 = ae[1];\n    const a22 = ae[5];\n    const a23 = ae[9];\n    const a24 = ae[13];\n    const a31 = ae[2];\n    const a32 = ae[6];\n    const a33 = ae[10];\n    const a34 = ae[14];\n    const a41 = ae[3];\n    const a42 = ae[7];\n    const a43 = ae[11];\n    const a44 = ae[15];\n\n    const b11 = be[0];\n    const b12 = be[4];\n    const b13 = be[8];\n    const b14 = be[12];\n    const b21 = be[1];\n    const b22 = be[5];\n    const b23 = be[9];\n    const b24 = be[13];\n    const b31 = be[2];\n    const b32 = be[6];\n    const b33 = be[10];\n    const b34 = be[14];\n    const b41 = be[3];\n    const b42 = be[7];\n    const b43 = be[11];\n    const b44 = be[15];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n    return this;\n  }\n\n  multiplyScalar(s: number) {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n\n    return this;\n  }\n\n  makeTranslation(x: any, y: any, z: any) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  // snap values close to integers to their integer value\n  // useful and identifying identity matrices\n  snap(digits: number) {\n    if (!digits) digits = 4;\n    const mult = 10 ** 4;\n    const te = this.elements;\n    for (let i = 0; i < 16; i++) {\n      const rounded = Math.round(te[i]);\n      if (rounded === Math.round(te[i] * mult) / mult) {\n        te[i] = rounded;\n      }\n    }\n    return this;\n  }\n\n  transpose() {\n    const te = this.elements;\n    let tmp: any;\n\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n\n    return this;\n  }\n\n  setPosition(v: Vector3) {\n    const te = this.elements;\n\n    te[12] = v.x;\n    te[13] = v.y;\n    te[14] = v.z;\n\n    return this;\n  }\n\n  translate(v: Vector3) {\n    const te = this.elements;\n\n    te[12] += v.x;\n    te[13] += v.y;\n    te[14] += v.z;\n\n    return this;\n  }\n\n  getInverse(m: Matrix4, throwOnInvertible?: boolean) {\n    // based on\n    // http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements;\n    const me = m.elements;\n\n    const n11 = me[0];\n    const n12 = me[4];\n    const n13 = me[8];\n    const n14 = me[12];\n    const n21 = me[1];\n    const n22 = me[5];\n    const n23 = me[9];\n    const n24 = me[13];\n    const n31 = me[2];\n    const n32 = me[6];\n    const n33 = me[10];\n    const n34 = me[14];\n    const n41 = me[3];\n    const n42 = me[7];\n    const n43 = me[11];\n    const n44 = me[15];\n\n    te[0] =\n      n23 * n34 * n42 -\n      n24 * n33 * n42 +\n      n24 * n32 * n43 -\n      n22 * n34 * n43 -\n      n23 * n32 * n44 +\n      n22 * n33 * n44;\n    te[4] =\n      n14 * n33 * n42 -\n      n13 * n34 * n42 -\n      n14 * n32 * n43 +\n      n12 * n34 * n43 +\n      n13 * n32 * n44 -\n      n12 * n33 * n44;\n    te[8] =\n      n13 * n24 * n42 -\n      n14 * n23 * n42 +\n      n14 * n22 * n43 -\n      n12 * n24 * n43 -\n      n13 * n22 * n44 +\n      n12 * n23 * n44;\n    te[12] =\n      n14 * n23 * n32 -\n      n13 * n24 * n32 -\n      n14 * n22 * n33 +\n      n12 * n24 * n33 +\n      n13 * n22 * n34 -\n      n12 * n23 * n34;\n    te[1] =\n      n24 * n33 * n41 -\n      n23 * n34 * n41 -\n      n24 * n31 * n43 +\n      n21 * n34 * n43 +\n      n23 * n31 * n44 -\n      n21 * n33 * n44;\n    te[5] =\n      n13 * n34 * n41 -\n      n14 * n33 * n41 +\n      n14 * n31 * n43 -\n      n11 * n34 * n43 -\n      n13 * n31 * n44 +\n      n11 * n33 * n44;\n    te[9] =\n      n14 * n23 * n41 -\n      n13 * n24 * n41 -\n      n14 * n21 * n43 +\n      n11 * n24 * n43 +\n      n13 * n21 * n44 -\n      n11 * n23 * n44;\n    te[13] =\n      n13 * n24 * n31 -\n      n14 * n23 * n31 +\n      n14 * n21 * n33 -\n      n11 * n24 * n33 -\n      n13 * n21 * n34 +\n      n11 * n23 * n34;\n    te[2] =\n      n22 * n34 * n41 -\n      n24 * n32 * n41 +\n      n24 * n31 * n42 -\n      n21 * n34 * n42 -\n      n22 * n31 * n44 +\n      n21 * n32 * n44;\n    te[6] =\n      n14 * n32 * n41 -\n      n12 * n34 * n41 -\n      n14 * n31 * n42 +\n      n11 * n34 * n42 +\n      n12 * n31 * n44 -\n      n11 * n32 * n44;\n    te[10] =\n      n12 * n24 * n41 -\n      n14 * n22 * n41 +\n      n14 * n21 * n42 -\n      n11 * n24 * n42 -\n      n12 * n21 * n44 +\n      n11 * n22 * n44;\n    te[14] =\n      n14 * n22 * n31 -\n      n12 * n24 * n31 -\n      n14 * n21 * n32 +\n      n11 * n24 * n32 +\n      n12 * n21 * n34 -\n      n11 * n22 * n34;\n    te[3] =\n      n23 * n32 * n41 -\n      n22 * n33 * n41 -\n      n23 * n31 * n42 +\n      n21 * n33 * n42 +\n      n22 * n31 * n43 -\n      n21 * n32 * n43;\n    te[7] =\n      n12 * n33 * n41 -\n      n13 * n32 * n41 +\n      n13 * n31 * n42 -\n      n11 * n33 * n42 -\n      n12 * n31 * n43 +\n      n11 * n32 * n43;\n    te[11] =\n      n13 * n22 * n41 -\n      n12 * n23 * n41 -\n      n13 * n21 * n42 +\n      n11 * n23 * n42 +\n      n12 * n21 * n43 -\n      n11 * n22 * n43;\n    te[15] =\n      n12 * n23 * n31 -\n      n13 * n22 * n31 +\n      n13 * n21 * n32 -\n      n11 * n23 * n32 -\n      n12 * n21 * n33 +\n      n11 * n22 * n33;\n\n    const det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];\n\n    if (det === 0) {\n      const msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n        throw new Error(msg);\n      } else {\n        console.warn(msg);\n      }\n\n      this.identity();\n\n      return this;\n    }\n\n    this.multiplyScalar(1 / det);\n\n    return this;\n  }\n\n  isReflected() {\n    const te = this.elements;\n\n    const m0 = te[0];\n    const m3 = te[4];\n    const m6 = te[8];\n    const m1 = te[1];\n    const m4 = te[5];\n    const m7 = te[9];\n    const m2 = te[2];\n    const m5 = te[6];\n    const m8 = te[10];\n\n    const determinant =\n      m0 * m4 * m8 + // +aei\n      m1 * m5 * m6 + // +bfg\n      m2 * m3 * m7 - // +cdh\n      m2 * m4 * m6 - // -ceg\n      m1 * m3 * m8 - // -bdi\n      m0 * m5 * m7; // -afh\n\n    return determinant < 0;\n  }\n\n  scale(v: { x?: any; y?: any; z?: any }) {\n    const te = this.elements;\n    const { x } = v;\n    const { y } = v;\n    const { z } = v;\n\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n\n    return this;\n  }\n\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\n  }\n\n  makeFrustum(\n    left: number,\n    right: number,\n    bottom: number,\n    top: number,\n    near: number,\n    far: number\n  ) {\n    const te = this.elements;\n\n    const x = (2 * near) / (right - left);\n    const y = (2 * near) / (top - bottom);\n\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    const c = -(far + near) / (far - near);\n    const d = (-2 * far * near) / (far - near);\n\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n\n    return this;\n  }\n\n  makePerspective(fov: number, aspect: number, near: number, far: any) {\n    const ymax = near * Math.tan(degToRad(fov * 0.5));\n    const ymin = -ymax;\n    const xmin = ymin * aspect;\n    const xmax = ymax * aspect;\n\n    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\n  }\n\n  makeOrthographic(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    near: number,\n    far: number\n  ) {\n    const te = this.elements;\n    const w = 1.0 / (right - left);\n    const h = 1.0 / (top - bottom);\n    const p = 1.0 / (far - near);\n\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    const z = (far + near) * p;\n\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  isEqual(m: { elements: any }) {\n    const me = m.elements;\n    const te = this.elements;\n\n    if (\n      te[0] === me[0] &&\n      te[4] === me[4] &&\n      te[8] === me[8] &&\n      te[12] === me[12] &&\n      te[1] === me[1] &&\n      te[5] === me[5] &&\n      te[9] === me[9] &&\n      te[13] === me[13] &&\n      te[2] === me[2] &&\n      te[6] === me[6] &&\n      te[10] === me[10] &&\n      te[14] === me[14] &&\n      te[3] === me[3] &&\n      te[7] === me[7] &&\n      te[11] === me[11] &&\n      te[15] === me[15]\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  clone() {\n    const te = this.elements;\n\n    return new Matrix4(\n      te[0],\n      te[4],\n      te[8],\n      te[12],\n      te[1],\n      te[5],\n      te[9],\n      te[13],\n      te[2],\n      te[6],\n      te[10],\n      te[14],\n      te[3],\n      te[7],\n      te[11],\n      te[15]\n    );\n  }\n\n  isIdentity() {\n    const te = this.elements;\n\n    if (\n      te[0] === 1 &&\n      te[4] === 0 &&\n      te[8] === 0 &&\n      te[12] === 0 &&\n      te[1] === 0 &&\n      te[5] === 1 &&\n      te[9] === 0 &&\n      te[13] === 0 &&\n      te[2] === 0 &&\n      te[6] === 0 &&\n      te[10] === 1 &&\n      te[14] === 0 &&\n      te[3] === 0 &&\n      te[7] === 0 &&\n      te[11] === 0 &&\n      te[15] === 1\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // return true if elements are with digits of identity\n  isNearlyIdentity(digits: any) {\n    const snapped = this.clone().snap(digits);\n    return snapped.isIdentity();\n  }\n\n\n  getScale(scale?: Vector3): Vector3 {\n    const te = this.elements;\n    scale = scale || new Vector3();\n    // grab the axis vectors\n    x.set(te[0], te[1], te[2]);\n    y.set(te[4], te[5], te[6]);\n    z.set(te[8], te[9], te[10]);\n\n    scale.x = x.length();\n    scale.y = y.length();\n    scale.z = z.length();\n\n    return scale;\n  }\n\n  lookAt(eye: Vector3, target: Vector3, up: Vector3) {\n    const te = this.elements;\n\n    z.subVectors(eye, target).normalize();\n\n    if (z.length() === 0) {\n      z.z = 1;\n    }\n\n    x.crossVectors(up, z).normalize();\n\n    if (x.length() === 0) {\n      z.x += 0.0001;\n      x.crossVectors(up, z).normalize();\n    }\n\n    y.crossVectors(z, x);\n\n    te[0] = x.x;\n    te[4] = y.x;\n    te[8] = z.x;\n    te[1] = x.y;\n    te[5] = y.y;\n    te[9] = z.y;\n    te[2] = x.z;\n    te[6] = y.z;\n    te[10] = z.z;\n\n    return this;\n  }\n\n  compose(translation: Vector3, rotation: Quaternion, scale: Vector3) {\n    const te = this.elements;\n\n    mRotation.identity();\n    mRotation.setRotationFromQuaternion(rotation);\n\n    mScale.makeScale(scale.x, scale.y, scale.z);\n\n    this.multiplyMatrices(mRotation, mScale);\n\n    te[12] = translation.x;\n    te[13] = translation.y;\n    te[14] = translation.z;\n\n    return this;\n  }\n}\n\nmRotation = new Matrix4();\nmScale = new Matrix4();\n\n/**\n * @interface\n */\nexport interface XYZ {\n  /**  */\n  x: number;\n  /**  */\n  y: number;\n  /**  */\n  z: number;\n}\n\n/** @class \n *  @subcategory  Math\n * */ \nexport class Vector3 {\n  // unaccounted for assignents to vector3 properties in other parts of the code\n  // look in glcartoon.js for example\n  color?: any;\n  resi?: any;\n  style?: any;\n  smoothen?: any;\n  atom?: any;\n  skip?: any;\n  atomid?: undefined;\n\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x?: number, y?: number, z?: number) {\n    this.x = x || 0.0;\n    this.y = y || 0.0;\n    this.z = z || 0.0;\n    this.atomid = undefined;\n  }\n\n  set(x: any, y: any, z: any) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n\n    return this;\n  }\n\n  copy(v: { x: any; y: any; z: any }) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n\n    return this;\n  }\n\n  add(v: { x: any; y: any; z: any }) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n\n    return this;\n  }\n\n  addVectors(a: { x: any; y: any; z: any }, b: { x: any; y: any; z: any }) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n\n    return this;\n  }\n\n  multiplyVectors(\n    a: { x: number; y: number; z: number },\n    b: { x: number; y: number; z: number }\n  ) {\n    // elementwise\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n\n    return this;\n  }\n\n  sub(v: { x: number; y: number; z: number }) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n\n    return this;\n  }\n\n  subVectors(\n    a: { x: number; y: number; z: number },\n    b: { x: number; y: number; z: number }\n  ) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n\n    return this;\n  }\n\n  multiplyScalar(s: number) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n\n    return this;\n  }\n\n  divideScalar(s: number) {\n    if (s !== 0) {\n      this.x /= s;\n      this.y /= s;\n      this.z /= s;\n    } else {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    }\n\n    return this;\n  }\n\n  // accumulate maximum\n  max(s: { x: number; y: number; z: number }) {\n    this.x = Math.max(this.x, s.x);\n    this.y = Math.max(this.y, s.y);\n    this.z = Math.max(this.z, s.z);\n\n    return this;\n  }\n\n  // accumulate min\n  min(s: { x: number; y: number; z: number }) {\n    this.x = Math.min(this.x, s.x);\n    this.y = Math.min(this.y, s.y);\n    this.z = Math.min(this.z, s.z);\n\n    return this;\n  }\n\n  distanceTo(v: any) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v: { x: number; y: number; z: number }) {\n    const dx = this.x - v.x;\n    const dy = this.y - v.y;\n    const dz = this.z - v.z;\n\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  applyMatrix3(m: { elements: any }) {\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n\n    const e = m.elements;\n    // column major ordering\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n\n    return this;\n  }\n\n  applyMatrix4(m: { elements: any }) {\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n    return this;\n  }\n\n  applyProjection(m: { elements: any }) {\n    // input: Matrix4 projection matrix\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n\n    const e = m.elements;\n    const d = e[3] * x + e[7] * y + e[11] * z + e[15];\n\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) / d;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) / d;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) / d;\n\n    return this;\n  }\n\n  applyQuaternion(q: Quaternion): Vector3 {\n    // save values\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n\n    // compute this as\n    // t = 2 * cross(q.xyz, v)\n    // newv = v + q.w * t + cross(q.xyz, t)\n    // this from molecularmusings\n    // http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    const t: { x?: number; y?: number; z?: number } = {};\n    t.x = 2 * (y * qz - z * qy);\n    t.y = 2 * (z * qx - x * qz);\n    t.z = 2 * (x * qy - y * qx);\n\n    // cross t with q\n    const t2: { x?: number; y?: number; z?: number } = {};\n    t2.x = t.y * qz - t.z * qy;\n    t2.y = t.z * qx - t.x * qz;\n    t2.z = t.x * qy - t.y * qx;\n\n    this.x = x + qw * t.x + t2.x;\n    this.y = y + qw * t.y + t2.y;\n    this.z = z + qw * t.z + t2.z;\n\n    return this;\n  }\n\n  negate() {\n    return this.multiplyScalar(-1);\n  }\n\n  dot(v: Vector3) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  normalize() {\n    return this.divideScalar(this.length());\n  }\n\n  cross(v: Vector3) {\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n\n    this.x = y * v.z - z * v.y;\n    this.y = z * v.x - x * v.z;\n    this.z = x * v.y - y * v.x;\n\n    return this;\n  }\n\n  crossVectors(a: Vector3, b: Vector3) {\n    this.x = a.y * b.z - a.z * b.y;\n    this.y = a.z * b.x - a.x * b.z;\n    this.z = a.x * b.y - a.y * b.x;\n\n    return this;\n  }\n\n  equals(b: Vector3) {\n    return this.x == b.x && this.y == b.y && this.z == b.z;\n  }\n  \n  getPositionFromMatrix(m: Matrix4) {\n    this.x = m.elements[12];\n    this.y = m.elements[13];\n    this.z = m.elements[14];\n\n    return this;\n  }\n\n  setEulerFromRotationMatrix(m: Matrix4, order: string) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    const te = m.elements;\n    const m11 = te[0];\n    const m12 = te[4];\n    const m13 = te[8];\n    // var m21 = te[1];\n    const m22 = te[5];\n    const m23 = te[9];\n    // var m31 = te[2];\n    const m32 = te[6];\n    const m33 = te[10];\n\n    if (order === undefined || order === \"XYZ\") {\n      this.y = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        this.x = Math.atan2(-m23, m33);\n        this.z = Math.atan2(-m12, m11);\n      } else {\n        this.x = Math.atan2(m32, m22);\n        this.z = 0;\n      }\n    } else {\n      console.error(\n        `Error with vector's setEulerFromRotationMatrix: Unknown order: ${order}`\n      );\n    }\n\n    return this;\n  }\n\n  rotateAboutVector(axis: Vector3, ang: number) {\n    axis.normalize();\n    const cosang = Math.cos(ang);\n    const sinang = Math.sin(ang);\n    // Rodrigues' rotation formula, from wikipedia\n    const term1 = this.clone().multiplyScalar(cosang);\n    const term2 = axis.clone().cross(this).multiplyScalar(sinang);\n    const term3 = axis\n      .clone()\n      .multiplyScalar(axis.clone().dot(this))\n      .multiplyScalar(1 - cosang);\n\n    const rot = term1.add(term2).add(term3);\n\n    this.x = rot.x;\n    this.y = rot.y;\n    this.z = rot.z;\n\n    return this;\n  }\n\n  setFromMatrixPosition(m: { elements: any }) {\n    const e = m.elements;\n\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n\n    return this;\n  }\n\n  // unproject is defined after Matrix4\n  transformDirection(m: { elements: any }) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n    const { x } = this;\n    const { y } = this;\n    const { z } = this;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n\n    return this.normalize();\n  }\n\n  clone() {\n    return new Vector3(this.x, this.y, this.z);\n  }\n\n  unproject(camera: { matrixWorld: any; projectionMatrix: any }) {\n    const mat4 = mRotation;\n    mat4.multiplyMatrices(\n      camera.matrixWorld,\n      mat4.getInverse(camera.projectionMatrix)\n    );\n    return this.applyMatrix4(mat4);\n  }\n}\n\nx = new Vector3();\ny = new Vector3();\nz = new Vector3();\n\n/* \n * @interface Matrix3\n */\nexport interface Matrix3 {\n  elements: Float32Array;\n}\n\n/** @class \n *  @subcategory  Math\n * */ \nexport class Matrix3 {\n  constructor(\n    n11: number = 1,\n    n12: number = 0,\n    n13: number = 0,\n    n21: number = 0,\n    n22: number = 1,\n    n23: number = 0,\n    n31: number = 0,\n    n32: number = 0,\n    n33: number = 1\n  ) {\n    this.elements = new Float32Array(9);\n    this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n  }\n\n  set(\n    n11: number,\n    n12: number,\n    n13: number,\n    n21: number,\n    n22: number,\n    n23: number,\n    n31: number,\n    n32: number,\n    n33: number\n  ) {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[3] = n12;\n    te[6] = n13;\n    te[1] = n21;\n    te[4] = n22;\n    te[7] = n23;\n    te[2] = n31;\n    te[5] = n32;\n    te[8] = n33;\n\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  copy(m: { elements: any }) {\n    const me = m.elements;\n\n    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);\n  }\n\n  multiplyScalar(s: number) {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n\n    return this;\n  }\n\n  getInverse3(matrix: { elements: any }) {\n    // input: Matrix3\n    const me = matrix.elements;\n    const te = this.elements;\n\n    te[0] = me[4] * me[8] - me[5] * me[7];\n    te[3] = me[6] * me[5] - me[3] * me[8];\n    te[6] = me[3] * me[7] - me[6] * me[4];\n    te[1] = me[7] * me[2] - me[1] * me[8];\n    te[4] = me[0] * me[8] - me[6] * me[2];\n    te[7] = me[1] * me[6] - me[0] * me[7];\n    te[2] = me[1] * me[5] - me[2] * me[4];\n    te[5] = me[2] * me[3] - me[0] * me[5];\n    te[8] = me[0] * me[4] - me[1] * me[3];\n\n    const det = me[0] * te[0] + me[3] * te[1] + me[6] * te[2];\n    this.multiplyScalar(1.0 / det);\n\n    return this;\n  }\n\n  getInverse(matrix: { elements: any }, throwOnInvertible: any) {\n    // input: Matrix4\n    const me = matrix.elements;\n    const te = this.elements;\n\n    te[0] = me[10] * me[5] - me[6] * me[9];\n    te[1] = -me[10] * me[1] + me[2] * me[9];\n    te[2] = me[6] * me[1] - me[2] * me[5];\n    te[3] = -me[10] * me[4] + me[6] * me[8];\n    te[4] = me[10] * me[0] - me[2] * me[8];\n    te[5] = -me[6] * me[0] + me[2] * me[4];\n    te[6] = me[9] * me[4] - me[5] * me[8];\n    te[7] = -me[9] * me[0] + me[1] * me[8];\n    te[8] = me[5] * me[0] - me[1] * me[4];\n\n    const det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];\n\n    // no inverse\n    if (det === 0) {\n      const msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n        throw new Error(msg);\n      } else {\n        console.warn(msg);\n      }\n\n      this.identity();\n\n      return this;\n    }\n\n    this.multiplyScalar(1.0 / det);\n\n    return this;\n  }\n\n  // https://en.wikipedia.org/wiki/Determinant\n  getDeterminant() {\n    const m = this.elements;\n\n    /*\n     * |a b c| |d e f| |g h i|\n     */\n    const determinant =\n      m[0] * m[4] * m[8] + // +aei\n      m[1] * m[5] * m[6] + // +bfg\n      m[2] * m[3] * m[7] - // +cdh\n      m[2] * m[4] * m[6] - // -ceg\n      m[1] * m[3] * m[8] - // -bdi\n      m[0] * m[5] * m[7]; // -afh\n    return determinant;\n  }\n\n  transpose() {\n    let tmp: any;\n    const m = this.elements;\n\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n\n    return this;\n  }\n\n  clone() {\n    const te = this.elements;\n\n    return new Matrix3(\n      te[0],\n      te[3],\n      te[6],\n      te[1],\n      te[4],\n      te[7],\n      te[2],\n      te[5],\n      te[8]\n    );\n  }\n\n  getMatrix4() {\n    const m = this.elements;\n    return new Matrix4(\n      m[0],\n      m[3],\n      m[6],\n      0,\n      m[1],\n      m[4],\n      m[7],\n      0,\n      m[2],\n      m[5],\n      m[8],\n      0\n    );\n  }\n}\n\n/** @class \n *  @subcategory  Math\n * */ \nexport class Ray {\n  origin: Vector3;\n  direction: Vector3;\n\n  constructor(origin?: Vector3, direction?: Vector3) {\n    this.origin = origin !== undefined ? origin : new Vector3();\n    this.direction = direction !== undefined ? direction : new Vector3();\n  }\n\n  set(origin: Vector3, direction: Vector3) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n\n    return this;\n  }\n\n  copy(ray: Ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n\n    return this;\n  }\n\n  at(t: number, optionalTarget: Vector3) {\n    const result = optionalTarget || new Vector3();\n\n    return result.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n\n  recast(t: any) {\n    const v1 = x;\n    this.origin.copy(this.at(t, v1));\n\n    return this;\n  }\n\n  closestPointToPoint(point: Vector3, optionalTarget: Vector3) {\n    const result = optionalTarget || new Vector3();\n    result.subVectors(point, this.origin);\n    const directionDistance = result.dot(this.direction);\n\n    // returns a point on this ray\n    return result\n      .copy(this.direction)\n      .multiplyScalar(directionDistance)\n      .add(this.origin);\n  }\n\n  distanceToPoint(point: Vector3) {\n    const v1 = x;\n    const directionDistance = v1\n      .subVectors(point, this.origin)\n      .dot(this.direction);\n    v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n    return v1.distanceTo(point);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isIntersectionCylinder() {}\n\n  isIntersectionSphere(sphere: Sphere) {\n    return this.distanceToPoint(sphere.center) <= sphere.radius;\n  }\n\n  isIntersectionPlane(plane: any) {\n    const denominator = plane.normal.dot(this.direction);\n\n    // plane and ray are not perpendicular\n    if (denominator !== 0) return true;\n\n    if (plane.distanceToPoint(this.origin) === 0) return true;\n\n    return false;\n  }\n\n  distanceToPlane(plane: any) {\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) {\n      // line is coplanar\n      if (plane.distanceToPoint(this.origin) === 0) return 0;\n\n      // ray is parallel\n      return undefined;\n    }\n\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n\n    return t;\n  }\n\n  intersectPlane(plane: any, optionalTarget: any) {\n    const t = this.distanceToPlane(plane);\n\n    if (t === undefined) return undefined;\n\n    return this.at(t, optionalTarget);\n  }\n\n  applyMatrix4(matrix4: any) {\n    this.direction.add(this.origin).applyMatrix4(matrix4);\n    this.origin.applyMatrix4(matrix4);\n    this.direction.sub(this.origin);\n\n    return this;\n  }\n\n  clone() {\n    return new Ray().copy(this);\n  }\n}\n", "/*\n * math-like functionality\n * quaternion, vector, matrix\n */\nexport function clamp(x: number, min: number, max: number) {\n  return Math.min(Math.max(x, min), max);\n}", "// return conversion matrix given crystal unit cell parameters\n\nimport { Matrix3 } from \"../math\";\n\n/**\n *\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} alpha\n * @param {number} beta\n * @param {number} gamma\n * @returns {Matrix3}\n */\nexport function conversionMatrix3(\n  a: number,\n  b: number,\n  c: number,\n  alpha: number,\n  beta: number,\n  gamma: number\n) {\n  // Convert to radians\n  alpha = (alpha * Math.PI) / 180;\n  beta = (beta * Math.PI) / 180;\n  gamma = (gamma * Math.PI) / 180;\n  const sqr = (x: number) => {\n    return x*x\n  };\n  const cosAlpha = Math.cos(alpha);\n  const cosBeta = Math.cos(beta);\n  const cosGamma = Math.cos(gamma);\n  const sinGamma = Math.sin(gamma);\n  const conversionMatrix = new Matrix3(\n    a,\n    b * cosGamma,\n    c * cosBeta,\n    0,\n    b * sinGamma,\n    (c * (cosAlpha - cosBeta * cosGamma)) / sinGamma,\n    0,\n    0,\n    (c *\n      Math.sqrt(\n        1 -\n          sqr(cosAlpha) -\n          sqr(cosBeta) -\n          sqr(cosGamma) +\n          2 * cosAlpha * cosBeta * cosGamma\n      )) /\n      sinGamma\n  );\n  return conversionMatrix;\n}\n", "const degreeToRadiansFactor = Math.PI / 180;\n\nexport function degToRad(deg: number) {\n  return deg * degreeToRadiansFactor;\n}", "import { Material, LineBasicMaterial } from \"../materials\";\nimport type { Geometry } from \"../core\";\nimport { Object3D } from \"../core\";\n\nexport enum LineStyle {\n  LineStrip = 0,\n  LinePieces = 1,\n}\n\nexport class Line extends Object3D {\n  type: any;\n  geometry: Geometry;\n  material: Material;\n  constructor(\n    geometry: Geometry,\n    material: Material = new LineBasicMaterial({\n      color: Math.random() * 0xffffff,\n    }) as Material,\n    type: LineStyle = LineStyle.LineStrip\n  ) {\n    super();\n\n    this.geometry = geometry;\n    //TODO: update material and type to webgl\n    this.material = material;\n    this.type = type;\n  }\n\n  clone<T extends this>(\n    object = new Line(this.geometry, this.material, this.type) as T\n  ): T {\n    super.clone.call(this, object);\n    return object;\n  }\n}\n\n\n", "import type { Material } from \"../materials\";\nimport type { Geometry } from \"../core\";\nimport { Object3D } from \"../core\";\n//Mesh Object\n/* @constructor */\nexport class Mesh extends Object3D {\n  geometry: Geometry;\n  material: Material;\n  constructor(\n    geometry: Geometry,\n    material: Material\n  ) {\n    super();\n    this.geometry = geometry;\n    this.material = material;\n  }\n\n  clone(object: Mesh): Mesh {\n    if (object === undefined) object = new Mesh(this.geometry, this.material);\n\n    super.clone.call(this, object);\n\n    return object;\n  }\n}\n", "import { Material } from './../materials/Material';\nimport { SpriteMaterial } from '../materials';\nimport { Object3D } from \"../core\";\nimport { Vector3 } from '../math';\n//Sprite object\n/* @constructor */\nexport class Sprite extends Object3D {\n  rotation3d: Vector3;\n  _modelViewMatrix: any;\n  z?: number;\n  material?: Material;\n\n  constructor(material = new SpriteMaterial() as Material) {\n    super();\n    this.material = material as Material;\n    this.rotation3d = this.rotation as Vector3;\n    this.rotation = 0;\n  }\n\n  updateMatrix() {\n    this.matrix.setPosition(this.position);\n    this.rotation3d.set(0, 0, this.rotation);\n    this.matrix.setRotationFromEuler(this.rotation3d);\n\n    if (this.scale.x !== 1 || this.scale.y !== 1) this.matrix.scale(this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  }\n\n  clone<T extends this>(object = new Sprite(this.material)): Sprite  {\n    Object3D.prototype.clone.call(this, object);\n    return object;\n  }\n}\n", "export * from \"./Line\";\nexport * from \"./Mesh\";\nexport * from \"./Sprite\";", "export type Shader = {\n  fragmentShader: string;\n  vertexShader: string;\n  uniforms: Record<string, any>\n}", "export * from \"./lib\"\nexport * from \"./utils\"\nexport * from \"./ShaderType\"", "export default \"uniform mat4 viewMatrix;\\nuniform float opacity;\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\nvarying vec3 vColor;\\nvarying vec4 mvPosition;\\n\\n//DEFINEFRAGCOLOR\\nvoid main() {\\n    gl_FragColor = vec4( vColor, opacity );\\n    if(fogNear != fogFar) {\\n        float depth = -mvPosition.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n}\";", "export default \"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nattribute vec3 position;\\nattribute vec3 color;\\n\\nvarying vec3 vColor;\\nvarying vec4 mvPosition;\\n\\nvoid main() {\\n\\n    vColor = color;\\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n\\n}\";", "import { uniforms } from './uniforms';\nimport { Shader } from '../../ShaderType';\nimport fragmentShader from './basic.frag';\nimport vertexShader from './basic.vert';\n\nexport const basic: Shader = {\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000}\n}", "export default \"const float INV_TOTAL_SAMPLES_FACTOR = 1.0 / 9.0;\\nuniform highp sampler2D inTex;\\nvarying highp vec2 vTexCoords;\\n    \\nvoid main() {\\n \\n vec2 texelSize = 1.0 / vec2(textureSize(inTex,0));\\n float blurred_visibility_factor = 0.0f;\\n for (int t = -1; t <= 1; ++t) {\\n  for (int s = -1; s <= 1; ++s) {\\n   vec2 offset = vec2(float(s), float(t)) * texelSize;\\n   blurred_visibility_factor += texture2D(inTex, vTexCoords + offset).r;\\n  }\\n }\\n    \\n gl_FragDepthEXT = blurred_visibility_factor * INV_TOTAL_SAMPLES_FACTOR;\\n \\n}\";", "export default \"attribute vec2 vertexPosition;\\nvarying highp vec2 vTexCoords;\\nconst vec2 scale = vec2(0.5, 0.5);\\n\\nvoid main() {\\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\\n}\\n        \";", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './blur.frag';\nimport vertexShader from './blur.vert';\n\nexport const blur: Shader = {\n    fragmentShader: fragmentShader,\n    vertexShader: vertexShader,\n    uniforms\n}", "\nexport const uniforms = {\n};\n", "export * from \"./basic\"\nexport * from \"./instanced\"\nexport * from \"./lambert\"\nexport * from \"./lambertdouble\"\nexport * from \"./outline\"\nexport * from \"./screen\"\nexport * from \"./screenaa\"\nexport * from \"./sphereimposter\"\nexport * from \"./sphereimposteroutline\"\nexport * from \"./sprite\"\nexport * from \"./stickimposter\"\nexport * from \"./stickimposteroutline\"\nexport * from \"./volumetric\"\n\nimport { Shader } from '../ShaderType';\nimport { basic } from \"./basic\"\nimport { instanced } from \"./instanced\"\nimport { lambert } from \"./lambert\"\nimport { lambertdouble } from \"./lambertdouble\"\nimport { outline } from \"./outline\"\nimport { screen } from \"./screen\"\nimport { screenaa } from \"./screenaa\"\nimport { ssao } from \"./ssao\"\nimport { sphereimposter } from \"./sphereimposter\"\nimport { sphereimposteroutline } from \"./sphereimposteroutline\"\nimport { sprite } from \"./sprite\"\nimport { stickimposter } from \"./stickimposter\"\nimport { stickimposteroutline } from \"./stickimposteroutline\"\nimport { volumetric } from \"./volumetric\"\nimport {blur } from \"./blur\"\n\nexport const ShaderLib: Record<string, Shader> = {\n    basic,\n    blur,\n    instanced,\n    lambert,\n    lambertdouble,\n    outline,\n    screen,\n    screenaa,\n    ssao,\n    sphereimposter,\n    sphereimposteroutline,\n    sprite,\n    stickimposter,\n    stickimposteroutline,\n    volumetric,\n}", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './instanced.frag';\nimport vertexShader from './instanced.vert';\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"./instanced.frag\", \"utf8\")\n//const vertexShader = fs.readFileSync(__dirname + \"./instanced.vert\", \"utf8\") \n\nexport const instanced: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms,\n}", "export default \"uniform mat4 viewMatrix;\\nuniform float opacity;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\n#ifdef SHADED\\nuniform highp sampler2D shading;\\n#endif\\nvarying vec3 vLightFront;\\nvarying vec3 vColor;\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n\\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\\n\\n    #ifndef WIREFRAME\\n    gl_FragColor.xyz *= vLightFront;\\n    #endif\\n\\n#ifdef SHADED\\n    ivec2 dim = textureSize(shading,0);\\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\\n    vColor *= shadowFactor;\\n#endif\\n    gl_FragColor = gl_FragColor * vec4( vColor, opacity );\\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n\\n}\\n\\n\\n\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\n\\nattribute vec3 offset;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\nattribute float radius;\\n\\nvarying vec3 vColor;\\nvarying vec3 vLightFront;\\n\\nvoid main() {\\n\\n    vColor = color;\\n\\n    vec3 objectNormal = normal;\\n    vec3 transformedNormal = normalMatrix * objectNormal;\\n    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );\\n\\n    vLightFront = vec3( 0.0 );\\n\\n    transformedNormal = normalize( transformedNormal );\\n\\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\\n    vec3 dirVector = normalize( lDirection.xyz );\\n    float dotProduct = dot( transformedNormal, dirVector );\\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\\n\\n    gl_Position = projectionMatrix * mvPosition;\\n}\\n\\n\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    directionalLightColor: { type: 'fv', value: [] as number[] },\n    directionalLightDirection: { type: 'fv', value: [] as number[] }\n}\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './lambert.frag';\nimport vertexShader from './lambert.vert';\n//import fs from 'fs';\n//\n//const fragmentShader = fs.readFileSync(__dirname + '/lambert.frag', 'utf8');\n//const vertexShader = fs.readFileSync(__dirname + '/lambert.vert', 'utf8');\n\nexport const lambert: Shader = {\n    fragmentShader: fragmentShader.replace('#define GLSLIFY 1', ''),\n    vertexShader: vertexShader.replace('#define GLSLIFY 1', ''),\n    uniforms,\n}", "export default \"uniform mat4 viewMatrix;\\nuniform float opacity;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\n#ifdef SHADED\\nuniform highp sampler2D shading;\\n#endif\\nvarying vec3 vLightFront;\\nvarying vec3 vColor;\\nvarying vec4 mvPosition;\\n\\n\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n\\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\\n\\n    #ifndef WIREFRAME\\n    gl_FragColor.xyz *= vLightFront;\\n    #endif\\n#ifdef SHADED\\n    ivec2 dim = textureSize(shading,0);\\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\\n    vColor *= shadowFactor;\\n#endif\\n    gl_FragColor = gl_FragColor * vec4( vColor, opacity );\\n\\n    if(fogNear != fogFar) {\\n        float depth = -mvPosition.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n\\n}\";", "export default \"\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\n\\nvarying vec3 vColor;\\nvarying vec3 vLightFront;\\nvarying vec4 mvPosition;\\n\\nvoid main() {\\n\\n    vColor = color;\\n\\n    vec3 objectNormal = normal;\\n    vec3 transformedNormal = normalMatrix * objectNormal;\\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n    vLightFront = vec3( 0.0 );\\n\\n    transformedNormal = normalize( transformedNormal );\\n\\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\\n    vec3 dirVector = normalize( lDirection.xyz );\\n    float dotProduct = dot( transformedNormal, dirVector );\\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\\n\\n    gl_Position = projectionMatrix * mvPosition;\\n}\";", "import { Color } from \"../../../../colors\";\n\nexport const  uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] },\n}", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './lambertdouble.frag';\nimport vertexShader from './lambertdouble.vert';\n//import fs from 'fs';\n//\n//const fragmentShader = fs.readFileSync(__dirname + '/lambertdouble.frag', 'utf8');\n//const vertexShader = fs.readFileSync(__dirname + '/lambertdouble.vert', 'utf8');\n\nexport const lambertdouble: Shader = {\n    fragmentShader: fragmentShader.replace('#define GLSLIFY 1', ''),\n    vertexShader: vertexShader.replace('#define GLSLIFY 1', ''),\n    uniforms\n}", "export default \"\\n#ifdef SHADED\\nuniform highp sampler2D shading;\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform float opacity;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\n\\nvarying vec3 vLightFront;\\nvarying vec3 vLightBack;\\n\\nvarying vec3 vColor;\\nvarying vec4 mvPosition;\\n\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n\\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\\n\\n    #ifndef WIREFRAME\\n    if ( gl_FrontFacing )\\n       gl_FragColor.xyz *= vLightFront;\\n    else\\n       gl_FragColor.xyz *= vLightBack;\\n    #endif\\n\\n    vec3 color = vColor;\\n#ifdef SHADED\\n    ivec2 dim = textureSize(shading,0);\\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\\n    color *= shadowFactor;\\n#endif\\n    gl_FragColor = gl_FragColor * vec4( color, opacity );\\n\\n    if(fogNear != fogFar) {\\n        float depth = -mvPosition.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n\\n}\\n\\n\\n\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\n\\nvarying vec3 vColor;\\nvarying vec3 vLightFront;\\nvarying vec3 vLightBack;\\nvarying vec4 mvPosition;\\n\\nvoid main() {\\n\\n    vColor = color;\\n\\n    vec3 objectNormal = normal;\\n    vec3 transformedNormal = normalMatrix * objectNormal;\\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n    vLightFront = vec3( 0.0 );\\n    vLightBack = vec3( 0.0 );\\n\\n    transformedNormal = normalize( transformedNormal );\\n\\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\\n    vec3 dirVector = normalize( lDirection.xyz );\\n    float dotProduct = dot( transformedNormal, dirVector );\\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;\\n    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;\\n\\n    gl_Position = projectionMatrix * mvPosition;\\n}\\n\\n\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    directionalLightColor: { type: 'fv', value: [] as number[] },\n    directionalLightDirection: { type: 'fv', value: [] as number[] }\n}\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from \"./uniforms\";\nimport fragmentShader from \"./outline.frag\";\nimport vertexShader from \"./outline.vert\";\n\n//import fs from \"fs\";\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/outline.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/outline.vert\", \"utf8\");\n\nexport const outline: Shader = {\n  fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n  vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n  uniforms,\n};\n", "export default \"\\n\\nuniform float opacity;\\nuniform vec3 outlineColor;\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\n\\nvarying vec4 mvPosition;\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n    gl_FragColor = vec4( outlineColor, 1 );\\n\\n    if(fogNear != fogFar) {\\n        float depth = -mvPosition.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n}\\n\\n\\n\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float outlineWidth;\\nuniform float outlinePushback;\\nuniform float vWidth;\\nuniform float vHeight;\\nuniform float outlineMaxPixels;\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\n\\nvarying vec4 mvPosition;\\n\\nvoid main() {\\n\\n    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);\\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n    mvPosition.xy += norm.xy*outlineWidth;\\n    vec4 outpos = projectionMatrix * mvPosition;\\n\\n    if(outlineMaxPixels > 0.0) {\\n        vec4 unadjusted = projectionMatrix*modelViewMatrix * vec4( position, 1.0 );\\n        float w = outpos.w;\\n        //normalize homogeneous coords\\n        unadjusted /= unadjusted.w;\\n        outpos /= outpos.w;\\n        vec2 diff = outpos.xy-unadjusted.xy;\\n        //put into pixels\\n        diff.x *= vWidth;\\n        diff.y *= vHeight;\\n        if ( length(diff) > outlineMaxPixels) {\\n            vec2 ndiff = normalize(diff)*outlineMaxPixels;\\n            ndiff.x /= vWidth;\\n            ndiff.y /= vHeight;\\n            outpos.xy = unadjusted.xy;\\n            outpos.xy += ndiff;\\n        }\\n        outpos *= w; //if I don't do this things blow up\\n    }\\n    gl_Position = outpos;\\n    mvPosition.z -= outlinePushback; //go backwards in model space\\n    vec4 pushpos = projectionMatrix*mvPosition; //project to get z in projection space, I'm probably missing some simple math to do the same thing..\\n    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;\\n}\\n\\n\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n  opacity: { type: \"f\", value: 1.0 },\n  outlineColor: { type: \"c\", value: new Color(0.0, 0.0, 0.0) },\n  fogColor: { type: \"c\", value: new Color(1.0, 1.0, 1.0) },\n  fogNear: { type: \"f\", value: 1.0 },\n  fogFar: { type: \"f\", value: 2000 },\n  outlineWidth: { type: \"f\", value: 0.1 },\n  outlinePushback: { type: \"f\", value: 1.0 },\n  outlineMaxPixels: {type: \"f\", value: 0.0 }\n};\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './screen.frag';\nimport vertexShader from './screen.vert';\n\nexport const screen: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "export default \"uniform sampler2D colormap;\\nvarying highp vec2 vTexCoords;\\nuniform vec2 dimensions;\\n//DEFINEFRAGCOLOR\\nvoid main (void) {\\n   gl_FragColor = texture2D(colormap, vTexCoords);\\n\\n   //gl_FragColor.g = gl_FragColor.b =  gl_FragColor.r; //debug shading \\n}\\n        \";", "export default \"attribute vec2 vertexPosition;\\nvarying highp vec2 vTexCoords;\\nconst vec2 scale = vec2(0.5, 0.5);\\n\\nvoid main() {\\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\\n}\\n        \";", "export const uniforms = {}\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from \"./uniforms\"\nimport fragmentShader from \"./screenaa.frag\"\nimport vertexShader from \"./screenaa.vert\"\n\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/screenaa.frag\", \"utf8\")\n//const vertexShader = fs.readFileSync(__dirname + \"/screenaa.vert\", \"utf8\")\n\nexport const screenaa: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}\n", "export default \"\\n        \\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\n\\nuniform sampler2D tColor;\\nvarying highp vec2 vTexCoords;\\n\\n// adapted from https://github.com/kosua20/Rendu\\n// MIT License Copyright (c) 2017 Simon Rodriguez\\n// by way of molstar (https://github.com/molstar/molstar/blob/master/src/mol-gl/shader/fxaa.frag.ts)\\n\\n#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\\n\\nfloat rgb2luma(vec3 rgb){\\n    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));\\n}\\n\\nfloat sampleLuma(vec2 uv) {\\n    return rgb2luma(texture2D(tColor, uv).rgb);\\n}\\n\\nfloat sampleLuma(vec2 uv, float uOffset, float vOffset) {\\n    uv += vec2(uOffset, vOffset);\\n    return sampleLuma(uv);\\n}\\n\\n//DEFINEFRAGCOLOR\\nvoid main(void) {\\n    ivec2 dim = textureSize(tColor,0);\\n    vec2 dimensions = vec2(float(dim.x),float(dim.y));\\n    vec2 inverseScreenSize = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);\\n    vec2 coords = vTexCoords;\\n\\n    vec4 colorCenter = texture2D(tColor, coords);\\n    float dEdgeThresholdMin = 0.0312;\\n    float dEdgeThresholdMax = 0.125;\\n    int dIterations = 12;\\n    float dSubpixelQuality = 0.3;\\n\\n    // Luma at the current fragment\\n    float lumaCenter = rgb2luma(colorCenter.rgb);\\n\\n    // Luma at the four direct neighbours of the current fragment.\\n    float lumaDown = sampleLuma(coords, 0.0, -inverseScreenSize.y);\\n    float lumaUp = sampleLuma(coords, 0.0, inverseScreenSize.y);\\n    float lumaLeft = sampleLuma(coords, -inverseScreenSize.x, 0.0);\\n    float lumaRight = sampleLuma(coords, inverseScreenSize.x, 0.0);\\n\\n    // Find the maximum and minimum luma around the current fragment.\\n    float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));\\n    float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));\\n\\n    // Compute the delta.\\n    float lumaRange = lumaMax - lumaMin;\\n\\n    // If the luma variation is lower that a threshold (or if we are in a really dark area),\\n    // we are not on an edge, don't perform any AA.\\n    if (lumaRange < max(dEdgeThresholdMin, lumaMax * dEdgeThresholdMax)) {\\n        gl_FragColor = colorCenter;\\n        return;\\n    }\\n\\n    // Query the 4 remaining corners lumas.\\n    float lumaDownLeft = sampleLuma(coords, -inverseScreenSize.x, -inverseScreenSize.y);\\n    float lumaUpRight = sampleLuma(coords, inverseScreenSize.x, inverseScreenSize.y);\\n    float lumaUpLeft = sampleLuma(coords, -inverseScreenSize.x, inverseScreenSize.y);\\n    float lumaDownRight = sampleLuma(coords, inverseScreenSize.x, -inverseScreenSize.y);\\n\\n    // Combine the four edges lumas (using intermediary variables for future computations\\n    // with the same values).\\n    float lumaDownUp = lumaDown + lumaUp;\\n    float lumaLeftRight = lumaLeft + lumaRight;\\n\\n    // Same for corners\\n    float lumaLeftCorners = lumaDownLeft + lumaUpLeft;\\n    float lumaDownCorners = lumaDownLeft + lumaDownRight;\\n    float lumaRightCorners = lumaDownRight + lumaUpRight;\\n    float lumaUpCorners = lumaUpRight + lumaUpLeft;\\n\\n    // Compute an estimation of the gradient along the horizontal and vertical axis.\\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaLeftCorners) + abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 + abs(-2.0 * lumaRight + lumaRightCorners);\\n    float edgeVertical = abs(-2.0 * lumaUp + lumaUpCorners) + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 + abs(-2.0 * lumaDown + lumaDownCorners);\\n\\n    // Is the local edge horizontal or vertical ?\\n    bool isHorizontal = (edgeHorizontal >= edgeVertical);\\n\\n    // Choose the step size (one pixel) accordingly.\\n    float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;\\n\\n    // Select the two neighboring texels lumas in the opposite direction to the local edge.\\n    float luma1 = isHorizontal ? lumaDown : lumaLeft;\\n    float luma2 = isHorizontal ? lumaUp : lumaRight;\\n    // Compute gradients in this direction.\\n    float gradient1 = luma1 - lumaCenter;\\n    float gradient2 = luma2 - lumaCenter;\\n\\n    // Which direction is the steepest ?\\n    bool is1Steepest = abs(gradient1) >= abs(gradient2);\\n\\n    // Gradient in the corresponding direction, normalized.\\n    float gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));\\n\\n    // Average luma in the correct direction.\\n    float lumaLocalAverage = 0.0;\\n    if(is1Steepest){\\n        // Switch the direction\\n        stepLength = -stepLength;\\n        lumaLocalAverage = 0.5 * (luma1 + lumaCenter);\\n    } else {\\n        lumaLocalAverage = 0.5 * (luma2 + lumaCenter);\\n    }\\n\\n    // Shift UV in the correct direction by half a pixel.\\n    vec2 currentUv = coords;\\n    if(isHorizontal){\\n        currentUv.y += stepLength * 0.5;\\n    } else {\\n        currentUv.x += stepLength * 0.5;\\n    }\\n\\n    // Compute offset (for each iteration step) in the right direction.\\n    vec2 offset = isHorizontal ? vec2(inverseScreenSize.x, 0.0) : vec2(0.0, inverseScreenSize.y);\\n    // Compute UVs to explore on each side of the edge, orthogonally.\\n    // The QUALITY allows us to step faster.\\n    vec2 uv1 = currentUv - offset * QUALITY(0);\\n    vec2 uv2 = currentUv + offset * QUALITY(0);\\n\\n    // Read the lumas at both current extremities of the exploration segment,\\n    // and compute the delta wrt to the local average luma.\\n    float lumaEnd1 = sampleLuma(uv1);\\n    float lumaEnd2 = sampleLuma(uv2);\\n    lumaEnd1 -= lumaLocalAverage;\\n    lumaEnd2 -= lumaLocalAverage;\\n\\n    // If the luma deltas at the current extremities is larger than the local gradient,\\n    // we have reached the side of the edge.\\n    bool reached1 = abs(lumaEnd1) >= gradientScaled;\\n    bool reached2 = abs(lumaEnd2) >= gradientScaled;\\n    bool reachedBoth = reached1 && reached2;\\n\\n    // If the side is not reached, we continue to explore in this direction.\\n    if(!reached1){\\n        uv1 -= offset * QUALITY(1);\\n    }\\n    if(!reached2){\\n        uv2 += offset * QUALITY(1);\\n    }\\n\\n    // If both sides have not been reached, continue to explore.\\n    if(!reachedBoth){\\n        for(int i = 2; i < dIterations; i++){\\n            // If needed, read luma in 1st direction, compute delta.\\n            if(!reached1){\\n                lumaEnd1 = sampleLuma(uv1);\\n                lumaEnd1 = lumaEnd1 - lumaLocalAverage;\\n            }\\n            // If needed, read luma in opposite direction, compute delta.\\n            if(!reached2){\\n                lumaEnd2 = sampleLuma(uv2);\\n                lumaEnd2 = lumaEnd2 - lumaLocalAverage;\\n            }\\n            // If the luma deltas at the current extremities is larger than the local gradient,\\n            // we have reached the side of the edge.\\n            reached1 = abs(lumaEnd1) >= gradientScaled;\\n            reached2 = abs(lumaEnd2) >= gradientScaled;\\n            reachedBoth = reached1 && reached2;\\n\\n            // If the side is not reached, we continue to explore in this direction,\\n            // with a variable quality.\\n            if(!reached1){\\n                uv1 -= offset * QUALITY(i);\\n            }\\n            if(!reached2){\\n                uv2 += offset * QUALITY(i);\\n            }\\n\\n            // If both sides have been reached, stop the exploration.\\n            if(reachedBoth){\\n                break;\\n            }\\n        }\\n    }\\n\\n    // Compute the distances to each side edge of the edge (!).\\n    float distance1 = isHorizontal ? (coords.x - uv1.x) : (coords.y - uv1.y);\\n    float distance2 = isHorizontal ? (uv2.x - coords.x) : (uv2.y - coords.y);\\n\\n    // In which direction is the side of the edge closer ?\\n    bool isDirection1 = distance1 < distance2;\\n    float distanceFinal = min(distance1, distance2);\\n\\n    // Thickness of the edge.\\n    float edgeThickness = (distance1 + distance2);\\n\\n    // Is the luma at center smaller than the local average ?\\n    bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;\\n\\n    // If the luma at center is smaller than at its neighbour,\\n    // the delta luma at each end should be positive (same variation).\\n    bool correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;\\n    bool correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;\\n\\n    // Only keep the result in the direction of the closer side of the edge.\\n    bool correctVariation = isDirection1 ? correctVariation1 : correctVariation2;\\n\\n    // UV offset: read in the direction of the closest side of the edge.\\n    float pixelOffset = - distanceFinal / edgeThickness + 0.5;\\n\\n    // If the luma variation is incorrect, do not offset.\\n    float finalOffset = correctVariation ? pixelOffset : 0.0;\\n\\n    // Sub-pixel shifting\\n    // Full weighted average of the luma over the 3x3 neighborhood.\\n    float lumaAverage = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);\\n    // Ratio of the delta between the global average and the center luma,\\n    // over the luma range in the 3x3 neighborhood.\\n    float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter) / lumaRange, 0.0, 1.0);\\n    float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;\\n    // Compute a sub-pixel offset based on this delta.\\n    float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * float(dSubpixelQuality);\\n\\n    // Pick the biggest of the two offsets.\\n    finalOffset = max(finalOffset, subPixelOffsetFinal);\\n\\n    // Compute the final UV coordinates.\\n    vec2 finalUv = coords;\\n    if(isHorizontal){\\n        finalUv.y += finalOffset * stepLength;\\n    } else {\\n        finalUv.x += finalOffset * stepLength;\\n    }\\n\\n    // Read the color at the new UV coordinates, and use it.\\n    gl_FragColor = texture2D(tColor, finalUv);\\n}        \\n\\n/* old fxaa implementation\\nuniform highp sampler2D colormap;\\nvarying highp vec2 vTexCoords;\\n\\n\\n// Basic FXAA implementation based on the code on geeks3d.com \\n#define FXAA_REDUCE_MIN (1.0/ 128.0)\\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\\n#define FXAA_SPAN_MAX 8.0\\n\\n\\nvec4 applyFXAA(vec2 fragCoord, highp sampler2D tex)\\n{\\n    vec4 color;\\n    ivec2 dim = textureSize(tex,0);\\n    vec2 dimensions = vec2(float(dim.x),float(dim.y));\\n    vec2 inverseVP = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);\\n    vec4 rgbNW = texture2D(tex, fragCoord + vec2(-1.0, -1.0) * inverseVP);\\n    vec4 rgbNE = texture2D(tex, fragCoord + vec2(1.0, -1.0) * inverseVP);\\n    vec4 rgbSW = texture2D(tex, fragCoord + vec2(-1.0, 1.0) * inverseVP);\\n    vec4 rgbSE = texture2D(tex, fragCoord + vec2(1.0, 1.0) * inverseVP);\\n    vec4 rgbM  = texture2D(tex, fragCoord );\\n    vec3 luma = vec3(0.299, 0.587, 0.114);\\n    float lumaNW = dot(rgbNW.xyz, luma);\\n    float lumaNE = dot(rgbNE.xyz, luma);\\n    float lumaSW = dot(rgbSW.xyz, luma);\\n    float lumaSE = dot(rgbSE.xyz, luma);\\n    float lumaM  = dot(rgbM.xyz,  luma);\\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n    vec2 dir;\\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\\n                        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n\\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n            dir * rcpDirMin)) * inverseVP;\\n\\n    vec4 rgbA = 0.5 * (\\n        texture2D(tex, fragCoord + dir * (1.0 / 3.0 - 0.5)) +\\n        texture2D(tex, fragCoord  + dir * (2.0 / 3.0 - 0.5)));\\n    vec4 rgbB = rgbA * 0.5 + 0.25 * (\\n        texture2D(tex, fragCoord  + dir * -0.5) +\\n        texture2D(tex, fragCoord  + dir * 0.5));\\n\\n    float lumaB = dot(rgbB.xyz, luma);\\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\\n        color = rgbA;\\n    else\\n        color = rgbB;\\n\\n    return color;\\n}\\n\\n\\n//DEFINEFRAGCOLOR\\nvoid main (void) {\\n    ivec2 dim = textureSize(colormap,0);\\n\\n  gl_FragColor = applyFXAA(vTexCoords, colormap);\\n}\\n        \\n*/\";", "export default \"attribute vec2 vertexPosition;\\nvarying highp vec2 vTexCoords;\\nconst vec2 scale = vec2(0.5, 0.5);\\n\\nvoid main() {\\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\\n}\\n        \";", "export const uniforms = {}\n", "import { uniforms } from './uniforms';\nimport { Shader } from '../../ShaderType';\nimport fragmentShader from './sphereimposter.frag';\nimport vertexShader from './sphereimposter.vert';\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"./sphereimposter.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"./sphereimposter.vert\", \"utf8\");\n\n\nexport const sphereimposter: Shader = {\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "export default \"\\nuniform mat4 viewMatrix;\\nuniform float opacity;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float uDepth;\\nuniform vec3 directionalLightColor[ 1 ];\\n\\nvarying vec3 vColor;\\nvarying vec2 mapping;\\nvarying float rval;\\nvarying vec3 vLight;\\nvarying vec3 center;\\n\\n#ifdef SHADED\\nuniform highp sampler2D shading;\\n#endif\\n\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n    float lensqr = dot(mapping,mapping);\\n    float rsqr = rval*rval;\\n    if(lensqr > rsqr)\\n       discard;\\n    float z = sqrt(rsqr-lensqr);\\n    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);\\n    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);\\n    float ndcDepth = clipPos.z / clipPos.w;\\n    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\\n    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));\\n    float dotProduct = dot( norm, vLight );\\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;\\n    vec3 color = vLight*vColor;\\n#ifdef SHADED\\n    ivec2 dim = textureSize(shading,0);\\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\\n    color *= shadowFactor;\\n#endif    \\n    gl_FragColor = vec4(color, opacity*opacity );\\n\\n    if(fogNear != fogFar) {\\n        float depth = -cameraPos.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n     \\n}\\n\\n\";", "export default \"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\n\\nvarying vec2 mapping;\\nvarying vec3 vColor;\\nvarying float rval;\\nvarying vec3 vLight;\\nvarying vec3 center;\\n\\nvoid main() {\\n\\n    vColor = color;\\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n    center = mvPosition.xyz;\\n    vec4 projPosition = projectionMatrix * mvPosition;\\n    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;\\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\\n    vLight = normalize( lDirection.xyz );\\n    mapping = normal.xy;\\n    rval = abs(normal.x);\\n    gl_Position = projPosition+adjust;\\n\\n}\\n\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    directionalLightColor: { type: 'fv', value: [] as number[] },\n    directionalLightDirection: { type: 'fv', value: [] as number[] }\n}\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from \"./uniforms\";\nimport fragmentShader from \"./sphereimposteroutline.frag\";\nimport vertexShader from \"./sphereimposteroutline.vert\";\n//import fs from 'fs';\n//const fragmentShader = fs.readFileSync(__dirname + \"/sphereimposteroutline.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/sphereimposteroutline.vert\", \"utf8\");\n\nexport const sphereimposteroutline: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "export default \"\\n\\nuniform float opacity;\\nuniform vec3 outlineColor;\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform mat4 projectionMatrix;\\nvarying vec2 mapping;\\nvarying float rval;\\nvarying vec3 center;\\n\\nuniform float outlinePushback;\\n\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n    float lensqr = dot(mapping,mapping);\\n    float rsqr = rval*rval;\\n    if(lensqr > rsqr)\\n       discard;\\n    float z = sqrt(rsqr-lensqr);\\n    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);\\n    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);\\n    float ndcDepth = clipPos.z / clipPos.w;\\n    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\\n    gl_FragColor = vec4(outlineColor, 1 );\\n\\n    if(fogNear != fogFar) {\\n        float depth = -cameraPos.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n}\\n\\n\\n\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float outlineWidth;\\nuniform float outlinePushback;\\nuniform float outlineMaxPixels;\\nuniform float vWidth;\\nuniform float vHeight;\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\n\\nvarying vec2 mapping;\\nvarying float rval;\\nvarying vec3 center;\\n\\nvoid main() {\\n\\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n    center = mvPosition.xyz;\\n    vec4 projPosition = projectionMatrix * mvPosition;\\n    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);\\n\\n    vec4 adjust = projectionMatrix* vec4(norm,normal.z,1.0); \\n    mapping = norm.xy;\\n    rval = abs(norm.x);\\n    gl_Position = projPosition+vec4(adjust.xy,0.0,0.0);\\n\\n    if(outlineMaxPixels > 0.0) {\\n        vec4 unadjusted = projectionMatrix*vec4(center.x+normal.x, center.y,center.z,1.0); \\n        vec4 ccoord = projectionMatrix*vec4(center.xyz,1.0);\\n        adjust = projectionMatrix* vec4(center.x+norm.x,center.y,center.z,1.0); \\n        //subtract center \\n        unadjusted.xyz -= ccoord.xyz;\\n        adjust.xyz -= ccoord.xyz;\\n        unadjusted /= unadjusted.w;\\n        adjust /= adjust.w;\\n        float diff = abs(adjust.x-unadjusted.x);\\n        diff *= vWidth;\\n        if(diff > outlineMaxPixels) {\\n            \\n            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth;\\n            //adjsut reval by ratio of lengths\\n            rval *= fixlen/abs(adjust.x);\\n        }\\n\\n    }\\n}\\n\\n\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    outlineColor: { type: 'c', value: new Color(0.0, 0.0, 0.0) },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    outlineWidth: { type: 'f', value: 0.1 },\n    outlinePushback: { type: 'f', value: 1.0 },\n    outlineMaxPixels: { type: 'f', value: 0.0 }\n}", "import { Shader } from '../../ShaderType';\nimport { uniforms } from \"./uniforms\"\n//import { fragmentShader, vertexShader } from \"./shaders\"\nimport fragmentShader from \"./sprite.frag\"\nimport vertexShader from \"./sprite.vert\"\n\n\n//const fragmentShader = fs.readFileSync(path.resove(__dirname, \"./sprite.frag\"), \"utf8\")\n//const vertexShader = fs.readFileSync(path.resove(__dirname, \"./sprite.vert\"), \"utf8\")\n\nexport const sprite: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "export default \"\\n\\nuniform vec3 color;\\nuniform sampler2D map;\\nuniform float opacity;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float alphaTest;\\n\\nvarying vec2 vUV;\\n//DEFINEFRAGCOLOR\\n\\nvoid main() {\\n\\n    vec4 texture = texture2D(map, vUV);\\n\\n    if (texture.a <= alphaTest) discard;\\n\\n    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);\\n\\n    if (fogNear != fogFar) {\\n\\n        float depth = gl_FragCoord.z / gl_FragCoord.w; //probably wrong\\n        float fogFactor = smoothstep(fogNear, fogFar, depth);        \\n        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);\\n    }\\n}\\n\\n\";", "export default \"\\n\\nuniform int useScreenCoordinates;\\nuniform vec3 screenPosition;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float rotation;\\nuniform vec2 scale;\\nuniform vec2 alignment;\\nuniform vec2 uvOffset;\\nuniform vec2 uvScale;\\n\\nattribute vec2 position;\\nattribute vec2 uv;\\n\\nvarying vec2 vUV;\\n\\nvoid main() {\\n\\n    vUV = uvOffset + uv * uvScale;\\n\\n    vec2 alignedPosition = position + alignment;\\n\\n    vec2 rotatedPosition;\\n    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;\\n    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;\\n\\n    vec4 finalPosition;\\n\\n    if(useScreenCoordinates != 0) {\\n        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);\\n    }\\n\\n    else {\\n        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;\\n        finalPosition.xy += rotatedPosition; \\n    }\\n\\n    gl_Position = finalPosition;\\n\\n}\\n\\n\";", "export const uniforms = {}", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport fragmentShader from './ssao.frag';\nimport vertexShader from './ssao.vert';\n\nexport const ssao: Shader = {\n    fragmentShader: fragmentShader,\n    vertexShader: vertexShader,\n    uniforms\n}", "export default \"uniform sampler2D depthmap;\\nvarying highp vec2 vTexCoords;\\nuniform float vWidth;\\nuniform float vHeight;\\nuniform float total_strength;\\nuniform float radius;\\nuniform mat4 projinv;\\nuniform mat4 projectionMatrix;\\n\\n//code for pseudorandom vector from chatgpt\\nfloat hash(vec3 p) {\\n    p = fract(p * vec3(0.1031, 0.1030, 0.0973));\\n    p += dot(p, p.yzx + 33.33);\\n    return fract((p.x + p.y) * p.z);\\n}\\n\\n// Generate a pseudorandom vec3 from a seed vec3\\nvec3 pseudorandomVec3(vec3 seed) {\\n    vec3 randomVec;\\n    randomVec.x = hash(seed);\\n    randomVec.y = hash(seed + vec3(1.0, 0.0, 17.1));\\n    randomVec.z = hash(seed + vec3(0.0, 13.23, 0.0));\\n    return randomVec;\\n}\\n\\nvoid main(void)\\n{   \\n   const float base = 0.2;\\n   const float area = 0.75;\\n   const int cycles = 1;\\n\\n   const int samples = 64;\\n   vec3 sample_sphere[64] = vec3[](\\n      vec3(0.091258,-0.510164,0.000000),\\n      vec3(-0.204347,-0.872967,0.187199),\\n      vec3(0.009690,-0.263696,-0.110414),\\n      vec3(0.175208,-0.563987,0.228527),\\n      vec3(-0.001824,-0.003113,-0.000323),\\n      vec3(0.411134,-0.719869,-0.261530),\\n      vec3(-0.074272,-0.377368,0.276290),\\n      vec3(-0.147773,-0.381587,-0.284529),\\n      vec3(0.173317,-0.199635,0.063295),\\n      vec3(-0.186452,-0.199460,0.076965),\\n      vec3(0.143985,-0.308160,-0.307687),\\n      vec3(0.053194,-0.148286,0.169589),\\n      vec3(-0.547656,-0.486476,-0.317378),\\n      vec3(0.020804,-0.015092,-0.004574),\\n      vec3(-0.038006,-0.043165,0.054059),\\n      vec3(-0.094795,-0.443908,-0.731525),\\n      vec3(0.547552,-0.396466,0.461477),\\n      vec3(-0.176886,-0.089989,0.007315),\\n      vec3(0.074401,-0.048840,-0.074039),\\n      vec3(-0.008240,-0.075697,0.178197),\\n      vec3(-0.307880,-0.185053,-0.368943),\\n      vec3(0.309520,-0.108483,0.041646),\\n      vec3(-0.773478,-0.292946,0.538166),\\n      vec3(0.184487,-0.231594,-0.820065),\\n      vec3(0.207318,-0.100531,0.361797),\\n      vec3(-0.173306,-0.037737,-0.055289),\\n      vec3(0.548102,-0.105342,-0.253237),\\n      vec3(-0.119342,-0.043907,0.285162),\\n      vec3(-0.270247,-0.087861,-0.751357),\\n      vec3(0.449312,-0.039777,0.236146),\\n      vec3(-0.743773,-0.036095,0.196056),\\n      vec3(0.148819,-0.004300,-0.231448),\\n      vec3(0.008773,0.000809,0.051047),\\n      vec3(-0.461467,0.027390,-0.357386),\\n      vec3(0.169626,0.013338,-0.014053),\\n      vec3(-0.043786,0.007095,0.047331),\\n      vec3(0.004821,0.140371,-0.988260),\\n      vec3(0.092402,0.023994,0.101860),\\n      vec3(-0.295335,0.061530,-0.027372),\\n      vec3(0.024903,0.007537,-0.018901),\\n      vec3(-0.081463,0.125402,0.447794),\\n      vec3(-0.397119,0.231805,-0.631062),\\n      vec3(0.163853,0.059014,0.044905),\\n      vec3(-0.495220,0.214357,0.254139),\\n      vec3(0.306123,0.373687,-0.825715),\\n      vec3(0.021665,0.026737,0.053220),\\n      vec3(-0.208231,0.117129,-0.098685),\\n      vec3(0.139749,0.080968,-0.043086),\\n      vec3(-0.153599,0.182814,0.262090),\\n      vec3(-0.159673,0.496777,-0.743568),\\n      vec3(0.134797,0.117152,0.095753),\\n      vec3(-0.155626,0.120533,0.019395),\\n      vec3(0.042311,0.054462,-0.049709),\\n      vec3(0.001257,0.031288,0.034468),\\n      vec3(-0.002271,0.003199,-0.002304),\\n      vec3(0.662104,0.717307,0.033854),\\n      vec3(-0.373100,0.576021,0.308274),\\n      vec3(0.024233,0.231316,-0.173688),\\n      vec3(0.161311,0.420217,0.234273),\\n      vec3(-0.045248,0.078031,-0.010411),\\n      vec3(0.167453,0.376942,-0.094872),\\n      vec3(-0.056194,0.433247,0.173218),\\n      vec3(-0.016224,0.123149,-0.035569),\\n      vec3(0.067127,0.407641,0.028479)\\n   );\\n\\n   float depth = texture2D(depthmap, vTexCoords).r;\\n   if(depth == 1.0) {\\n      discard;\\n   }\\n\\n   vec4 screen_position = vec4(vTexCoords, depth,1.0);\\n   vec4 pos = projinv*screen_position;\\n   pos /= pos.w;\\n   vec3 position = pos.xyz;\\n\\n   //approximate the normal from the depth map; I find this simpler\\n   //than trying to recompute the exact normal within every possible object shader\\n\\n   //pixel offset positions in screen space\\n   ivec2 dim = textureSize(depthmap,0);\\n   vec2 offset1 = vec2(0.0,1.0/float(dim.y));\\n   vec2 offset2 = vec2(1.0/float(dim.x),0.0);\\n   float depth1 = texture2D(depthmap, vTexCoords + offset1).r;\\n   float depth2 = texture2D(depthmap, vTexCoords + offset2).r;\\n   \\n   vec3 p1 = vec3(screen_position.xy+offset1, depth1 - depth);\\n   vec3 p2 = vec3(screen_position.xy+offset2, depth2 - depth);\\n\\n   //convert to model space\\n   vec4 pos1 = projinv*vec4(p1,1);\\n   pos1 /= pos1.w;\\n   vec4 pos2 = projinv*vec4(p2,1);\\n   pos2 /= pos2.w;\\n\\n   vec3 normal = normalize(cross(pos1.xyz-position, pos2.xyz-position)); //model normal, important we normalize in model space\\n\\n   //pseudo random number\\n\\n   float occlusion = 0.0;\\n   for(int c = 0; c < cycles; c++) {\\n   vec3 random = normalize(pseudorandomVec3(position+float(c)));\\n   for(int i=0; i < samples; i++) {\\n\\n      vec3 ray = radius * reflect(sample_sphere[i],random);\\n      vec3 hemi_ray = position + sign(dot(ray,normal)) * ray; //model space\\n      vec4 hemi_screen = projectionMatrix*vec4(hemi_ray,1.0);\\n      hemi_screen /= hemi_screen.w;\\n      \\n      float occ_depth = texture2D(depthmap, clamp(hemi_screen.xy,0.0,1.0)).r;\\n      float difference = hemi_screen.z - occ_depth;\\n      \\n      occlusion += step(0.0, difference) * (1.0-smoothstep(0.0, area, difference));\\n   }\\n   }\\n   float ao = 1.0 - total_strength * occlusion * (1.0 / float(cycles*samples));\\n   gl_FragDepthEXT = clamp(ao+base,0.0,1.0);\\n\\n}\";", "export default \"attribute vec2 vertexPosition;\\nvarying highp vec2 vTexCoords;\\nconst vec2 scale = vec2(0.5, 0.5);\\n\\nvoid main() {\\n   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range\\n   gl_Position = vec4(vertexPosition, 0.0, 1.0);\\n}\\n        \";", "import { Matrix4 } from \"WebGL/math\";\n\nexport const uniforms = {\n    total_strength: { type: 'f', value: 1.0 },\n    radius: { type: 'f', value: 5},    \n    projinv: { type: 'mat4', value: [] as Matrix4[] },\n\n};\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport stickimposterFragmentShaderStart from './stickimposterFragmentShader.partial.frag';\nimport stickimposterFragmentShaderEnd from './stickimposter.partial.frag';\nimport vertexShader from './stickimposter.vert';\n\nconst fragmentShader = [stickimposterFragmentShaderStart, stickimposterFragmentShaderEnd].join('\\n');\n\nexport const stickimposter: Shader = {\n    fragmentShader: fragmentShader,\n    vertexShader: vertexShader,\n    uniforms\n}", "export default \"    float dotProduct = dot( norm, vLight );\\n    vec3 light = vec3( max( dotProduct, 0.0 ) );\\n    color *= light;\\n#ifdef SHADED\\n    ivec2 dim = textureSize(shading,0);\\n    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;\\n    color *= shadowFactor;\\n#endif    \\n    gl_FragColor = vec4(color, opacity*opacity );\\n    if(fogNear != fogFar) {\\n        float depth = -qi.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n}\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\nattribute float radius;\\n\\nvarying vec3 vColor;\\nvarying vec3 vLight;\\nvarying vec3 cposition;\\nvarying vec3 p1;\\nvarying vec3 p2;\\nvarying float r;\\n\\nvoid main() {\\n\\n    vColor = color; vColor.z = abs(vColor.z); //z indicates which vertex and so would vary\\n    r = abs(radius);\\n    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder\\n    vec4 pt = modelViewMatrix*vec4(position, 1.0);\\n    vec4 mvPosition = pt;\\n    p1 = pt.xyz; p2 = to.xyz;\\n    vec3 norm = to.xyz-pt.xyz;\\n    float mult = 1.1; //slop to account for perspective of sphere\\n    if(length(p1) > length(p2)) { //billboard at level of closest point\\n       mvPosition = to;\\n    }\\n    vec3 n = normalize(mvPosition.xyz);\\n    bool isperspective = (projectionMatrix[3][3] == 0.0);\\n//intersect with the plane defined by the camera looking at the billboard point\\n    if(color.z >= 0.0) { //p1\\n       if(isperspective) { //perspective\\n         vec3 pnorm = normalize(p1);\\n         float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);\\n         mvPosition.xyz = p1+t*pnorm; \\n       } else { //orthographic\\n         mvPosition.xyz = p1;\\n       }\\n    } else {\\n      if(isperspective) { //perspective\\n         vec3 pnorm = normalize(p2);\\n         float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);\\n         mvPosition.xyz = p2+t*pnorm;\\n       } else { //orthographic\\n         mvPosition.xyz = p2;\\n       } \\n       mult *= -1.0;\\n    }\\n\\n    if(isperspective) { //perspective\\n      vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;\\n      vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;\\n      mvPosition.xyz +=  mult*(cr + doublecr).xyz;\\n    } else {\\n      vec3 cr = normalize(cross(vec3(0.0,0.0,-1.0),norm))*radius;\\n      vec3 doublecr = normalize(cross(vec3(0.0,0.0,-1.0),cr))*radius;\\n      mvPosition.xyz +=  mult*(cr + doublecr).xyz;     \\n    }\\n\\n    cposition = mvPosition.xyz;\\n    gl_Position = projectionMatrix * mvPosition;\\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );\\n    vLight = normalize( lDirection.xyz )*directionalLightColor[0]; //not really sure this is right, but color is always white so..\\n}\\n\\n\";", "export default \"uniform float opacity;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec3 fogColor;\\nuniform float fogNear;\\nuniform float fogFar;\\n\\nvarying vec3 vLight;\\nvarying vec3 vColor;\\nvarying vec3 cposition;\\nvarying vec3 p1;\\nvarying vec3 p2;\\nvarying float r;\\n\\n#ifdef SHADED\\nuniform highp sampler2D shading;\\n#endif\\n\\n//DEFINEFRAGCOLOR\\n\\n//cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf\\n//also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl\\n//with a bit more care (caps) this could be a general cylinder imposter (see also outline)\\nvoid main() {\\n    vec3 color = abs(vColor);\\n    vec3 pos = cposition;\\n    vec3 p = pos; //ray point\\n    vec3 v = vec3(0.0,0.0,-1.0); //ray normal - orthographic\\n    if(projectionMatrix[3][3] == 0.0) v = normalize(pos); //ray normal - perspective\\n    vec3 pa = p1; //cyl start\\n    vec3 va = normalize(p2-p1); //cyl norm\\n    vec3 tmp1 = v-(dot(v,va)*va);\\n    vec3 deltap = p-pa;\\n    float A = dot(tmp1,tmp1);\\n    if(A == 0.0) discard;\\n    vec3 tmp2 = deltap-(dot(deltap,va)*va);\\n    float B = 2.0*dot(tmp1, tmp2);\\n    float C = dot(tmp2,tmp2)-r*r;\\n//quadratic equation!\\n    float det = (B*B) - (4.0*A*C);\\n    if(det < 0.0) discard;\\n    float sqrtDet = sqrt(det);\\n    float posT = (-B+sqrtDet)/(2.0*A);\\n    float negT = (-B-sqrtDet)/(2.0*A);\\n    float intersectionT = min(posT,negT);\\n    vec3 qi = p+v*intersectionT;\\n    float dotp1 = dot(va,qi-p1);\\n    float dotp2 = dot(va,qi-p2);\\n    vec3 norm;\\n    if( dotp1 < 0.0 || dotp2 > 0.0) { //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0\\n       vec3 cp;\\n       if( dotp1 < 0.0) {  \\n//        if(vColor.x < 0.0 ) discard; //color sign bit indicates if we should cap or not\\n        cp = p1;\\n       } else {\\n//          if(vColor.y < 0.0 ) discard;\\n          cp = p2;\\n       }\\n       vec3 diff = p-cp;\\n       A = dot(v,v);\\n       B = dot(diff,v)*2.0;\\n       C = dot(diff,diff)-r*r;\\n       det = (B*B) - (4.0*C);\\n       if(det < 0.0) discard;\\n       sqrtDet = sqrt(det);\\n       posT = (-B+sqrtDet)/(2.0);\\n       negT = (-B-sqrtDet)/(2.0);\\n       float t = min(posT,negT);\\n       qi = p+v*t; \\n       norm = normalize(qi-cp); \\n    } else {\\n       norm = normalize(qi-(dotp1*va + p1));\\n    }\\n    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);\\n    float ndcDepth = clipPos.z / clipPos.w;\\n    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\\n    gl_FragDepthEXT = depth;\";", "import { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    directionalLightColor: { type: 'fv', value: [] as number[] },\n    directionalLightDirection: { type: 'fv', value: [] as number[] }\n}\n", "import { Shader } from '../../ShaderType';\nimport { uniforms } from './uniforms';\nimport stickimposterFragmentShaderStart from \"../stickimposter/stickimposterFragmentShader.partial.frag\";\nimport stickimposterFragmentShaderEnd from './stickimposteroutline.partial.frag';\n\nimport vertexShader from \"./stickimposteroutline.vert\";\n\nconst fragmentShader = stickimposterFragmentShaderStart + stickimposterFragmentShaderEnd;\n\nexport const stickimposteroutline: Shader = {\n    fragmentShader: fragmentShader,\n    vertexShader: vertexShader,\n    uniforms\n}", "export default \"\\n    gl_FragColor = vec4(color, opacity*opacity );\\n    if(fogNear != fogFar) {\\n        float depth = -qi.z;\\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n    }\\n}\";", "export default \"\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 directionalLightColor[ 1 ];\\nuniform vec3 directionalLightDirection[ 1 ];\\nuniform vec3 outlineColor;\\nuniform float outlineWidth;\\nuniform float outlinePushback;\\nuniform float outlineMaxPixels;\\nuniform float vWidth;\\nuniform mat4 projinv;\\n\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec3 color;\\nattribute float radius;\\n\\nvarying vec3 vColor;\\nvarying vec3 vLight;\\nvarying vec3 cposition;\\nvarying vec3 p1;\\nvarying vec3 p2;\\nvarying float r;\\n\\nvoid main() {\\n\\n    vColor = outlineColor;\\n    float rad = radius+sign(radius)*outlineWidth;\\n    r = abs(rad);\\n\\n    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder\\n    vec4 pt = modelViewMatrix*vec4(position, 1.0);\\n//pushback\\n    float scale = 1.0;\\n    if(projectionMatrix[3][3] != 0.0) { //orthographic\\n        to.z -= outlinePushback;\\n        pt.z -= outlinePushback;\\n    } else { //perspective\\n        vec4 midbefore = pt;\\n        if(length(to.xyz) < length(pt)) {\\n            midbefore = to;\\n        }\\n        vec4 midafter = midbefore;\\n        midafter.xyz += normalize(midbefore.xyz)*outlinePushback;\\n\\n        to.xyz += normalize(to.xyz)*outlinePushback;\\n        pt.xyz += normalize(pt.xyz)*outlinePushback;\\n\\n        //figure out a scaling factor for radius to account for perspective setback\\n        vec4 midbeforer = vec4(midbefore.x+rad,midbefore.y, midbefore.z, midbefore.w);\\n        vec4 midafterr = vec4(midafter.x+rad,midafter.y, midafter.z, midafter.w);\\n\\n        vec4 mb = projectionMatrix*midbefore;\\n        vec4 mbr = projectionMatrix*midbeforer;\\n        vec4 ma = projectionMatrix*midafter;\\n        vec4 mar = projectionMatrix*midafterr;\\n        mb /= mb.w;\\n        mbr /= mbr.w;\\n        ma /= ma.w;\\n        mar /= mar.w;\\n        scale = abs((mbr.x-mb.x)/(mar.x-ma.x));\\n        rad *= scale;\\n        r = abs(rad);\\n    }\\n    vec4 mvPosition = pt;\\n    p1 = pt.xyz; p2 = to.xyz;\\n    vec3 norm = to.xyz-pt.xyz;\\n    float mult = 1.1; //slop to account for perspective of sphere\\n    if(length(p1) > length(p2)) { //billboard at level of closest point\\n       mvPosition = to;\\n    }\\n\\n    vec3 n = normalize(mvPosition.xyz);\\n//intersect with the plane defined by the camera looking at the billboard point\\n    if(color.z >= 0.0) { //p1\\n       vec3 pnorm = normalize(p1);\\n       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);\\n       mvPosition.xyz = p1+t*pnorm;\\n    } else {\\n       vec3 pnorm = normalize(p2);\\n       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);\\n       mvPosition.xyz = p2+t*pnorm;\\n       mult *= -1.0;\\n    }\\n\\n    if(outlineMaxPixels > 0.0) {\\n        vec4 cpos = mvPosition;\\n        vec4 unadjusted = projectionMatrix*vec4(cpos.x+abs(scale*radius), cpos.y,cpos.z,cpos.w); \\n        vec4 ccoord = projectionMatrix*cpos;\\n        vec4 adjust = projectionMatrix*vec4(cpos.x+r,cpos.y,cpos.z,cpos.w); \\n        unadjusted /= unadjusted.w;\\n        adjust /= adjust.w;\\n        unadjusted.xyz -= ccoord.xyz/ccoord.w;\\n        adjust.xyz -= ccoord.xyz/ccoord.w;\\n        float diff = abs(adjust.x-unadjusted.x);\\n        diff *= vWidth; //this should now be in pixels\\n        if(diff > outlineMaxPixels) {\\n            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth; \\n            vec4 pcoord = ccoord;\\n            pcoord.x += fixlen*pcoord.w;\\n            vec4 altc = projinv*pcoord;\\n            r= abs(altc.x-cpos.x);\\n        }\\n    }\\n\\n    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;\\n    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;\\n    mvPosition.xy +=  mult*(cr + doublecr).xy;\\n    cposition = mvPosition.xyz;\\n    gl_Position = projectionMatrix * mvPosition;\\n    vLight = vec3(1.0,1.0,1.0);\\n}\\n\\n\";", "import { Matrix4 } from \"WebGL/math\";\nimport { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    outlineColor: { type: 'c', value: new Color(0.0, 0.0, 0.0) },\n    outlineWidth: { type: 'f', value: 0.1 },\n    outlinePushback: { type: 'f', value: 1.0 },\n    outlineMaxPixels: { type: 'f', value: 0.0 },\n    projinv: { type: 'mat4', value: [] as Matrix4[] }\n}", "import { uniforms } from \"./uniforms\";\nimport { Shader } from '../../ShaderType';\nimport fragmentShader from \"./volumetric.frag\";\nimport vertexShader from \"./volumetric.vert\";\n//import fs from \"fs\";\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/volumetric.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/volumetric.vert\", \"utf8\");\n\nexport const volumetric: Shader = {\n    fragmentShader: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: vertexShader.replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms\n}", "import { Matrix4 } from \"WebGL/math\";\nimport { Color } from \"../../../../colors\";\n\nexport const uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000},\n    data: { type: 'i', value: 3 },\n    colormap: { type: 'i', value: 4 },\n    depthmap: { type: 'i', value: 5 },\n    step: { type: 'f', value: 1.0 }, //length of a step\n    maxdepth: {type: 'f',value: 100.0}, //how far to step along ray before stopping\n    subsamples: { type: 'f', value: 5.0}, //how many substeps to take\n    textmat: { type: 'mat4', value: [] as Matrix4[]  },\n    projinv: { type: 'mat4', value: [] as Matrix4[] },\n    transfermin: {type: 'f', value: -0.2 },\n    transfermax: {type: 'f', value: 0.2},\n}\n", "export default \"\\nuniform highp sampler3D data;\\nuniform highp sampler2D colormap;\\nuniform highp sampler2D depthmap;\\n\\n\\nuniform mat4 textmat;\\nuniform mat4 projinv;\\nuniform mat4 projectionMatrix;\\n\\nuniform float step;\\nuniform float subsamples;\\nuniform float maxdepth;\\nuniform float transfermin;\\nuniform float transfermax;\\nin  vec4 mvPosition;\\nout vec4 color;\\nvoid main(void) {\\n\\n   vec4 pos = mvPosition;\\n   bool seengood = false;\\n   float i = 0.0;\\n   color = vec4(1,1,1,0);\\n   float increment = 1.0/subsamples;\\n   float maxsteps = (maxdepth*subsamples/step);\\n//there's probably a better way to do this..\\n//calculate farthest possible point in model coordinates\\n   vec4 maxpos = vec4(pos.x,pos.y,pos.z-maxdepth,1.0);\\n// convert to projection\\n   maxpos = projectionMatrix*maxpos;\\n   vec4 startp = projectionMatrix*pos;\\n// homogonize\\n   maxpos /= maxpos.w;\\n   startp /= startp.w;\\n//take x,y from start and z from max\\n   maxpos = vec4(startp.x,startp.y,maxpos.z,1.0);\\n//convert back to model space\\n   maxpos = projinv*maxpos;\\n   maxpos /= maxpos.w;\\n   float incr = step/subsamples;\\n//get depth from depthmap\\n//startp is apparently [-1,1]\\n   vec2 tpos = startp.xy/2.0+0.5;\\n   float depth = texture(depthmap, tpos).r;\\n//compute vector between start and end\\n   vec4 direction = maxpos-pos;\\n   for( i = 0.0; i <= maxsteps; i++) {\\n      vec4 pt = (pos+(i/maxsteps)*direction);\\n      vec4 ppt = projectionMatrix*pt;\\n      float ptdepth = ppt.z/ppt.w;\\n      ptdepth = ((gl_DepthRange.diff * ptdepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;\\n      if(ptdepth > depth) break;\\n      pt = textmat*pt;\\n//       pt /= pt.w;\\n      if(pt.x >= -0.01 && pt.y >= -0.01 && pt.z >= -0.01 && pt.x <= 1.01 && pt.y <= 1.01 && pt.z <= 1.01) {\\n         seengood = true;\\n      } else if(seengood) {\\n         break;\\n      }\\n      if( pt.x < -0.01 || pt.x > 1.01 || pt.y < -0.01 || pt.y > 1.01 || pt.z < -0.01 || pt.z > 1.01  ){\\n          color.a = 0.0;\\n          continue;\\n      }\\n      else {\\n         float val = texture(data, pt.zyx).r;\\n         if(isinf(val)) continue; //masked out\\n         float cval = (val-transfermin)/(transfermax-transfermin); //scale to texture 0-1 range\\n         vec4 val_color = texture(colormap, vec2(cval,0.5));\\n         color.rgb = color.rgb*color.a + (1.0-color.a)*val_color.a*val_color.rgb;\\n         color.a += (1.0 - color.a) * val_color.a; \\n         if(color.a > 0.0) color.rgb /= color.a;\\n//          color = vec4(pt.x, pt.y, pt.z, 1.0);\\n      }\\n//       color = vec4(pt.x, pt.y, pt.z, 0.0)\\n    }\\n}\\n\\n        \";", "export default \"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\n\\nin vec3 position;\\nout vec4 mvPosition;\\nvoid main() {\\n\\n    mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n    gl_Position = projectionMatrix*mvPosition;\\n}\\n\";", "import { Color } from \"../../../colors\";\n\nexport type Uniform = Record<any, { type?: unknown; value?: unknown }>\n\nexport function clone(\n  uniforms_src: Uniform\n) {\n  let uniforms_clone: Uniform = {};\n\n  for (const u in uniforms_src) {\n    uniforms_clone[u] = {};\n    uniforms_clone[u].type = uniforms_src[u].type;\n\n    var srcValue = uniforms_src[u].value;\n\n    if (srcValue instanceof Color) uniforms_clone[u].value = srcValue.clone();\n    else if (typeof srcValue === \"number\") uniforms_clone[u].value = srcValue;\n    else if (srcValue instanceof Array) uniforms_clone[u].value = [];\n    else\n      console.error(\n        \"Error copying shader uniforms from ShaderLib: unknown type for uniform\"\n      );\n  }\n\n  return uniforms_clone;\n}\n", "import { clone } from \"./clone\"\n\nexport * from \"./clone\"\nexport const ShaderUtils = {\n    clone\n}", "import type { Matrix4 } from '../math';\nimport { Vector3 } from '../math';\nlet vector = new Vector3()\n\n//Bounding cylinder for stick render\n/** @class \n *  @subcategory  Math\n * */ \nexport class Cylinder {\n  c1: Vector3\n  c2: Vector3\n  direction: Vector3\n  radius: number\n\n  constructor(c1:Vector3 = new Vector3(), c2:Vector3 = new Vector3(), radius:number = 0) {\n    this.c1 = c1;\n    this.c2 = c2;\n    this.radius = radius;\n    this.direction = new Vector3()\n      .subVectors(this.c2, this.c1)\n      .normalize();\n  }\n\n  copy(cylinder:Cylinder):Cylinder {\n    this.c1.copy(cylinder.c1);\n    this.c2.copy(cylinder.c2);\n    this.direction.copy(cylinder.direction);\n    this.radius = cylinder.radius;\n    return this;\n  }\n\n  lengthSq():number { \n    return vector.subVectors(this.c2, this.c1).lengthSq();\n  }\n\n  applyMatrix4(matrix:Matrix4):Cylinder {\n    this.direction.add(this.c1).applyMatrix4(matrix);\n    this.c1.applyMatrix4(matrix);\n    this.c2.applyMatrix4(matrix);\n    this.direction.sub(this.c1).normalize();\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n    return this;\n  }\n}\n", "import { Matrix4 } from '../math';\nimport { Vector3, XYZ } from '../math';\n//Intersection sphere and box shapes.\n\n//Intersection sphere for sphere, stick render\n/** @class \n *  @subcategory  Math\n * */ \nexport class Sphere {\n  center: Vector3\n  radius: number\n  box?: any;\n\n  constructor(center: XYZ = {x:0,y:0,z:0}, radius = 0) {\n    this.center = new Vector3(center.x,center.y,center.z);\n    this.radius = radius;\n  }\n\n  set(center: Vector3, radius: number): Sphere {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n\n  copy(sphere: Sphere): Sphere {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n\n  applyMatrix4(matrix: Matrix4): Sphere {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n\n  translate(offset: Vector3): Sphere {\n    this.center.add(offset);\n    return this;\n  }\n\n  equals(sphere: Sphere): boolean {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n  clone(): Sphere {\n    return new Sphere().copy(this);\n  }\n}\n", "import type { Matrix4 } from \"../math\";\nimport { Vector3 } from \"../math\";\n\nconst v1 = new Vector3();\n\n\n/**   plane specified by three points\n\n *  @class \n *  @subcategory  Math\n *  \n * \n */ \nexport class Triangle {\n  a: Vector3;\n  b: Vector3;\n  c: Vector3;\n\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  copy(triangle: Triangle): Triangle {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n\n    return this;\n  }\n\n  applyMatrix4(matrix: Matrix4): Triangle {\n    this.a.applyMatrix4(matrix);\n    this.b.applyMatrix4(matrix);\n    this.c.applyMatrix4(matrix);\n\n    return this;\n  }\n\n  getNormal(): Vector3 {\n    var norm = this.a.clone();\n    norm.sub(this.b);\n    v1.subVectors(this.c, this.b);\n\n    norm.cross(v1);\n    norm.normalize();\n\n    return norm;\n  }\n}\n", "export * from \"./Sphere\";\nexport * from \"./Cylinder\";\nexport * from \"./Triangle\";", "//auto-initialization\n\nimport { GLViewer, createViewer } from \"./GLViewer\";\nimport { SurfaceType } from \"./ProteinSurface4\";\nimport { get, getbin, makeFunction, specStringToObject } from \"./utilities\";\nimport { CC } from \"./colors\";\n\nexport var autoinit = false;\nexport var processing_autoinit = false;\n\n/**\n * Contains a dictionary of embedded viewers created from HTML elements\n * with a the viewer_3Dmoljs css class indexed by their id (or numerically\n * if they do not have an id).\n*/\nexport var viewers: any = {};\n\n//Create embedded viewer from HTML attributes if true\n//viewer and callback are used by the testing harness\nexport function autoload(viewer?: any, callback?: (arg0: any) => void) {\n    var i: string | number, dataname: string, type: string;\n    if (document.querySelector(\".viewer_3Dmoljs\") != null)\n        autoinit = true;\n\n    if (autoinit) {\n        processing_autoinit = true;\n        viewer = (viewer != undefined) ? viewer : null;\n        var nviewers = 0;\n        document.querySelectorAll<HTMLInputElement>(\".viewer_3Dmoljs\").forEach(viewerdiv => {\n            var datauri = [];\n            var datatypes = [];\n            var uri = '';\n\n            if (viewerdiv.style.position == 'static') {\n                //slight hack - canvas needs this element to be positioned\n                viewerdiv.style.position = 'relative';\n            }\n\n            var UI:any = null;\n\n            type = null;\n            if (viewerdiv.dataset.pdb) {\n                datauri.push(\"https://files.rcsb.org/view/\" + viewerdiv.dataset.pdb + \".pdb\");\n                datatypes.push(\"pdb\");\n            } else if (viewerdiv.dataset.cid) {\n                //this doesn't actually work since pubchem does have CORS enabled\n                datatypes.push(\"sdf\");\n                datauri.push(\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\" + viewerdiv.dataset.cid +\n                    \"/SDF?record_type=3d\");\n            }\n            else if (viewerdiv.dataset.href || viewerdiv.dataset.url) {\n                if (viewerdiv.dataset.href)\n                    uri = viewerdiv.dataset.href;\n                else\n                    uri = viewerdiv.dataset.url;\n                datauri.push(uri);\n                type = uri.substring(uri.lastIndexOf('.') + 1);\n                if(type == 'gz') {\n                    let pos = uri.substring(0,uri.lastIndexOf('.')).lastIndexOf('.');\n                    type = uri.substring(pos+1);\n                }\n                datatypes.push(type);\n\n                var molName = uri.substring(uri.lastIndexOf('/') + 1, uri.lastIndexOf('.'));\n                if (molName == '/')\n                    molName = uri.substring(uri.lastIndexOf('/') + 1);\n\n                viewerdiv.dataset[datatypes[datatypes.length - 1]] = molName;\n            }\n\n            let divdata = viewerdiv.dataset;\n            for (i in divdata) {\n                if ((i.substring(0, 3) === \"pdb\" && (i !== \"pdb\"))) {\n                    datauri.push(\"https://files.rcsb.org/view/\" + divdata[i] + \".pdb\");\n                    datatypes.push('pdb');\n\n                } else if (i.substring(0, 4) === \"href\" && (i !== \"href\")) {\n                    uri = divdata[i];\n                    datauri.push(uri);\n                    datatypes.push(uri.substring(uri.lastIndexOf('.') + 1));\n                } else if (i.substring(0, 3) === \"cid\" && (i !== \"cid\")) {\n                    datauri.push(\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\" + divdata[i] + \"/SDF?record_type=3d\");\n                    datatypes.push('sdf');\n                }\n            }\n            var options = {};\n            if (viewerdiv.dataset.options)\n                options = specStringToObject(viewerdiv.dataset.options);\n\n            //note that data tags must be lowercase\n            var bgcolor = CC.color(viewerdiv.dataset.backgroundcolor);\n            var bgalpha: string | number = viewerdiv.dataset.backgroundalpha;\n            bgalpha = (bgalpha == undefined) ? 1.0 : parseFloat(bgalpha);\n            var style = { line: {} };\n            if (viewerdiv.dataset.style) style = specStringToObject(viewerdiv.dataset.style);\n            var select = {};\n            if (viewerdiv.dataset.select) select = specStringToObject(viewerdiv.dataset.select);\n            var selectstylelist = [];\n            var surfaces = [];\n            var labels = [];\n            var zoomto = {};\n            var spin = null;\n            var d = viewerdiv.dataset;\n\n            //let users specify individual but matching select/style/surface tags, eg.\n            //data-select1 data-style1\n            var stylere = /style(.+)/;\n            var surfre = /surface(.*)/;\n            var reslabre = /labelres(.*)/;\n            var keys = [];\n            for (dataname in d) {\n                if (Object.prototype.hasOwnProperty.call(d, dataname)) {\n                    keys.push(dataname);\n                }\n            }\n            keys.sort();\n            for (i = 0; i < keys.length; i++) {\n                dataname = keys[i];\n                var m = stylere.exec(dataname);\n                var selname: string, newsel: any, styleobj: any;\n                if (m) {\n                    selname = \"select\" + m[1];\n                    newsel = specStringToObject(d[selname]);\n                    styleobj = specStringToObject(d[dataname]);\n                    selectstylelist.push([newsel, styleobj]);\n                }\n                m = surfre.exec(dataname);\n                if (m) {\n                    selname = \"select\" + m[1];\n                    newsel = specStringToObject(d[selname]);\n                    styleobj = specStringToObject(d[dataname]);\n                    surfaces.push([newsel, styleobj]);\n                }\n                m = reslabre.exec(dataname);\n                if (m) {\n                    selname = \"select\" + m[1];\n                    newsel = specStringToObject(d[selname]);\n                    styleobj = specStringToObject(d[dataname]);\n                    labels.push([newsel, styleobj]);\n                }\n                if (dataname == \"zoomto\") {\n                    zoomto = specStringToObject(d[dataname]);\n                }\n                if (dataname == \"spin\") {\n                    spin = specStringToObject(d[dataname]);\n                }\n            }\n\n            //apply all the selections/styles parsed out above to the passed viewer\n            var applyStyles = function (glviewer: GLViewer) {\n                glviewer.setStyle(select, style);\n\n                if (UI) {\n                    UI.createSelectionAndStyle(select, style);\n                }\n\n                for (i = 0; i < selectstylelist.length; i++) {\n                    let sel = selectstylelist[i][0] || {};\n                    let sty = selectstylelist[i][1] || { \"line\": {} };\n                    glviewer.setStyle(sel, sty);\n                    if (UI) {\n                        UI.createSelectionAndStyle(select, style);\n                    }\n                }\n                for (i = 0; i < surfaces.length; i++) {\n                    let sel = surfaces[i][0] || {};\n                    let sty = surfaces[i][1] || {};\n                    let viewer = glviewer;\n\n                    if (UI) {\n                        viewer.addSurface(SurfaceType.VDW, sty, sel, sel).then((surfid: any) => {\n                            UI.loadSurface(\"VDW\", sel, sty, surfid);\n                        });\n                    }\n                    else {\n                        glviewer.addSurface(SurfaceType.VDW, sty, sel, sel);\n                    }\n\n                }\n                for (i = 0; i < labels.length; i++) {\n                    let sel = labels[i][0] || {};\n                    let sty = labels[i][1] || {};\n                    glviewer.addResLabels(sel, sty);\n                }\n\n                glviewer.render();\n                glviewer.zoomTo(zoomto);\n\n                if (spin) {\n                    glviewer.spin(spin.axis, spin.speed);\n                }\n            };\n\n            let glviewer = viewer;\n            try {\n                var config: any = specStringToObject(viewerdiv.dataset.config) || {};\n                if (config.backgroundColor === undefined) config.backgroundColor = bgcolor;\n                if (config.backgroundAlpha === undefined) config.backgroundAlpha = bgalpha;\n                if (glviewer == null) {\n                    glviewer = viewers[viewerdiv.id || nviewers++] = createViewer(viewerdiv, config);\n                } else {\n                    glviewer.setBackgroundColor(bgcolor, bgalpha);\n                    glviewer.setConfig(config);\n                    if (UI) \n                        UI.initiateUI();\n                }\n\n                if(viewerdiv.dataset.ui && $3Dmol.StateManager) {\n                    UI = new $3Dmol.StateManager(glviewer); // Creates the UI state management tool\n                }\n            } catch (error) {\n                console.log(error);\n                //for autoload, provide a useful error message\n                viewerdiv.textContent = \"WebGL appears to be disabled.\";\n            }\n\n            if (datauri.length != 0) {\n                //load multiple data elements in serial\n                let i = 0;\n                let process = ((viewerdiv, glviewer) => function (moldata: any) {\n                    //add moldata to viewer and load next model\n                    uri = datauri[i]; //this is where the moldata came from\n                    var type = viewerdiv.dataset.type || viewerdiv.dataset.datatype || datatypes[i];\n                    glviewer.addModel(moldata, type, options);\n                    if (UI) {\n                        var modelName = viewerdiv.dataset[datatypes[i]];\n                        UI.setModelTitle(modelName);\n                    }\n                    i +=1;\n                    if (i < datauri.length) {\n                        get(datauri[i]).then(process);\n                    }\n                    else {\n                        // or finalize if this is the last model\n                        applyStyles(glviewer);\n                        if (viewerdiv.dataset.callback) {\n                            //evaluate javascript in the string, if it resolves to a function,\n                            //call it with the viewer\n                            let runres = makeFunction(viewerdiv.dataset.callback);\n                            runres(glviewer);                            \n                        }\n                        processing_autoinit = false;\n                        if (callback) callback(glviewer);\n                    }\n                })(viewerdiv,glviewer);\n\n                if(type && type.endsWith('gz')) {\n                    getbin(datauri[0]).then(process);\n                } else {\n                    get(datauri[0]).then(process);\n                }\n            }\n            else {\n\n                if (viewerdiv.dataset.element) {\n                    var moldataid = \"#\" + viewerdiv.dataset.element;\n                    var molelem = document.querySelector(moldataid);\n                    var moldata = molelem ? molelem.textContent : \"\";\n                    type = viewerdiv.dataset.type || viewerdiv.dataset.datatype;\n                    glviewer.addModel(moldata, type, options);\n                }\n\n                applyStyles(glviewer);\n                if (viewerdiv.dataset.callback) {\n                    //evaluate javascript in the string, if it resolves to a function,\n                    //call it with the viewer\n                    let runres = makeFunction(viewerdiv.dataset.callback);\n                    runres(glviewer);                    \n                }\n                processing_autoinit = false;\n                if (callback)\n                    callback(glviewer);\n            }\n        });\n    }\n};\n\n\n\ndocument.onreadystatechange = () => {\n    if (document.readyState === \"complete\") {\n        autoload();\n    }\n};\n", "import { GradientType } from \"./Gradient\";\n\n/* @interface\n *\n */\nexport interface Colored {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nexport type ColorConstructorArg = number | Color | Colored | undefined;\n\n\n/**\n * @class\n   *\n   * @param r red 8bit number or numeric value of full color\n   * @param g green 8bit number\n   * @param b blue 8bit number\n   */\n\nexport class Color implements Colored {\n  r: number = 0.0;\n  g: number = 0.0;\n  b: number = 0.0;\n\n\n  constructor(r?: ColorConstructorArg, g?: number, b?: number) {\n    if (arguments.length > 1 && typeof r === \"number\") {\n      this.r = r || 0.0;\n      this.g = g || 0.0;\n      this.b = b || 0.0;\n\n      return this;\n    }\n\n    return this.set(r || 0.0);\n  }\n\n  set<T extends Colored>(val: Color | number | T): Color {\n    if (val instanceof Color) return val.clone();\n    else if (typeof val === \"number\") this.setHex(val);\n    else if (typeof val === \"object\") {\n      this.r = val?.r || 0.0;\n      this.g = val?.g || 0.0;\n      this.b = val?.b || 0.0;\n    }\n    return this;\n  }\n\n  setHex(hex: number): Color {\n    hex = Math.floor(hex);\n\n    this.r = ((hex >> 16) & 255) / 255;\n    this.g = ((hex >> 8) & 255) / 255;\n    this.b = (hex & 255) / 255;\n\n    return this;\n  }\n\n  getHex(): number {\n    var R = Math.round(this.r * 255);\n    var G = Math.round(this.g * 255);\n    var B = Math.round(this.b * 255);\n    return (R << 16) | (G << 8) | B;\n  }\n\n  clone(): Color {\n    return new Color(this.r, this.g, this.b);\n  }\n\n  copy(color: Color): Color {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n\n    return this;\n  }\n\n  //return object that represents color components from 0 to 255\n  scaled<T extends Colored>(): Colored {\n    var ret: Partial<T> = {};\n    ret.r = Math.round(this.r * 255);\n    ret.g = Math.round(this.g * 255);\n    ret.b = Math.round(this.b * 255);\n    ret.a = 1.0;\n    return ret as T;\n  }\n}\n\n// in an attempt to reduce memory overhead, cache all $3Dmol.Colors\n// this makes things a little faster\nexport class CC {\n  static rgbRegEx =\n    /rgb(a?)\\(\\s*([^ ,\\)\\t]+)\\s*,\\s*([^ ,\\)\\t]+)\\s*,\\s*([^ ,\\)\\t]+)/i;\n  static cache: Record<number, Color> = { 0: new Color(0) };\n  static color(hex: undefined): Color;\n  static color(hex: number): Color;\n  static color(hex: string): Color;\n  static color(hex: number[]): Color[];\n  static color(hex: Color): Color;\n  static color(hex: ColorSpec): Color;\n  static color(hex: ColorSpec[]): Color[];\n  static color(hex: ColorSpec|ColorSpec[]): Color|Color[];\n  static color(hex?: unknown): unknown {\n    // Undefined values default to black\n    if (!hex) return CC.cache[0];\n    //noop\n    if ( hex instanceof Color ) {\n      return hex;\n    }\n    // cache hits\n    if (typeof hex === \"number\" && typeof CC.cache[hex] !== \"undefined\")\n      return CC.cache[hex];\n\n    // arrays\n    if (hex && Array.isArray(hex))\n      // parse elements recursively\n      return hex.map(CC.color as (hex: number) => Color);\n\n    // numbers and hex strings\n    let hexval = CC.getHex(hex as (string | number));\n    let c = new Color(hexval);\n    CC.cache[hexval] = c;\n    return c;\n  }\n\n  static getHex(hex: Array<string | number>): number[];\n  static getHex(hex: string | number): number;\n  static getHex(hex: unknown): unknown {\n    if (Array.isArray(hex)) return hex.map(CC.getHex) as number[];\n    if (typeof hex === \"string\") {\n      let hexs: string = hex as string;\n      if (!isNaN(parseInt(hexs))) return parseInt(hexs);\n      hexs = hexs.trim();\n\n      if (hexs.length == 4 && hexs[0] == \"#\") {\n        hexs = \"#\" + hexs[1] + hexs[1] + hexs[2] + hexs[2] + hexs[3] + hexs[3]; //expand to full hex number\n      }\n\n      if (hexs.length == 7 && hexs[0] == \"#\") {\n        return parseInt(hexs.substring(1), 16);\n      }\n\n      let m = CC.rgbRegEx.exec(hexs);\n      if (m) {\n        if (m[1] != \"\") {\n          console.log(\n            \"WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.\",\n          );\n        }\n        let ret = 0;\n        for (let i = 2; i < 5; i++) {\n          ret *= 256;\n          let val = m[i].endsWith(\"%\")\n            ? (255 * parseFloat(m[i])) / 100\n            : parseFloat(m[i]);\n          ret += Math.round(val);\n        }\n        return ret;\n      }\n      // check if hex.toLowerCase() is in htmlColors and console.error log if not\n      let val = htmlColors[hexs.toLowerCase()];\n      if (val !== undefined) {\n        return val;\n      } else {\n        console.error(\"color not found\", hex.toLowerCase(), htmlColors);\n        return 0x000000;\n      }\n    }\n    return hex as number;\n  }\n}\n\n\nexport const htmlColors: Record<string, ColorSpec> = {\n  //htmlcolors\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgrey: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  grey: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgrey: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32,\n  //matplotlib single char colors\n  'b': 0x0000ff,  // blue\n  'g': 0x008000,  // green\n  'r': 0xff0000,  // red\n  'c': 0x00bfbf,  // cyan\n  'm': 0xbf00bf,  // magenta\n  'y': 0xbfbf00,  // yellow\n  'k': 0x000000,  // black\n  'w': 0xffffff   // white  \n};\n\n/**\n * Color representation. A hex number, html color name, or object with r/g/b properties\n */\nexport type ColorSpec =  number | string | Colored;\n\n/**\n*  Colorscheme specification.\n*  @see builtinColorSchemes\n*/\nexport type ColorschemeSpec = string | {\n  gradient?: GradientType|string;\n  min?: number;\n  max?: number;\n  /**  {AtomSpec} property to use for gradient calculation.  E.g., 'b' for temperature factors of a PDB. */\n  prop?: string;\n  /** mid point value for gradient (for rwb) */\n  mid?: number;\n  /** Custom colors for gradient (for {@link CustomLinear}) */\n  colors?: Array<ColorSpec>;\n  /** map of a certain {@link AtomSpec} property to a color of the form `{'prop': 'elem', map:elementColors.greenCarbon}` Allows the user to provide a mapping of elements to colors to the colorscheme.  This can be done with any properties, and not just 'elem'.\n */\n  map?: Record<string, unknown>\n};\n\n/** Preset secondary structure color scheme\n * @struct\n */\nexport const ssColors = {\n  //names are in helix-sheet-coil order\n  pyMol: { h: 0xff0000, s: 0xffff00, c: 0x00ff00 },\n  Jmol: { h: 0xff0080, s: 0xffc800, c: 0xffffff },\n};\n\nconst rasmol: Record<string, ColorSpec> = {\n  H: 0xffffff,\n  He: 0xffc0cb,\n  HE: 0xffc0cb,\n  Li: 0xb22222,\n  LI: 0xb22222,\n  B: 0x00ff00,\n  C: 0xc8c8c8,\n  N: 0x8f8fff,\n  O: 0xf00000,\n  F: 0xdaa520,\n  Na: 0x0000ff,\n  NA: 0x0000ff,\n  Mg: 0x228b22,\n  MG: 0x228b22,\n  Al: 0x808090,\n  AL: 0x808090,\n  Si: 0xdaa520,\n  SI: 0xdaa520,\n  P: 0xffa500,\n  S: 0xffc832,\n  Cl: 0x00ff00,\n  CL: 0x00ff00,\n  Ca: 0x808090,\n  CA: 0x808090,\n  Ti: 0x808090,\n  TI: 0x808090,\n  Cr: 0x808090,\n  CR: 0x808090,\n  Mn: 0x808090,\n  MN: 0x808090,\n  Fe: 0xffa500,\n  FE: 0xffa500,\n  Ni: 0xa52a2a,\n  NI: 0xa52a2a,\n  Cu: 0xa52a2a,\n  CU: 0xa52a2a,\n  Zn: 0xa52a2a,\n  ZN: 0xa52a2a,\n  Br: 0xa52a2a,\n  BR: 0xa52a2a,\n  Ag: 0x808090,\n  AG: 0x808090,\n  I: 0xa020f0,\n  Ba: 0xffa500,\n  BA: 0xffa500,\n  Au: 0xdaa520,\n  AU: 0xdaa520,\n};\n\n/** Preset element coloring - from individual element colors to entire mappings (e.g. 'elementColors.Jmol' colors atoms with Jmol stylings)\n * @struct\n */\nexport const elementColors = {\n  defaultColor: 0xff1493,\n  /** Jmol-like element colors*/\n  Jmol: {\n    H: 0xffffff,\n    He: 0xd9ffff,\n    HE: 0xd9ffff,\n    Li: 0xcc80ff,\n    LI: 0xcc80ff,\n    Be: 0xc2ff00,\n    BE: 0xc2ff00,\n    B: 0xffb5b5,\n    C: 0x909090,\n    N: 0x3050f8,\n    O: 0xff0d0d,\n    F: 0x90e050,\n    Ne: 0xb3e3f5,\n    NE: 0xb3e3f5,\n    Na: 0xab5cf2,\n    NA: 0xab5cf2,\n    Mg: 0x8aff00,\n    MG: 0x8aff00,\n    Al: 0xbfa6a6,\n    AL: 0xbfa6a6,\n    Si: 0xf0c8a0,\n    SI: 0xf0c8a0,\n    P: 0xff8000,\n    S: 0xffff30,\n    Cl: 0x1ff01f,\n    CL: 0x1ff01f,\n    Ar: 0x80d1e3,\n    AR: 0x80d1e3,\n    K: 0x8f40d4,\n    Ca: 0x3dff00,\n    CA: 0x3dff00,\n    Sc: 0xe6e6e6,\n    SC: 0xe6e6e6,\n    Ti: 0xbfc2c7,\n    TI: 0xbfc2c7,\n    V: 0xa6a6ab,\n    Cr: 0x8a99c7,\n    CR: 0x8a99c7,\n    Mn: 0x9c7ac7,\n    MN: 0x9c7ac7,\n    Fe: 0xe06633,\n    FE: 0xe06633,\n    Co: 0xf090a0,\n    CO: 0xf090a0,\n    Ni: 0x50d050,\n    NI: 0x50d050,\n    Cu: 0xc88033,\n    CU: 0xc88033,\n    Zn: 0x7d80b0,\n    ZN: 0x7d80b0,\n    Ga: 0xc28f8f,\n    GA: 0xc28f8f,\n    Ge: 0x668f8f,\n    GE: 0x668f8f,\n    As: 0xbd80e3,\n    AS: 0xbd80e3,\n    Se: 0xffa100,\n    SE: 0xffa100,\n    Br: 0xa62929,\n    BR: 0xa62929,\n    Kr: 0x5cb8d1,\n    KR: 0x5cb8d1,\n    Rb: 0x702eb0,\n    RB: 0x702eb0,\n    Sr: 0x00ff00,\n    SR: 0x00ff00,\n    Y: 0x94ffff,\n    Zr: 0x94e0e0,\n    ZR: 0x94e0e0,\n    Nb: 0x73c2c9,\n    NB: 0x73c2c9,\n    Mo: 0x54b5b5,\n    MO: 0x54b5b5,\n    Tc: 0x3b9e9e,\n    TC: 0x3b9e9e,\n    Ru: 0x248f8f,\n    RU: 0x248f8f,\n    Rh: 0x0a7d8c,\n    RH: 0x0a7d8c,\n    Pd: 0x006985,\n    PD: 0x006985,\n    Ag: 0xc0c0c0,\n    AG: 0xc0c0c0,\n    Cd: 0xffd98f,\n    CD: 0xffd98f,\n    In: 0xa67573,\n    IN: 0xa67573,\n    Sn: 0x668080,\n    SN: 0x668080,\n    Sb: 0x9e63b5,\n    SB: 0x9e63b5,\n    Te: 0xd47a00,\n    TE: 0xd47a00,\n    I: 0x940094,\n    Xe: 0x429eb0,\n    XE: 0x429eb0,\n    Cs: 0x57178f,\n    CS: 0x57178f,\n    Ba: 0x00c900,\n    BA: 0x00c900,\n    La: 0x70d4ff,\n    LA: 0x70d4ff,\n    Ce: 0xffffc7,\n    CE: 0xffffc7,\n    Pr: 0xd9ffc7,\n    PR: 0xd9ffc7,\n    Nd: 0xc7ffc7,\n    ND: 0xc7ffc7,\n    Pm: 0xa3ffc7,\n    PM: 0xa3ffc7,\n    Sm: 0x8fffc7,\n    SM: 0x8fffc7,\n    Eu: 0x61ffc7,\n    EU: 0x61ffc7,\n    Gd: 0x45ffc7,\n    GD: 0x45ffc7,\n    Tb: 0x30ffc7,\n    TB: 0x30ffc7,\n    Dy: 0x1fffc7,\n    DY: 0x1fffc7,\n    Ho: 0x00ff9c,\n    HO: 0x00ff9c,\n    Er: 0x00e675,\n    ER: 0x00e675,\n    Tm: 0x00d452,\n    TM: 0x00d452,\n    Yb: 0x00bf38,\n    YB: 0x00bf38,\n    Lu: 0x00ab24,\n    LU: 0x00ab24,\n    Hf: 0x4dc2ff,\n    HF: 0x4dc2ff,\n    Ta: 0x4da6ff,\n    TA: 0x4da6ff,\n    W: 0x2194d6,\n    Re: 0x267dab,\n    RE: 0x267dab,\n    Os: 0x266696,\n    OS: 0x266696,\n    Ir: 0x175487,\n    IR: 0x175487,\n    Pt: 0xd0d0e0,\n    PT: 0xd0d0e0,\n    Au: 0xffd123,\n    AU: 0xffd123,\n    Hg: 0xb8b8d0,\n    HG: 0xb8b8d0,\n    Tl: 0xa6544d,\n    TL: 0xa6544d,\n    Pb: 0x575961,\n    PB: 0x575961,\n    Bi: 0x9e4fb5,\n    BI: 0x9e4fb5,\n    Po: 0xab5c00,\n    PO: 0xab5c00,\n    At: 0x754f45,\n    AT: 0x754f45,\n    Rn: 0x428296,\n    RN: 0x428296,\n    Fr: 0x420066,\n    FR: 0x420066,\n    Ra: 0x007d00,\n    RA: 0x007d00,\n    Ac: 0x70abfa,\n    AC: 0x70abfa,\n    Th: 0x00baff,\n    TH: 0x00baff,\n    Pa: 0x00a1ff,\n    PA: 0x00a1ff,\n    U: 0x008fff,\n    Np: 0x0080ff,\n    NP: 0x0080ff,\n    Pu: 0x006bff,\n    PU: 0x006bff,\n    Am: 0x545cf2,\n    AM: 0x545cf2,\n    Cm: 0x785ce3,\n    CM: 0x785ce3,\n    Bk: 0x8a4fe3,\n    BK: 0x8a4fe3,\n    Cf: 0xa136d4,\n    CF: 0xa136d4,\n    Es: 0xb31fd4,\n    ES: 0xb31fd4,\n    Fm: 0xb31fba,\n    FM: 0xb31fba,\n    Md: 0xb30da6,\n    MD: 0xb30da6,\n    No: 0xbd0d87,\n    NO: 0xbd0d87,\n    Lr: 0xc70066,\n    LR: 0xc70066,\n    Rf: 0xcc0059,\n    RF: 0xcc0059,\n    Db: 0xd1004f,\n    DB: 0xd1004f,\n    Sg: 0xd90045,\n    SG: 0xd90045,\n    Bh: 0xe00038,\n    BH: 0xe00038,\n    Hs: 0xe6002e,\n    HS: 0xe6002e,\n    Mt: 0xeb0026,\n    MT: 0xeb0026,\n  } as Record<string, ColorSpec>,\n  /** rasmol-like element colors */\n  rasmol,\n  defaultColors: {\n    ...rasmol,\n  } as Record<string, ColorSpec>,\n  greenCarbon: {\n    ...rasmol,\n    C: 0x00ff00,\n  } as Record<string, ColorSpec>,\n  cyanCarbon: {\n    ...rasmol,\n    C: 0x00ffff,\n  } as Record<string, ColorSpec>,\n  magentaCarbon: {\n    ...rasmol,\n    C: 0xff00ff,\n  } as Record<string, ColorSpec>,\n  yellowCarbon: {\n    ...rasmol,\n    C: 0xffff00,\n  } as Record<string, ColorSpec>,\n  whiteCarbon: {\n    ...rasmol,\n    C: 0xffffff,\n  } as Record<string, ColorSpec>,\n  orangeCarbon: {\n    ...rasmol,\n    C: 0xffa500,\n  } as Record<string, ColorSpec>,\n  purpleCarbon: {\n    ...rasmol,\n    C: 0x800080,\n  } as Record<string, ColorSpec>,\n  blueCarbon: {\n    ...rasmol,\n    C: 0x0000ff,\n  } as Record<string, ColorSpec>,\n};\n\nexport const residues = {\n  /** @property standard amino acid color scheme*/\n\n  amino: {\n    ALA: 0xc8c8c8,\n    ARG: 0x145aff,\n    ASN: 0x00dcdc,\n    ASP: 0xe60a0a,\n    CYS: 0xe6e600,\n    GLN: 0x00dcdc,\n    GLU: 0xe60a0a,\n    GLY: 0xebebeb,\n    HIS: 0x8282d2,\n    ILE: 0x0f820f,\n    LEU: 0x0f820f,\n    LYS: 0x145aff,\n    MET: 0xe6e600,\n    PHE: 0x3232aa,\n    PRO: 0xdc9682,\n    SER: 0xfa9600,\n    THR: 0xfa9600,\n    TRP: 0xb45ab4,\n    TYR: 0x3232aa,\n    VAL: 0x0f820f,\n    ASX: 0xff69b4,\n    GLX: 0xff69b4,\n  } as Record<string, ColorSpec>,\n\n  /** @property shapely amino acid color scheme*/\n  shapely: {\n    ALA: 0x8cff8c,\n    ARG: 0x00007c,\n    ASN: 0xff7c70,\n    ASP: 0xa00042,\n    CYS: 0xffff70,\n    GLN: 0xff4c4c,\n    GLU: 0x660000,\n    GLY: 0xffffff,\n    HIS: 0x7070ff,\n    ILE: 0x004c00,\n    LEU: 0x455e45,\n    LYS: 0x4747b8,\n    MET: 0xb8a042,\n    PHE: 0x534c52,\n    PRO: 0x525252,\n    SER: 0xff7042,\n    THR: 0xb84c00,\n    TRP: 0x4f4600,\n    TYR: 0x8c704c,\n    VAL: 0xff8cff,\n    ASX: 0xff00ff,\n    GLX: 0xff00ff,\n  } as Record<string, ColorSpec>,\n\n  /** @property nucleic acid color scheme*/\n  nucleic: {\n    A: 0xa0a0ff,\n    G: 0xff7070,\n    I: 0x80ffff,\n    C: 0xff8c4b,\n    T: 0xa0ffa0,\n    U: 0xff8080,\n  } as Record<string, ColorSpec>,\n};\n\nexport const chains = {\n  /** @property chain based standard color scheme */\n  atom: {\n    A: 0xc0d0ff,\n    B: 0xb0ffb0,\n    C: 0xffc0c8,\n    D: 0xffff80,\n    E: 0xffc0ff,\n    F: 0xb0f0f0,\n    G: 0xffd070,\n    H: 0xf08080,\n    I: 0xf5deb3,\n    J: 0x00bfff,\n    K: 0xcd5c5c,\n    L: 0x66cdaa,\n    M: 0x9acd32,\n    N: 0xee82ee,\n    O: 0x00ced1,\n    P: 0x00ff7f,\n    Q: 0x3cb371,\n    R: 0x00008b,\n    S: 0xbdb76b,\n    T: 0x006400,\n    U: 0x800000,\n    V: 0x808000,\n    W: 0x800080,\n    X: 0x008080,\n    Y: 0xb8860b,\n    Z: 0xb22222,\n  } as Record<string, ColorSpec>,\n\n  /** @property hetatm color scheme */\n  hetatm: {\n    A: 0x90a0cf,\n    B: 0x80cf98,\n    C: 0xcf90b0,\n    D: 0xcfcf70,\n    E: 0xcf90cf,\n    F: 0x80c0c0,\n    G: 0xcfa060,\n    H: 0xc05070,\n    I: 0xc5ae83,\n    J: 0x00a7cf,\n    K: 0xb54c4c,\n    L: 0x56b592,\n    M: 0x8ab52a,\n    N: 0xbe72be,\n    O: 0x00b6a1,\n    P: 0x00cf6f,\n    Q: 0x349b61,\n    R: 0x0000bb,\n    S: 0xa59f5b,\n    T: 0x009400,\n    U: 0xb00000,\n    V: 0xb0b000,\n    W: 0xb000b0,\n    X: 0x00b0b0,\n    Y: 0xe8b613,\n    Z: 0xc23232,\n  } as Record<string, ColorSpec>,\n};\n\n/**\n * built in color schemes\n * The user can pass these strings directly as the colorscheme\n * @prop ssPyMol - pymol secondary structure\n * @prop  ssJmol - jmol secondary structure\n   @prop Jmol - jmol element defaults\n   @prop amino - amino acid coloring\n   @prop shapely - amino acid coloring\n   @prop nucleic - nucleic acid coloring\n   @prop chain - color by chain\n   @prop rasmol - rasmol default element coloring\n   @prop default - default element coloring\n   @prop greenCarbon - default element coloring with green carbon\n   @prop cyanCarbon - default element coloring with cyan carbon\n   @prop magentaCarbon - default element coloring with magenta carbon\n   @prop purpleCarbon - default element coloring with purple carbon\n   @prop whiteCarbon - default element coloring with white carbon\n   @prop orangeCarbon - default element coloring with orange carbon\n   @prop yellowCarbon - default element coloring with yellow carbon\n   @prop blueCarbon - default element coloring with blue carbon\n   @prop chainHetatm - color chains\n *\n * @example window.$3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n *    viewer.setBackgroundColor(0xffffffff);\n *    var colorAsSnake = function(atom) {\n *      return atom.resi % 2 ? 'white': 'green'\n *    };\n *    viewer.setStyle( {chain:'A'}, { cartoon: {colorfunc: colorAsSnake }});\n *    viewer.setStyle( {chain:'B'}, { stick: {colorscheme: 'yellowCarbon'}});\n *    viewer.render();\n *  });\n  */\nexport const builtinColorSchemes = {\n  /** secondary structure pymol */\n  ssPyMol: { prop: \"ss\", map: ssColors.pyMol },\n  ssJmol: { prop: \"ss\", map: ssColors.Jmol },\n  Jmol: { prop: \"elem\", map: elementColors.Jmol },\n  amino: { prop: \"resn\", map: residues.amino },\n  shapely: { prop: \"resn\", map: residues.shapely },\n  nucleic: { prop: \"resn\", map: residues.nucleic },\n  chain: { prop: \"chain\", map: chains.atom },\n  rasmol: { prop: \"elem\", map: elementColors.rasmol },\n  default: { prop: \"elem\", map: elementColors.defaultColors },\n  greenCarbon: { prop: \"elem\", map: elementColors.greenCarbon },\n  chainHetatm: { prop: \"chain\", map: chains.hetatm },\n  cyanCarbon: { prop: \"elem\", map: elementColors.cyanCarbon },\n  magentaCarbon: { prop: \"elem\", map: elementColors.magentaCarbon },\n  purpleCarbon: { prop: \"elem\", map: elementColors.purpleCarbon },\n  whiteCarbon: { prop: \"elem\", map: elementColors.whiteCarbon },\n  orangeCarbon: { prop: \"elem\", map: elementColors.orangeCarbon },\n  yellowCarbon: { prop: \"elem\", map: elementColors.yellowCarbon },\n  blueCarbon: { prop: \"elem\", map: elementColors.blueCarbon },\n};\n", "\n//put the global $3Dmol object into a module\nif (typeof module === \"object\" && typeof module.exports === \"object\") {\n\t//for node.js exporting\n\tmodule.exports = window.$3Dmol;\n}", "//glcartoon.js\n//This contains all the routines for rendering a cartoon given a set\n//of atoms with assigned secondary structure\n\nimport { Vector3 } from \"./WebGL/math\";\nimport { Triangle, Sphere } from \"./WebGL/shapes\";\nimport { MeshDoubleLambertMaterial, Mesh, Geometry, Material, Coloring } from \"./WebGL\";\nimport { Gradient } from \"./Gradient\";\nimport { CC, ColorSpec, ColorschemeSpec } from \"./colors\";\nimport { CAP, GLDraw } from \"./GLDraw\";\nimport { isNumeric, getColorFromStyle, extend } from \"./utilities\";\nimport { AtomSpec } from \"specs\";\n\n/**\n * A visualization of protein or nucleic acid secondary structure.  Applying this to other molecules will not show anything.\n  In nucleic acids, the base cylinders obtain their color from the  atom to which the cylinder is drawn, which is 'N1' for purines (resn: 'A', 'G', 'DA', 'DG') and \n  'N3' for pyrimidines (resn: 'C', 'U', 'DC', 'DT'). \n  The different nucleobases can therefore be distinguished as by setting the colors \n  of each of these atoms. The backbone color is set from the 'P' atoms ('O5' for the 5' terminus).\n\n * \n * @example $3Dmol.download(\"pdb:4ZD3\",viewer,{},function(){\n                  viewer.setBackgroundColor(0xffffffff);\n                  viewer.setViewStyle({style:\"outline\"});\n                  viewer.setStyle({},{cartoon:{}});\n                  viewer.render();\n              });\n */\nexport interface CartoonStyleSpec {\n    /** do not show  */\n    hidden?: boolean;\n    /** colorscheme to use on atoms; overrides color */\n    colorscheme?: ColorschemeSpec;\n    /** strand color, may specify as 'spectrum' which will apply reversed gradient based on residue number */\n    color?: ColorSpec;\n    /**  Allows the user to provide a function for setting the colorschemes. */\n    colorfunc?: Function;\n    /**  style of cartoon rendering (trace, oval, rectangle (default), parabola, edged) */\n    style?: string;\n    /**  whether to use constant strand width, disregarding\n    *       secondary structure; use thickness to adjust radius */\n    ribbon?: boolean;\n    /** whether to add arrows showing beta-sheet\n    *       directionality; does not apply to trace or ribbon */\n    arrows?: boolean;\n    /** whether to display alpha helices as simple cylinders;\n    *       does not apply to trace */\n    tubes?: boolean;\n    /** cartoon strand thickness, default is 0.4 */\n    thickness?: number;\n    /** cartoon strand width, default is secondary\n    *       structure-dependent; does not apply to trace or ribbon */\n    width?: number;\n    /** set opacity from 0-1; transparency is set per-chain\n    *       with a warning outputted in the event of ambiguity */\n    opacity?: number,\n    /** If there is a gap of strictly fewer than gapcutoff missing residues\n     * within a chain, draw a dashed line.\n     */\n    gapcutoff?: number\n};\n\n// helper functions\n// Catmull-Rom subdivision\nexport function subdivide_spline(_points, DIV) { // points as Vector3\n    var ret = [];\n    var points = _points;\n    points = []; // Smoothing test\n    points.push(_points[0]);\n\n    var i, lim, size;\n    var p0, p1, p2, p3, v0, v1;\n\n    for (i = 1, lim = _points.length - 1; i < lim; i++) {\n        p1 = _points[i];\n        p2 = _points[i + 1];\n        if (p1.smoothen) {\n            var np = new Vector3((p1.x + p2.x) / 2,\n                (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n            np.atom = p1.atom;\n            points.push(np);\n        }\n        else\n            points.push(p1);\n    }\n    points.push(_points[_points.length - 1]);\n\n    for (i = -1, size = points.length; i <= size - 3; i++) {\n        p0 = points[(i === -1) ? 0 : i];\n        p1 = points[i + 1];\n        p2 = points[i + 2];\n        p3 = points[(i === size - 3) ? size - 1 : i + 3];\n        v0 = new Vector3().subVectors(p2, p0).multiplyScalar(0.5);\n        v1 = new Vector3().subVectors(p3, p1).multiplyScalar(0.5);\n        if (p2.skip)\n            continue;\n\n        for (var j = 0; j < DIV; j++) {\n            var t = 1.0 / DIV * j;\n            var x = p1.x + t * v0.x + t * t *\n                (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x) + t * t * t *\n                (2 * p1.x - 2 * p2.x + v0.x + v1.x);\n            var y = p1.y + t * v0.y + t * t *\n                (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y) + t * t * t *\n                (2 * p1.y - 2 * p2.y + v0.y + v1.y);\n            var z = p1.z + t * v0.z + t * t *\n                (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z) + t * t * t *\n                (2 * p1.z - 2 * p2.z + v0.z + v1.z);\n\n            var pt = new Vector3(x, y, z);\n            if (j < DIV / 2) {\n                pt.atom = p1.atom;\n            } else {\n                pt.atom = p2.atom;\n            }\n\n            ret.push(pt);\n        }\n    }\n    ret.push(points[points.length - 1]);\n    return ret;\n};\n\n\nconst coilWidth = 0.5;\nconst helixSheetWidth = 1.3;\nconst nucleicAcidWidth = 0.8;\nconst defaultThickness = 0.4;\nconst baseThickness = 0.4;\n\nfunction drawThinStrip(geo: Geometry, p1, p2, colors) {\n\n    var offset, vertoffset;\n    var color, colori;\n\n    for (var i = 0, lim = p1.length; i < lim; i++) {\n\n        colori = Math.round(i * (colors.length - 1) / lim);\n        color = CC.color(colors[colori]);\n\n        var geoGroup = geo.updateGeoGroup(2);\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        offset = geoGroup.vertices;\n        vertoffset = offset * 3;\n\n        vertexArray[vertoffset] = p1[i].x;\n        vertexArray[vertoffset + 1] = p1[i].y;\n        vertexArray[vertoffset + 2] = p1[i].z;\n\n        vertexArray[vertoffset + 3] = p2[i].x;\n        vertexArray[vertoffset + 4] = p2[i].y;\n        vertexArray[vertoffset + 5] = p2[i].z;\n\n        for (var j = 0; j < 6; ++j) {\n            colorArray[vertoffset + 3 * j] = color.r;\n            colorArray[vertoffset + 1 + 3 * j] = color.g;\n            colorArray[vertoffset + 2 + 3 * j] = color.b;\n        }\n\n        if (i > 0) {\n            var faces = [offset, offset + 1, offset - 1, offset - 2];\n            var faceoffset = geoGroup.faceidx;\n\n            faceArray[faceoffset] = faces[0];\n            faceArray[faceoffset + 1] = faces[1];\n            faceArray[faceoffset + 2] = faces[3];\n            faceArray[faceoffset + 3] = faces[1];\n            faceArray[faceoffset + 4] = faces[2];\n            faceArray[faceoffset + 5] = faces[3];\n\n            geoGroup.faceidx += 6;\n        }\n\n        geoGroup.vertices += 2;\n    }\n\n};\n\nfunction drawShapeStrip(geo: Geometry, points, colors, div, thickness, opacity, shape) {\n\n    // points is a 2D array, dimensionality given by [num = cross-sectional\n    // resolution][len = length of strip]\n    var i, j, num, len;\n    num = points.length;\n    if (num < 2 || points[0].length < 2)\n        return;\n\n    for (i = 0; i < num; i++) { // spline to generate greater length-wise\n        // resolution\n        points[i] = subdivide_spline(points[i], div);\n    }\n    len = points[0].length;\n\n    if (!thickness) // if thickness is 0, we can use a smaller geometry than\n        // this function generates\n        return drawThinStrip(geo, points[0], points[num - 1], colors);\n\n    var axis, cs_shape, cs_bottom, cs_top, last_cs_bottom, last_cs_top;\n\n    // cache the available cross-sectional shapes\n    var cs_ellipse = [], cs_rectangle = [], cs_parabola = [];\n    for (j = 0; j < num; j++) {\n        cs_ellipse.push(0.25 + 1.5 *\n            Math.sqrt((num - 1) * j - Math.pow(j, 2)) / (num - 1));\n        cs_rectangle.push(0.5);\n        cs_parabola.push(2 * (Math.pow(j / num, 2) - j / num) + 0.6);\n    }\n\n    /*\n     * face_refs array is used to generate faces from vertexArray\n     * iteratively. As we move through each cross-sectional segment of\n     * points, we draw lateral faces backwards to the previous\n     * cross-sectional segment.\n     * \n     * To correctly identify the points needed to make each face we use this\n     * array as a lookup table for the relative indices of each needed point\n     * in the vertices array.\n     * \n     * 4 points are used to create 2 faces.\n     */\n\n    var face_refs = [];\n    for (j = 0; j < num * 2 - 1; j++) {\n        /*\n         * [curr vertex in curr cross-section, next vertex in curr\n         * cross-section, next vertex in prev cross-section, curr vertex in\n         * prev cross-section]\n         */\n        face_refs[j] = [j, j + 1, j + 1 - 2 * num, j - 2 * num];\n    }\n    // last face is different. easier to conceptualize this by drawing a\n    // diagram\n    face_refs[num * 2 - 1] = [j, j + 1 - 2 * num, j + 1 - 4 * num,\n        j - 2 * num];\n\n    var v_offset, va_offset, f_offset;\n    var currentAtom;\n    var color, colori;\n    var vertexArray, colorArray, faceArray, face;\n    let geoGroup = geo.updateGeoGroup();\n\n    for (i = 0; i < len; i++) {\n        let gnum = geo.groups;\n        let replicating = false;\n        geoGroup = geo.updateGeoGroup(2 * num); // ensure vertex capacity\n        if (gnum != geo.groups && i > 0) {\n            //we created a new geo - need to replicate vertices at edge \n            //(but not faces)\n            i = i - 1;\n            replicating = true;\n        }\n        colori = Math.round(i * (colors.length - 1) / len);\n        color = CC.color(colors[colori]);\n\n        last_cs_bottom = cs_bottom;\n        last_cs_top = cs_top;\n        cs_bottom = [];\n        cs_top = [];\n        axis = [];\n\n        if (points[0][i].atom !== undefined) // TODO better edge case\n        // handling\n        {\n            currentAtom = points[0][i].atom;\n            if (shape === \"oval\")\n                cs_shape = cs_ellipse;\n            else if (shape === \"rectangle\")\n                cs_shape = cs_rectangle;\n            else if (shape === \"parabola\")\n                cs_shape = cs_parabola;\n        }\n        if (!cs_shape)\n            cs_shape = cs_rectangle;\n\n        // calculate thickness at each width point, from cross-sectional\n        // shape\n        var toNext, toSide;\n        for (j = 0; j < num; j++) {\n            if (i < len - 1)\n                toNext = points[j][i + 1].clone().sub(points[j][i]);\n            else\n                toNext = points[j][i - 1].clone().sub(points[j][i])\n                    .negate();\n\n            if (j < num - 1)\n                toSide = points[j + 1][i].clone().sub(points[j][i]);\n            else\n                toSide = points[j - 1][i].clone().sub(points[j][i])\n                    .negate();\n\n            axis[j] = toSide.cross(toNext).normalize().multiplyScalar(\n                thickness * cs_shape[j]);\n        }\n\n        // generate vertices by applying cross-sectional shape thickness to\n        // input points\n        for (j = 0; j < num; j++)\n            cs_bottom[j] = points[j][i].clone().add(\n                axis[j].clone().negate());\n        for (j = 0; j < num; j++)\n            cs_top[j] = points[j][i].clone().add(axis[j]);\n\n        /*\n         * Until this point the vertices have been dealt with as\n         * Vector3() objects, but we need to serialize them into the\n         * geoGroup.vertexArray, where every three indices represents the\n         * next vertex. The colorArray is analogous.\n         * \n         * In the following for-loops, j iterates through VERTICES so we\n         * need to index them in vertexArray by 3*j + either 0, 1, or 2 for\n         * xyz or rgb component.\n         */\n\n        vertexArray = geoGroup.vertexArray;\n        colorArray = geoGroup.colorArray;\n        faceArray = geoGroup.faceArray;\n        v_offset = geoGroup.vertices;\n        va_offset = v_offset * 3; // in case geoGroup already contains\n        // vertices\n\n        // bottom edge of cross-section, vertices [0, num)\n        for (j = 0; j < num; j++) {\n            vertexArray[va_offset + 3 * j + 0] = cs_bottom[j].x;\n            vertexArray[va_offset + 3 * j + 1] = cs_bottom[j].y;\n            vertexArray[va_offset + 3 * j + 2] = cs_bottom[j].z;\n        }\n\n        // top edge of cross-section, vertices [num, 2*num)\n        // add these backwards, so that each cross-section's vertices are\n        // added sequentially to vertexArray\n        for (j = 0; j < num; j++) {\n            vertexArray[va_offset + 3 * j + 0 + 3 * num] = cs_top[num - 1 - j].x;\n            vertexArray[va_offset + 3 * j + 1 + 3 * num] = cs_top[num - 1 - j].y;\n            vertexArray[va_offset + 3 * j + 2 + 3 * num] = cs_top[num - 1 - j].z;\n        }\n\n        for (j = 0; j < 2 * num; ++j) {\n            colorArray[va_offset + 3 * j + 0] = color.r;\n            colorArray[va_offset + 3 * j + 1] = color.g;\n            colorArray[va_offset + 3 * j + 2] = color.b;\n        }\n\n        if (i > 0 && !replicating) {\n\n            for (j = 0; j < num * 2; j++) {\n\n                // get VERTEX indices of the 4 points of a rectangular face\n                // (as opposed to literal vertexArray indices)\n                face = [v_offset + face_refs[j][0],\n                v_offset + face_refs[j][1],\n                v_offset + face_refs[j][2],\n                v_offset + face_refs[j][3]];\n\n                f_offset = geoGroup.faceidx;\n\n                // need 2 triangles to draw a face between 4 points\n                faceArray[f_offset] = face[0];\n                faceArray[f_offset + 1] = face[1];\n                faceArray[f_offset + 2] = face[3];\n\n                faceArray[f_offset + 3] = face[1];\n                faceArray[f_offset + 4] = face[2];\n                faceArray[f_offset + 5] = face[3];\n\n                geoGroup.faceidx += 6;\n\n                // TODO implement clickable the right way. midpoints of\n                // strand between consecutive atoms\n            }\n\n            if (currentAtom.clickable || currentAtom.hoverable) {\n                var faces = [];\n\n                faces.push(new Triangle(last_cs_bottom[0],\n                    cs_bottom[0], cs_bottom[num - 1]));\n                faces.push(new Triangle(last_cs_bottom[0],\n                    cs_bottom[num - 1], last_cs_bottom[num - 1]));\n\n                faces.push(new Triangle(last_cs_bottom[num - 1],\n                    cs_bottom[num - 1], cs_top[num - 1]));\n                faces.push(new Triangle(last_cs_bottom[num - 1],\n                    cs_top[num - 1], last_cs_top[num - 1]));\n\n                faces.push(new Triangle(cs_top[0], last_cs_top[0],\n                    last_cs_top[num - 1]));\n                faces.push(new Triangle(cs_top[num - 1], cs_top[0],\n                    last_cs_top[num - 1]));\n\n                faces.push(new Triangle(cs_bottom[0],\n                    last_cs_bottom[0], last_cs_top[0]));\n                faces.push(new Triangle(cs_top[0], cs_bottom[0],\n                    last_cs_top[0]));\n\n                for (j in faces) {\n                    currentAtom.intersectionShape.triangle.push(faces[j]);\n                }\n            }\n        }\n\n        geoGroup.vertices += 2 * num;\n    }\n\n    // for terminal faces\n    vertexArray = geoGroup.vertexArray;\n    colorArray = geoGroup.colorArray;\n    faceArray = geoGroup.faceArray;\n    v_offset = geoGroup.vertices;\n    va_offset = v_offset * 3;\n    f_offset = geoGroup.faceidx;\n\n    for (i = 0; i < num - 1; i++) // \"rear\" face\n    {\n        face = [i, i + 1, 2 * num - 2 - i, 2 * num - 1 - i];\n\n        f_offset = geoGroup.faceidx;\n\n        faceArray[f_offset] = face[0];\n        faceArray[f_offset + 1] = face[1];\n        faceArray[f_offset + 2] = face[3];\n\n        faceArray[f_offset + 3] = face[1];\n        faceArray[f_offset + 4] = face[2];\n        faceArray[f_offset + 5] = face[3];\n\n        geoGroup.faceidx += 6;\n    }\n\n    for (i = 0; i < num - 1; i++) // \"front\" face\n    {\n        face = [v_offset - 1 - i, v_offset - 2 - i,\n        v_offset - 2 * num + i + 1, v_offset - 2 * num + i];\n\n        f_offset = geoGroup.faceidx;\n\n        faceArray[f_offset] = face[0];\n        faceArray[f_offset + 1] = face[1];\n        faceArray[f_offset + 2] = face[3];\n\n        faceArray[f_offset + 3] = face[1];\n        faceArray[f_offset + 4] = face[2];\n        faceArray[f_offset + 5] = face[3];\n\n        geoGroup.faceidx += 6;\n    }\n\n};\n\nfunction drawPlainStrip(geo, points, colors, div, thickness, opacity) {\n    if ((points.length) < 2)\n        return;\n\n    var p1, p2;\n    p1 = points[0];\n    p2 = points[points.length - 1];\n\n    p1 = subdivide_spline(p1, div);\n    p2 = subdivide_spline(p2, div);\n    if (!thickness)\n        return drawThinStrip(geo, p1, p2, colors);\n\n    // var vs = geo.vertices, fs = geo.faces;\n    var vs = [];\n    var axis, p1v, p2v, a1v, a2v;\n\n    var faces = [[0, 2, -6, -8], [-4, -2, 6, 4], [7, -1, -5, 3],\n    [-3, 5, 1, -7]];\n\n    var offset, vertoffset, faceoffset;\n    var color, colori;\n    var currentAtom, lastAtom;\n    var i, lim, j;\n    var face1, face2, face3;\n    var geoGroup, vertexArray, colorArray, faceArray;\n\n    for (i = 0, lim = p1.length; i < lim; i++) {\n\n        colori = Math.round(i * (colors.length - 1) / lim);\n        color = CC.color(colors[colori]);\n\n        vs.push(p1v = p1[i]); // 0\n        vs.push(p1v); // 1\n        vs.push(p2v = p2[i]); // 2\n        vs.push(p2v); // 3\n        if (i < lim - 1) {\n            var toNext = p1[i + 1].clone().sub(p1[i]);\n            var toSide = p2[i].clone().sub(p1[i]);\n            axis = toSide.cross(toNext).normalize().multiplyScalar(\n                thickness);\n        }\n        vs.push(a1v = p1[i].clone().add(axis)); // 4\n        vs.push(a1v); // 5\n        vs.push(a2v = p2[i].clone().add(axis)); // 6\n        vs.push(a2v); // 7\n\n        if (p1v.atom !== undefined)\n            currentAtom = p1v.atom;\n\n        geoGroup = geo.updateGeoGroup(8);\n        vertexArray = geoGroup.vertexArray;\n        colorArray = geoGroup.colorArray;\n        faceArray = geoGroup.faceArray;\n        offset = geoGroup.vertices;\n        vertoffset = offset * 3;\n\n        vertexArray[vertoffset] = p1v.x;\n        vertexArray[vertoffset + 1] = p1v.y;\n        vertexArray[vertoffset + 2] = p1v.z;\n        vertexArray[vertoffset + 3] = p1v.x;\n        vertexArray[vertoffset + 4] = p1v.y;\n        vertexArray[vertoffset + 5] = p1v.z;\n        vertexArray[vertoffset + 6] = p2v.x;\n        vertexArray[vertoffset + 7] = p2v.y;\n        vertexArray[vertoffset + 8] = p2v.z;\n        vertexArray[vertoffset + 9] = p2v.x;\n        vertexArray[vertoffset + 10] = p2v.y;\n        vertexArray[vertoffset + 11] = p2v.z;\n        vertexArray[vertoffset + 12] = a1v.x;\n        vertexArray[vertoffset + 13] = a1v.y;\n        vertexArray[vertoffset + 14] = a1v.z;\n        vertexArray[vertoffset + 15] = a1v.x;\n        vertexArray[vertoffset + 16] = a1v.y;\n        vertexArray[vertoffset + 17] = a1v.z;\n        vertexArray[vertoffset + 18] = a2v.x;\n        vertexArray[vertoffset + 19] = a2v.y;\n        vertexArray[vertoffset + 20] = a2v.z;\n        vertexArray[vertoffset + 21] = a2v.x;\n        vertexArray[vertoffset + 22] = a2v.y;\n        vertexArray[vertoffset + 23] = a2v.z;\n\n        for (j = 0; j < 8; ++j) {\n            colorArray[vertoffset + 3 * j] = color.r;\n            colorArray[vertoffset + 1 + 3 * j] = color.g;\n            colorArray[vertoffset + 2 + 3 * j] = color.b;\n        }\n\n        if (i > 0) {\n\n            // both points have distinct atoms\n            var diffAtoms = ((lastAtom !== undefined && currentAtom !== undefined) && lastAtom.serial !== currentAtom.serial);\n\n            for (j = 0; j < 4; j++) {\n\n                var face = [offset + faces[j][0], offset + faces[j][1],\n                offset + faces[j][2], offset + faces[j][3]];\n\n                faceoffset = geoGroup.faceidx;\n\n                faceArray[faceoffset] = face[0];\n                faceArray[faceoffset + 1] = face[1];\n                faceArray[faceoffset + 2] = face[3];\n                faceArray[faceoffset + 3] = face[1];\n                faceArray[faceoffset + 4] = face[2];\n                faceArray[faceoffset + 5] = face[3];\n\n                geoGroup.faceidx += 6;\n\n                if (currentAtom.clickable || lastAtom.clickable || currentAtom.hoverable || lastAtom.hoverable) {\n\n                    var p1a = vs[face[3]].clone(), p1b = vs[face[0]]\n                        .clone(), p2a = vs[face[2]].clone(), p2b = vs[face[1]]\n                            .clone();\n\n                    p1a.atom = vs[face[3]].atom || null; // should be\n                    // same\n                    p2a.atom = vs[face[2]].atom || null;\n\n                    p1b.atom = vs[face[0]].atom || null; // should be\n                    // same\n                    p2b.atom = vs[face[1]].atom || null;\n\n                    if (diffAtoms) {\n                        var m1 = p1a.clone().add(p1b).multiplyScalar(0.5);\n                        var m2 = p2a.clone().add(p2b).multiplyScalar(0.5);\n                        var m = p1a.clone().add(p2b).multiplyScalar(0.5);\n\n                        if (j % 2 === 0) {\n                            if (lastAtom.clickable || lastAtom.hoverable) {\n                                face1 = new Triangle(m1, m, p1a);\n                                face2 = new Triangle(m2, p2a, m);\n                                face3 = new Triangle(m, p2a, p1a);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face2);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n\n                            if (currentAtom.clickable || currentAtom.hoverable) {\n                                face1 = new Triangle(p1b, p2b, m);\n                                face2 = new Triangle(p2b, m2, m);\n                                face3 = new Triangle(p1b, m, m1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face2);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                        } else {\n                            if (currentAtom.clickable || currentAtom.hoverable) {\n                                face1 = new Triangle(m1, m, p1a);\n                                face2 = new Triangle(m2, p2a, m);\n                                face3 = new Triangle(m, p2a, p1a);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face2);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n\n                            if (lastAtom.clickable || lastAtom.hoverable) {\n                                face1 = new Triangle(p1b, p2b, m);\n                                face2 = new Triangle(p2b, m2, m);\n                                face3 = new Triangle(p1b, m, m1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face2);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                        }\n\n                    }\n\n                    // face for single atom\n                    else if (currentAtom.clickable || currentAtom.hoverable) {\n                        face1 = new Triangle(p1b, p2b, p1a);\n                        face2 = new Triangle(p2b, p2a, p1a);\n                        currentAtom.intersectionShape.triangle.push(face1);\n                        currentAtom.intersectionShape.triangle.push(face2);\n                    }\n\n                }\n\n            }\n        }\n\n        geoGroup.vertices += 8;\n        lastAtom = currentAtom;\n    }\n\n    var vsize = vs.length - 8; // Cap\n\n    geoGroup = geo.updateGeoGroup(8);\n    vertexArray = geoGroup.vertexArray;\n    colorArray = geoGroup.colorArray;\n    faceArray = geoGroup.faceArray;\n    offset = geoGroup.vertices;\n    vertoffset = offset * 3;\n    faceoffset = geoGroup.faceidx;\n\n    for (i = 0; i < 4; i++) {\n        vs.push(vs[i * 2]);\n        vs.push(vs[vsize + i * 2]);\n\n        var v1 = vs[i * 2], v2 = vs[vsize + i * 2];\n\n        vertexArray[vertoffset + 6 * i] = v1.x;\n        vertexArray[vertoffset + 1 + 6 * i] = v1.y;\n        vertexArray[vertoffset + 2 + 6 * i] = v1.z;\n        vertexArray[vertoffset + 3 + 6 * i] = v2.x;\n        vertexArray[vertoffset + 4 + 6 * i] = v2.y;\n        vertexArray[vertoffset + 5 + 6 * i] = v2.z;\n\n        colorArray[vertoffset + 6 * i] = color.r;\n        colorArray[vertoffset + 1 + 6 * i] = color.g;\n        colorArray[vertoffset + 2 + 6 * i] = color.b;\n        colorArray[vertoffset + 3 + 6 * i] = color.r;\n        colorArray[vertoffset + 4 + 6 * i] = color.g;\n        colorArray[vertoffset + 5 + 6 * i] = color.b;\n\n    }\n\n    vsize += 8;\n\n    face1 = [offset, offset + 2, offset + 6, offset + 4];\n    face2 = [offset + 1, offset + 5, offset + 7, offset + 3];\n\n    faceArray[faceoffset] = face1[0];\n    faceArray[faceoffset + 1] = face1[1];\n    faceArray[faceoffset + 2] = face1[3];\n    faceArray[faceoffset + 3] = face1[1];\n    faceArray[faceoffset + 4] = face1[2];\n    faceArray[faceoffset + 5] = face1[3];\n    faceArray[faceoffset + 6] = face2[0];\n    faceArray[faceoffset + 7] = face2[1];\n    faceArray[faceoffset + 8] = face2[3];\n    faceArray[faceoffset + 9] = face2[1];\n    faceArray[faceoffset + 10] = face2[2];\n    faceArray[faceoffset + 11] = face2[3];\n\n    geoGroup.faceidx += 12;\n    geoGroup.vertices += 8;\n\n    // TODO: Add intersection planes for caps\n};\n\n\nfunction drawStrip(geo, points, colors, div, thickness, opacity, shape) {\n    if (!shape || shape === \"default\")\n        shape = \"rectangle\";\n    if (shape === 'edged')\n        drawPlainStrip(geo, points, colors, div, thickness, opacity);\n    else if (shape === \"rectangle\" || shape === \"oval\" || shape === \"parabola\")\n        drawShapeStrip(geo, points, colors, div, thickness, opacity, shape);\n};\n\n// check if given atom is an alpha carbon\nfunction isAlphaCarbon(atom) {\n    return atom && atom.elem === \"C\" && atom.atom === \"CA\"; // note that\n    // calcium is\n    // also CA\n};\n\n// check whether two atoms are members of the same residue or subsequent,\n// connected residues (a before b)\nfunction inConnectedResidues(a, b) {\n    if (a && b && a.chain === b.chain) {\n        if (!a.hetflag && !b.hetflag && (a.reschain === b.reschain) &&\n            (a.resi === b.resi || a.resi === b.resi - 1))\n            return true;\n        if (a.resi < b.resi) {\n            // some PDBs have gaps in the numbering but the residues are\n            // still connected\n            // assume if within 4A they are connected\n            var dx = a.x - b.x;\n            var dy = a.y - b.y;\n            var dz = a.z - b.z;\n            var dist = dx * dx + dy * dy + dz * dz;\n            if (a.atom == \"CA\" && b.atom == \"CA\" && dist < 16.0) //protein residues not connected\n                return true; // calpha dist\n            else if ((a.atom == \"P\" || b.atom == \"P\") && dist < 64.0) //dna\n                return true;\n        }\n    }\n\n    return false;\n};\n\n// add geo to the group\nfunction setGeo(group, geo, opacity, outline, setNormals) {\n\n    if (geo == null || geo.vertices == 0) return;\n    if (setNormals) {\n        geo.initTypedArrays();\n        geo.setUpNormals();\n    }\n\n    var cartoonMaterial = new MeshDoubleLambertMaterial();\n    cartoonMaterial.vertexColors = Coloring.FaceColors;\n    if (typeof (opacity) === \"number\" && opacity >= 0 && opacity < 1) {\n        cartoonMaterial.transparent = true;\n        cartoonMaterial.opacity = opacity;\n    }\n    cartoonMaterial.outline = outline;\n    var cartoonMesh = new Mesh(geo, cartoonMaterial as Material);\n    group.add(cartoonMesh);\n};\n\nfunction addBackbonePoints(points, num, smoothen, backbonePt,\n    orientPt, prevOrientPt, backboneAtom, atoms, atomi) {\n    var widthScalar, i, delta, v, addArrowPoints, testStyle;\n\n    if (!backbonePt || !orientPt || !backboneAtom)\n        return;\n\n    // the side vector points along the axis from backbone atom to\n    // orientation atom (eg. CA to O, in peptides)\n    var sideVec = orientPt.sub(backbonePt);\n    sideVec.normalize();\n\n    //find next atom like this one\n    var forwardVec = atoms[atomi];\n    for (i = atomi + 1; i < atoms.length; i++) {\n        forwardVec = atoms[i];\n        if (forwardVec.atom == backboneAtom.atom)\n            break;\n    }\n    // the forward vector points along the axis from backbone atom to next\n    // backbone atom\n    forwardVec = forwardVec ? new Vector3(forwardVec.x,\n        forwardVec.y, forwardVec.z) : new Vector3(0, 0, 0);\n    forwardVec.sub(backbonePt);\n\n    // adjustments for proper beta arrow appearance\n    if (backboneAtom.ss === \"arrow start\") {\n        var adjustment = forwardVec.clone().multiplyScalar(0.3).cross(\n            orientPt); // adjust perpendicularly to strand face\n        backbonePt.add(adjustment);\n\n        var upVec = forwardVec.clone().cross(sideVec).normalize();\n        sideVec.rotateAboutVector(upVec, 0.43);\n    }\n\n    // determine from cartoon style or secondary structure how wide the\n    // strand should be here\n    // ribbon shape should have same width as thickness\n    if (backboneAtom.style.cartoon.ribbon) {\n        widthScalar = backboneAtom.style.cartoon.thickness || defaultThickness;\n\n    } else // depending on secondary structure, multiply the orientation\n    // vector by some scalar\n    {\n        if (!backboneAtom.style.cartoon.width) {\n            if (backboneAtom.ss === \"c\") {\n                if (backboneAtom.atom === \"P\")\n                    widthScalar = nucleicAcidWidth;\n                else\n                    widthScalar = coilWidth;\n            } else if (backboneAtom.ss === \"arrow start\") {\n                widthScalar = helixSheetWidth;\n                addArrowPoints = true;\n\n            } else if (backboneAtom.ss === \"arrow end\")\n                widthScalar = coilWidth;\n\n            else if (backboneAtom.ss === \"h\" &&\n                backboneAtom.style.cartoon.tubes ||\n                backboneAtom.ss === \"tube start\")\n                widthScalar = coilWidth;\n\n            else\n                widthScalar = helixSheetWidth;\n        } else\n            widthScalar = backboneAtom.style.cartoon.width;\n    }\n\n    // make sure the strand orientation doesn't twist more than 90 degrees\n    if (prevOrientPt != null && sideVec.dot(prevOrientPt) < 0)\n        sideVec.negate();\n\n    sideVec.multiplyScalar(widthScalar);\n    for (i = 0; i < num; i++) {\n        // produces NUM incremental points from backbone atom minus\n        // orientation vector\n        // to backbone atom plus orientation vector\n        delta = -1 + i * 2 / (num - 1); // -1 to 1 incrementing by num\n        v = new Vector3(backbonePt.x + delta * sideVec.x,\n            backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);\n        v.atom = backboneAtom;\n        if (smoothen && backboneAtom.ss === \"s\")\n            v.smoothen = true;\n        points[i].push(v); // a num-length array of arrays, where each\n        // inner array contains length-wise points\n        // along the backbone offset by some constant pertaining to its cell\n        // in the outer array\n    }\n\n    if (addArrowPoints) {\n\n        sideVec.multiplyScalar(2);\n        for (i = 0; i < num; i++) {\n            delta = -1 + i * 2 / (num - 1); // -1 to 1 incrementing by num\n            v = new Vector3(backbonePt.x + delta * sideVec.x,\n                backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);\n            v.atom = backboneAtom;\n            v.smoothen = false;\n            v.skip = true;\n            points[i].push(v);\n        }\n    }\n\n    // make sure the strand is all the same style\n    testStyle = backboneAtom.style.cartoon.style || 'default';\n    if (points.style) {\n        if (points.style != testStyle) {\n            console\n                .log(\"Warning: a cartoon chain's strand-style is ambiguous\");\n            points.style = 'default';\n        }\n\n    } else\n        points.style = testStyle;\n\n    // revert ss keywords used for arrow rendering back to original value\n    if (backboneAtom.ss === \"arrow start\" || backboneAtom.ss === \"arrow end\")\n        backboneAtom.ss = \"s\";\n\n    return addArrowPoints;\n};\n\n// proteins na backbone na terminus nucleobases\nconst cartoonAtoms = {\n    \"C\": true, \"CA\": true, \"O\": true, \"P\": true, \"OP2\": true,\n    \"O2P\": true, \"O5'\": true, \"O3'\": true, \"C5'\": true,\n    \"C2'\": true, \"O5*\": true, \"O3*\": true, \"C5*\": true,\n    \"C2*\": true, \"N1\": true, \"N3\": true\n};\nconst purResns = { \"DA\": true, \"DG\": true, \"A\": true, \"G\": true };\nconst pyrResns = { \"DT\": true, \"DC\": true, \"U\": true, \"C\": true, \"T\": true };\nconst naResns = { \"DA\": true, \"DG\": true, \"A\": true, \"G\": true, \"DT\": true, \"DC\": true, \"U\": true, \"C\": true, \"T\": true };\n\n\nexport function drawCartoon(group, atomList, gradientrange, quality = 10) {\n\n    let num = quality;\n    let div = quality;\n\n    var cartoon, prev, curr, next, currColor, nextColor, thickness, i;\n    var backbonePt, orientPt, prevOrientPt, terminalPt, termOrientPt, baseStartPt, baseEndPt;\n    var tubeStart, tubeEnd, drawingTube;\n    var shapeGeo = new Geometry(true); // for shapes that don't need normals computed\n    var geo = new Geometry(true);\n    var colors = [];\n    var points: any = [];\n    var opacity = 1;\n    var outline = false;\n\n    var gradients: any = {};\n    for (var g in Gradient.builtinGradients) {\n        if (Gradient.builtinGradients.hasOwnProperty(g)) {\n            //COUNTER INTUITIVE - spectrum reverses direction to gradient to match other tools\n            gradients[g] = new Gradient.builtinGradients[g](gradientrange[1], gradientrange[0]);\n        }\n    }\n\n    var cartoonColor = function (next, cartoon) { //atom and cartoon style object\n        if (gradientrange && cartoon.color === 'spectrum') {\n            if (cartoon.colorscheme in gradients) {\n                return gradients[cartoon.colorscheme].valueToHex(next.resi);\n            } else {\n                return gradients.sinebow.valueToHex(next.resi);\n            }\n        }\n        else {\n            return getColorFromStyle(next, cartoon).getHex();\n        }\n    };\n\n    for (i = 0; i < num; i++)\n        points[i] = [];\n\n    // first determine where beta sheet arrows and alpha helix tubes belong\n    var inSheet = false;\n    var inHelix = false; //only considering tube styled helices\n    var atoms = [];\n    for (i in atomList) {\n        next = atomList[i];\n        if (next.elem === 'C' && next.atom === 'CA') {\n            var connected = inConnectedResidues(curr, next);\n\n            // last two residues in a beta sheet become arrowhead\n            if (connected && next.ss === \"s\") {\n                inSheet = true;\n            } else if (inSheet) {\n                if (curr && prev && curr.style.cartoon.arrows && prev.style.cartoon.arrows) {\n                    curr.ss = \"arrow end\";\n                    prev.ss = \"arrow start\";\n                }\n                inSheet = false;\n            }\n\n            // first and last residues in a helix are used to draw tube\n            if (connected && (curr.ss === \"h\" || curr.ss == \"tube start\") && curr.style.cartoon.tubes) {\n                if (!inHelix && curr.ss != \"tube start\" && next.style.cartoon.tubes) {\n                    next.ss = \"tube start\";\n                    inHelix = true;\n                }\n            } else if (inHelix) {\n                if (curr.ss === \"tube start\") {\n                    curr.ss = \"tube end\"; //only one residue\n                } else if (prev && prev.style.cartoon.tubes) {\n                    prev.ss = \"tube end\";\n                }\n                inHelix = false;\n            }\n            prev = curr;\n            curr = next;\n        }\n        if (next && next.atom in cartoonAtoms) {\n            atoms.push(next);\n        }\n    }\n    if (inHelix && curr.style.cartoon.tubes) {\n        curr.ss = \"tube end\";\n        inHelix = false;\n    }\n\n    var flushGeom = function (connect) {\n        //write out points, update geom,etc\n        if (points[0].length > 0) {\n            drawStrip(geo, points, colors, div, thickness, opacity, points.style);\n        }\n\n        var saved = [], savedc = null;\n        if (connect) {\n            //recycle last point to first point of next points array\n            for (i = 0; i < num; i++) {\n                saved[i] = points[i][points[i].length - 1];\n            }\n            savedc = colors[colors.length - 1];\n        }\n        points = [];\n        for (i = 0; i < num; i++)\n            points[i] = [];\n        colors = [];\n\n        if (connect) {\n            for (i = 0; i < num; i++) {\n                points[i].push(saved[i]);\n            }\n            colors.push(savedc);\n        }\n\n        setGeo(group, geo, opacity, outline, true);\n        setGeo(group, shapeGeo, opacity, outline, false);\n        geo = new Geometry(true);\n        shapeGeo = new Geometry(true);\n    };\n\n    // then accumulate points\n    curr = undefined;\n    let disconnects = []\n    for (var a = 0; a < atoms.length; a++) {\n        next = atoms[a];\n\n        var nextresn = next.resn.trim();\n        var inNucleicAcid = nextresn in naResns;\n        opacity = 1;\n        // determine cartoon style\n        cartoon = next.style.cartoon;\n        if (curr && curr.style.cartoon)\n            opacity = curr.style.cartoon.opacity;\n        if (curr && curr.style.cartoon && curr.style.cartoon.outline)\n            outline = curr.style.cartoon.outline;\n\n        // create a new geometry when opacity changes\n        //this should work fine if opacity is set by chain, but will\n        //break if it changes within the chain\n        if (curr && curr.style.cartoon && (!next.style.cartoon ||\n            curr.style.cartoon.opacity != next.style.cartoon.opacity)) {\n            flushGeom(curr.chain == next.chain);\n        }\n\n        //check for disconnects in the same chain\n        if (curr && next && !inConnectedResidues(curr, next) && curr.chain &&\n            curr.chain == next.chain && !curr.hetflag && !next.hetflag &&\n            curr.reschain + 1 == next.reschain) {\n            disconnects.push([curr, next]);\n        }\n\n        if (cartoon.style === \"trace\") // draw cylinders connecting\n        // consecutive 'backbone' atoms\n        {\n            /*\n             * \"trace\" style just draws cylinders between consecutive\n             * 'backbone' atoms, such as alpha carbon for polypeptides and\n             * phosphorus for DNA.\n             */\n            if (next.hetflag) {\n                ; //ignore non-protein atoms\n            } else if (next.elem === 'C' && next.atom === 'CA' ||\n                inNucleicAcid && next.atom === \"P\" ||\n                next.atom === 'BB') {\n                // determine cylinder color\n                nextColor = cartoonColor(next, cartoon);\n\n                // determine cylinder thickness\n                if (isNumeric(cartoon.thickness))\n                    thickness = cartoon.thickness;\n                else\n                    thickness = defaultThickness;\n\n                if (inConnectedResidues(curr, next)) {\n                    // if both atoms are same color, draw single cylinder\n                    if (nextColor == currColor) {\n                        var color = CC.color(nextColor);\n                        GLDraw.drawCylinder(shapeGeo, curr, next,\n                            thickness, color, 2, 2);\n                    }\n\n                    else // otherwise draw cylinders for each color\n                    // (split down the middle)\n                    {\n                        var midpoint = new Vector3().addVectors(\n                            curr, next).multiplyScalar(0.5);\n                        var color1 = CC.color(currColor);\n                        var color2 = CC.color(nextColor);\n                        GLDraw.drawCylinder(shapeGeo, curr,\n                            midpoint, thickness, color1, 2, 0);\n                        GLDraw.drawCylinder(shapeGeo, midpoint,\n                            next, thickness, color2, 0, 2);\n                    } // note that an atom object can be duck-typed as a\n                    // Vector3 in this case\n                }\n\n                if ((next.clickable === true || next.hoverable) && (next.intersectionShape !== undefined)) {\n                    //can click on joints to get alpha carbons\n                    var center = new Vector3(next.x, next.y, next.z);\n                    next.intersectionShape.sphere.push(new Sphere(center, thickness));\n                }\n\n                curr = next;\n                currColor = nextColor;\n            }\n        } else // draw default-style cartoons based on secondary structure\n        {\n            // draw backbone through these atoms\n            if (isAlphaCarbon(next) || inNucleicAcid && (next.atom === \"P\" || next.atom.indexOf('O5') == 0)) {\n                if (drawingTube) {\n                    if (next.ss === \"tube end\") {\n                        drawingTube = false;\n                        tubeEnd = new Vector3(next.x, next.y, next.z);\n                        GLDraw.drawCylinder(shapeGeo, tubeStart,\n                            tubeEnd, 2, CC.color(currColor), 1,\n                            1);\n                        next.ss = \"h\";\n\n                    }\n                    else if (curr.chain != next.chain || curr.ss === \"tube end\") { //don't span chains no matter what, check for short tubes (less than ideal)\n                        drawingTube = false;\n                        curr.ss = \"h\";\n                        tubeEnd = new Vector3(curr.x, curr.y, curr.z);\n                        GLDraw.drawCylinder(shapeGeo, tubeStart,\n                            tubeEnd, 2, CC.color(currColor), 1,\n                            1);\n                    }\n                    else\n                        continue; // don't accumulate strand points while\n                    // in the middle of drawing a tube\n                }\n\n                // end of a chain of connected residues (of same style)\n                if (curr && (!inConnectedResidues(curr, next) || curr.ss === \"tube start\")) {\n                    if (curr.ss === \"tube start\") {\n                        drawingTube = true;\n                        tubeStart = new Vector3(curr.x, curr.y,\n                            curr.z);\n                        curr.ss = \"h\";\n                    }\n\n                    if (baseEndPt) // draw the last base if it's a NA chain\n                    {\n                        if (terminalPt)\n                            baseStartPt = new Vector3().addVectors(\n                                curr, terminalPt).multiplyScalar(0.5);\n                        else\n                            baseStartPt = new Vector3(curr.x,\n                                curr.y, curr.z);\n\n                        GLDraw.drawCylinder(shapeGeo, baseStartPt,\n                            baseEndPt, baseThickness, CC\n                                .color(baseEndPt.color), 0, 2);\n                        addBackbonePoints(points, num,\n                            true, terminalPt, termOrientPt,\n                            prevOrientPt, curr, atoms, a);\n                        colors.push(nextColor);\n\n                        baseStartPt = null;\n                        baseEndPt = null;\n                    }\n\n                    // draw accumulated strand points\n                    if (points[0].length > 0)\n                        drawStrip(geo, points, colors, div, thickness,\n                            opacity, points.style);\n\n                    // clear arrays for points and colors\n                    points = [];\n                    for (i = 0; i < num; i++)\n                        points[i] = [];\n                    colors = [];\n                }\n\n                // reached next residue (potentially the first residue)\n                if (curr === undefined || curr.rescode != next.rescode || curr.resi != next.resi) {\n                    if (baseEndPt && curr != undefined) // draw last NA residue's base\n                    {\n                        // start the cylinder at the midpoint between\n                        // consecutive backbone atoms\n                        baseStartPt = new Vector3().addVectors(curr,\n                            next).multiplyScalar(0.5);\n                        var startFix = baseStartPt.clone().sub(baseEndPt)\n                            .multiplyScalar(0.02); // TODO: apply this\n                        // as function of\n                        // thickness\n                        baseStartPt.add(startFix);\n\n                        GLDraw.drawCylinder(shapeGeo, baseStartPt,\n                            baseEndPt, baseThickness, CC\n                                .color(baseEndPt.color), 0, 2);\n                        baseStartPt = null;\n                        baseEndPt = null;\n                    }\n\n                    // determine color and thickness of the next strand\n                    // segment\n                    nextColor = cartoonColor(next, cartoon);\n                    colors.push(nextColor);\n                    if (isNumeric(cartoon.thickness))\n                        thickness = cartoon.thickness;\n                    else\n                        thickness = defaultThickness;\n\n                    curr = next; // advance backbone\n                    backbonePt = new Vector3(curr.x, curr.y, curr.z);\n                    backbonePt.resi = curr.resi;\n                    currColor = nextColor;\n                }\n\n                // click handling\n                if ((next.clickable === true || next.hoverable === true) &&\n                    (next.intersectionShape === undefined || next.intersectionShape.triangle === undefined))\n                    next.intersectionShape = {\n                        sphere: null,\n                        cylinder: [],\n                        line: [],\n                        triangle: []\n                    };\n            }\n            // atoms used to orient the backbone strand\n            else if (curr != undefined && (isAlphaCarbon(curr) && next.atom === \"O\" ||\n                inNucleicAcid && curr.atom === \"P\" &&\n                (next.atom === \"OP2\" || next.atom === \"O2P\") ||\n                inNucleicAcid && curr.atom.indexOf(\"O5\") == 0 &&\n                next.atom.indexOf(\"C5\") == 0)) {\n                orientPt = new Vector3(next.x, next.y, next.z);\n                orientPt.resi = next.resi;\n                if (next.atom === \"OP2\" || next.atom === \"O2P\") // for NA 3'\n                    // terminus\n                    termOrientPt = new Vector3(next.x, next.y,\n                        next.z);\n            }\n\n            // NA 3' terminus is an edge case, need a vector for most recent\n            // O3'\n            else if (inNucleicAcid && next.atom.indexOf(\"O3\") == 0) {\n                terminalPt = new Vector3(next.x, next.y, next.z);\n            }\n\n            // atoms used for drawing the NA base cylinders (diff for\n            // purines and pyramidines)\n            else if ((next.atom === \"N1\" && (nextresn in purResns)) ||\n                (next.atom === \"N3\" && (nextresn in pyrResns))) {\n                baseEndPt = new Vector3(next.x, next.y, next.z);\n                baseEndPt.color = getColorFromStyle(next, cartoon)\n                    .getHex();\n            }\n\n            // when we have a backbone point and orientation point in the\n            // same residue, accumulate strand points\n            if (orientPt && backbonePt && orientPt.resi === backbonePt.resi) {\n                addBackbonePoints(points, num, true,\n                    backbonePt, orientPt, prevOrientPt, curr, atoms,\n                    a);\n                prevOrientPt = orientPt;\n                backbonePt = null;\n                orientPt = null;\n                colors.push(nextColor);\n            }\n        }\n\n    }\n\n    if (baseEndPt) // draw last NA base if needed\n    {\n        if (terminalPt)\n            baseStartPt = new Vector3().addVectors(curr, terminalPt)\n                .multiplyScalar(0.5);\n        else\n            baseStartPt = new Vector3(curr.x, curr.y, curr.z);\n\n        GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness,\n            CC.color(baseEndPt.color), 0, 2);\n        addBackbonePoints(points, num, true, terminalPt,\n            termOrientPt, prevOrientPt, curr, atoms, a);\n        colors.push(nextColor);\n    }\n\n    // for default style, draw the last strand\n    flushGeom(false);\n\n    //cartoon gaps\n    var drawGap = function (start: AtomSpec, end: AtomSpec) {\n        if (start.style.cartoon.gapcutoff &&\n            start.style.cartoon.gapcutoff == end.style.cartoon.gapcutoff) {\n            let cut = start.style.cartoon.gapcutoff;\n            let gap = end.resi - start.resi;\n            if (gap > 0 && gap < cut) {\n\n                let radius = 0.25;\n                let xdiff = end.x-start.x;\n                let ydiff = end.y-start.y;\n                let zdiff = end.z-start.z;\n\n                let gapLength = Math.sqrt(xdiff*xdiff+ydiff*ydiff+zdiff*zdiff);\n                let cylinderLength = gapLength/(2*gap); //one dash for each missing residue, evenly spaced\n\n                let new_start = new Vector3(start.x,start.y,start.z);\n                let div = gapLength/cylinderLength;\n                let dashVector = new Vector3((end.x - start.x) / div, (end.y - start.y) / div, (end.z - start.z) / div);\n\n                new_start.add({x:dashVector.x/2,y:dashVector.y/2,z:dashVector.z/2});\n                let new_end = new_start.clone().add(dashVector);\n                dashVector.multiplyScalar(2); //skip over dash and gap\n                let fakeres = extend({},start);\n                for (var place = 0; place < gap; place++) {\n                    fakeres.resi += 1;\n                    let color = cartoonColor(fakeres, fakeres.style.cartoon);\n                    GLDraw.drawCylinder(shapeGeo, new_start, new_end, radius, CC.color(color), CAP.FLAT, CAP.FLAT);\n                    new_start.add(dashVector);\n                    new_end.add(dashVector);\n                }\n                flushGeom(false);\n            }\n\n        }\n    }\n\n    for (let pair of disconnects) {\n        drawGap(pair[0], pair[1]);\n    }\n};\n\n\n\n", "// Create the global $3Dmol \"namespace\"\n\n\nexport * from \"./3Dmol\";\n\n//import * as $ from 'jquery';\ndeclare var __webpack_exports__: any;\n\nif (window) {\n    //this needs to be exported here so the webworker can see it\n    window.$3Dmol = __webpack_exports__;\n}\n", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { base64ToArray, inflateString } from \"../utilities\";\nimport { MMTFobj } from \"./MMTF\"\n//import { Matrix4 } from \"../WebGL\";\nimport { computeSecondaryStructure } from \"./utils/computeSecondaryStructure\";\nimport { processSymmetries } from \"./utils/processSymmetries\";\nimport { Category } from \"./cifutils/category\";\nimport { AtomSpec } from \"specs\";\nimport { assignPDBBonds } from \"./utils/assignPDBBonds\";\nimport { Matrix4 } from \"../WebGL\";\nimport { isEmpty } from \"./utils/isEmpty\";\n\ndeclare var MMTF: MMTFobj;\n\n\nclass Connectivity {\n  C: Record<string, Record<string, Record<string, number>>> = {};\n\n  constructor(comp_bond) {\n    if (comp_bond) {\n      let ids = comp_bond.getField('comp_id');\n      let a1s = comp_bond.getField('atom_id_1');\n      let a2s = comp_bond.getField('atom_id_2');\n      let orders = comp_bond.getField('value_order');\n\n      for (let i = 0; i < ids.length; i++) {\n        let resn = ids[i];\n        let a1 = a1s[i];\n        let a2 = a2s[i];\n        let oname = orders[i];\n        let o = 1;\n        if (oname == 'doub') o = 2;\n        else if (oname == 'trip') o = 3;\n\n        if (this.C[resn] == undefined) {\n          this.C[resn] = {};\n        }\n        if (this.C[resn][a1] == undefined) {\n          this.C[resn][a1] = {};\n        }\n        if (this.C[resn][a2] == undefined) {\n          this.C[resn][a2] = {};\n        }\n        this.C[resn][a1][a2] = o;\n        this.C[resn][a2][a1] = o;\n      }\n    }\n  }\n\n  //returns bond order, zero if not connected\n  order(resn: string, atom1: string, atom2: string): number {\n    if (this.C[resn] !== undefined) {\n      if (this.C[resn][atom1] !== undefined) {\n        if (this.C[resn][atom1][atom2] !== undefined) {\n          return this.C[resn][atom1][atom2];\n        }\n      }\n    }\n    return 0;\n  }\n}\n\n/* Class for recording inter-component connectivity */\nclass StructConn {\n  public C: [[string,number,string,string],[string,number,string,string],number][] = []; //chain,resi,resn,atomn\n\n  constructor(struct_conn) {\n    if(struct_conn) {\n      //have no idea what the deal with with ptnr3..\n      let types = struct_conn.getField('conn_type_id');\n      let chain1 = struct_conn.getField('ptnr1_label_asym_id');\n      let resi1 = struct_conn.getField('ptnr1_label_seq_id');\n      let resn1 = struct_conn.getField('ptnr1_label_comp_id');\n      let a1 = struct_conn.getField('ptnr1_label_atom_id');\n      let chain2 = struct_conn.getField('ptnr2_label_asym_id');\n      let resi2 = struct_conn.getField('ptnr2_label_seq_id');\n      let resn2 = struct_conn.getField('ptnr2_label_comp_id');\n      let a2 = struct_conn.getField('ptnr2_label_atom_id');\n      let bo = struct_conn.getField('pdbx_value_order');\n\n      for(let i = 0; i < types.length; i++) {\n        if(types[i] == 'disulf' || types[i] == 'covale') { //metal too?\n          let o = bo ? (bo[i] == \"\" ? 1: parseInt(bo[i])) : 1;\n          this.C.push([[chain1[i],resi1[i],resn1[i],a1[i]],[chain2[i],resi2[i],resn2[i],a2[i]],o]);\n        }\n      }\n\n    }\n  }\n}\n\n/* group atoms by chain/resid */\nclass Residues {\n  R: Record<string, Record<number, Record<string, Array<AtomSpec>>>> = {}; //chain, resid, resn (redundant), atom list\n  constructor() {\n\n  }\n\n  add(a: AtomSpec) {\n    if (this.R[a.lchain] == undefined) this.R[a.lchain] = {};\n    if (this.R[a.lchain][a.lresi] == undefined) this.R[a.lchain][a.lresi] = {};\n    if (this.R[a.lchain][a.lresi][a.lresn] == undefined) this.R[a.lchain][a.lresi][a.lresn] = [];\n    this.R[a.lchain][a.lresi][a.lresn].push(a);\n    this.R[a.lchain][a.lresi][a.lresn][a.atom] = a; //look up by atom name\n  }\n\n  private geta([ch,resi,resn,aname]: [string,number,string,string]) {\n    if(this.R[ch] !== undefined &&\n      this.R[ch][resi] !== undefined &&\n      this.R[ch][resi][resn] !== undefined) {\n        return this.R[ch][resi][resn][aname];\n      }\n    return undefined;\n  }\n\n  setBonds(C: Connectivity, SC: StructConn) {\n    for(let ch in this.R) {\n      for(let resi in this.R[ch]) {\n        for(let resn in this.R[ch][resi]) {\n          let atoms = this.R[ch][resi][resn];\n          for(let i = 0; i < atoms.length; i++) {\n            for(let j = i+1; j < atoms.length; j++) {\n              let a1 = atoms[i];\n              let a2 = atoms[j];\n              let bo = C.order(resn,a1.atom,a2.atom);\n              if(a1.altLoc != a2.altLoc && a1.altLoc != \"\" && a2.altLoc != \"\") {\n                bo = 0; \n              }\n              if(bo > 0) {\n                a1.bonds.push(a2.index);\n                a2.bonds.push(a1.index);\n                a1.bondOrder.push(bo);\n                a2.bondOrder.push(bo);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for(let conn of SC.C) {\n      let a1 = conn[0];\n      let a2 = conn[1];\n      let bo = conn[2];\n      let atom1 = this.geta(a1);\n      let atom2 = this.geta(a2);\n      if(atom1 != undefined && atom2 != undefined) {\n        atom1.bonds.push(atom2.index);\n        atom2.bonds.push(atom1.index);\n        atom1.bondOrder.push(bo);\n        atom2.bondOrder.push(bo);      \n      }\n    }\n\n  }\n}\n\n\n/** \n * @param bindata - binary UInt8Array buffer or a base64 encoded string\n * @param ParserOptionsSpec\n * @category Parsers\n*/\nexport function BCIF(bindata: any, options: ParserOptionsSpec) {\n\n  var noH = !options.keepH; // suppress hydrogens by default\n  var selAltLoc = options.altLoc ? options.altLoc : 'A'; //default alternate location to select if present\n  var computeStruct = !options.noComputeSecondaryStructure;\n  //var assemblyIndex = options.assemblyIndex ? options.assemblyIndex : 0;\n  const noAssembly = !options.doAssembly; // don't assemble by default\n  const assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n\n  if (typeof (bindata) == \"string\") {\n    //assume base64 encoded\n    try {\n      bindata = base64ToArray(bindata);\n    } catch (error) {\n      //not base64\n      const encoder = new TextEncoder();\n      bindata = encoder.encode(bindata);\n    }\n  } else {\n    bindata = new Uint8Array(bindata);\n  }\n\n  var bcifData = MMTF.decodeMsgpack(bindata);\n  if (bcifData == 31) {\n    //was gziped\n    bindata = inflateString(bindata, false);\n    bcifData = MMTF.decodeMsgpack(bindata);\n  }\n\n  var atoms: any[][] & Record<string, any> = [];\n  var modelData: any[] = atoms.modelData = [];\n\n\n  var numModels = bcifData.dataBlocks.length;\n  if (numModels == 0) return atoms;\n  if (!options.multimodel) numModels = 1; //first only\n\n\n\n  //loop over models\n  for (let m = 0; m < numModels; m++) {\n    let startm = atoms.length;\n    const serialToIndex: [number, number][] = []; // map from pdb serial to index in atoms\n    modelData.push({ symmetries: [] });\n    atoms.push([]);\n\n    const block = bcifData.dataBlocks[m];\n    const cats = Object.create(null);\n    for (const cat of block.categories) {\n      cats[cat.name.substr(1)] = Category(cat);\n    }\n\n    //extract secondary structure information\n\n    //helices\n    let sslookup = {}; //chain to residue range\n    let sshelix = cats.struct_conf;\n    if (sshelix) {\n      let htypes = sshelix.getField('conf_type_id');\n      let hchain = sshelix.getField('beg_label_asym_id');\n      let hstart = sshelix.getField('beg_label_seq_id');\n      let hend = sshelix.getField('end_label_seq_id');\n\n      for (let i = 0; i < htypes.length; i++) {\n        if (htypes[i].startsWith('H')) {\n          let ch = hchain[i];\n          let startResi = hstart[i];\n          let endResi = hend[i];\n          if (!(ch in sslookup)) {\n            sslookup[ch] = {};\n          }\n          sslookup[ch][startResi] = \"h1\";\n          for (let res = startResi + 1; res < endResi; res++) {\n            sslookup[ch][res] = \"h\";\n          }\n          sslookup[ch][endResi] = \"h2\";\n        }\n      }\n    }\n    //sheets\n    let sssheet = cats.struct_sheet_range;\n    if (sssheet) {\n      let sids = sssheet.getField('id');\n      let schain = sssheet.getField('beg_label_asym_id');\n      let sstart = sssheet.getField('beg_label_seq_id');\n      let send = sssheet.getField('end_label_seq_id');\n\n      for (let i = 0; i < sids.length; i++) {\n        let ch = schain[i];\n        let startResi = sstart[i];\n        let endResi = send[i];\n        if (!(ch in sslookup)) {\n          sslookup[ch] = {};\n        }\n        sslookup[ch][startResi] = \"s1\";\n        for (let res = startResi + 1; res < endResi; res++) {\n          sslookup[ch][res] = \"s\";\n        }\n        sslookup[ch][endResi] = \"s2\";\n\n      }\n    }\n\n    //symmetry operations\n    let structops = cats.pdbx_struct_oper_list;\n    let opids = structops.getField('id');\n    if (opids && !noAssembly) {\n      let matrix11 = structops.getField('matrix[1][1]');\n      let matrix12 = structops.getField('matrix[1][2]');\n      let matrix13 = structops.getField('matrix[1][3]');\n      let matrix21 = structops.getField('matrix[2][1]');\n      let matrix22 = structops.getField('matrix[2][2]');\n      let matrix23 = structops.getField('matrix[2][3]');\n      let matrix31 = structops.getField('matrix[3][1]');\n      let matrix32 = structops.getField('matrix[3][2]');\n      let matrix33 = structops.getField('matrix[3][3]');\n      let vector1 = structops.getField('vector[1]');\n      let vector2 = structops.getField('vector[2]');\n      let vector3 = structops.getField('vector[3]');\n\n      for (let i = 0; i < opids.length; i++) {\n        const matrix = new Matrix4(\n          matrix11[i],\n          matrix12[i],\n          matrix13[i],\n          vector1[i],\n          matrix21[i],\n          matrix22[i],\n          matrix23[i],\n          vector2[i],\n          matrix31[i],\n          matrix32[i],\n          matrix33[i],\n          vector3[i]\n        );\n        modelData[modelData.length - 1].symmetries.push(matrix);\n      }\n    }\n\n    //extract connectivity information\n    let connect = new Connectivity(cats.chem_comp_bond);\n    let residues = new Residues();\n    let sconnect = new StructConn(cats.struct_conn);\n\n    //atom info\n    let asites = cats.atom_site;\n    let atomCount = asites.rowCount;\n    let group_pdb = asites.getField('group_PDB')\n    let cartn_x = asites.getField('Cartn_x');\n    let cartn_y = asites.getField('Cartn_y');\n    let cartn_z = asites.getField('Cartn_z');\n    let auth_asym_id = asites.getField('auth_asym_id');\n    let label_asym_id = asites.getField('label_asym_id');\n    let auth_seq_id = asites.getField('auth_seq_id');\n    let label_seq_id = asites.getField('label_seq_id');\n    let auth_comp_id = asites.getField('auth_comp_id');\n    let label_comp_id = asites.getField('label_comp_id');\n    let auth_atom_id = asites.getField('auth_atom_id');\n    let label_atom_id = asites.getField('label_atom_id');\n    let type_symbol = asites.getField('type_symbol');\n    let bfactors = asites.getField(\"B_iso_or_equiv\");\n    let serials = asites.getField('id');\n    let icodes = asites.getField('label_alt_id');\n    let modelnums = asites.getField('pdbx_PDB_model_num');\n    let curmodel = modelnums ? modelnums[0] : 0;\n\n    for (let i = 0; i < atomCount; i++) {\n      if (group_pdb !== undefined &&\n        group_pdb[i] === \"TER\"\n      )\n        continue;\n\n      if (modelnums && modelnums[i] != curmodel) {\n        curmodel = modelnums[i];\n        if (options.multimodel) {\n          if (!options.onemol) {\n            atoms.push([]);\n            modelData.push(modelData[modelData.length - 1]);\n            curmodel = modelnums[i];\n            residues.setBonds(connect, sconnect);\n            residues = new Residues();\n          }\n        } else {\n          break; //first model only\n        }\n      }\n\n      const atom: AtomSpec = {};\n      atom.x = cartn_x[i];\n      atom.y = cartn_y[i];\n      atom.z = cartn_z[i];\n\n      atom.chain = auth_asym_id\n        ? auth_asym_id[i]\n        : label_asym_id\n          ? label_asym_id[i]\n          : undefined;\n      atom.lchain = label_asym_id\n        ? label_asym_id[i]\n        : undefined;\n      atom.resi = auth_seq_id\n        ? auth_seq_id[i]\n        : label_seq_id\n          ? label_seq_id[i]\n          : undefined;\n      atom.lresi = label_seq_id\n        ? label_seq_id[i]\n        : undefined;\n      atom.resn = auth_comp_id\n        ? auth_comp_id[i].trim()\n        : label_comp_id\n          ? label_comp_id[i].trim()\n          : undefined;\n      atom.lresn = label_comp_id ? label_comp_id[i].trim() : undefined;\n      atom.atom = auth_atom_id\n        ? auth_atom_id[i].replace(/\"/gm, \"\")\n        : label_atom_id\n          ? label_atom_id[i].replace(/\"/gm, \"\")\n          : undefined; //\"primed\" names are in quotes\n\n      atom.icode = icodes ? icodes[i] : undefined;\n      atom.altLoc = atom.icode;\n      atom.hetflag =\n        !group_pdb ||\n        group_pdb[i] === \"HETA\" ||\n        group_pdb[i] === \"HETATM\";\n      let elem = \"X\";\n      if (type_symbol) {\n        elem = type_symbol[i].replace(/\\(?\\+?\\d+.*/, \"\");\n      }\n\n      atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();\n      if (bfactors) atom.b = bfactors[i];\n\n      if (noH && atom.elem == 'H') {\n        continue;\n      }\n      if (atom.altLoc != '' && atom.altLoc != selAltLoc && selAltLoc != '*') {\n        continue;\n      }\n\n      atom.bonds = [];\n      atom.ss = \"c\";\n      atom.serial = serials[i];\n      atom.model = curmodel;\n      atom.bondOrder = [];\n      atom.properties = {};\n      atom.index = atoms[atoms.length - 1].length;\n      serialToIndex[atom.serial] = [atoms.length, atom.index];\n      atoms[atoms.length - 1].push(atom);\n      residues.add(atom);\n\n    }\n\n    residues.setBonds(connect, sconnect);\n    // Assign secondary structures from pdb file\n    if (!isEmpty(sslookup)) {\n      for (let mi = startm; mi < atoms.length; mi++) {\n        let matoms = atoms[mi];\n        for (let i = 0; i < matoms.length; i++) {\n          const atom = matoms[i];\n          if (atom === undefined) continue;\n          if (atom.lchain in sslookup && atom.lresi in sslookup[atom.lchain]) {\n            const code = sslookup[atom.lchain][atom.lresi];\n            atom.ss = code[0];\n            if (code.length > 1) {\n              if (code[1] == \"1\") atom.ssbegin = true;\n              else if (code[1] == \"2\") atom.ssend = true;\n            }\n          }\n        }\n      }\n    }\n\n    if (options.multimodel && m < numModels - 1) {\n      if (!options.onemol) {\n        atoms.push([]);\n        modelData.push({ symmetries: [] });\n      }\n    }\n  }\n\n  for (let i = 0; i < atoms.length; i++) {\n    if (\n      assignbonds &&\n      !(options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms)\n    ) {\n      assignPDBBonds(atoms[i], options);\n    }\n\n    if (computeStruct) {\n      computeSecondaryStructure(atoms[i], options.hbondCutoff);\n    }\n\n    processSymmetries(\n      modelData[i].symmetries,\n      atoms[i],\n      options,\n      modelData[i].cryst\n    );\n    if (\n      options.duplicateAssemblyAtoms &&\n      !options.dontConnectDuplicatedAtoms &&\n      assignbonds\n    )\n      assignPDBBonds(atoms[i], options);\n  }\n  return atoms;\n\n};", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\n\n/** \n * This parses the ChemDoodle json file format. Although this is registered\n * for the json file extension, other chemical json file formats exist that\n * this can not parse. Check which one you have and do not assume that\n * .json can be parsed\n * \n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n*/\n\nexport function CDJSON(str: string, options: ParserOptionsSpec) {\n  var atoms: any[][] & Record<string, any> = [[]];\n  if (typeof str === \"string\") {\n    // Str is usually automatically parsed by JQuery\n    str = JSON.parse(str);\n  }\n  var molecules = (str as any).m;\n  var atomsInFile = molecules[0].a; // Assumes there is at least one\n  var bondsInFile = molecules[0].b; // molecule and ignores any more\n  // Ignores any shapes\n  var styles = molecules[0].s;\n  var parseStyle =\n    options !== undefined && options.parseStyle !== undefined\n      ? options.parseStyle\n      : styles !== undefined;\n\n  var offset = atoms[atoms.length - 1].length; // When adding atoms their index will be\n  // Offset by the number of existing atoms\n\n  for (var i = 0; i < atomsInFile.length; i++) {\n    var currentAtom = atomsInFile[i];\n    var atom: Record<string, any> = {};\n    atom.id = currentAtom.i; // Probably won't exist. Doesn't seem to\n    // break anything.\n    atom.x = currentAtom.x;\n    atom.y = currentAtom.y;\n    atom.z = currentAtom.z || 0; // Default value if file is 2D\n\n    atom.bonds = [];\n    atom.bondOrder = [];\n\n    var elem = currentAtom.l || \"C\";\n    atom.elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n\n    atom.serial = atoms[atoms.length - 1].length;\n    if (parseStyle) {\n      atom.style = styles[currentAtom.s || 0];\n    }\n    atoms[atoms.length - 1].push(atom);\n  }\n  for (let i = 0; i < bondsInFile.length; i++) {\n    let currentBond = bondsInFile[i];\n    let beginIndex = currentBond.b + offset;\n    let endIndex = currentBond.e + offset;\n    let bondOrder = currentBond.o || 1;\n\n    let firstAtom = atoms[atoms.length - 1][beginIndex];\n    let secondAtom = atoms[atoms.length - 1][endIndex];\n\n    firstAtom.bonds.push(endIndex);\n    firstAtom.bondOrder.push(bondOrder);\n    secondAtom.bonds.push(beginIndex);\n    secondAtom.bondOrder.push(bondOrder);\n  }\n  return atoms;\n}\n", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\n\nimport { computeSecondaryStructure } from \"./utils/computeSecondaryStructure\";\nimport { processSymmetries } from \"./utils/processSymmetries\";\nimport { conversionMatrix3, Matrix3, Matrix4, Vector3 } from \"../WebGL\";\nimport { assignPDBBonds } from \"./utils/assignPDBBonds\";\nimport { AtomSpec } from \"specs\";\n\n//coordinate conversion\nconst fractionalToCartesian = function (\n  cmat: Matrix3,\n  x: number,\n  y: number,\n  z: number\n) {\n  return new Vector3(x, y, z).applyMatrix3(cmat);\n};\n\n/**\n * Puts atoms specified in mmCIF fromat in str into atoms\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n */\nexport function CIF(str: string, options: ParserOptionsSpec = {}) {\n  const atoms: Array<AtomSpec[]> & { modelData?: unknown } = [];\n  const noAssembly = !options.doAssembly; // don't assemble by default\n  const modelData = (atoms.modelData = []);\n  const assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n\n  // Used to handle quotes correctly\n  function splitRespectingQuotes(string: string, separator: string) {\n    const sections: string[] = [];\n    let sectionStart = 0;\n    let sectionEnd = 0;\n    while (sectionEnd < string.length) {\n      while (\n        string.substring(sectionEnd, sectionEnd + separator.length) !==\n          separator &&\n        sectionEnd < string.length\n      ) {\n        // currently does not support escaping quotes\n        if (string[sectionEnd] === \"'\") {\n          sectionEnd++;\n          while (sectionEnd < string.length && string[sectionEnd] !== \"'\") {\n            sectionEnd++;\n          }\n          //biopython apparently generates invalid string literals so if we think we are done but aren't at a separator keep going\n          while (\n            string.substring(sectionEnd, sectionEnd + separator.length) !==\n              separator &&\n            sectionEnd < string.length\n          ) {\n            sectionEnd++;\n          }\n        } else if (string[sectionEnd] === '\"') {\n          sectionEnd++;\n          while (sectionEnd < string.length && string[sectionEnd] !== '\"') {\n            sectionEnd++;\n          }\n          sectionEnd++;\n        } else {\n          sectionEnd++;\n        }\n      }\n      sections.push(string.substring(sectionStart, sectionEnd));\n      sectionStart = sectionEnd = sectionEnd + separator.length;\n    }\n    return sections;\n  }\n\n  const lines = str.split(/\\r?\\n|\\r/);\n  // Filter text to remove comments, trailing spaces, and empty lines\n  const linesFiltered: string[] = [];\n  let trimDisabled = false;\n  for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n    // first remove comments\n    // incorrect if #'s are allowed in strings\n    // comments might only be allowed at beginning of line, not sure\n    var line = lines[lineNum].split(\"#\")[0];\n\n    // inside data blocks, the string must be left verbatim\n    // datablocks are started with a ';' at the beginning of a line\n    // and ended with a ';' on its own line.\n    if (trimDisabled) {\n      if (line[0] === \";\") {\n        trimDisabled = false;\n      }\n    } else {\n      if (line[0] === \";\") {\n        trimDisabled = true;\n      }\n    }\n\n    if (trimDisabled || line !== \"\") {\n      if (!trimDisabled) {\n        line = line.trim();\n        if (line[0] === \"_\") {\n          // Replace dot separating category from data item with underscore. Dots aren't guarenteed, to makes\n          // files consistent.\n          const dot = line.split(/\\s/)[0].indexOf(\".\");\n          if (dot > -1) {\n            let lineArr = line.split(\"\");\n            lineArr[dot] = \"_\";\n            line = lineArr.join(\"\");\n            line = line.substring(0, dot) + \"_\" + line.substring(dot + 1);\n          }\n        }\n      }\n      linesFiltered.push(line);\n    }\n  }\n\n  let lineNum = 0;\n  while (lineNum < linesFiltered.length) {\n    while (\n      !linesFiltered[lineNum].startsWith(\"data_\") ||\n      linesFiltered[lineNum] === \"data_global\"\n    ) {\n      lineNum++;\n    }\n    lineNum++;\n\n    // Process the lines and puts all of the data into an object.\n    const mmCIF: Record<string, any> = {};\n    while (\n      lineNum < linesFiltered.length &&\n      !linesFiltered[lineNum].startsWith(\"data_\")\n    ) {\n      if (linesFiltered[lineNum][0] === undefined) {\n        lineNum++;\n      } else if (linesFiltered[lineNum][0] === \"_\") {\n        const dataItemName = linesFiltered[lineNum]\n          .split(/\\s/)[0]\n          .toLowerCase();\n        const dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);\n\n        // if nothing left on the line go to the next one\n        const restOfLine = linesFiltered[lineNum].substring(\n          linesFiltered[lineNum].indexOf(dataItemName) + dataItemName.length\n        );\n        if (restOfLine === \"\") {\n          lineNum++;\n          if (linesFiltered[lineNum][0] === \";\") {\n            let dataBlock = linesFiltered[lineNum].substring(1);\n            lineNum++;\n            while (linesFiltered[lineNum] !== \";\") {\n              dataBlock = dataBlock + \"\\n\" + linesFiltered[lineNum];\n              lineNum++;\n            }\n            dataItem.push(dataBlock);\n          } else {\n            dataItem.push(linesFiltered[lineNum]);\n          }\n        } else {\n          dataItem.push(restOfLine.trim());\n        }\n        lineNum++;\n      } else if (linesFiltered[lineNum].substring(0, 5) === \"loop_\") {\n        lineNum++;\n        const dataItems = [];\n        while (\n          linesFiltered[lineNum] === \"\" ||\n          linesFiltered[lineNum][0] === \"_\"\n        ) {\n          if (linesFiltered[lineNum] !== \"\") {\n            let dataItemName = linesFiltered[lineNum]\n              .split(/\\s/)[0]\n              .toLowerCase();\n            let dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);\n            dataItems.push(dataItem);\n          }\n          lineNum++;\n        }\n\n        let currentDataItem = 0;\n        while (\n          lineNum < linesFiltered.length &&\n          linesFiltered[lineNum][0] !== \"_\" &&\n          !linesFiltered[lineNum].startsWith(\"loop_\") &&\n          !linesFiltered[lineNum].startsWith(\"data_\")\n        ) {\n          let line = splitRespectingQuotes(linesFiltered[lineNum], \" \");\n          for (let field = 0; field < line.length; field++) {\n            if (line[field] !== \"\") {\n              dataItems[currentDataItem].push(line[field]);\n              currentDataItem = (currentDataItem + 1) % dataItems.length;\n            }\n          }\n          lineNum++;\n        }\n      } else {\n        lineNum++;\n      }\n    }\n\n    modelData.push({ symmetries: [] });\n\n    // Pulls atom information out of the data\n    atoms.push([]);\n    const atomCount =\n      mmCIF._atom_site_id !== undefined\n        ? mmCIF._atom_site_id.length\n        : mmCIF._atom_site_label.length;\n\n    let conversionMatrix: Matrix3;\n    if (mmCIF._cell_length_a !== undefined) {\n      const a = parseFloat(mmCIF._cell_length_a);\n      const b = parseFloat(mmCIF._cell_length_b);\n      const c = parseFloat(mmCIF._cell_length_c);\n      const alpha_deg = parseFloat(mmCIF._cell_angle_alpha) || 90;\n      const beta_deg = parseFloat(mmCIF._cell_angle_beta) || 90;\n      const gamma_deg = parseFloat(mmCIF._cell_angle_gamma) || 90;\n\n      conversionMatrix = conversionMatrix3(\n        a,\n        b,\n        c,\n        alpha_deg,\n        beta_deg,\n        gamma_deg\n      );\n      modelData[modelData.length - 1].cryst = {\n        a: a,\n        b: b,\n        c: c,\n        alpha: alpha_deg,\n        beta: beta_deg,\n        gamma: gamma_deg,\n      };\n    }\n\n    for (let i = 0; i < atomCount; i++) {\n      if (\n        mmCIF._atom_site_group_pdb !== undefined &&\n        mmCIF._atom_site_group_pdb[i] === \"TER\"\n      )\n        continue;\n      const atom: AtomSpec = {};\n      if (mmCIF._atom_site_cartn_x !== undefined) {\n        atom.x = parseFloat(mmCIF._atom_site_cartn_x[i]);\n        atom.y = parseFloat(mmCIF._atom_site_cartn_y[i]);\n        atom.z = parseFloat(mmCIF._atom_site_cartn_z[i]);\n      } else {\n        const coords = fractionalToCartesian(\n          conversionMatrix,\n          parseFloat(mmCIF._atom_site_fract_x[i]),\n          parseFloat(mmCIF._atom_site_fract_y[i]),\n          parseFloat(mmCIF._atom_site_fract_z[i])\n        );\n        atom.x = coords.x;\n        atom.y = coords.y;\n        atom.z = coords.z;\n      }\n      atom.chain = mmCIF._atom_site_auth_asym_id\n        ? mmCIF._atom_site_auth_asym_id[i]\n        : mmCIF._atom_site_label_asym_id\n        ? mmCIF._atom_site_label_asym_id[i]\n        : undefined;\n      atom.lchain = mmCIF._atom_site_label_asym_id\n        ? mmCIF._atom_site_label_asym_id[i]\n        : undefined;\n      atom.resi = mmCIF._atom_site_auth_seq_id\n        ? parseInt(mmCIF._atom_site_auth_seq_id[i])\n        : mmCIF._atom_site_label_seq_id\n        ? mmCIF._atom_site_label_seq_id[i]\n        : undefined;\n      atom.resn = mmCIF._atom_site_auth_comp_id\n        ? mmCIF._atom_site_auth_comp_id[i].trim()\n        : mmCIF._atom_site_label_comp_id\n        ? mmCIF._atom_site_label_comp_id[i].trim()\n        : undefined;\n      atom.atom = mmCIF._atom_site_auth_atom_id\n        ? mmCIF._atom_site_auth_atom_id[i].replace(/\"/gm, \"\")\n        : mmCIF._atom_site_label_atom_id\n        ? mmCIF._atom_site_label_atom_id[i].replace(/\"/gm, \"\")\n        : undefined; //\"primed\" names are in quotes\n      atom.hetflag =\n        !mmCIF._atom_site_group_pdb ||\n        mmCIF._atom_site_group_pdb[i] === \"HETA\" ||\n        mmCIF._atom_site_group_pdb[i] === \"HETATM\";\n      if(mmCIF._atom_site_b_iso_or_equiv ) {\n        atom.b = parseFloat(mmCIF._atom_site_b_iso_or_equiv[i]);\n      }\n      let elem = \"X\";\n      if (mmCIF._atom_site_type_symbol) {\n        elem = mmCIF._atom_site_type_symbol[i].replace(/\\(?\\+?\\d+.*/, \"\");\n      } else if (mmCIF._atom_site_label) {\n        //first two components are concatenated, then separated by underscore\n        //best I can do is assume second component, if present, starts with a number\n        elem = mmCIF._atom_site_label[i].split(\"_\")[0].replace(/\\(?\\d+.*/, \"\");\n      }\n      atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();\n      atom.bonds = [];\n      atom.ss = \"c\";\n      atom.serial = i;\n      atom.bondOrder = [];\n      atom.properties = {};\n      atoms[atoms.length - 1].push(atom);\n    }\n\n    if (mmCIF._pdbx_struct_oper_list_id !== undefined && !noAssembly) {\n      for (let i = 0; i < mmCIF._pdbx_struct_oper_list_id.length; i++) {\n        const matrix11 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[1][1]\"][i]\n        );\n        const matrix12 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[1][2]\"][i]\n        );\n        const matrix13 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[1][3]\"][i]\n        );\n        const vector1 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_vector[1]\"][i]\n        );\n        const matrix21 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[2][1]\"][i]\n        );\n        const matrix22 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[2][2]\"][i]\n        );\n        const matrix23 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[2][3]\"][i]\n        );\n        const vector2 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_vector[2]\"][i]\n        );\n        const matrix31 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[3][1]\"][i]\n        );\n        const matrix32 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[3][2]\"][i]\n        );\n        const matrix33 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_matrix[3][3]\"][i]\n        );\n        const vector3 = parseFloat(\n          mmCIF[\"_pdbx_struct_oper_list_vector[3]\"][i]\n        );\n\n        const matrix = new Matrix4(\n          matrix11,\n          matrix12,\n          matrix13,\n          vector1,\n          matrix21,\n          matrix22,\n          matrix23,\n          vector2,\n          matrix31,\n          matrix32,\n          matrix33,\n          vector3\n        );\n        modelData[modelData.length - 1].symmetries.push(matrix);\n      }\n    }\n    const parseTerm = function (term: string) {\n      const negative = term.match(\"-\");\n      term = term.replace(/[-xyz]/g, \"\");\n      const fractionParts = term.split(\"/\");\n\n      let numerator: number, denominator: number;\n      if (fractionParts[1] === undefined) {\n        denominator = 1;\n      } else {\n        denominator = parseInt(fractionParts[1]);\n      }\n      if (fractionParts[0] === \"\") {\n        numerator = 1;\n      } else {\n        numerator = parseInt(fractionParts[0]);\n      }\n      return (numerator / denominator) * (negative ? -1 : 1);\n    };\n    if (mmCIF._symmetry_equiv_pos_as_xyz !== undefined && !noAssembly) {\n      for (let sym = 0; sym < mmCIF._symmetry_equiv_pos_as_xyz.length; sym++) {\n        const transform = mmCIF._symmetry_equiv_pos_as_xyz[sym].replace(\n          /[\"' ]/g,\n          \"\"\n        );\n        const componentStrings = transform\n          .split(\",\")\n          .map(function (val: string) {\n            return val.replace(/-/g, \"+-\");\n          });\n        let matrix = new Matrix4(\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1\n        );\n        for (let coord = 0; coord < 3; coord++) {\n          const terms = componentStrings[coord].split(\"+\");\n          for (let t = 0; t < terms.length; t++) {\n            const term = terms[t];\n            if (term === \"\") continue;\n            const coefficient = parseTerm(term);\n            if (term.match(\"x\")) {\n              matrix.elements[coord + 0] = coefficient;\n            } else if (term.match(\"y\")) {\n              matrix.elements[coord + 4] = coefficient;\n            } else if (term.match(\"z\")) {\n              matrix.elements[coord + 8] = coefficient;\n            } else {\n              matrix.elements[coord + 12] = coefficient;\n            }\n          }\n        }\n        const conversionMatrix4 = conversionMatrix.getMatrix4();\n        const conversionInverse = new Matrix4().getInverse(\n          conversionMatrix4,\n          true\n        );\n        matrix = new Matrix4().multiplyMatrices(matrix, conversionInverse);\n        matrix = new Matrix4().multiplyMatrices(conversionMatrix4, matrix);\n        modelData[modelData.length - 1].symmetries.push(matrix);\n      }\n    }\n  }\n  for (let i = 0; i < atoms.length; i++) {\n    if (\n      assignbonds &&\n      !(options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms)\n    ) {\n      assignPDBBonds(atoms[i], options);\n    }\n    computeSecondaryStructure(atoms[i], options.hbondCutoff);\n    processSymmetries(\n      modelData[i].symmetries,\n      atoms[i],\n      options,\n      modelData[i].cryst\n    );\n    if (\n      options.duplicateAssemblyAtoms &&\n      !options.dontConnectDuplicatedAtoms &&\n      assignbonds\n    )\n      assignPDBBonds(atoms[i], options);\n  }\n\n  return atoms;\n}\n", "import { Vector3, Matrix4 } from \"../WebGL\";\nimport { assignBonds } from \"./utils/assignBonds\";\nimport { anumToSymbol } from \"./utils/anumToSymbol\";\nimport { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { AtomSpec, Cryst } from \"specs\";\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n */\nexport function CUBE(str: string, options: ParserOptionsSpec) {\n  options = options || {};\n  const atoms: Array<AtomSpec[]> & { modelData?: unknown } = [[]];\n  let lines = str.split(/\\r?\\n/);\n  const assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n\n  if (lines.length < 6) return atoms;\n\n  let lineArr = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n\n  const natoms = Math.abs(parseFloat(lineArr[0]));\n\n  let cryst: Omit<Cryst, \"a\" | \"b\" | \"c\" | \"alpha\" | \"beta\" | \"gamma\"> = {\n    origin: undefined,\n    size: undefined,\n    unit: undefined,\n    matrix4: undefined,\n    matrix: undefined,\n  };\n\n  const origin = (cryst.origin = new Vector3(\n    parseFloat(lineArr[1]),\n    parseFloat(lineArr[2]),\n    parseFloat(lineArr[3])\n  ));\n\n  lineArr = lines[3].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n  lineArr = lines[3].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n\n  // might have to convert from bohr units to angstroms\n  // there is a great deal of confusion here:\n  // n>0 means angstroms: http://www.gaussian.com/g_tech/g_ur/u_cubegen.htm\n  // n<0 means angstroms: http://paulbourke.net/dataformats/cube/\n  // always assume bohr: openbabel source code\n  // always assume angstrom: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html\n  // we are going to go with n<0 means angstrom - note this is just the first n\n  const convFactor = (lineArr[0] as any) > 0 ? 0.529177 : 1;\n  origin.multiplyScalar(convFactor);\n\n  const nX = Math.abs(lineArr[0] as any);\n  const xVec = new Vector3(\n    parseFloat(lineArr[1]),\n    parseFloat(lineArr[2]),\n    parseFloat(lineArr[3])\n  ).multiplyScalar(convFactor);\n\n  lineArr = lines[4].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n  const nY = Math.abs(lineArr[0] as any);\n  const yVec = new Vector3(\n    parseFloat(lineArr[1]),\n    parseFloat(lineArr[2]),\n    parseFloat(lineArr[3])\n  ).multiplyScalar(convFactor);\n\n  lineArr = lines[5].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n  const nZ = Math.abs(lineArr[0] as any);\n  const zVec = new Vector3(\n    parseFloat(lineArr[1]),\n    parseFloat(lineArr[2]),\n    parseFloat(lineArr[3])\n  ).multiplyScalar(convFactor);\n\n  cryst.size = { x: nX, y: nY, z: nZ };\n  cryst.unit = new Vector3(xVec.x, yVec.y, zVec.z);\n\n  if (\n    xVec.y != 0 ||\n    xVec.z != 0 ||\n    yVec.x != 0 ||\n    yVec.z != 0 ||\n    zVec.x != 0 ||\n    zVec.y != 0\n  ) {\n    //need a transformation matrix\n    cryst.matrix4 = new Matrix4(\n      xVec.x,\n      yVec.x,\n      zVec.x,\n      0,\n      xVec.y,\n      yVec.y,\n      zVec.y,\n      0,\n      xVec.z,\n      yVec.z,\n      zVec.z,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    // include translation in matrix\n    let t = new Matrix4().makeTranslation(origin.x, origin.y, origin.z);\n    cryst.matrix4 = cryst.matrix4.multiplyMatrices(t, cryst.matrix4);\n    cryst.matrix = cryst.matrix4.matrix3FromTopLeft();\n    // all translation and scaling done by matrix, so reset origin and unit\n    cryst.origin = new Vector3(0, 0, 0);\n    cryst.unit = new Vector3(1, 1, 1);\n  }\n\n  atoms.modelData = [{ cryst: cryst }];\n\n  // Extract atom portion; send to new GLModel...\n  lines = lines.splice(6, natoms);\n\n  var start = atoms[atoms.length - 1].length;\n  var end = start + lines.length;\n\n  for (var i = start; i < end; ++i) {\n    var atom: Record<string, any> = {};\n    atom.serial = i;\n    var line = lines[i - start];\n    var tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    atom.elem = anumToSymbol[tokens[0]];\n    atom.x = parseFloat(tokens[2]) * convFactor;\n    atom.y = parseFloat(tokens[3]) * convFactor;\n    atom.z = parseFloat(tokens[4]) * convFactor;\n\n    atom.hetflag = true;\n    atom.bonds = [];\n    atom.bondOrder = [];\n    atom.properties = {};\n    atoms[atoms.length - 1].push(atom);\n  }\n\n  if (assignbonds) {\n    for (let i = 0; i < atoms.length; i++) assignBonds(atoms[i], options);\n  }\n  return atoms;\n}\n", "import { AtomSpec } from \"specs\";\nimport { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { assignPDBBonds } from \"./utils/assignPDBBonds\";\nimport { atomNameToElem } from \"./utils/atomNameToElem\";\n\n/**\n * Parse a gro file from str and create atoms\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n * @returns {Array<AtomSpec[]>} - Returns a 2D array of type AtomSpec\n */\n\nexport function GRO(str: string, options: ParserOptionsSpec) {\n  const allatoms: AtomSpec[][] & { box?: string[] } = [];\n  const lines = str.split(/\\r?\\n|\\r/);\n  while (lines.length > 0) {\n    const atomCount = parseInt(lines[1]);\n    const breakCondition =\n      lines.length < 3 ||\n      isNaN(atomCount) ||\n      atomCount <= 0 ||\n      lines.length < atomCount + 3;\n    if (breakCondition) break;\n    const atoms: AtomSpec[] = [];\n    allatoms.push(atoms);\n    let offset = 2;\n    const start = atoms.length;\n    const end = start + atomCount;\n    for (let i = start; i < end; i++) {\n      const line = lines[offset++];\n      const atom: AtomSpec = {};\n      atom.serial = i;\n      atom.atom = line.slice(10, 15).trim();\n      atom.elem = atomNameToElem(atom.atom, true);\n      //coordinates are in nM, convert to A\n      atom.x = 10.0 * parseFloat(line.slice(20, 28));\n      atom.y = 10.0 * parseFloat(line.slice(28, 36));\n      atom.z = 10.0 * parseFloat(line.slice(36, 44));\n      atom.resi = parseInt(line.slice(0, 5));\n      atom.resn = line.slice(5, 10).trim();\n      atom.bonds = [];\n      atom.bondOrder = [];\n      atom.properties = {};\n      if (line.length > 44) {\n        atom.dx = 10.0 * parseFloat(line.slice(44, 52));\n        atom.dy = 10.0 * parseFloat(line.slice(52, 60));\n        atom.dz = 10.0 * parseFloat(line.slice(60, 68));\n      }\n      atoms[i] = atom;\n    } //for all atoms\n\n    if (lines.length <= offset + 3) {\n      //single line left, assume it is the box\n      const last = lines[offset++];\n      const box = last.trim().split(/\\s+/);\n      if (box.length === 3) {\n        for (let b = 0; b < 3; b++) {\n          box[b] = (parseFloat(box[b]) * 10.0).toString();\n        }\n        allatoms.box = box;\n      }\n    }\n    lines.splice(0, ++offset);\n  }\n\n  for (let i = 0; i < allatoms.length; i++) {\n    assignPDBBonds(allatoms[i], options);\n  }\n  return allatoms;\n}\n", "import { AtomSpec } from \"specs\";\nimport { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { assignBonds } from \"./utils/assignBonds\";\n\n/**\n * Parse a lammps trajectory file from str and create atoms\n * \n * @category Parsers\n*/\nconst dic: Record<string,string> = {\n    id: \"serial\",\n    type: \"atom\",\n    element: \"elem\",\n    q: \"charge\",\n    radius: \"radius\",\n    x: \"x\",\n    xu: \"x\",\n    xs: \"x\",\n    xsu: \"x\",\n    y: \"y\",\n    yu: \"y\",\n    ys: \"y\",\n    ysu: \"y\",\n    z: \"z\",\n    zu: \"z\",\n    zs: \"z\",\n    zsu: \"z\",\n  };\n\nexport function LAMMPSTRJ(str: string, options: ParserOptionsSpec) {\n  const atoms: AtomSpec[][] = [];\n  const lines = str.split(/\\r?\\n|\\r/);\n  let offset = 0;\n  let atomCount = 0;\n  let start = 0;\n  while (start < lines.length - 9) {\n    for (var j = start; j < lines.length; j++) {\n      if (lines[j].match(/ITEM: NUMBER OF ATOMS/))\n        atomCount = parseInt(lines[j + 1]);\n      if (lines[j].match(/ITEM: ATOMS/)) {\n        offset = j + 1;\n        break;\n      }\n    }\n    const types = lines[offset - 1].replace(\"ITEM: ATOMS \", \"\").split(\" \");\n    atoms.push([]);\n    for (let j = offset; j < offset + atomCount; j++) {\n      const atom: AtomSpec = {};\n      const properties = {};\n      const tokens = lines[j].split(\" \");\n      for (let k = 0; k < tokens.length; k++) {\n        const prop = dic[types[k]];\n        if (prop !== undefined) {\n          if (prop === \"serial\") atom[prop] = parseInt(tokens[k]);\n          else if (prop === \"x\" || prop === \"y\" || prop === \"z\")\n            atom[prop] = parseFloat(tokens[k]);\n          else if (prop === \"charge\" || prop === \"radius\")\n            properties[prop] = parseFloat(tokens[k]);\n          else atom[prop] = tokens[k];\n        }\n        atom.properties = properties;\n        atom.bonds = [];\n        atom.bondOrder = [];\n      }\n      atoms[atoms.length - 1][j - offset] = atom;\n    }\n    start = offset + atomCount - 1;\n  }\n  if (options.assignBonds) {\n    for (let i = 0; i < atoms.length; i++) assignBonds(atoms[i], options);\n  }\n  return atoms;\n}\n", "import { base64ToArray } from \"../utilities\";\nimport { Matrix4 } from \"../WebGL\";\nimport { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { computeSecondaryStructure } from \"./utils/computeSecondaryStructure\";\nimport { processSymmetries } from \"./utils/processSymmetries\";\n\nexport interface MMTFobj {\n    decode(data: Uint8Array | ArrayBuffer): any;\n    decodeMsgpack(data: Uint8Array | ArrayBuffer): any;\n}\ndeclare var MMTF: MMTFobj;\n\nvar fromCharCode = function (charCodeArray: any) {\n    return String.fromCharCode.apply(null, charCodeArray).replace(/\\0/g, '');\n};\n\nvar convertSS = function (val: number | boolean) {\n    // Convert mmtf code to 3dmol code\n    /*    \n      0:  pi helix\n      1:  bend\n      2:  alpha helix\n      3:  sheet extended\n      4:  3-10 helix\n      5:  bridge\n      6:  turn\n      7:  coil\n     */\n    if (val == 0 || val == 2 || val == 4) return 'h';\n    if (val == 3) return 's';\n    return 'c';\n};\n\nlet mmtfHETATMtypes = new Set([\n    \"D-SACCHARIDE\",\n    \"D-SACCHARIDE 1,4 AND 1,4 LINKING\",\n    \"D-SACCHARIDE 1,4 AND 1,6 LINKING\",\n    \"L-SACCHARIDE\",\n    \"L-SACCHARIDE 1,4 AND 1,4 LINKING\",\n    \"L-SACCHARIDE 1,4 AND 1,6 LINKING\",\n    \"NON-POLYMER\",\n    \"OTHER\",\n    \"PEPTIDE-LIKE\",\n    \"SACCHARIDE\"]);\n\n/** \n * @param bindata - binary UInt8Array buffer or a base64 encoded string\n * @param ParserOptionsSpec\n * @category Parsers\n*/\nexport function MMTFparser(bindata: any, options: ParserOptionsSpec) {\n\n    var noH = !options.keepH; // suppress hydrogens by default\n    var selAltLoc = options.altLoc ? options.altLoc : 'A'; //default alternate location to select if present\n    var ignoreStruct = !!options.noSecondaryStructure;\n    var computeStruct = !options.noComputeSecondaryStructure;\n    //extract symmetries - only take first assembly, apply to all models (ignoring changes for now)\n    var noAssembly = !options.doAssembly; // don't assemble by default\n    var assemblyIndex = options.assemblyIndex ? options.assemblyIndex : 0;\n\n    if (typeof (bindata) == \"string\") {\n        //assume base64 encoded\n        bindata = base64ToArray(bindata);\n    } else {\n        bindata = new Uint8Array(bindata);\n    }\n\n    var mmtfData = MMTF.decode(bindata);\n\n    var atoms: any[][] & Record<string, any> = [[]];\n    var modelData: any[] = atoms.modelData = [];\n\n    // setup index counters\n    var chainIndex = 0;\n    var groupIndex = 0;\n    var atomIndex = 0;\n\n    // setup optional fields\n    var secStructList = mmtfData.secStructList;\n    var bFactorList = mmtfData.bFactorList;\n    var altLocList = mmtfData.altLocList;\n    var occupancyList = mmtfData.occupancyList;\n    var bondAtomList = mmtfData.bondAtomList;\n    var bondOrderList = mmtfData.bondOrderList;\n\n    var numModels = mmtfData.numModels;\n    if (numModels == 0) return atoms;\n    if (!options.multimodel) numModels = 1; //first only\n    // hoisted loop variables\n    var i: number, j: number, k: number, kl: number, m: number, n: number;\n\n\n\n    var symmetries: Matrix4[] = [];\n    if (!noAssembly && mmtfData.bioAssemblyList && mmtfData.bioAssemblyList.length > 0) {\n        var transforms = mmtfData.bioAssemblyList[assemblyIndex].transformList;\n        for (i = 0, n = transforms.length; i < n; i++) {\n            var matrix = new Matrix4(transforms[i].matrix);\n            matrix.transpose();\n            symmetries.push(matrix);\n        }\n    }\n    var unitCell = null as Record<string, number> | null;\n    //unit cell info\n    if (mmtfData.unitCell) {\n        var u = mmtfData.unitCell;\n        unitCell = { 'a': u[0], 'b': u[1], 'c': u[2], 'alpha': u[3], 'beta': u[4], 'gamma': u[5] };\n    }\n\n    let chainIsPolymer: boolean[] = [];\n    mmtfData.entityList.forEach((entity: { chainIndexList: any[]; type: string; }) => {\n        entity.chainIndexList.forEach(ch => {\n            chainIsPolymer[ch] = entity.type == \"polymer\";\n        });\n    });\n    var bondAtomListStart = 0; //for current model\n    //loop over models, \n    for (m = 0; m < numModels; m++) {\n        var modelChainCount = mmtfData.chainsPerModel[m];\n        var matoms = atoms[atoms.length - 1];\n        var serialToIndex: number[] = []; // map to matoms index, needed for noh\n\n        modelData.push({ symmetries: symmetries, cryst: unitCell });\n        for (i = 0; i < modelChainCount; ++i) {\n\n            var chainGroupCount = mmtfData.groupsPerChain[chainIndex];\n            var chainId = fromCharCode(\n                mmtfData.chainIdList.subarray(chainIndex * 4, chainIndex * 4 + 4)\n            );\n            if (mmtfData.chainNameList) {\n                chainId = fromCharCode(\n                    mmtfData.chainNameList.subarray(chainIndex * 4, chainIndex * 4 + 4)\n                );\n            }\n\n            var startGroup = groupIndex;\n            var prevSS = '';\n            for (j = 0; j < chainGroupCount; ++j) { //over residues (groups)\n\n                var groupData = mmtfData.groupList[mmtfData.groupTypeList[groupIndex]];\n                var groupAtomCount = groupData.atomNameList.length;\n                var secStruct = 0;\n                var secStructBegin = false;\n                var secStructEnd = false;\n\n                if (secStructList) {\n                    secStruct = secStructList[groupIndex];\n                    var sscode = convertSS(secStruct);\n                    if (groupIndex == 0 || sscode != prevSS) {\n                        secStructBegin = true;\n                    }\n                    prevSS = sscode;\n                    var nextgroup = groupIndex + 1;\n                    if (nextgroup >= secStructList.length || convertSS(secStructList[nextgroup] != sscode)) {\n                        secStructEnd = true;\n                    }\n                }\n                var groupId = mmtfData.groupIdList[groupIndex];\n                var groupName = groupData.groupName;\n                let groupType = groupData.chemCompType;\n                var startAtom = atomIndex;\n                // Note the following is not identical to respecting HETATM records\n                // this information isn't available in MMTF.  \n                let isHETATM = mmtfHETATMtypes.has(groupType) || !chainIsPolymer[chainIndex];\n\n                for (k = 0; k < groupAtomCount; ++k) {\n\n                    var element = groupData.elementList[k];\n                    if (noH && element == 'H') {\n                        atomIndex += 1;\n                        continue;\n                    }\n\n                    var bFactor = '';\n                    if (bFactorList) {\n                        bFactor = bFactorList[atomIndex];\n                    }\n                    var altLoc = '';\n                    if (altLocList && altLocList[atomIndex]) { //not zero\n                        altLoc = String.fromCharCode(altLocList[atomIndex]);\n                    }\n                    var occupancy = '';\n                    if (occupancyList) {\n                        occupancy = occupancyList[atomIndex];\n                    }\n\n                    if (altLoc != '' && altLoc != selAltLoc && selAltLoc != '*') {\n                        atomIndex += 1;\n                        continue;\n                    }\n\n                    var atomId = mmtfData.atomIdList[atomIndex];\n                    var atomName = groupData.atomNameList[k];\n                    var atomCharge = 0;\n                    if (groupData.atomChargeList) atomCharge = groupData.atomChargeList[k];\n                    var xCoord = mmtfData.xCoordList[atomIndex];\n                    var yCoord = mmtfData.yCoordList[atomIndex];\n                    var zCoord = mmtfData.zCoordList[atomIndex];\n\n                    serialToIndex[atomIndex] = matoms.length;\n                    matoms.push({\n                        'resn': groupName,\n                        'x': xCoord,\n                        'y': yCoord,\n                        'z': zCoord,\n                        'elem': element,\n                        'hetflag': isHETATM,\n                        'chain': chainId,\n                        'resi': groupId,\n                        'icode': altLoc,\n                        'rescode': groupId + (altLoc != ' ' ? \"^\" + altLoc : \"\"), // combo\n                        // resi\n                        // and\n                        // icode\n                        'serial': atomId,\n                        'altLoc': altLoc,\n                        'index': atomIndex,\n                        'atom': atomName,\n                        'bonds': [],\n                        'ss': convertSS(secStruct),\n                        'ssbegin': secStructBegin,\n                        'ssend': secStructEnd,\n                        'bondOrder': [],\n                        'properties': { charge: atomCharge, occupancy: occupancy },\n                        'b': bFactor,\n                    });\n\n                    atomIndex += 1;\n                }\n\n                // intra group bonds\n                var groupBondAtomList = groupData.bondAtomList;\n                for (k = 0, kl = groupData.bondOrderList.length; k < kl; ++k) {\n                    var atomIndex1 = startAtom + groupBondAtomList[k * 2];\n                    var atomIndex2 = startAtom + groupBondAtomList[k * 2 + 1];\n                    var bondOrder = groupData.bondOrderList[k];\n\n                    //I assume bonds are only recorded once\n                    var i1 = serialToIndex[atomIndex1];\n                    var i2 = serialToIndex[atomIndex2];\n                    var a1 = matoms[i1];\n                    var a2 = matoms[i2];\n                    if (a1 && a2) {\n                        a1.bonds.push(i2);\n                        a1.bondOrder.push(bondOrder);\n                        a2.bonds.push(i1);\n                        a2.bondOrder.push(bondOrder);\n                    }\n                }\n\n                groupIndex += 1;\n            }\n\n            //reset for bonds\n            groupIndex = startGroup;\n            for (j = 0; j < chainGroupCount; ++j) { //over residues (groups)\n\n                groupIndex += 1;\n\n            }\n\n            chainIndex += 1;\n        }\n\n\n        // inter group bonds\n        if (bondAtomList) {\n            for (let k = bondAtomListStart, kl = bondAtomList.length; k < kl; k += 2) {\n                let atomIndex1 = bondAtomList[k];\n                let atomIndex2 = bondAtomList[k + 1];\n                let bondOrder = bondOrderList ? bondOrderList[k / 2] : 1;\n\n                if (atomIndex1 >= atomIndex) {\n                    bondAtomListStart = k;\n                    break; //on next model\n                }\n                //I assume bonds are only recorded once\n                let i1 = serialToIndex[atomIndex1];\n                let i2 = serialToIndex[atomIndex2];\n                let a1 = matoms[i1];\n                let a2 = matoms[i2];\n                if (a1 && a2) {\n                    a1.bonds.push(i2);\n                    a1.bondOrder.push(bondOrder);\n                    a2.bonds.push(i1);\n                    a2.bondOrder.push(bondOrder);\n                }\n            }\n        }\n\n        if (options.multimodel) {\n            if (!options.onemol) atoms.push([]);\n        }\n    }\n\n    if (!noAssembly) {\n        for (let n = 0; n < atoms.length; n++) {\n            processSymmetries(modelData[n].symmetries, atoms[n], options, modelData[n].cryst);\n        }\n    }\n\n    if (computeStruct && !ignoreStruct) {\n        computeSecondaryStructure(atoms as any, options.hbondCutoff);\n    }\n\n    return atoms;\n};", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\n\nlet SYBYLtoElem:any = {\n  'C.1': 'C',\n  'C1': 'C',\n  'C.2': 'C',\n  'C2': 'C',\n  'C.3': 'C',\n  'C3': 'C',  \n  'C.ar': 'C',\n  'Car': 'C',\n  'C.cat': 'C',\n  'Ccat': 'C',\n  'H.spc' :'H',\n  'Hspc':'H',\n  'H.t3p':'H',\n  'Ht3p': 'H',\n  'N.1':'N',\n  'N1':'N',\n  'N.2':'N',\n  'N2':'N',\n  'N.3':'N',\n  'N3':'N',\n  'N.4':'N',\n  'N4':'N',\n  'N.am':'N',\n  'Nam':'N',\n  'N.ar':'N',\n  'Nar':'N',\n  'N.p13':'N',\n  'Np13':'N',    \n  'O.2':'O',\n  'O2':'O',\n  'O.3':'O',\n  'O3':'O',\n  'O.co2':'O',\n  'Oco2':'O',\n  'O.spc':'O',\n  'Ospc':'O',    \n  'O.t3p':'O',\n  'Ot3p':'O',  \n  'P.3':'P',\n  'P3':'P',\n  'S.2':'S',\n  'S2':'S',  \n  'S.3':'S',\n  'S3':'S',  \n  'S.o':'S',\n  'So':'S',  \n  'S.o2':'S',\n  'So2':'S'\n};\n\n// Parse SYBYL mol2 file from string - assumed to only contain one molecule tag\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\n\nexport function MOL2(str: string, options: ParserOptionsSpec) {\n  var atoms: any[][] & Record<string,any> = [[]];\n  var noH = false;\n  if (typeof options.keepH !== \"undefined\") noH = !options.keepH;\n\n  // Note: these regex's work, though they don't match '<TRIPOS>'\n  // correctly - something to do with angle brackets\n  var mol_pos = str.search(/@<TRIPOS>MOLECULE/);\n  var atom_pos = str.search(/@<TRIPOS>ATOM/);\n\n  // Assuming both Molecule and Atom sections exist\n  if (mol_pos == -1 || atom_pos == -1) return atoms;\n\n  var lines = str.substring(mol_pos).split(/\\r?\\n|\\r/);\n  while (lines.length > 0) {\n    // serial is atom's index in file; index is atoms index in 'atoms'\n    var serialToIndex: number[] = [];\n    var tokens = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    var natoms = parseInt(tokens[0]);\n    var nbonds = 0;\n\n    if (tokens.length > 1) nbonds = parseInt(tokens[1]);\n\n    var offset = 4;\n    var i: number;\n    // Continue until 'Atom' section\n    for (i = 3; i < lines.length; i++) {\n      if (lines[i] == \"@<TRIPOS>ATOM\") {\n        offset = i + 1;\n        break;\n      }\n    }\n\n    var start = atoms[atoms.length - 1].length;\n    var end = start + natoms;\n    var line: string;\n    // Process ATOMS\n    for (i = start; i < end; i++) {\n      line = lines[offset++];\n      tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n      var atom: Record<string, any> = {};\n      // get element\n      var elem = tokens[5];\n      if(SYBYLtoElem[elem] !== undefined) {        \n        elem = SYBYLtoElem[elem];\n      } else {\n        elem = elem.split(\".\")[0];\n        elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n      }\n\n      atom.atom = tokens[1];\n      atom.elem = elem;\n        \n      if (atom.elem == \"H\" && noH) {\n        // ignore\n      } else {\n        // 'index' is this atom's index in 'atoms'; 'serial' is this\n        // atom's\n        // serial id in mol2 file\n        var index = atoms[atoms.length - 1].length;\n        var serial = parseInt(tokens[0]);\n        atom.serial = serial;\n        // atom.serial = i;\n\n        atom.x = parseFloat(tokens[2]);\n        atom.y = parseFloat(tokens[3]);\n        atom.z = parseFloat(tokens[4]);\n        atom.atom = tokens[5];\n        var charge = parseFloat(tokens[8]);\n\n        atom.index = index;\n        atom.bonds = [];\n        atom.bondOrder = [];\n        atom.properties = {\n          charge: charge,\n          partialCharge: charge,\n        };\n        serialToIndex[serial] = index;\n\n        atoms[atoms.length - 1].push(atom);\n      }\n    }\n\n    // Process BONDS\n    var bonds_found = false;\n    while (offset < lines.length) {\n      if (lines[offset++] == \"@<TRIPOS>BOND\") {\n        bonds_found = true;\n        break;\n      }\n    }\n\n    if (bonds_found && nbonds) {\n      for (i = 0; i < nbonds; i++) {\n        line = lines[offset++];\n\n        tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n        var from = parseInt(tokens[1]);\n        var fromAtom = atoms[atoms.length - 1][serialToIndex[from]];\n        var to = parseInt(tokens[2]);\n        var toAtom = atoms[atoms.length - 1][serialToIndex[to]];\n\n        // Won't be able to read aromatic bonds correctly...\n        var order = parseInt(tokens[3]);\n        if (isNaN(order)) order = 1;\n\n        if (fromAtom !== undefined && toAtom !== undefined) {\n          fromAtom.bonds.push(serialToIndex[to]);\n          fromAtom.bondOrder.push(order);\n          toAtom.bonds.push(serialToIndex[from]);\n          toAtom.bondOrder.push(order);\n        }\n      }\n    }\n    if (options.multimodel) {\n      if (!options.onemol) atoms.push([]);\n      lines.splice(0, offset);\n      str = lines.join(\"\\n\"); //update for str.search\n      continue;\n    } else {\n      break;\n    }\n  }\n  return atoms;\n}\n", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { getSinglePDB } from \"./utils/getSinglePDB\";\n\n/**\n * Parse pdb file from str and create atoms if computeStruct is true will always perform secondary structure analysis, \n * otherwise only do analysis of SHEET/HELIX comments are missing\n * \n * @param {string} str\n * @param {ParserOptionsSpec} options - keepH (do not strip hydrogens), noSecondaryStructure,\n *            assignbonds (default true, calculate implicit bonds)\n *            (do not compute ss), altLoc (which alternate location to select, if present; '*' to load all)\n * @category Parsers\n * \n*/\n\nexport function PDB(str: string, options: ParserOptionsSpec) {\n  options = options || {};\n  var atoms: any[] & Record<string, any> = []; //a separate list for each model\n  var sslookup = {}; //stores SHEET and HELIX info, which is shared across models\n  atoms.modelData = [];\n  var lines: any = str.split(/\\r?\\n|\\r/);\n  while (lines.length > 0) {\n    var pdbinfo = getSinglePDB(lines, options, sslookup);\n    var modelatoms = pdbinfo[0];\n    var modelData = pdbinfo[1];\n    lines = pdbinfo[2];\n\n    if (modelatoms.length == 0) {\n      continue; //happens when there are blank lines\n    }\n    if (options.multimodel && options.onemol && atoms.length > 0) {\n      //merge into existing atoms\n      var inc = atoms[0].length;\n      for (var i = 0; i < modelatoms.length; i++) {\n        //renumber\n        var atom = modelatoms[i];\n        atom.index = i;\n        for (var b = 0; b < atom.bonds.length; b++) {\n          atom.bonds[b] += inc;\n        }\n        atoms[0].push(atom);\n      }\n    } else {\n      atoms.modelData.push(modelData);\n      atoms.push(modelatoms);\n    }\n\n    if (!options.multimodel) {\n      break;\n    }\n  }\n\n  return atoms;\n}\n", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { assignPDBBonds } from \"./utils/assignPDBBonds\";\nimport { computeSecondaryStructure } from \"./utils/computeSecondaryStructure\";\n\n\n/**\n * Parse a pqr file from str and create atoms. A pqr file is assumed to be a whitespace delimited PDB with charge and radius fields.\n * \n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options - noSecondaryStructure (do not compute ss)\n * @category Parsers \n*/\n\nexport function PQR(str: string, options: ParserOptionsSpec) {\n      var atoms: any[][] & Record<string, any> = [[]];\n      var computeStruct = !options.noSecondaryStructure;\n      atoms.modelData = [{symmetries:[]}];\n      var serialToIndex: number[] = []; // map from pdb serial to index in atoms\n      var lines = str.split(/\\r?\\n|\\r/);\n      var line: string | string[];\n      for (let i = 0; i < lines.length; i++) {\n          line = lines[i].replace(/^\\s*/, ''); // remove indent\n          var recordName = line.substring(0, 6);\n          \n          if (recordName.indexOf(\"END\") == 0) {\n              if (options.multimodel) {\n                  if (!options.onemol)\n                      atoms.push([]);\n                  continue;\n              }\n              else {\n                  break;\n              }\n          }\n          else if (recordName == 'ATOM  ' || recordName == 'HETATM') {\n              // I would have liked to split based solely on whitespace, but\n              // it seems that there is no guarantee that all the fields will\n              // be filled out (e.g. the chain) so this doesn't work\n              var hetflag: boolean;\n              let serial = parseInt(line.substring(6, 11));\n              let atom = line.substring(12, 16).replace(/ /g, \"\");\n              let resn = line.substring(17, 20).trim();\n              let chain = line.substring(21, 22);\n              let resi = parseInt(line.substring(22, 26));\n              // however let's split the coordinates, charge and radius by\n              // whitespace\n              // to support extra precision\n              var vals = line.substring(30).trim().split(/\\s+/);\n              var x = parseFloat(vals[0]);\n              var y = parseFloat(vals[1]);\n              var z = parseFloat(vals[2]);\n              var charge = parseFloat(vals[3]);\n              var radius = parseFloat(vals[4]);\n\n              var elem = atom[0];\n              if (atom.length > 1 && atom[1].toUpperCase() != atom[1]) {\n                  // slight hack - identify two character elements by the\n                  // second character in the atom name being lowercase\n                  elem = atom.substring(0, 2);\n              }\n\n              if (line[0] == 'H')\n                  hetflag = true;\n              else\n                  hetflag = false;\n              serialToIndex[serial] = atoms[atoms.length-1].length;\n              atoms[atoms.length-1].push({\n                  'resn' : resn,\n                  'x' : x,\n                  'y' : y,\n                  'z' : z,\n                  'elem' : elem,\n                  'hetflag' : hetflag,\n                  'chain' : chain,\n                  'resi' : resi,\n                  'serial' : serial,\n                  'atom' : atom,\n                  'bonds' : [],\n                  'ss' : 'c',\n                  'bondOrder' : [],\n                  'properties' : {\n                      'charge' : charge,\n                      'partialCharge' : charge,\n                      'radius' : radius\n                  },\n                  'pdbline' : line\n              });\n          } else if (recordName == 'CONECT') {\n              // MEMO: We don't have to parse SSBOND, LINK because both are\n              // also\n              // described in CONECT. But what about 2JYT???\n              var from = parseInt(line.substring(6, 11));\n              var fromAtom = atoms[atoms.length-1][serialToIndex[from]];\n              for (let j = 0; j < 4; j++) {\n                  var to = parseInt(line.substring([ 11, 16, 21, 26 ][j], [ 11, 16, 21, 26 ][j] + 5));\n                  var toAtom = atoms[atoms.length-1][serialToIndex[to]];\n                  if (fromAtom !== undefined && toAtom !== undefined) {\n                      fromAtom.bonds.push(serialToIndex[to]);\n                      fromAtom.bondOrder.push(1);\n                  }\n              }\n          }\n      }\n\n      // assign bonds - yuck, can't count on connect records\n      for (let i = 0; i < atoms.length; i++) {\n          assignPDBBonds(atoms[i],options);\n          if (computeStruct)\n              computeSecondaryStructure(atoms[i],options.hbondCutoff);\n      }\n      \n      return atoms;\n  };", "// @ts-nocheck\n\n/**\n * Parse a prmtop file from str and create atoms\n * \n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options - noSecondaryStructure (do not compute ss)\n * @category Parsers\n*/\n\nexport function PRMTOP(str: string /*, options*/) {\n  var atoms = [];\n  var atomIndex: number;\n  var count = 0;\n  var lines = str.split(/\\r?\\n|\\r/);\n  if (lines.length > 0 && lines[0].includes(\"VERSION\")) {\n    var sectionList = lines.filter(function (line) {\n      //store the relevant section lists\n      return (\n        line.includes(\"POINTERS\") ||\n        line.includes(\"ATOM_NAME\") ||\n        line.includes(\"CHARGE\") ||\n        line.includes(\"RADII\") ||\n        line.includes(\"BONDS_INC_HYDROGEN\") ||\n        line.includes(\"BONDS_WITHOUT_HYDROGEN\") ||\n        line.includes(\"RESIDUE_LABEL\") ||\n        line.includes(\"RESIDUE_POINTER\")\n      );\n    });\n    var index = getIndex(\"POINTERS\");\n    if (index == -1) return [];\n    var col = getColEleSize(index);\n    var atomCount = parseInt(lines[index + 1].slice(0, col[1]));\n    let resCount = parseInt(lines[index + 2].slice(col[1], col[0] + col[1]));\n    if (isNaN(atomCount) || atomCount <= 0) return [];\n    index = getIndex(\"ATOM_NAME\");\n    if (index == -1) return [];\n    col = getColEleSize(index);\n    var noOfCol = col[0];\n    for (let i = 0; i < atomCount / col[0]; i++) {\n      if (i == parseInt(atomCount / col[0])) noOfCol = atomCount % col[0];\n      for (let j = 0; j < noOfCol; j++) {\n        let atom = {};\n        let properties = { charge: \"\", radii: \"\" };\n        atom.serial = count;\n        atom.x = 0;\n        atom.y = 0;\n        atom.z = 0;\n        atom.atom = lines[index + 1].slice(col[1] * j, col[1] * (j + 1)).trim();\n        atom.elem = lines[index + 1].slice(col[1] * j, col[1] * j + 1).trim();\n        atom.properties = properties;\n        atom.bonds = [];\n        atom.bondOrder = [];\n        atom.index = atoms.length;\n\n        atoms.push(atom);\n        count++;\n      }\n      index++;\n    }\n    index = getIndex(\"CHARGE\");\n    if (index != -1) {\n      col = getColEleSize(index);\n      count = 0;\n      noOfCol = col[0];\n      for (let i = 0; i < atomCount / col[0]; i++) {\n        if (i == parseInt(atomCount / col[0])) noOfCol = atomCount % col[0];\n        for (let j = 0; j < noOfCol; j++) {\n          atoms[count].properties.charge = parseFloat(\n            lines[index + 1].slice(col[1] * j, col[1] * (j + 1))\n          );\n          count++;\n        }\n        index++;\n      }\n    }\n\n    index = getIndex(\"RESIDUE_POINTER\");\n    var resstarts = [];\n    if (index != -1) {\n      col = getColEleSize(index);\n      noOfCol = col[0];\n      index += 1;\n      for (let i = 0; i < resCount / col[0]; i++) {\n        if (i == parseInt(resCount / col[0])) noOfCol = resCount % col[0];\n        for (let j = 0; j < noOfCol; j++) {\n          resstarts.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1))));\n        }\n        index++;\n      }\n      index = getIndex(\"RESIDUE_LABEL\");\n      if (index != -1) {\n        let resnames = []\n        col = getColEleSize(index);\n        noOfCol = col[0];\n        index += 1;\n        for (let i = 0; i < resCount / col[0]; i++) {\n          if (i == parseInt(resCount / col[0])) noOfCol = resCount % col[0];\n          for (let j = 0; j < noOfCol; j++) {\n            resnames.push(lines[index].slice(col[1] * j, col[1] * (j + 1)).trim());\n          }\n          index++;\n        }\n\n        let curres = 0;\n        let resi = 0;\n        let resn = '';\n        resstarts.push(atoms.length+1);\n        for(let i = 0; i < atoms.length; i++) {\n          if(i+1 >= resstarts[curres]) {\n            resn = resnames[curres];\n            curres += 1;\n            resi += 1;\n          }\n          atoms[i].resi = resi;\n          atoms[i].resn = resn;\n        }\n      }\n    }\n    index = getIndex(\"RADII\");\n    if (index != -1) {\n      col = getColEleSize(index);\n      count = 0;\n      noOfCol = col[0];\n      for (let i = 0; i < atomCount / col[0]; i++) {\n        if (i == parseInt(atomCount / col[0])) noOfCol = atomCount % col[0];\n        for (let j = 0; j < noOfCol; j++) {\n          atoms[count].properties.radii = parseFloat(\n            lines[index + 1].slice(col[1] * j, col[1] * (j + 1))\n          );\n          count++;\n        }\n        index++;\n      }\n    }\n    index = getIndex(\"BONDS_WITHOUT_HYDROGEN\");\n    if (index != -1) {\n      col = getColEleSize(index);\n      count = 0;\n      noOfCol = col[0];\n      index = index + 1;\n      while (!lines[index].match(/^%FLAG/)) {\n        if (lines[index + 1].match(/^%FLAG/))\n          //its the last line\n          noOfCol = atomCount % col[0];\n        for (let j = 0; j < noOfCol; j++) {\n          if (count % 3 == 0) {\n            atomIndex = parseInt(\n              lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3\n            );\n          } else if (count % 3 == 1) {\n            atoms[atomIndex].bonds.push(\n              parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3)\n            );\n            atoms[atomIndex].bondOrder.push(1);\n          }\n          count++;\n        }\n        index++;\n      }\n    }\n    index = getIndex(\"BONDS_INC_HYDROGEN\");\n    if (index != -1) {\n      col = getColEleSize(index);\n      count = 0;\n      noOfCol = col[0];\n      index = index + 1;\n      while (!lines[index].match(/^%FLAG/)) {\n        if (lines[index + 1].match(/^%FLAG/))\n          //its the last line\n          noOfCol = atomCount % col[0];\n        for (let j = 0; j < noOfCol; j++) {\n          if (count % 3 == 0) {\n            atomIndex = parseInt(\n              lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3\n            );\n          } else if (count % 3 == 1) {\n            atoms[atomIndex].bonds.push(\n              parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3)\n            );\n            atoms[atomIndex].bonds.push(1);\n          }\n          count++;\n        }\n        index++;\n      }\n    }\n  } else {\n    return [];\n  }\n\n  function getIndex(section) {\n    var index = lines.indexOf(\n      sectionList.filter(function (line) {\n        return line.includes(section);\n      })[0]\n    ); //returns the index of the line containing FLAG POINTERS\n    if (Number.isInteger(index) && index > 0) {\n      while (!lines[index].includes(\"FORMAT\"))\n        //doing this so as to take comments into consideration\n        index++;\n      return index;\n    } else {\n      return -1;\n    }\n  }\n  function getColEleSize(i) {\n    var numberOfCol = lines[i].match(/\\((\\d*)\\S*/); // stores the number of columns\n    var elementSize = lines[i].match(/[a-zA-Z](\\d*)\\)\\s*/);\n    if (elementSize == null) {\n      elementSize = lines[i].match(/[a-zA-Z](\\d*)\\.\\d*\\)\\s*/); //stores the element size\n    }\n    return [parseInt(numberOfCol[1]), parseInt(elementSize[1])];\n  }\n  return [atoms];\n}\n", "import { ParserOptionsSpec } from \"./ParserOptionsSpec\";\n\nvar parseV2000 = function (lines: any, options: ParserOptionsSpec) {\n  var atoms: any & Record<string, any> = [[]];\n  var noH = false;\n  if (typeof options.keepH !== \"undefined\") noH = !options.keepH;\n\n  while (lines.length > 0) {\n    if (lines.length < 4) break;\n    var atomCount = parseInt(lines[3].substring(0, 3));\n    if (isNaN(atomCount) || atomCount <= 0) break;\n    var bondCount = parseInt(lines[3].substring(3, 6));\n    var offset = 4;\n    if (lines.length < 4 + atomCount + bondCount) break;\n\n    // Serial is atom's index in file; index is atoms index in 'atoms'\n    var serialToIndex: number[] = [];\n    var start = atoms[atoms.length - 1].length;\n    var end = start + atomCount;\n    var i: number, line: string;\n    for (i = start; i < end; i++, offset++) {\n      line = lines[offset];\n      var atom: Record<string, any> = {};\n      var elem = line.substring(31, 34).replace(/ /g, \"\");\n      atom.atom = atom.elem =\n        elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n\n      if (atom.elem !== \"H\" || !noH) {\n        atom.serial = i;\n        serialToIndex[i] = atoms[atoms.length - 1].length;\n        atom.x = parseFloat(line.substring(0, 10));\n        atom.y = parseFloat(line.substring(10, 20));\n        atom.z = parseFloat(line.substring(20, 30));\n        atom.hetflag = true;\n        atom.bonds = [];\n        atom.bondOrder = [];\n        atom.properties = {};\n        atom.index = atoms[atoms.length - 1].length;\n        atoms[atoms.length - 1].push(atom);\n      }\n    }\n\n    for (i = 0; i < bondCount; i++, offset++) {\n      line = lines[offset];\n      var from = serialToIndex[parseInt(line.substring(0, 3)) - 1 + start];\n      var to = serialToIndex[parseInt(line.substring(3, 6)) - 1 + start];\n      var order = parseFloat(line.substring(6));\n      if (typeof from != \"undefined\" && typeof to != \"undefined\") {\n        atoms[atoms.length - 1][from].bonds.push(to);\n        atoms[atoms.length - 1][from].bondOrder.push(order);\n        atoms[atoms.length - 1][to].bonds.push(from);\n        atoms[atoms.length - 1][to].bondOrder.push(order);\n      }\n    }\n    if (options.multimodel) {\n      if (!options.onemol) atoms.push([]);\n      while (lines[offset] !== \"$$$$\" && offset < lines.length) offset++;\n      lines.splice(0, ++offset);\n    } else {\n      break;\n    }\n  }\n  return atoms;\n};\n\n/**\n * @param {!Array.<string>} lines\n * @param {ParserOptionsSpec} options\n * @returns {!Array.<!Array<!Object>>}\n*/\n\nvar parseV3000 = function (lines: any, options: ParserOptionsSpec) {\n  var atoms: any[][] & Record<string, any> = [[]];\n  var noH = false;\n  if (typeof options.keepH !== \"undefined\") noH = !options.keepH;\n\n  while (lines.length > 0) {\n    if (lines.length < 8) break;\n\n    if (!lines[4].startsWith(\"M  V30 BEGIN CTAB\")) break;\n    if (!lines[5].startsWith(\"M  V30 COUNTS\") || lines[5].length < 14) break;\n\n    var counts = lines[5].substring(13).match(/\\S+/g);\n\n    if (counts.length < 2) break;\n\n    var atomCount = parseInt(counts[0]);\n    if (isNaN(atomCount) || atomCount <= 0) break;\n    var bondCount = parseInt(counts[1]);\n    var offset = 7;\n\n    if (lines.length < 8 + atomCount + bondCount)\n      //header, bgn+end CTAB, counts, END\n      break;\n\n    // serial is atom's index in file; index is atoms index in 'atoms'\n    var serialToIndex: number[] = [];\n    var start = atoms[atoms.length - 1].length;\n    var end = start + atomCount;\n    var i: number, line: string;\n    for (i = start; i < end; i++, offset++) {\n      line = lines[offset];\n      var atomParts = line.substring(6).match(/\\S+/g);\n      if (atomParts!.length > 4) {\n        var atom: Record<string, any> = {};\n        var elem = atomParts![1].replace(/ /g, \"\");\n        atom.atom = atom.elem =\n          elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n\n        if (atom.elem !== \"H\" || !noH) {\n          atom.serial = i;\n          serialToIndex[i] = atoms[atoms.length - 1].length;\n          atom.x = parseFloat(atomParts![2]);\n          atom.y = parseFloat(atomParts![3]);\n          atom.z = parseFloat(atomParts![4]);\n          atom.hetflag = true;\n          atom.bonds = [];\n          atom.bondOrder = [];\n          atom.properties = {};\n          atom.index = atoms[atoms.length - 1].length;\n          atoms[atoms.length - 1].push(atom);\n        }\n      }\n    }\n\n    if (lines[offset] === \"M  V30 END ATOM\") offset++;\n    else break;\n\n    if (bondCount !== 0 && lines[offset] === \"M  V30 BEGIN BOND\") offset++;\n    else break;\n\n    for (i = 0; i < bondCount; i++, offset++) {\n      line = lines[offset];\n      var bondParts = line.substring(6).match(/\\S+/g);\n      if (bondParts!.length > 3) {\n        var from = serialToIndex[parseInt(bondParts![2]) - 1 + start];\n        var to = serialToIndex[parseInt(bondParts![3]) - 1 + start];\n        var order = parseFloat(bondParts![1]);\n        if (typeof from != \"undefined\" && typeof to != \"undefined\") {\n          atoms[atoms.length - 1][from].bonds.push(to);\n          atoms[atoms.length - 1][from].bondOrder.push(order);\n          atoms[atoms.length - 1][to].bonds.push(from);\n          atoms[atoms.length - 1][to].bondOrder.push(order);\n        }\n      }\n    }\n    if (options.multimodel) {\n      if (!options.onemol) {\n        atoms.push([]);\n      }\n      while (lines[offset] !== \"$$$$\" && offset < lines.length) {\n        offset++;\n      }\n      lines.splice(0, ++offset);\n    } else {\n      break;\n    }\n  }\n  return atoms;\n};\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\n\nexport function SDF(str: string, options: ParserOptionsSpec) {\n  var molformat = \"V2000\";\n  var lines = str.split(/\\r?\\n|\\r/);\n  if (lines.length > 3 && lines[3].length > 38) {\n    molformat = lines[3].substring(34, 39);\n  }\n  if (molformat === \"V2000\") {\n    return parseV2000(lines, options);\n  } else if (molformat === \"V3000\") {\n    return parseV3000(lines, options);\n  }\n  return [['']];\n}\n", "\nimport { Matrix3 } from \"../WebGL\";\n\nimport { assignBonds } from \"./utils/assignBonds\";\nimport { ParserOptionsSpec } from \"./ParserOptionsSpec\";\nimport { AtomSpec } from \"specs\";\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\n\nexport function VASP(str: string, options: ParserOptionsSpec = {}) {\n  var atoms: any[][] & Record<string, any> = [[]];\n  var lattice: Record<string, number | Float32Array> = {};\n  const assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n\n  var lines = str.replace(/^\\s+/, \"\").split(/\\r?\\n/);\n\n  if (lines.length < 3) {\n    return atoms;\n  }\n\n  if (lines[1].match(/\\d+/)) {\n    lattice.length = parseFloat(lines[1]);\n  } else {\n    console.log(\n      \"Warning: second line of the vasp structure file must be a number\"\n    );\n    return atoms;\n  }\n\n  if (lattice.length < 0) {\n    console.log(\n      \"Warning: Vasp implementation for negative lattice lengths is not yet available\"\n    );\n    return atoms;\n  }\n\n  lattice.xVec = new Float32Array((lines[2] as any).replace(/^\\s+/, \"\").split(/\\s+/));\n  lattice.yVec = new Float32Array((lines[3] as any).replace(/^\\s+/, \"\").split(/\\s+/));\n  lattice.zVec = new Float32Array((lines[4] as any).replace(/^\\s+/, \"\").split(/\\s+/));\n\n  var matrix = new Matrix3(\n    lattice.xVec[0],\n    lattice.xVec[1],\n    lattice.xVec[2],\n    lattice.yVec[0],\n    lattice.yVec[1],\n    lattice.yVec[2],\n    lattice.zVec[0],\n    lattice.zVec[1],\n    lattice.zVec[2]\n  );\n\n  matrix.multiplyScalar(lattice.length);\n  atoms.modelData = [{ symmetries: [], cryst: { matrix: matrix } }];\n  var atomSymbols = lines[5].trim().split(/\\s+/);\n  var atomSpeciesNumber = new Int16Array(\n    lines[6].trim().split(/\\s+/) as any\n  );\n  var vaspMode = lines[7].trim();\n\n  var selective = false\n  if (vaspMode.match(/S/)) {\n    selective = true\n    vaspMode = lines[8].trim();\n  }\n\n  if (vaspMode.toLowerCase()[0] == \"c\") {\n    vaspMode = \"cartesian\";\n  } else if (vaspMode.toLowerCase()[0] == \"d\") {\n    vaspMode = \"direct\";\n  } else {    \n    console.log(\n      \"Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)\"\n    );\n    return atoms;\n  }\n\n  if (atomSymbols.length != atomSpeciesNumber.length) {\n    console.log(\"Warning: declaration of atomary species wrong:\");\n    console.log(atomSymbols);\n    console.log(atomSpeciesNumber);\n    return atoms;\n  }\n\n  if (selective) {\n    lines.splice(0, 9);\n  }\n  else {\n    lines.splice(0, 8);\n  }\n\n  var atomCounter = 0;\n\n  for (var i = 0, len = atomSymbols.length; i < len; i++) {\n    var atomSymbol = atomSymbols[i];\n    for (var j = 0, atomLen = atomSpeciesNumber[i]; j < atomLen; j++) {\n      var coords = new Float32Array(\n        lines[atomCounter + j].trim().split(/\\s+/) as any\n      );\n\n      var atom: AtomSpec = {};\n      (atom.elem as any) = atomSymbol;\n      if (vaspMode == \"cartesian\") {\n        atom.x = lattice.length * coords[0];\n        atom.y = lattice.length * coords[1];\n        atom.z = lattice.length * coords[2];\n      } else {\n        atom.x =\n          lattice.length *\n          (coords[0] * lattice.xVec[0] +\n            coords[1] * lattice.yVec[0] +\n            coords[2] * lattice.zVec[0]);\n        atom.y =\n          lattice.length *\n          (coords[0] * lattice.xVec[1] +\n            coords[1] * lattice.yVec[1] +\n            coords[2] * lattice.zVec[1]);\n        atom.z =\n          lattice.length *\n          (coords[0] * lattice.xVec[2] +\n            coords[1] * lattice.yVec[2] +\n            coords[2] * lattice.zVec[2]);\n      }\n\n      atom.bonds = [];\n      atom.bondOrder = [];\n\n      atoms[0].push(atom);\n    }\n    atomCounter += atomSpeciesNumber[i];\n  }\n\n  if (assignbonds) {\n    for (let i = 0; i < atoms.length; i++) {\n      assignBonds(atoms[i], options);\n    }\n  }\n  return atoms;\n}\n", "import { ParserOptionsSpec } from './ParserOptionsSpec';\n\nimport { Matrix3 } from \"../WebGL\";\nimport { assignBonds } from \"./utils/assignBonds\";\n\n/**\n * Read an XYZ file from str and return result\n * \n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n*/\n\nexport function XYZ(str: string, options: ParserOptionsSpec) {\n  options = options || {};\n  var atoms: any[][] & Record<string, any> = [[]];\n  var assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n  var lines = str.trimStart().split(/\\r?\\n|\\r/);\n  while (lines.length > 0) {\n    if (lines.length < 3) break;\n    var atomCount = parseInt(lines[0]);\n    if (isNaN(atomCount) || atomCount <= 0) break;\n    if (lines.length < atomCount + 2) break;\n\n    var lattice_re = /Lattice\\s*=\\s*[\"\\{\\}]([^\"\\{\\}]+)[\"\\{\\}]\\s*/gi;\n    var lattice_match = lattice_re.exec(lines[1]);\n    if (lattice_match != null && lattice_match.length > 1) {\n      var lattice = new Float32Array(lattice_match[1].split(/\\s+/) as any);\n      var matrix = new Matrix3(\n        lattice[0],\n        lattice[3],\n        lattice[6],\n        lattice[1],\n        lattice[4],\n        lattice[7],\n        lattice[2],\n        lattice[5],\n        lattice[8]\n      );\n      atoms.modelData = [{ cryst: { matrix: matrix } }];\n    }\n\n    var offset = 2;\n    var start = atoms[atoms.length - 1].length;\n    var end = start + atomCount;\n    for (var i = start; i < end; i++) {\n      var line = lines[offset++];\n      var tokens = line.trim().split(/\\s+/);\n      var atom: Record<string, any> = {};\n      atom.serial = i;\n      var elem = tokens[0];\n      atom.atom = atom.elem =\n        elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();\n      atom.x = parseFloat(tokens[1]);\n      atom.y = parseFloat(tokens[2]);\n      atom.z = parseFloat(tokens[3]);\n      atom.hetflag = true;\n      atom.bonds = [];\n      atom.bondOrder = [];\n      atom.properties = {};\n      atoms[atoms.length - 1][i] = atom;\n      if (tokens.length >= 7) {\n        atom.dx = parseFloat(tokens[4]);\n        atom.dy = parseFloat(tokens[5]);\n        atom.dz = parseFloat(tokens[6]);\n      }\n    }\n\n    if (options.multimodel) {\n      atoms.push([]);\n      lines.splice(0, offset);\n    } else {\n      break;\n    }\n  }\n\n  if (assignbonds) {\n    for (let i = 0; i < atoms.length; i++) {\n      assignBonds(atoms[i], options);\n    }\n  }\n\n  if (options.onemol) {\n    var temp = atoms;\n    atoms = [];\n    atoms.push(temp[0]);\n    for (let i = 1; i < temp.length; i++) {\n      let offset = atoms[0].length;\n      for (let j = 0; j < temp[i].length; j++) {\n        let a = temp[i][j];\n        for (let k = 0; k < a.bonds.length; k++) {\n          a.bonds[k] = a.bonds[k] + offset;\n        }\n        a.index = atoms[0].length;\n        a.serial = atoms[0].length;\n        atoms[0].push(a);\n      }\n    }\n  }\n\n  return atoms;\n}\n", "/* Note - all code in this directory is adapted from molstar -dkoes */\nimport { EncodedCategory } from \"./encoding\";\nimport { decode } from './decoder';\n\nexport function Category(data: EncodedCategory) {\n  const map = Object.create(null);\n  const cache = Object.create(null);\n  for (const col of data.columns) map[col.name] = col;\n  return {\n      rowCount: data.rowCount,\n      name: data.name.substring(1),\n      fieldNames: data.columns.map(c => c.name),\n      getField(name) {\n          const col = map[name];\n          if (!col) return void 0;\n          if (!!cache[name]) return cache[name];\n          cache[name] = decode(col.data);\n          return cache[name];\n      }\n  };\n}", "/**\n * Copyright (c) 2017-2024 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * From CIFTools.js\n * @author David Sehnal <david.sehnal@gmail.com>\n */\n\nimport { Encoding, EncodedData } from './encoding';\n\nconst IsNativeEndianLittle = new Uint16Array(new Uint8Array([0x12, 0x34]).buffer)[0] === 0x3412;\n\nfunction flipByteOrder(data: Uint8Array, bytes: number) {\n  const buffer = new ArrayBuffer(data.length);\n  const ret = new Uint8Array(buffer);\n  for (let i = 0, n = data.length; i < n; i += bytes) {\n    for (let j = 0; j < bytes; j++) {\n      ret[i + bytes - j - 1] = data[i + j];\n    }\n  }\n  return buffer;\n}\n\n/**\n * Fixed point, delta, RLE, integer packing adopted from https://github.com/rcsb/mmtf-javascript/\n * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016\n */\n\nexport function decode(data: EncodedData): any[] {\n  let current: any = data.data;\n  for (let i = data.encoding.length - 1; i >= 0; i--) {\n    current = decodeStep(current, data.encoding[i]);\n  }\n  return current as any[];\n}\n\nfunction decodeStep(data: any, encoding: Encoding): any {\n  switch (encoding.kind) {\n    case 'ByteArray': {\n      switch (encoding.type) {\n        case Encoding.IntDataType.Uint8: return data;\n        case Encoding.IntDataType.Int8: return int8(data);\n        case Encoding.IntDataType.Int16: return int16(data);\n        case Encoding.IntDataType.Uint16: return uint16(data);\n        case Encoding.IntDataType.Int32: return int32(data);\n        case Encoding.IntDataType.Uint32: return uint32(data);\n        case Encoding.FloatDataType.Float32: return float32(data);\n        case Encoding.FloatDataType.Float64: return float64(data);\n        default: throw new Error('unreachable');\n      }\n    }\n    case 'FixedPoint': return fixedPoint(data, encoding);\n    case 'IntervalQuantization': return intervalQuantization(data, encoding);\n    case 'RunLength': return runLength(data, encoding);\n    case 'Delta': return delta(data, encoding);\n    case 'IntegerPacking': return integerPacking(data, encoding);\n    case 'StringArray': return stringArray(data, encoding);\n  }\n}\n\nfunction getIntArray(type: Encoding.IntDataType, size: number) {\n  switch (type) {\n    case Encoding.IntDataType.Int8: return new Int8Array(size);\n    case Encoding.IntDataType.Int16: return new Int16Array(size);\n    case Encoding.IntDataType.Int32: return new Int32Array(size);\n    case Encoding.IntDataType.Uint8: return new Uint8Array(size);\n    case Encoding.IntDataType.Uint16: return new Uint16Array(size);\n    case Encoding.IntDataType.Uint32: return new Uint32Array(size);\n    default: return new Int32Array(size);\n  }\n}\n\nfunction getFloatArray(type: Encoding.FloatDataType, size: number) {\n  switch (type) {\n    case Encoding.FloatDataType.Float32: return new Float32Array(size);\n    case Encoding.FloatDataType.Float64: return new Float64Array(size);\n    default: return new Float64Array(size);\n  }\n}\n\nfunction int8(data: Uint8Array) { return new Int8Array(data.buffer, data.byteOffset); }\n\nfunction view<T>(data: Uint8Array, byteSize: number, c: new (buffer: ArrayBuffer) => T) {\n  if (data.byteOffset != 0 || data.byteLength != data.buffer.byteLength) { //dkoes - extract from larger buffer if needed\n    data = new Uint8Array(data);\n  }\n  if (IsNativeEndianLittle) return new c(data.buffer as ArrayBuffer);\n  return new c(flipByteOrder(data, byteSize));\n}\n\nfunction int16(data: Uint8Array) { return view(data, 2, Int16Array); }\nfunction uint16(data: Uint8Array) { return view(data, 2, Uint16Array); }\nfunction int32(data: Uint8Array) { return view(data, 4, Int32Array); }\nfunction uint32(data: Uint8Array) { return view(data, 4, Uint32Array); }\nfunction float32(data: Uint8Array) { return view(data, 4, Float32Array); }\nfunction float64(data: Uint8Array) { return view(data, 8, Float64Array); }\n\nfunction fixedPoint(data: Int32Array, encoding: Encoding.FixedPoint) {\n  const n = data.length;\n  const output = getFloatArray(encoding.srcType, n);\n  const f = 1 / encoding.factor;\n  for (let i = 0; i < n; i++) {\n    output[i] = f * data[i];\n  }\n  return output;\n}\n\nfunction intervalQuantization(data: Int32Array, encoding: Encoding.IntervalQuantization) {\n  const n = data.length;\n  const output = getFloatArray(encoding.srcType, n);\n  const delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);\n  const min = encoding.min;\n  for (let i = 0; i < n; i++) {\n    output[i] = min + delta * data[i];\n  }\n  return output;\n}\n\nfunction runLength(data: Int32Array, encoding: Encoding.RunLength) {\n  const output = getIntArray(encoding.srcType, encoding.srcSize);\n  let dataOffset = 0;\n  for (let i = 0, il = data.length; i < il; i += 2) {\n    const value = data[i]; // value to be repeated\n    const length = data[i + 1]; // number of repeats\n    for (let j = 0; j < length; ++j) {\n      output[dataOffset++] = value;\n    }\n  }\n  return output;\n}\n\nfunction delta(data: (Int8Array | Int16Array | Int32Array), encoding: Encoding.Delta) {\n  const n = data.length;\n  const output = getIntArray(encoding.srcType, n);\n  if (!n) return data;\n  output[0] = data[0] + (encoding.origin | 0);\n  for (let i = 1; i < n; ++i) {\n    output[i] = data[i] + output[i - 1];\n  }\n  return output;\n}\n\nfunction integerPackingSigned(data: (Int8Array | Int16Array), encoding: Encoding.IntegerPacking) {\n  const upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;\n  const lowerLimit = -upperLimit - 1;\n  const n = data.length;\n  const output = new Int32Array(encoding.srcSize);\n  let i = 0;\n  let j = 0;\n  while (i < n) {\n    let value = 0, t = data[i];\n    while (t === upperLimit || t === lowerLimit) {\n      value += t;\n      i++;\n      t = data[i];\n    }\n    value += t;\n    output[j] = value;\n    i++;\n    j++;\n  }\n  return output;\n}\n\nfunction integerPackingUnsigned(data: (Uint8Array | Uint16Array), encoding: Encoding.IntegerPacking) {\n  const upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;\n  const n = data.length;\n  const output = new Int32Array(encoding.srcSize);\n  let i = 0;\n  let j = 0;\n  while (i < n) {\n    let value = 0, t = data[i];\n    while (t === upperLimit) {\n      value += t;\n      i++;\n      t = data[i];\n    }\n    value += t;\n    output[j] = value;\n    i++;\n    j++;\n  }\n  return output;\n}\n\nfunction integerPacking(data: (Int8Array | Int16Array | Uint8Array | Uint16Array), encoding: Encoding.IntegerPacking) {\n  if (data.length === encoding.srcSize) return data;\n  return encoding.isUnsigned ? integerPackingUnsigned(data as any, encoding) : integerPackingSigned(data as any, encoding);\n}\n\nfunction stringArray(data: Uint8Array, encoding: Encoding.StringArray) {\n  const offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });\n  const indices = decode({ encoding: encoding.dataEncoding, data });\n\n  const str = encoding.stringData;\n  const strings = new Array(offsets.length);\n  strings[0] = '';\n  for (let i = 1, _i = offsets.length; i < _i; i++) {\n    strings[i] = str.substring(offsets[i - 1], offsets[i]);\n  }\n\n  let offset = 0;\n  const result = new Array(indices.length);\n  for (let i = 0, _i = indices.length; i < _i; i++) {\n    result[offset++] = strings[indices[i] + 1];\n  }\n  return result;\n}", "/*\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * From CIFTools.js\n * @author David Sehnal <david.sehnal@gmail.com>\n * \n * Note: all files in this directory are adapted from molstar - dkoes\n */\n\nexport type TypedIntArray = Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array\nexport type TypedFloatArray = Float32Array | Float64Array\nexport const VERSION = '0.3.0';\n\nexport type Encoding =\n    | Encoding.ByteArray\n    | Encoding.FixedPoint\n    | Encoding.RunLength\n    | Encoding.Delta\n    | Encoding.IntervalQuantization\n    | Encoding.IntegerPacking\n    | Encoding.StringArray;\n\n\nexport interface EncodedDataBlock {\n    header: string,\n    categories: EncodedCategory[],\n}\n\nexport interface EncodedCategory {\n    name: string,\n    rowCount: number,\n    columns: EncodedColumn[],\n}\n\nexport interface EncodedColumn {\n    name: string,\n    data: EncodedData,\n\n    /**\n     * The mask represents the presence or absent of particular \"CIF value\".\n     * If the mask is not set, every value is present.\n     *\n     * 0 = Value is present\n     * 1 = . = value not specified\n     * 2 = ? = value unknown\n     */\n    mask?: EncodedData\n}\n\nexport interface EncodedData {\n    encoding: Encoding[],\n    data: Uint8Array\n}\n\nexport namespace Encoding {\n\n    export enum IntDataType {\n        Int8 = 1,\n        Int16 = 2,\n        Int32 = 3,\n        Uint8 = 4,\n        Uint16 = 5,\n        Uint32 = 6,\n    }\n\n    export enum FloatDataType {\n        Float32 = 32,\n        Float64 = 33\n    }\n\n    export type DataType = IntDataType | FloatDataType\n\n    export function getDataType(data: TypedIntArray | TypedFloatArray): DataType {\n        let srcType: DataType;\n        if (data instanceof Int8Array) srcType = Encoding.IntDataType.Int8;\n        else if (data instanceof Int16Array) srcType = Encoding.IntDataType.Int16;\n        else if (data instanceof Int32Array) srcType = Encoding.IntDataType.Int32;\n        else if (data instanceof Uint8Array) srcType = Encoding.IntDataType.Uint8;\n        else if (data instanceof Uint16Array) srcType = Encoding.IntDataType.Uint16;\n        else if (data instanceof Uint32Array) srcType = Encoding.IntDataType.Uint32;\n        else if (data instanceof Float32Array) srcType = Encoding.FloatDataType.Float32;\n        else if (data instanceof Float64Array) srcType = Encoding.FloatDataType.Float64;\n        else srcType = Encoding.IntDataType.Int32; // throw new Error('Unsupported integer data type.');\n        return srcType;\n    }\n\n    export function isSignedIntegerDataType(data: TypedIntArray) {\n        if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array) return true;\n        for (let i = 0, _i = data.length; i < _i; i++) {\n            if (i < 0) return false;\n        }\n        return true;\n    }\n\n    // type[] -> Uint8[]\n    export interface ByteArray {\n        kind: 'ByteArray',\n        type: DataType\n    }\n\n    // (Float32 | Float64)[] -> Int32[]\n    export interface FixedPoint {\n        kind: 'FixedPoint',\n        factor: number,\n        srcType: FloatDataType\n    }\n\n    // (Float32|Float64)[] -> Int32\n    export interface IntervalQuantization {\n        kind: 'IntervalQuantization',\n        min: number,\n        max: number,\n        numSteps: number,\n        srcType: FloatDataType\n    }\n\n    // (Uint8 | Int8 | Int16 | Int32)[] -> Int32[]\n    export interface RunLength {\n        kind: 'RunLength',\n        srcType: IntDataType,\n        srcSize: number\n    }\n\n    // T=(Int8Array | Int16Array | Int32Array)[] -> T[]\n    export interface Delta {\n        kind: 'Delta',\n        origin: number,\n        srcType: IntDataType\n    }\n\n    // Int32[] -> (Int8 | Int16 | Uint8 | Uint16)[]\n    export interface IntegerPacking {\n        kind: 'IntegerPacking',\n        byteCount: number,\n        isUnsigned: boolean,\n        srcSize: number\n    }\n\n    // string[] -> Uint8[]\n    // stores 0 and indices of ends of strings:\n    // stringData = '123456'\n    // offsets = [0,2,5,6]\n    // encodes ['12','345','6']\n    export interface StringArray {\n        kind: 'StringArray',\n        dataEncoding: Encoding[],\n        stringData: string,\n        offsetEncoding: Encoding[],\n        offsets: Uint8Array\n    }\n\n}", "import { ParserOptionsSpec } from './ParserOptionsSpec';\nimport { VASP } from \"./VASP\";\nimport { CUBE } from \"./CUBE\";\nimport { XYZ } from \"./XYZ\";\nimport { SDF } from \"./SDF\";\nimport { CDJSON } from \"./CDJSON\";\nimport { CIF } from \"./CIF\";\nimport { MOL2 } from \"./MOL2\";\nimport { PDB } from \"./PDB\";\nimport { PQR } from \"./PQR\";\nimport { MMTFparser } from \"./MMTF\";\nimport { PRMTOP } from \"./PRMTOP\";\nimport { GRO } from \"./GRO\";\nimport { LAMMPSTRJ } from \"./LAMMPSTRJ\";\nimport {BCIF} from \"./BCIF\";\n\nexport { bondLength, setBondLength } from './utils/bondLength';\n\n// @category Parsers\nexport const Parsers = {\n  vasp: VASP,\n  VASP,\n  cube: CUBE,\n  CUBE,\n  xyz: XYZ,\n  XYZ,\n  sdf: SDF,\n  SDF,\n  json: CDJSON,\n  cdjson: CDJSON,\n  CDJSON,\n  mcif: CIF,\n  cif: CIF,\n  CIF,\n  mol2: MOL2,\n  MOL2,\n  pdb: PDB,\n  PDB,\n  pdbqt: PDB,\n  PDBQT: PDB,\n  pqr: PQR,\n  PQR,\n  mmtf:MMTFparser, //need to avoid name collision\n  MMTF:MMTFparser,\n  prmtop: PRMTOP,\n  PRMTOP,\n  gro: GRO,\n  GRO,\n  lammpstrj: LAMMPSTRJ,\n  LAMMPSTRJ,\n  bcif: BCIF,\n  BCIF\n} as Record<string, (str: string, options: ParserOptionsSpec) => any>;\n", "export const anumToSymbol:Record<string, string> = {\n  1: 'H',                                                                                                                                2: 'He',\n  3:'Li',4:'Be',                                                                                  5: 'B', 6: 'C', 7:'N', 8:'O', 9:'F',  10: 'Ne',\n  11: 'Na',12:'Mg',                                                                               13: 'Al',14:'Si',15:'P',16:'S',17:'Cl',18:'Ar',\n  19: 'K',20:'Ca',21:'Sc',22:'Ti',23:'V',24:'Cr',25:'Mn',26:'Fe',27:'Co',28:'Ni',29:'Cu',30:'Zn',31:'Ga',32:'Ge',33:'As',34:'Se',35:'Br',36:'Kr',\n  37:'Rb',38:'Sr',39:'Y',40:'Zr',41:'Nb',42:'Mo',43:'Tc',44:'Ru',45:'Rh',46:'Pd',47:'Ag',48:'Cd',49:'In',50:'Sn',51:'Sb',52:'Te',53:'I', 54:'Xe',\n  55:'Cs',56:'Ba',71:'Lu',72:'Hf',73:'Ta',74:'W',75:'Re',76:'Os',77:'Ir',78:'Pt',79:'Au',80:'Hg',81:'Tl',82:'Pb',83:'Bi',84:'Po',85:'At',86:'Rn',\n  87:'Fr',88:'Ra',104:'Rf',105:'Db',106:'Sg',107:'Bh',108:'Hs',109:'Mt',110:'Ds',111:'Rg',112:'Cn',113:'Nh',114:'Fl',115:'Mc',116:'Lv',117:'Ts',118:'Og',\n  \n  57:'La',58:'Ce',59:'Pr',60:'Nd',61:'Pm',62:'Sm',63:'Eu',64:'Gd',65:'Tb',66:'Dy',67:'Ho',68:'Er',69:'Tm',70:'Yb',\n  89:'Ac',90:'Th',91:'Pa',92:'U',93:'Np',94:'Pu',95:'Am',96:'Cm',97:'Bk',98:'Cf',99:'Es',100:'Fm',101:'Md',102:'No',\n};", "import { AtomSpec } from \"specs\";\nimport { bondLength } from \"./bondLength\";\nimport { ParserOptionsSpec } from \"parsers/ParserOptionsSpec\";\n\nconst cations = new Set([\"Na\",\"K\",\"Ca\",\"Mg\",\"Mn\",\"Sr\"]);\n\n/*\n * Return true if atom1 and atom2 are probably bonded to each other based on distance alone\n */\nexport function areConnected(atom1: AtomSpec, atom2: AtomSpec, options: ParserOptionsSpec) {\n  if(options && options.unboundCations && (cations.has(atom1.elem) || cations.has(atom2.elem))) {\n    return false;\n  }\n  let maxsq = bondLength(atom1.elem) + bondLength(atom2.elem);\n  maxsq += 0.25; // fudge factor, especially important for md frames, also see 1i3d\n  maxsq *= maxsq;\n\n  let xdiff = atom1.x - atom2.x;\n  xdiff *= xdiff;\n  if (xdiff > maxsq) return false;\n  let ydiff = atom1.y - atom2.y;\n  ydiff *= ydiff;\n  if (ydiff > maxsq) return false;\n  let zdiff = atom1.z - atom2.z;\n  zdiff *= zdiff;\n  if (zdiff > maxsq) return false;\n\n  const distSquared = xdiff + ydiff + zdiff;\n\n  if (\n    isNaN(distSquared) ||\n    distSquared < 0.5 ||\n    distSquared > maxsq ||\n    (atom1.altLoc !== atom2.altLoc && atom1.altLoc.trim() !== \"\" && atom2.altLoc.trim() !== \"\")\n  )\n    return false;\n\n    \n  return true;\n}\n", "// This will identify all hydrogen bonds between backbone\n// atoms; assume atom names are correct, only identifies\n// single closest hbond\n\nimport { AtomSpec } from \"specs\";\n// interface Atoms {index: number; atom: string; hbondDistanceSq: number; hbondOther: any; hetflag:any}\nexport function assignBackboneHBonds(\n  atomsarray: Array<AtomSpec>,\n  hbondCutoff: number\n) {\n  const maxlength = hbondCutoff || 3.2;\n  const maxlengthSq = maxlength * maxlength;\n  const atoms = [];\n\n  for (let i = 0, n = atomsarray.length; i < n; i++) {\n    atomsarray[i].index = i;\n    // only consider 'N' and 'O'\n    const atom = atomsarray[i];\n    if (!atom.hetflag && (atom.atom === \"N\" || atom.atom === \"O\")) {\n      atoms.push(atom);\n      atom.hbondOther = null;\n      atom.hbondDistanceSq = Number.POSITIVE_INFINITY;\n    }\n  }\n\n  atoms.sort(function (a, b) {\n    return a.z - b.z;\n  });\n  for (let i = 0, n = atoms.length; i < n; i++) {\n    const ai = atoms[i];\n\n    for (let j = i + 1; j < n; j++) {\n      const aj = atoms[j];\n      const zdiff = aj.z - ai.z;\n      if (zdiff > maxlength)\n        // can't be connected\n        break;\n      if (aj.atom == ai.atom) continue; // can't be connected, but later might be\n      const ydiff = Math.abs(aj.y - ai.y);\n      if (ydiff > maxlength) continue;\n      const xdiff = Math.abs(aj.x - ai.x);\n      if (xdiff > maxlength) continue;\n      const dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;\n      if (dist > maxlengthSq) continue;\n\n      if (aj.chain == ai.chain && Math.abs(aj.resi - ai.resi) < 4) continue; // ignore bonds between too close residues\n      // select closest hbond\n      if (dist < ai.hbondDistanceSq) {\n        ai.hbondOther = aj;\n        ai.hbondDistanceSq = dist;\n      }\n      if (dist < aj.hbondDistanceSq) {\n        aj.hbondOther = ai;\n        aj.hbondDistanceSq = dist;\n      }\n    }\n  }\n}\n", "import { AtomSpec } from \"specs\";\nimport { areConnected } from \"./areConnected\";\nimport { ParserOptionsSpec } from \"parsers/ParserOptionsSpec\";\n\n/**\n * @param {AtomSpec[]} atoms\n */\nconst OFFSETS = [\n  { x: 0, y: 0, z: 1 },\n  { x: 0, y: 1, z: -1 },\n  { x: 0, y: 1, z: 0 },\n  { x: 0, y: 1, z: 1 },\n  { x: 1, y: -1, z: -1 },\n  { x: 1, y: -1, z: 0 },\n  { x: 1, y: -1, z: 1 },\n  { x: 1, y: 0, z: -1 },\n  { x: 1, y: 0, z: 0 },\n  { x: 1, y: 0, z: 1 },\n  { x: 1, y: 1, z: -1 },\n  { x: 1, y: 1, z: 0 },\n  { x: 1, y: 1, z: 1 },\n];\nconst MAX_BOND_LENGTH = 4.95; // (largest bond length, Cs) 2.25 * 2 * 1.1 (fudge factor)\n\nexport function assignBonds(atoms: AtomSpec[], options: ParserOptionsSpec) {\n  // Assign bonds - yuck, can't count on connect records\n\n  for (let i = 0, n = atoms.length; i < n; i++) {\n    // Don't reindex if atoms are already indexed\n    if (!atoms[i].index) atoms[i].index = i;\n  }\n\n  const grid: {\n    x: {\n      y: {\n        z: AtomSpec[];\n      };\n    };\n  } = {\n    x: {\n      y: {\n        z: [],\n      },\n    },\n  };\n\n  for (let index = 0; index < atoms.length; index++) {\n    const atom = atoms[index];\n    const x = Math.floor(atom.x / MAX_BOND_LENGTH);\n    const y = Math.floor(atom.y / MAX_BOND_LENGTH);\n    const z = Math.floor(atom.z / MAX_BOND_LENGTH);\n    if (!grid[x]) {\n      grid[x] = {};\n    }\n    if (!grid[x][y]) {\n      grid[x][y] = {};\n    }\n    if (!grid[x][y][z]) {\n      grid[x][y][z] = [];\n    }\n\n    grid[x][y][z].push(atom);\n  }\n\n  function findConnections(\n    points: Array<AtomSpec>,\n    otherPoints: Array<AtomSpec>\n  ) {\n    for (let i = 0; i < points.length; i++) {\n      const atom1 = points[i];\n      for (let j = 0; j < otherPoints.length; j++) {\n        const atom2 = otherPoints[j];\n\n        if (areConnected(atom1, atom2, options)) {\n          //gracefully handle one-sided bonds\n          const a2i = atom1.bonds.indexOf(atom2.index);\n          const a1i = atom2.bonds.indexOf(atom1.index);\n          if (a2i === -1 && a1i === -1) {\n            atom1.bonds.push(atom2.index);\n            atom1.bondOrder.push(1);\n            atom2.bonds.push(atom1.index);\n            atom2.bondOrder.push(1);\n          } else if (a2i === -1) {\n            atom1.bonds.push(atom2.index);\n            atom1.bondOrder.push(atom2.bondOrder[a1i]);\n          } else if (a1i === -1) {\n            atom2.bonds.push(atom1.index);\n            atom2.bondOrder.push(atom1.bondOrder[a2i]);\n          }\n        }\n      }\n    }\n  }\n\n  for (let xg in grid) {\n    const x = parseInt(xg);\n    for (let yg in grid[x]) {\n      const y = parseInt(yg);\n      for (let zg in grid[x][y]) {\n        const z = parseInt(zg);\n        const points = grid[x][y][z];\n\n        for (let i = 0; i < points.length; i++) {\n          const atom1 = points[i];\n          for (let j = i + 1; j < points.length; j++) {\n            const atom2 = points[j];\n            if (areConnected(atom1, atom2,options)) {\n              if (atom1.bonds.indexOf(atom2.index) == -1) {\n                atom1.bonds.push(atom2.index);\n                atom1.bondOrder.push(1);\n                atom2.bonds.push(atom1.index);\n                atom2.bondOrder.push(1);\n              }\n            }\n          }\n        }\n\n        for (let o = 0; o < OFFSETS.length; o++) {\n          const offset = OFFSETS[o];\n          if (\n            !grid[x + offset.x] ||\n            !grid[x + offset.x][y + offset.y] ||\n            !grid[x + offset.x][y + offset.y][z + offset.z]\n          )\n            continue;\n\n          const otherPoints = grid[x + offset.x][y + offset.y][z + offset.z];\n          findConnections(points, otherPoints);\n        }\n      }\n    }\n  }\n}\n", "// This is optimized for proteins where it is assumed connected atoms are on the same or next residue\n\nimport { AtomSpec } from \"specs\";\nimport { areConnected } from \"./areConnected\";\nimport { assignBonds } from \"./assignBonds\";\nimport { standardResidues } from \"./standardResidues\";\nimport { ParserOptionsSpec } from \"parsers/ParserOptionsSpec\";\n\n\n/**\n * @param {AtomSpec[]}\n *            atomsarray\n */\n\nexport function assignPDBBonds(atomsarray: AtomSpec[], options: ParserOptionsSpec) {\n  // assign bonds - yuck, can't count on connect records\n  const protatoms: Array<AtomSpec> = [];\n  const hetatoms: Array<AtomSpec> = [];\n  for (let i = 0, n = atomsarray.length; i < n; i++) {\n    const atom = atomsarray[i];\n    atom.index = i;\n    if (atom.hetflag || !standardResidues.has(atom.resn)) hetatoms.push(atom);\n    else protatoms.push(atom);\n  }\n\n  assignBonds(hetatoms, options);\n\n  // sort by resid\n  protatoms.sort(function (a, b) {\n    if (a.chain !== b.chain) return a.chain < b.chain ? -1 : 1;\n    return a.resi - b.resi;\n  });\n\n  // for identifying connected residues\n  let currentResi = -1;\n  let reschain = -1;\n  let lastResConnected: boolean;\n\n  for (let i = 0, n = protatoms.length; i < n; i++) {\n    const ai = protatoms[i];\n\n    if (ai.resi !== currentResi) {\n      currentResi = ai.resi;\n      if (!lastResConnected) reschain++;\n\n      lastResConnected = false;\n    }\n\n    ai.reschain = reschain;\n\n    for (let j = i + 1; j < protatoms.length; j++) {\n      const aj = protatoms[j];\n      if (aj.chain !== ai.chain || aj.resi - ai.resi > 1) break;\n\n      if (areConnected(ai, aj, options)) {\n        if (ai.bonds.indexOf(aj.index) === -1) {\n          // only add if not already there\n          ai.bonds.push(aj.index);\n          ai.bondOrder.push(1);\n          aj.bonds.push(ai.index);\n          aj.bondOrder.push(1);\n        }\n\n        if (ai.resi !== aj.resi) lastResConnected = true;\n      }\n    }\n  }\n}\n", "import { bondTable } from \"./bondLength\";\n\n// Attempts to infer atomic element from an atom name\nexport function atomNameToElem(name: string, nothetero: boolean) {\n  let elem = name.replace(/ /g, \"\");\n  if (\n    elem.length > 0 &&\n    elem[0] === \"H\" &&\n    elem !== \"Hg\" &&\n    elem !== \"He\" &&\n    elem !== \"Hf\" &&\n    elem !== \"Hs\" &&\n    elem !== \"Ho\"\n  ) {\n    elem = \"H\"; //workaround weird hydrogen names from MD, note mercury must use lowercase\n  }\n  if (elem.length > 1) {\n    elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n    if (bondTable[elem] === undefined) {\n      //not a known element, probably should just use first letter\n      elem = elem[0];\n    } else if (nothetero) {\n      if (elem === \"Ca\") {\n        //alpha carbon, not calcium\n        elem = \"C\";\n      } else if (elem === \"Cd\") {\n        elem = \"C\";\n      }\n    }\n  }\n  return elem;\n}\n", "// Covalent radii lookup table used to identify bonds in assignBonds\nexport let bondTable: Record<string, number> = {\n  H :0.37,                                                                                                                                He:0.32,\n  Li:1.34,Be:0.90,                                                                                B :0.82,C :0.77,N :0.75,O :0.73,F :0.71,Ne:0.69,\n  Na:1.54,Mg:1.30,                                                                                Al:1.18,Si:1.11,P :1.06,S :1.02,Cl:0.99,Ar:0.97,\n  K :1.96,Ca:1.74,Sc:1.44,Ti:1.56,V :1.25,/* Cr */Mn:1.39,Fe:1.25,Co:1.26,Ni:1.21,Cu:1.38,Zn:1.31,Ga:1.26,Ge:1.22,/* As */Se:1.16,Br:1.14,Kr:1.10,\n  Rb:2.11,Sr:1.92,Y :1.62,Zr:1.48,Nb:1.37,Mo:1.45,Tc:1.56,Ru:1.26,Rh:1.35,Pd:1.31,Ag:1.53,Cd:1.48,In:1.44,Sn:1.41,Sb:1.38,Te:1.35,I :1.33,Xe:1.30,\n  Cs:2.25,Ba:1.98,Lu:1.60,Hf:1.50,Ta:1.38,W :1.46,Re:1.59,Os:1.44,Ir:1.37,Pt:1.28,Au:1.44,Hg:1.49,Tl:1.48,Pb:1.47,Bi:1.46,/* Po *//* At */Rn:1.45,\n\n  // None of the bottom row or any of the Lanthanides have bond lengths\n};\n\n// Get the length used for bond identification for the specified element.\nexport function bondLength(elem: string | number) {\n  return bondTable[elem] || 1.6;\n}\n\n// Set the length used for bond identification for the specified element.\nexport function setBondLength(elem: string, radius: number) {\n  if (radius < 0) radius = 0;\n  bondTable[elem] = radius;\n}\n", "import { AtomSpec } from \"specs\";\nimport { assignBackboneHBonds } from \"./assignBackboneHBonds\";\n\nexport function computeSecondaryStructure(atomsarray: Array<AtomSpec>, hbondCutoff: number) {\n  assignBackboneHBonds(atomsarray, hbondCutoff);\n\n  // compute, per residue, what the secondary structure is\n  const chres = {}; // lookup by chain and resid\n  let i: number, il: number, c: string | number, r: number; // i: used in for loop, il: length of atomsarray\n  let atom: AtomSpec, val: string;\n\n  //identify helices first\n  for (i = 0, il = atomsarray.length; i < il; i++) {\n    atom = atomsarray[i];\n\n    if (chres[atom.chain] === undefined) chres[atom.chain] = [];\n\n    if (isFinite(atom.hbondDistanceSq)) {\n      const other = atom.hbondOther;\n      if (chres[other.chain] === undefined) chres[other.chain] = [];\n\n      if (Math.abs(other.resi - atom.resi) === 4) {\n        // helix\n        chres[atom.chain][atom.resi] = \"h\";\n      }\n    }\n  }\n\n  // plug gaps in helices\n  for (c in chres) {\n    for (r = 1; r < chres[c].length - 1; r++) {\n      const valbefore = chres[c][r - 1];\n      const valafter = chres[c][r + 1];\n      val = chres[c][r];\n      if (valbefore == \"h\" && valbefore == valafter && val != valbefore) {\n        chres[c][r] = valbefore;\n      }\n    }\n  }\n\n  //now potential sheets - but only if mate not part of helix\n  for (i = 0, il = atomsarray.length; i < il; i++) {\n    atom = atomsarray[i];\n\n    if (\n      isFinite(atom.hbondDistanceSq) &&\n      chres[atom.chain][atom.resi] != \"h\" &&\n      atom.ss !== \"h\"\n    ) {\n      chres[atom.chain][atom.resi] = \"maybesheet\";\n    }\n  }\n\n  //sheets must bond to other sheets\n  for (let i = 0, il = atomsarray.length; i < il; i++) {\n    atom = atomsarray[i];\n\n    if (\n      isFinite(atom.hbondDistanceSq) &&\n      chres[atom.chain][atom.resi] == \"maybesheet\"\n    ) {\n      let other = atom.hbondOther;\n      let otherval = chres[other.chain][other.resi];\n      if (otherval == \"maybesheet\" || otherval == \"s\") {\n        // true sheet\n        chres[atom.chain][atom.resi] = \"s\";\n        chres[other.chain][other.resi] = \"s\";\n      }\n    }\n  }\n\n  // plug gaps in sheets and remove singletons\n  for (let c in chres) {\n    for (let r = 1; r < chres[c].length - 1; r++) {\n      const valbefore = chres[c][r - 1];\n      const valafter = chres[c][r + 1];\n      val = chres[c][r];\n      if (valbefore == \"s\" && valbefore == valafter && val != valbefore) {\n        chres[c][r] = valbefore;\n      }\n    }\n    for (let r = 0; r < chres[c].length; r++) {\n      const val = chres[c][r];\n      if (val == \"h\" || val == \"s\") {\n        if (chres[c][r - 1] != val && chres[c][r + 1] != val)\n          delete chres[c][r];\n      }\n    }\n  }\n\n  // assign to all atoms in residue, keep track of start\n  for (i = 0, il = atomsarray.length; i < il; i++) {\n    atom = atomsarray[i];\n    val = chres[atom.chain][atom.resi];\n\n    //clear hbondOther to eliminate circular references that prohibit serialization\n    delete atom.hbondOther;\n    delete atom.hbondDistanceSq;\n    if (val === undefined || val === \"maybesheet\") continue;\n    atom.ss = val;\n    if (chres[atom.chain][atom.resi - 1] != val) atom.ssbegin = true;\n    if (chres[atom.chain][atom.resi + 1] != val) atom.ssend = true;\n  }\n}\n", "import { Matrix4 } from \"../../WebGL\";\nimport { atomNameToElem } from \"./atomNameToElem\";\nimport { bondTable } from \"./bondLength\";\nimport { computeSecondaryStructure } from \"./computeSecondaryStructure\";\nimport { isEmpty } from \"./isEmpty\";\nimport { processSymmetries } from \"./processSymmetries\";\nimport { assignPDBBonds } from \"./assignPDBBonds\";\nimport { validateBonds } from \"./validateBonds\";\nimport { ParserOptionsSpec } from \"../ParserOptionsSpec\";\nimport { AtomSpec, Cryst } from \"specs\";\n// Return one model worth of pdb, returns atoms, modelData, and remaining lines\nexport function getSinglePDB(\n  lines: string[],\n  options: ParserOptionsSpec,\n  sslookup: { [x: string]: { [x: string]: string }; hasOwnProperty?: any }\n): [\n    AtomSpec[],\n    {\n      symmetries: Matrix4[];\n      cryst: Omit<Cryst, \"origin\" | \"size\" | \"unit\" | \"matrix4\" | \"matrix\">;\n    },\n    string[]\n  ] {\n  const atoms: AtomSpec[] = [];\n  const assignbonds =\n    options.assignBonds === undefined ? true : options.assignBonds;\n  const noH = !options.keepH; // suppress hydrogens by default\n  const ignoreStruct = !!options.noSecondaryStructure;\n  const computeStruct = !options.noComputeSecondaryStructure;\n  const noAssembly = !options.doAssembly; // don't assemble by default\n  const selAltLoc = options.altLoc ? options.altLoc : \"A\"; //default alternate location to select if present\n  const modelData: {\n    symmetries: Matrix4[];\n    cryst: Omit<Cryst, \"origin\" | \"size\" | \"unit\" | \"matrix4\" | \"matrix\">;\n  } = { symmetries: [], cryst: undefined };\n  //atom name\n  let atom: string;\n  let remainingLines = [];\n\n  const serialToIndex: number[] = []; // map from pdb serial to index in atoms\n  let line: string | string[];\n  const seenbonds: Record<string, number> = {}; //sometimes connect records are duplicated as an unofficial means of relaying bond orders\n\n  for (let i = 0; i < lines.length; i++) {\n    line = lines[i].replace(/^\\s*/, \"\"); // remove indent\n    const recordName = line.substring(0, 6);\n\n    let startChain: string, startResi: number, endResi: number;\n\n    if (recordName.indexOf(\"END\") === 0) {\n      remainingLines = lines.slice(i + 1);\n      if (recordName === \"END\") {\n        //as opposed to ENDMDL\n        //reset secondary structure\n        for (const prop in sslookup) {\n          if (sslookup.hasOwnProperty(prop)) {\n            delete sslookup[prop];\n          }\n        }\n      }\n      break;\n    } else if (recordName === \"ATOM  \" || recordName === \"HETATM\") {\n      let resn: string,\n        chain: any,\n        resi: string | number,\n        icode: string,\n        x: number,\n        y: number,\n        z: number,\n        hetflag: boolean,\n        elem: string | string[],\n        serial: number,\n        altLoc: string,\n        b: number;\n      altLoc = line.substring(16, 17);\n      if (altLoc !== \" \" && altLoc !== selAltLoc && selAltLoc !== \"*\") continue;\n      serial = parseInt(line.substring(6, 11));\n      atom = line.substring(12, 16).replace(/ /g, \"\");\n      resn = line.substring(17, 20).replace(/ /g, \"\");\n      chain = line.substring(21, 22);\n      resi = parseInt(line.substring(22, 26));\n      icode = line.substring(26, 27);\n      x = parseFloat(line.substring(30, 38));\n      y = parseFloat(line.substring(38, 46));\n      z = parseFloat(line.substring(46, 54));\n      b = parseFloat(line.substring(60, 68));\n      elem = line.substring(76, 78).replace(/ /g, \"\");\n      if (elem === \"\" || bondTable[elem] === undefined) {\n        // for some incorrect PDB files\n        elem = atomNameToElem(line.substring(12, 14), line[0] == \"A\");\n      } else {\n        elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n      }\n\n      if (elem === \"H\" && noH) continue;\n      if (recordName[0] == \"H\") hetflag = true;\n      else hetflag = false;\n      serialToIndex[serial] = atoms.length;\n      atoms.push({\n        resn,\n        x,\n        y,\n        z,\n        elem,\n        hetflag,\n        altLoc,\n        chain,\n        resi,\n        icode: icode,\n        rescode: resi + (icode !== \" \" ? \"^\" + icode : \"\"), // combo\n        // resi\n        // and\n        // icode\n        serial,\n        atom,\n        bonds: [],\n        ss: \"c\",\n        bondOrder: [],\n        properties: {},\n        b,\n        pdbline: line,\n      });\n    } else if (recordName === \"SHEET \") {\n      startChain = line.substring(21, 22);\n      startResi = parseInt(line.substring(22, 26));\n      endResi = parseInt(line.substring(33, 37));\n      if (!(startChain in sslookup)) {\n        sslookup[startChain] = {};\n      }\n      //mark start and end with additional character\n      sslookup[startChain][startResi] = \"s1\";\n      for (let res = startResi + 1; res < endResi; res++) {\n        sslookup[startChain][res] = \"s\";\n      }\n      sslookup[startChain][endResi] = \"s2\";\n    } else if (recordName === \"CONECT\") {\n      // MEMO: We don't have to parse SSBOND, LINK because both are\n      // also\n      // described in CONECT. But what about 2JYT???\n      const from = parseInt(line.substring(6, 11));\n      const fromindex = serialToIndex[from];\n      const fromAtom = atoms[fromindex];\n      const coffsets = [11, 16, 21, 26];\n      for (let j = 0; j < 4; j++) {\n        const to = parseInt(line.substring(coffsets[j], coffsets[j] + 5));\n        const toindex = serialToIndex[to];\n        let from_to = fromindex + \":\" + toindex;\n        const toAtom = atoms[toindex];\n        if (fromAtom !== undefined && toAtom !== undefined) {\n          // duplicated conect records indicate bond order\n          if (!seenbonds[from_to]) {\n            seenbonds[from_to] = 1;\n            if (\n              fromAtom.bonds.length == 0 ||\n              fromAtom.bonds[fromAtom.bonds.length - 1] !== toindex\n            ) {\n              fromAtom.bonds.push(toindex);\n              fromAtom.bondOrder.push(1);\n            }\n          } else {\n            //update bond order\n            seenbonds[from_to] += 1;\n\n            for (let bi = 0; bi < fromAtom.bonds.length; bi++) {\n              if (fromAtom.bonds[bi] == toindex) {\n                const newbo = seenbonds[from_to];\n                if (newbo >= 4) {\n                  //aromatic\n                  fromAtom.bondOrder[bi] = 1;\n                } else {\n                  fromAtom.bondOrder[bi] = newbo;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else if (recordName === \"HELIX \") {\n      startChain = line.substring(19, 20);\n      startResi = parseInt(line.substring(21, 25));\n      endResi = parseInt(line.substring(33, 37));\n      if (!(startChain in sslookup)) {\n        sslookup[startChain] = {};\n      }\n      sslookup[startChain][startResi] = \"h1\";\n      for (let res = startResi + 1; res < endResi; res++) {\n        sslookup[startChain][res] = \"h\";\n      }\n      sslookup[startChain][endResi] = \"h2\";\n    } else if (\n      !noAssembly &&\n      recordName === \"REMARK\" &&\n      line.substring(13, 18) === \"BIOMT\"\n    ) {\n      let n: number;\n      let matrix = new Matrix4();\n      for (n = 1; n <= 3; n++) {\n        line = lines[i].replace(/^\\s*/, \"\");\n        if (parseInt(line.substring(18, 19)) == n) {\n          // check for all\n          // three lines\n          // by matching #\n          // @ end of\n          // \"BIOMT\" to n\n          matrix.elements[n - 1] = parseFloat(line.substring(23, 33));\n          matrix.elements[n - 1 + 4] = parseFloat(line.substring(33, 43));\n          matrix.elements[n - 1 + 8] = parseFloat(line.substring(43, 53));\n          matrix.elements[n - 1 + 12] = parseFloat(line.substring(53));\n          i++;\n        } else {\n          while (line.substring(13, 18) === \"BIOMT\") {\n            i++;\n            line = lines[i].replace(/^\\s*/, \"\");\n          }\n        }\n      }\n      matrix.elements[3] = 0;\n      matrix.elements[7] = 0;\n      matrix.elements[11] = 0;\n      matrix.elements[15] = 1;\n      modelData.symmetries.push(matrix);\n      i--; // set i back\n    } else if (recordName === \"CRYST1\") {\n      let a: number,\n        b: number,\n        c: number,\n        alpha: number,\n        beta: number,\n        gamma: number;\n      a = parseFloat(line.substring(7, 15));\n      b = parseFloat(line.substring(16, 24));\n      c = parseFloat(line.substring(25, 33));\n      alpha = parseFloat(line.substring(34, 40));\n      beta = parseFloat(line.substring(41, 47));\n      gamma = parseFloat(line.substring(48, 54));\n      modelData.cryst = {\n        a,\n        b,\n        c,\n        alpha,\n        beta,\n        gamma,\n      };\n    } else if (recordName === \"ANISOU\") {\n      const serial = parseInt(line.substring(6, 11));\n      const anisouAtomIndex = serialToIndex[serial];\n      const anisouAtom = atoms[anisouAtomIndex];\n      if (anisouAtom) {\n        const vals = line.substring(30).trim().split(/\\s+/);\n        const uMat = {\n          u11: parseInt(vals[0]),\n          u22: parseInt(vals[1]),\n          u33: parseInt(vals[2]),\n          u12: parseInt(vals[3]),\n          u13: parseInt(vals[4]),\n          u23: parseInt(vals[5]),\n        };\n\n        anisouAtom.uMat = uMat;\n      }\n    }\n  }\n\n  //fix any \"one-way\" bonds in CONECT records\n  validateBonds(atoms, serialToIndex);\n  // assign bonds - yuck, can't count on connect records\n  if (assignbonds) assignPDBBonds(atoms, options);\n\n  if (!noAssembly)\n    processSymmetries(modelData.symmetries, atoms, options, modelData.cryst);\n\n  if (computeStruct && !ignoreStruct) {\n    computeSecondaryStructure(atoms, options.hbondCutoff);\n  }\n\n  // Assign secondary structures from pdb file\n  if (!isEmpty(sslookup)) {\n    for (let i = 0; i < atoms.length; i++) {\n      const atom = atoms[i];\n      if (atom === undefined) continue;\n      if (atom.chain in sslookup && atom.resi in sslookup[atom.chain]) {\n        const code = sslookup[atom.chain][atom.resi];\n        atom.ss = code[0];\n        if (code.length > 1) {\n          if (code[1] == \"1\") atom.ssbegin = true;\n          else if (code[1] == \"2\") atom.ssend = true;\n        }\n      }\n    }\n  }\n  //console.log(\"assign structure \" + ((new Date()).getTime() - starttime));\n\n  return [atoms, modelData, remainingLines];\n}\n", "export function isEmpty(obj: {\n  [x: string]: { [x: string]: unknown };\n  hasOwnProperty?: any;\n}) {\n  for (const _ in obj) {\n    return false;\n  }\n  return true;\n}\n", "import { ParserOptionsSpec } from \"parsers/ParserOptionsSpec\";\nimport { Matrix3, conversionMatrix3, Vector3 } from \"../../WebGL\";\nimport { AtomSpec, Cryst } from \"specs\";\n// Adds symmetry info to either duplicate and rotate/translate biological unit later or add extra atoms now\n// matrices may be modified if normalization is requested\n\nexport function processSymmetries(\n  copyMatrices: string[] | any[],\n  atoms: AtomSpec[],\n  options: ParserOptionsSpec,\n  cryst: Omit<Cryst, \"origin\" | \"size\" | \"unit\" | \"matrix4\" | \"matrix\">\n) {\n  const dontDuplicate = !options.duplicateAssemblyAtoms;\n  const end = atoms.length;\n  let offset = end;\n\n  let modifiedIdentity = -1;\n  let conversionMatrix = null;\n  let toFrac = null;\n\n  if ((options.normalizeAssembly || options.wrapAtoms) && cryst) {\n    conversionMatrix = conversionMatrix3(\n      cryst.a,\n      cryst.b,\n      cryst.c,\n      cryst.alpha,\n      cryst.beta,\n      cryst.gamma\n    );\n    toFrac = new Matrix3();\n    toFrac.getInverse3(conversionMatrix);\n  }\n\n  let getAdjustment = function (v: Vector3) {\n    let c = v.clone().applyMatrix3(toFrac);\n    const coord = [c.x, c.y, c.z];\n    const adjustment = [0.0, 0.0, 0.0];\n    for (let i = 0; i < 3; i++) {\n      while (coord[i] < -0.001) {\n        coord[i] += 1.0;\n        adjustment[i] += 1.0;\n      }\n      while (coord[i] > 1.001) {\n        coord[i] -= 1.0;\n        adjustment[i] -= 1.0;\n      }\n    }\n    //convert adjustment to non-fractional\n    const adjustmentVec = new Vector3(\n      adjustment[0],\n      adjustment[1],\n      adjustment[2]\n    );\n    adjustmentVec.applyMatrix3(conversionMatrix);\n    return adjustmentVec;\n  };\n\n  if (options.normalizeAssembly && cryst) {\n    //to normalize, translate every symmetry so that the centroid is\n    //in the unit cell.  To do this, convert back to fractional coordinates,\n    //compute the centroid, calculate any adjustment needed to get it in [0,1],\n    //convert the adjustment to a cartesian translation, and then add it to\n    //the symmetry matrix\n\n    for (let t = 0; t < copyMatrices.length; t++) {\n      //transform with the symmetry, and then back to fractional coordinates\n      const center = new Vector3(0, 0, 0);\n      for (let n = 0; n < end; n++) {\n        const xyz = new Vector3(atoms[n].x, atoms[n].y, atoms[n].z);\n        xyz.applyMatrix4(copyMatrices[t]);\n        //figure out\n        center.add(xyz);\n      }\n      center.divideScalar(end);\n\n      const adjustmentVec = getAdjustment(center);\n      //modify symmetry matrix to include translation\n      if (\n        copyMatrices[t].isNearlyIdentity() &&\n        adjustmentVec.lengthSq() > 0.001\n      ) {\n        modifiedIdentity = t; //keep track of which matrix was identity\n      }\n      copyMatrices[t].translate(adjustmentVec);\n    }\n  }\n  if (!dontDuplicate) {\n    // do full assembly\n    for (let n = 0; n < end; n++) {\n      atoms[n].sym = -1; //if identity matrix is present, original labeled -1\n    }\n    for (let t = 0; t < copyMatrices.length; t++) {\n      if (!copyMatrices[t].isNearlyIdentity() && modifiedIdentity != t) {\n        let xyz = new Vector3();\n        for (let n = 0; n < end; n++) {\n          const bondsArr: number[] = [];\n          for (let l = 0; l < atoms[n].bonds.length; l++) {\n            bondsArr.push(atoms[n].bonds[l] + offset);\n          }\n          xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n          xyz.applyMatrix4(copyMatrices[t]);\n\n          if (options.wrapAtoms && cryst) {\n            //wrap per-atom instead of per matrix using the centroid\n            let adjustment = getAdjustment(xyz);\n            xyz.add(adjustment);\n          }\n\n          const newAtom: Record<string, unknown> = {};\n          for (const i in atoms[n]) {\n            newAtom[i] = atoms[n][i];\n          }\n          newAtom.x = xyz.x;\n          newAtom.y = xyz.y;\n          newAtom.z = xyz.z;\n          newAtom.bonds = bondsArr;\n          newAtom.sym = t; //so symmetries can be selected\n          newAtom.index = atoms.length;\n          atoms.push(newAtom);\n        }\n        offset = atoms.length;\n      } else {\n        for (let n = 0; n < end; n++) {\n          atoms[n].sym = t;\n        }\n      }\n    }\n    if (options.wrapAtoms && cryst) {\n      //wrap reference coordinates, because the world isn't kind enough\n      //to ensure these are in the box\n      let xyz = new Vector3();\n      for (let n = 0; n < end; n++) {\n        xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n        //wrap per-atom instead of per matrix using the centroid\n        let adjustment = getAdjustment(xyz);\n        xyz.add(adjustment);\n        atoms[n].x = xyz.x;\n        atoms[n].y = xyz.y;\n        atoms[n].z = xyz.z;\n      }\n    }\n    if (modifiedIdentity >= 0) {\n      //after applying the other transformations, apply this one in place\n      const xyz = new Vector3();\n      for (let n = 0; n < end; n++) {\n        xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n        xyz.applyMatrix4(copyMatrices[modifiedIdentity]);\n        atoms[n].x = xyz.x;\n        atoms[n].y = xyz.y;\n        atoms[n].z = xyz.z;\n      }\n    }\n    //we have explicitly duplicated the atoms, remove model symmetry information\n    (copyMatrices as any).length = 0;\n  } else if (copyMatrices.length > 1) {\n    for (let t = 0; t < atoms.length; t++) {\n      var symmetries: Vector3[] = [];\n      for (let l = 0; l < copyMatrices.length; l++) {\n        if (!copyMatrices[l].isNearlyIdentity()) {\n          var newXYZ = new Vector3();\n          newXYZ.set(atoms[t].x, atoms[t].y, atoms[t].z);\n          newXYZ.applyMatrix4(copyMatrices[l]);\n          symmetries.push(newXYZ);\n        }\n      }\n      atoms[t].symmetries = symmetries;\n    }\n  }\n}\n", "export const standardResidues: Set<string> = new Set([\n  \"ABU\",\n  \"ACD\",\n  \"ALA\",\n  \"ALB\",\n  \"ALI\",\n  \"ARG\",\n  \"AR0\",\n  \"ASN\",\n  \"ASP\",\n  \"ASX\",\n  \"BAS\",\n  \"CYS\",\n  \"CYH\",\n  \"CYX\",\n  \"CSS\",\n  \"CSH\",\n  \"GLN\",\n  \"GLU\",\n  \"GLX\",\n  \"GLY\",\n  \"HIS\",\n  \"HIE\",\n  \"HID\",\n  \"HIP\",\n  \"HYP\",\n  \"ILE\",\n  \"ILU\",\n  \"LEU\",\n  \"LYS\",\n  \"MET\",\n  \"PCA\",\n  \"PGA\",\n  \"PHE\",\n  \"PR0\",\n  \"PRO\",\n  \"PRZ\",\n  \"SER\",\n  \"THR\",\n  \"TRP\",\n  \"TYR\",\n  \"VAL\",\n  \"A\",\n  \"1MA\",\n  \"C\",\n  \"5MC\",\n  \"OMC\",\n  \"G\",\n  \"1MG\",\n  \"2MG\",\n  \"M2G\",\n  \"7MG\",\n  \"OMG\",\n  \"YG\",\n  \"I\",\n  \"T\",\n  \"U\",\n  \"+U\",\n  \"H2U\",\n  \"5MU\",\n  \"PSU\",\n  \"ACE\",\n  \"F0R\",\n  \"H2O\",\n  \"HOH\",\n  \"WAT\",\n]);\n", "import { AtomSpec } from \"specs\";\n\n// Make sure bonds are actually two way\nexport function validateBonds(atomsarray: AtomSpec[], serialToIndex: number[]) {\n  for (let i = 0, n = atomsarray.length; i < n; i++) {\n    const atom = atomsarray[i];\n    for (let b = 0; b < atom.bonds.length; b++) {\n      const a2i = atom.bonds[b];\n      const atom2 = atomsarray[a2i];\n      const atomi = serialToIndex[atom.serial];\n      if (atom2 && atomi) {\n        const a1i = atom2.bonds.indexOf(atomi);\n        if (a1i < 0) {\n          atom2.bonds.push(atomi);\n          atom2.bondOrder.push(atom.bondOrder[b]);\n        }\n      }\n    }\n  }\n}\n", "//properties for mapping\n/* partial charges for proteins */\nexport const partialCharges = {\n\"ALA:N\": -0.15,\n\"ALA:CA\": 0.10,\n\"ALA:CB\": 0.00,\n\"ALA:C\": 0.60,\n\"ALA:O\": -0.55,\n\"ARG:N\": -0.15,\n\"ARG:CA\": 0.10,\n\"ARG:CB\": 0.00,\n\"ARG:CG\": 0.00,\n\"ARG:CD\": 0.10,\n\"ARG:NE\": -0.10,\n\"ARG:CZ\": 0.50,\n\"ARG:NH1\": 0.25,\n\"ARG:NH2\": 0.25,\n\"ARG:C\": 0.60,\n\"ARG:O\": -0.55,\n\"ASN:N\": -0.15,\n\"ASN:CA\": 0.10,\n\"ASN:CB\": 0.00,\n\"ASN:CG\": 0.55,\n\"ASN:OD1\": -0.55,\n\"ASN:ND2\": 0.00,\n\"ASN:C\": 0.60,\n\"ASN:O\": -0.55,\n\"ASP:N\": -0.15,\n\"ASP:CA\": 0.10,\n\"ASP:CB\": 0.00,\n\"ASP:CG\": 0.14,\n\"ASP:OD1\": -0.57,\n\"ASP:OD2\": -0.57,\n\"ASP:C\": 0.60,\n\"ASP:O\": -0.55,\n\"CYS:N\": -0.15,\n\"CYS:CA\": 0.10,\n\"CYS:CB\": 0.19,\n\"CYS:SG\": -0.19,\n\"CYS:C\": 0.60,\n\"CYS:O\": -0.55,\n\"GLN:N\": -0.15,\n\"GLN:CA\": 0.10,\n\"GLN:CB\": 0.00,\n\"GLN:CG\": 0.00,\n\"GLN:CD\": 0.55,\n\"GLN:OE1\": -0.55,\n\"GLN:NE2\": 0.00,\n\"GLN:C\": 0.60,\n\"GLN:O\": -0.55,\n\"GLU:N\": -0.15,\n\"GLU:CA\": 0.10,\n\"GLU:CB\": 0.00,\n\"GLU:CG\": 0.00,\n\"GLU:CD\": 0.14,\n\"GLU:OE1\": -0.57,\n\"GLU:OE2\": -0.57,\n\"GLU:C\": 0.60,\n\"GLU:O\": -0.55,\n\"GLY:N\": -0.15,\n\"GLY:CA\": 0.10,\n\"GLY:C\": 0.60,\n\"GLY:O\": -0.55,\n\"HIS:N\": -0.15,\n\"HIS:CA\": 0.10,\n\"HIS:CB\": 0.00,\n\"HIS:CG\": 0.10,\n\"HIS:ND1\": -0.10,\n\"HIS:CD2\": 0.10,\n\"HIS:NE2\": -0.40,\n\"HIS:CE1\": 0.30,\n\"HIS:C\": 0.60,\n\"HIS:O\": -0.55,\n\"ILE:N\": -0.15,\n\"ILE:CA\": 0.10,\n\"ILE:CB\": 0.00,\n\"ILE:CG2\": 0.00,\n\"ILE:CG1\": 0.00,\n\"ILE:CD\": 0.00,\n\"ILE:C\": 0.60,\n\"ILE:O\": -0.55,\n\"LEU:N\": -0.15,\n\"LEU:CA\": 0.10,\n\"LEU:CB\": 0.00,\n\"LEU:CG\": 0.00,\n\"LEU:CD1\": 0.00,\n\"LEU:CD2\": 0.00,\n\"LEU:C\": 0.60,\n\"LEU:O\": -0.55,\n\"LYS:N\": -0.15,\n\"LYS:CA\": 0.10,\n\"LYS:CB\": 0.00,\n\"LYS:CG\": 0.00,\n\"LYS:CD\": 0.00,\n\"LYS:CE\": 0.25,\n\"LYS:NZ\": 0.75,\n\"LYS:C\": 0.60,\n\"LYS:O\": -0.55,\n\"MET:N\": -0.15,\n\"MET:CA\": 0.10,\n\"MET:CB\": 0.00,\n\"MET:CG\": 0.06,\n\"MET:SD\": -0.12,\n\"MET:CE\": 0.06,\n\"MET:C\": 0.60,\n\"MET:O\": -0.55,\n\"PHE:N\": -0.15,\n\"PHE:CA\": 0.10,\n\"PHE:CB\": 0.00,\n\"PHE:CG\": 0.00,\n\"PHE:CD1\": 0.00,\n\"PHE:CD2\": 0.00,\n\"PHE:CE1\": 0.00,\n\"PHE:CE2\": 0.00,\n\"PHE:CZ\": 0.00,\n\"PHE:C\": 0.60,\n\"PHE:O\": -0.55,\n\"PRO:N\": -0.25,\n\"PRO:CD\": 0.10,\n\"PRO:CA\": 0.10,\n\"PRO:CB\": 0.00,\n\"PRO:CG\": 0.00,\n\"PRO:C\": 0.60,\n\"PRO:O\": -0.55,\n\"SER:N\": -0.15,\n\"SER:CA\": 0.10,\n\"SER:CB\": 0.25,\n\"SER:OG\": -0.25,\n\"SER:C\": 0.60,\n\"SER:O\": -0.55,\n\"THR:N\": -0.15,\n\"THR:CA\": 0.10,\n\"THR:CB\": 0.25,\n\"THR:OG1\": -0.25,\n\"THR:CG2\": 0.00,\n\"THR:C\": 0.60,\n\"THR:O\": -0.55,\n\"TRP:N\": -0.15,\n\"TRP:CA\": 0.10,\n\"TRP:CB\": 0.00,\n\"TRP:CG\": -0.03,\n\"TRP:CD2\": 0.10,\n\"TRP:CE2\": -0.04,\n\"TRP:CE3\": -0.03,\n\"TRP:CD1\": 0.06,\n\"TRP:NE1\": -0.06,\n\"TRP:CZ2\": 0.00,\n\"TRP:CZ3\": 0.00,\n\"TRP:CH2\": 0.00,\n\"TRP:C\": 0.60,\n\"TRP:O\": -0.55,\n\"TYR:N\": -0.15,\n\"TYR:CA\": 0.10,\n\"TYR:CB\": 0.00,\n\"TYR:CG\": 0.00,\n\"TYR:CD1\": 0.00,\n\"TYR:CE1\": 0.00,\n\"TYR:CD2\": 0.00,\n\"TYR:CE2\": 0.00,\n\"TYR:CZ\": 0.25,\n\"TYR:OH\": -0.25,\n\"TYR:C\": 0.60,\n\"TYR:O\": -0.55,\n\"VAL:N\": -0.15,\n\"VAL:CA\": 0.10,\n\"VAL:CB\": 0.00,\n\"VAL:CG1\": 0.00,\n\"VAL:CG2\": 0.00,\n\"VAL:C\": 0.60,\n\"VAL:O\": -0.55\n};\n    \n//this can be supplied to mapAtomProperties\nexport function applyPartialCharges(atom: Record<string, any>, keepexisting: boolean) {\n    if(!keepexisting || typeof(atom.partialCharge) === \"undefined\") {\n        if(atom.resn && atom.atom) {\n            var key = atom.resn+\":\"+atom.atom;\n            atom.properties.partialCharge = (partialCharges as any)[key];\n        }\n    }\n};\n", "// Specifications for various object types used in 3Dmol.js\n// This is primarily for documentation\n\nimport { Matrix4, Vector3 } from \"WebGL\";\nimport { AtomStyleSpec, BondStyle, GLModel } from \"./GLModel\";\nimport { GLViewer } from \"./GLViewer\";\nimport { ColorSpec } from \"./colors\";\n\n/**\n * Atom representation. Depending on the input file format, not all fields may be defined.\n */\nexport interface AtomSpec {\n  /** Parent residue name */\n  resn?: string;\n  /** Residue label name */\n  lresn?: string;\n  /**  Atom's x coordinate  */\n  x?: number;\n  /**  Atom's y coordinate  */\n  y?: number;\n  /**  Atom's z coordinate  */\n  z?: number;\n  /**  Atom's color, as hex code or built-in color string */\n  color?: ColorSpec;\n  /**  Hex code for color to be used for surface patch over this atom */\n  surfaceColor?: ColorSpec;\n  /**  Element abbreviation (e.g. 'H', 'Ca', etc) */\n  elem?: string;\n  /**  Set to true if atom is a heteroatom */\n  hetflag?: boolean;\n  /**  Chain this atom belongs to, if specified in input file (e.g 'A' for chain A) */\n  chain?: string;\n  /** Label chain (not author) */\n  lchain?: string;\n  /**  Residue number */\n  resi?: number;\n  /** Label residues number (not author) */\n  lresi?: number; \n  icode?: string;\n  rescode?: string;\n  /** Atom's serial id number */\n  serial?: number;\n  /** Index of atom in molecule */\n  index?: number;\n  /** Atom name; may be more specific than 'elem' (e.g 'CA' for alpha carbon) */\n  atom?: string;\n  /** Array of atom ids this atom is bonded to */\n  bonds?: number[];\n  /** Secondary structure identifier (for cartoon render; e.g. 'h' for helix) */\n  ss?: string;\n  ssbegin?: boolean;\n  ssend?: boolean;\n  /** true if this atom forms only single bonds or no bonds at all */\n  singleBonds?: boolean;\n  /** Array of this atom's bond orders, corresponding to bonds identfied by 'bonds' */\n  bondOrder?: number[];\n  /** Optional mapping of additional properties */\n  properties?: Record<string, any>;\n  /** Atom b factor data */\n  b?: number;\n  /** If applicable, this atom's record entry from the input PDB file (used to output new PDB from models) */\n  pdbline?: string;\n  /** Set this flag to true to enable click selection handling for this atom */\n  clickable?: boolean;\n  /** Callback click handler function to be executed on this atom and its parent viewer */\n  callback?: (atom: AtomSpec, viewer: GLViewer) => void;\n  /** Set this flag to true to enable hover selection handling for this atom */\n  hoverable?: boolean;\n  /** Callback hover handler function to be executed on this atom and its parent viewer */\n  hover_callback?: (atom: AtomSpec, viewer: GLViewer) => void;\n  /** Callback handling \"unhover\" to be executed on this atom and its parent viewer */\n  unhover_callback?: (atom: AtomSpec, viewer: GLViewer) => void;\n  /** for selection, inverts the meaning of the selection */\n  invert?: boolean;\n  /** style of atom */\n  style?: AtomStyleSpec;\n  /** custom bond styling by position in bonds */\n  bondStyles?: BondStyle[];\n  intersectionShape?: any;\n  capDrawn?: boolean;\n  model?: number;\n  contextMenuEnabled?: boolean;\n  hbondDistanceSq?: number;\n  hbondOther?: any;\n  altLoc?: string;\n  reschain?: number;\n  uMat?: Record<string, number>;\n  symmetries?: Vector3[];\n  sym?: any;\n  dx?: number;\n  dy?: number;\n  dz?: number;\n}\n\n/**\n * Atom selection object. Used to specify what atoms should be selected.  Can include\n * any field from {@link AtomSpec} in which case atoms must equal the specified value.\n * All fields must match for the selection to hold. If values\n * are provided as a list, then only one value of the list must match.\n * @extends AtomSpec\n * @example\n * $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n *  viewer.setStyle({chain:'B'},{cartoon:{color:'spectrum'}});\n *  viewer.setStyle({chain:'B',invert:true},{cartoon:{}});\n *  viewer.setStyle({bonds: 0},{sphere:{radius:0.5}}); //water molecules\n *  viewer.setStyle({resn:'PMP',byres:true,expand:5},{stick:{colorscheme:\"greenCarbon\"}});\n *  viewer.setStyle({resi:[\"91-95\",\"42-50\"]},{cartoon:{color:\"green\",thickness:1.0}});\n *  viewer.render();\n * });\n */\nexport interface AtomSelectionSpec\n  extends Omit<AtomSpec, \"bonds\" | \"model\" | \"index\" | \"resi\"> {\n  /** a single model or list of models from which atoms should be selected.  Can also specify by numerical creation order.  Reverse indexing is allowed (-1 specifies last added model). */\n  model?: GLModel | number | GLModel[] | number[];\n  /** frame index of individual frame to style; will apply to all frames if not set */\n  frame?: number;\n  /** index of the atom or atoms to select */\n  index?: number | number[];\n  /** overloaded to select number of bonds, e.g. {bonds: 0} will select all nonbonded atoms */\n  bonds?: number;\n  /** overloaded to allow ranges and lists of residues, e.g. {resi: \"5-10\"} or {resi: [5,10,32]} */\n  resi?: number | SelectionRange | (number | SelectionRange)[];\n  /** user supplied function that gets passed an {@link AtomSpec} and should return true if the atom should be selected */\n  predicate?: (atom: AtomSpec) => boolean;\n  /** if set, inverts the meaning of the selection */\n  invert?: boolean;\n  /** if set, expands the selection to include all atoms of any residue that has any atom selected */\n  byres?: boolean;\n  /** expands the selection to include all atoms within a given distance from the selection */\n  expand?: number | string;\n  /** intersects the selection with the set of atoms within a given distance from another selection */\n  within?: WithinSelectionSpec;\n  /** take the intersection of the provided lists of {@link AtomSelectionSpec}s */\n  and?: AtomSelectionSpec[] & { __cached_results?: any };\n  /** take the union of the provided lists of {@link AtomSelectionSpec}s */\n  or?: AtomSelectionSpec[] & { __cached_results?: any };\n  /** take the inverse of the provided {@link AtomSelectionSpec} */\n  not?: AtomSelectionSpec;\n  contextMenuEnabled?: boolean;\n}\n\n/**\n * Within selection object. Used to find the subset of an atom selection that is within\n * some distance from another atom selection. When added as a field of an {@link AtomSelectionSpec},\n * intersects the set of atoms in that selection with the set of atoms within a given\n * distance from the given {@link AtomSelectionSpec}.\n * @example\n * $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n *  viewer.setStyle({chain: 'A', within:{distance: 10, sel:{chain: 'B'}}}, {sphere:{}});\n *  viewer.render();\n * });// stylizes atoms in chain A that are within 10 angstroms of an atom in chain B\n *\n */\nexport interface WithinSelectionSpec {\n  /** the distance in angstroms away from the atom selection to include atoms in the parent selection */\n  distance?: number;\n  /** if set, selects atoms not within distance range for intersection */\n  invert?: boolean;\n  /** the selection of atoms against which to measure the distance from the parent atom selection */\n  sel?: AtomSelectionSpec;\n}\n\nexport type Cryst = {\n  a: number;\n  b: number;\n  c: number;\n  alpha: number;\n  beta: number;\n  gamma: number;\n  origin: Vector3;\n  size: { x: number; y: number; z: number };\n  unit: Vector3;\n  matrix4: Matrix4;\n  matrix: unknown;\n};\nexport type SelectionRange = `${number}-${number}`;\n", "//a collection of miscellaneous utility functions\n\nimport { GLViewer } from \"GLViewer\";\nimport { getGradient, Gradient, GradientType } from \"./Gradient\";\nimport { VolumeData } from \"./VolumeData\";\nimport { builtinColorSchemes, CC, elementColors, htmlColors, Color } from \"./colors\";\nimport { IsoSurfaceSpec } from \"GLShape\";\nimport { inflate, InflateFunctionOptions, Data } from \"pako\"\n\n//simplified version of jquery extend\nexport function extend(obj1, src1) {\n    for (var key in src1) {\n        if (src1.hasOwnProperty(key) && src1[key] !== undefined) {\n            obj1[key] = src1[key];\n        }\n    }\n    return obj1;\n};\n\n//deep copy, cannot deal with circular refs; undefined input becomes an empty object\n//https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089\nexport function deepCopy(inObject) {\n    let outObject, value, key;\n\n    if (inObject == undefined) {\n        return {};\n    }\n    if (typeof inObject !== \"object\" || inObject === null) {\n        return inObject; // Return the value if inObject is not an object\n    }\n\n    // Create an array or object to hold the values\n    outObject = Array.isArray(inObject) ? [] : {};\n\n    for (key in inObject) {\n        value = inObject[key];\n        // Recursively (deep) copy for nested objects, including arrays\n        outObject[key] = deepCopy(value);\n    }\n\n    return outObject;\n};\n\nexport function isNumeric(obj) {\n\n    var type = typeof (obj);\n    return (type === \"number\" || type === \"string\") &&\n        !isNaN(obj - parseFloat(obj));\n};\n\nexport function isEmptyObject(obj: object) {\n    return Object.keys(obj).length === 0;\n};\n\nexport type Func = Function|string|undefined|null;\n\nexport function makeFunction(callback:Func): Function {\n    //for py3dmol let users provide callback as string\n    if (callback && typeof callback === \"string\") {\n        /* jshint ignore:start */\n        callback = eval(\"(\" + callback + \")\");\n        /* jshint ignore:end */\n    }\n    // report to console if callback is not a valid function\n    if (callback && typeof callback != \"function\") {\n        console.warn(\"Invalid callback provided.\");\n        return ()=>{}; //return noop function\n    }\n    return callback as Function;\n};\n\n//standardize voldata/volscheme in style\nexport function adjustVolumeStyle(style: IsoSurfaceSpec) {\n    if (style) {\n        if (style.volformat && !(style.voldata instanceof VolumeData)) {\n            style.voldata = new VolumeData(style.voldata, style.volformat);\n        }\n        if (style.volscheme) {\n            style.volscheme = Gradient.getGradient(style.volscheme);\n        }\n    }\n};\n\n\n/*\n * computes the bounding box around the provided atoms\n * @param {AtomSpec[]} atomlist\n * @return {Array}\n */\nexport function getExtent(atomlist, ignoreSymmetries?) {\n    var xmin, ymin, zmin, xmax, ymax, zmax, xsum, ysum, zsum, cnt;\n    var includeSym = !ignoreSymmetries;\n\n    xmin = ymin = zmin = 9999;\n    xmax = ymax = zmax = -9999;\n    xsum = ysum = zsum = cnt = 0;\n\n    if (atomlist.length === 0)\n        return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n    for (var i = 0; i < atomlist.length; i++) {\n        var atom = atomlist[i];\n        if (typeof atom === 'undefined' || !isFinite(atom.x) ||\n            !isFinite(atom.y) || !isFinite(atom.z))\n            continue;\n        cnt++;\n        xsum += atom.x;\n        ysum += atom.y;\n        zsum += atom.z;\n\n        xmin = (xmin < atom.x) ? xmin : atom.x;\n        ymin = (ymin < atom.y) ? ymin : atom.y;\n        zmin = (zmin < atom.z) ? zmin : atom.z;\n        xmax = (xmax > atom.x) ? xmax : atom.x;\n        ymax = (ymax > atom.y) ? ymax : atom.y;\n        zmax = (zmax > atom.z) ? zmax : atom.z;\n\n        if (atom.symmetries && includeSym) {\n            for (var n = 0; n < atom.symmetries.length; n++) {\n                cnt++;\n                xsum += atom.symmetries[n].x;\n                ysum += atom.symmetries[n].y;\n                zsum += atom.symmetries[n].z;\n                xmin = (xmin < atom.symmetries[n].x) ? xmin : atom.symmetries[n].x;\n                ymin = (ymin < atom.symmetries[n].y) ? ymin : atom.symmetries[n].y;\n                zmin = (zmin < atom.symmetries[n].z) ? zmin : atom.symmetries[n].z;\n                xmax = (xmax > atom.symmetries[n].x) ? xmax : atom.symmetries[n].x;\n                ymax = (ymax > atom.symmetries[n].y) ? ymax : atom.symmetries[n].y;\n                zmax = (zmax > atom.symmetries[n].z) ? zmax : atom.symmetries[n].z;\n            }\n        }\n    }\n\n    return [[xmin, ymin, zmin], [xmax, ymax, zmax],\n    [xsum / cnt, ysum / cnt, zsum / cnt]];\n};\n\n\n/* get the min and max values of the specified property in the provided\n* @function $3Dmol.getPropertyRange\n* @param {AtomSpec[]} atomlist - list of atoms to evaluate\n* @param {string} prop - name of property \n* @return {Array} - [min, max] values\n*/\nexport function getPropertyRange(atomlist, prop) {\n    var min = Number.POSITIVE_INFINITY;\n    var max = Number.NEGATIVE_INFINITY;\n\n    for (var i = 0, n = atomlist.length; i < n; i++) {\n        var atom = atomlist[i];\n        var val = getAtomProperty(atom, prop);\n\n        if (val != null) {\n            if (val < min)\n                min = val;\n            if (val > max)\n                max = val;\n        }\n    }\n\n    if (!isFinite(min) && !isFinite(max))\n        min = max = 0;\n    else if (!isFinite(min))\n        min = max;\n    else if (!isFinite(max))\n        max = min;\n\n    return [min, max];\n};\n\n\n//adapted from https://stackoverflow.com/questions/3969475/javascript-pause-settimeout\nexport class PausableTimer {\n    ident: any;\n    total_time_run = 0;\n    start_time: number;\n    countdown: number;\n    fn: any;\n    arg: any;\n\n    constructor(fn, countdown, arg?) {\n        this.fn = fn;\n        this.arg = arg;\n        this.countdown = countdown;\n        this.start_time = new Date().getTime();\n        this.ident = setTimeout(fn, countdown, arg);\n    }\n\n    cancel() {\n        clearTimeout(this.ident);\n    }\n\n    pause() {\n        clearTimeout(this.ident);\n        this.total_time_run = new Date().getTime() - this.start_time;\n    }\n\n    resume() {\n        this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);\n    }\n\n};\n\n/*\n * Convert a base64 encoded string to a Uint8Array\n * @param {string} base64 encoded string\n */\nexport function base64ToArray(base64) {\n    var binary_string = window.atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes;\n};\n\n//return the value of an atom property prop, or null if non existent\n// looks first in properties, then in the atom itself\nexport function getAtomProperty(atom, prop) {\n    var val = null;\n    if (atom.properties &&\n        typeof (atom.properties[prop]) != \"undefined\") {\n        val = atom.properties[prop];\n    } else if (typeof (atom[prop]) != 'undefined') {\n        val = atom[prop];\n    }\n    return val;\n};\n\n//Miscellaneous functions and classes - to be incorporated into $3Dmol proper\n/*\n * \n * @param {$3Dmol.Geometry} geometry\n * @param {$3Dmol.Mesh} mesh\n * @returns {undefined}\n */\nexport function mergeGeos(geometry, mesh) {\n\n    var meshGeo = mesh.geometry;\n\n    if (meshGeo === undefined)\n        return;\n\n    geometry.geometryGroups.push(meshGeo.geometryGroups[0]);\n\n};\n\n\n/*\n * Parse a string that represents a style or atom selection and convert it\n * into an object.  The goal is to make it easier to write out these specifications\n * without resorting to json. Objects cannot be defined recursively.\n * ; - delineates fields of the object \n * : - if the field has a value other than an empty object, it comes after a colon\n * , - delineates key/value pairs of a value object\n *     If the value object consists of ONLY keys (no = present) the keys are \n *     converted to a list.  Otherwise a object of key/value pairs is created with\n *     any missing values set to null\n * = OR ~ - separates key/value pairs of a value object, if not provided value is null\n *     twiddle is supported since = has special meaning in URLs\n * @param (String) str\n * @returns {Object}\n */\nexport function specStringToObject(str) {\n    if (typeof (str) === \"object\") {\n        return str; //not string, assume was converted already\n    }\n    else if (typeof (str) === \"undefined\" || str == null) {\n        return str;\n    }\n\n    //if this is a json string, parse it directly\n    try {\n        let parsed = JSON.parse(str);\n        return parsed;\n    } catch (error) {\n\n    }\n\n    str = str.replace(/%7E/g, '~'); //copy/pasting urls sometimes does this\n    //convert things that look like numbers into numbers\n    var massage = function (val) {\n        if (isNumeric(val)) {\n            //hexadecimal does not parse as float\n            if (Math.floor(parseFloat(val)) == parseInt(val)) {\n                return parseFloat(val);\n            }\n            else if (val.indexOf('.') >= 0) {\n                return parseFloat(val); // \".7\" for example, does not parseInt\n            }\n            else {\n                return parseInt(val);\n            }\n        }\n        //boolean conversions\n        else if (val === 'true') {\n            return true;\n        }\n        else if (val === 'false') {\n            return false;\n        }\n        return val;\n    };\n\n    var ret = {};\n    if (str === 'all') return ret;\n    var fields = str.split(';');\n    for (var i = 0; i < fields.length; i++) {\n        var fv = fields[i].split(':');\n        var f = fv[0];\n        var val = {};\n        var vstr = fv[1];\n        if (vstr) {\n            vstr = vstr.replace(/~/g, \"=\");\n            if (vstr.indexOf('=') !== -1) {\n                //has key=value pairs, must be object\n                var kvs = vstr.split(',');\n                for (var j = 0; j < kvs.length; j++) {\n                    var kv = kvs[j].split('=', 2);\n                    val[kv[0]] = massage(kv[1]);\n                }\n            }\n            else if (vstr.indexOf(',') !== -1) {\n                //has multiple values, must list\n                val = vstr.split(',');\n            }\n            else {\n                val = massage(vstr); //value itself\n            }\n        }\n        ret[f] = val;\n    }\n\n    return ret;\n};\n\n\n\nfunction checkStatus(response) {\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status} - ${response.statusText}`);\n    }\n    return response;\n}\n\n/**\n * Fetch data from URL\n * \n * @param uri URL\n * @param callback Function to call with data \n */\nexport function get(uri, callback?) {\n    var promise = fetch(uri).then(checkStatus).then((response) => response.text());\n    if (callback)\n        return promise.then(callback);\n    else\n        return promise;\n}\n\n/**\n * Download binary data (e.g. a gzipped file) into an array buffer and provide\n * arraybuffer to callback.\n * @param {string} uri - location of data\n * @param {Function} [callback] - Function to call with arraybuffer as argument.  \n * @param {string} [request] - type of request\n * @param {string} [postdata] - data for POST request\n * @return {Promise}\n */\nexport function getbin(uri, callback?, request?, postdata?) {\n    var promise;\n    if (request == \"POST\") {\n        promise = fetch(uri, { method: 'POST', body: postdata })\n            .then((response) => checkStatus(response))\n            .then((response) => response.arrayBuffer());\n    } else {\n        promise = fetch(uri).then((response) => checkStatus(response))\n            .then((response) => response.arrayBuffer());\n    }\n\n    if (callback) return promise.then(callback);\n    else return promise;\n};\n\n\n/**\n * Load a PDB/PubChem structure into existing viewer. Automatically calls 'zoomTo' and 'render' on viewer after loading model\n * @param {string} query - String specifying pdb or pubchem id; must be prefaced with \"pdb: \" or \"cid: \", respectively\n * @param {GLViewer} viewer - Add new model to existing viewer\n * @param {Object} options - Specify additional options\n *                           format: file format to download, if multiple are available, default format is pdb\n *                           pdbUri: URI to retrieve PDB files, default URI is http://www.rcsb.org/pdb/files/\n * @param {Function} [callback] - Function to call with model as argument after data is loaded.\n  \n * @return {GLModel} GLModel, Promise if callback is not provided\n * @example\n viewer.setBackgroundColor(0xffffffff);\n       $3Dmol.download('pdb:2nbd',viewer,{onemol: true,multimodel: true},function(m) {\n        m.setStyle({'cartoon':{colorscheme:{prop:'ss',map:$3Dmol.ssColors.Jmol}}});\n       viewer.zoomTo();\n       viewer.render(callback);\n    });\n */\nexport function download(query, viewer: GLViewer, options, callback?) {\n    var type = \"\";\n    var pdbUri = \"\";\n    var uri = \"\";\n    var promise = null;\n    var m = viewer.addModel();\n\n    if (query.indexOf(':') < 0) {\n        //no type specifier, guess\n        if (query.length == 4) {\n            query = 'pdb:' + query;\n        } else if (!isNaN(query)) {\n            query = 'cid:' + query;\n        } else {\n            query = 'url:' + query;\n        }\n    }\n    if (query.substring(0,5) == 'mmtf:') {\n        console.warn('WARNING: MMTF now deprecated.  Reverting to bcif.');\n        query = 'bcif:' + query.slice(5);\n    }\n    if (query.substring(0, 5) === 'bcif:') {\n        query = query.substring(5).toUpperCase();\n        uri = \"https://models.rcsb.org/\" + query + '.bcif.gz';\n        if (options && typeof options.noComputeSecondaryStructure === 'undefined') {\n            //when fetch directly from pdb, trust structure annotations\n            options.noComputeSecondaryStructure = true;\n        }\n        promise = new Promise(function (resolve) {\n            getbin(uri)\n                .then(function (ret) {\n                    m.addMolData(ret, 'bcif.gz', options);\n                    viewer.zoomTo();\n                    viewer.render();\n                    resolve(m);\n                }, function () { console.error(\"fetch of \" + uri + \" failed.\"); });\n        });\n    }\n    else {\n        if (query.substring(0, 4) === 'pdb:') {\n            type = 'bcif';\n            if (options && options.format) {\n                type = options.format; //can override and require pdb\n            }\n\n            if (options && typeof options.noComputeSecondaryStructure === 'undefined') {\n                //when fetch directly from pdb, trust structure annotations\n                options.noComputeSecondaryStructure = true;\n            }\n            query = query.substring(4).toUpperCase();\n            if (!query.match(/^[1-9][A-Za-z0-9]{3}$/)) {\n                alert(\"Wrong PDB ID\");\n                return;\n            }\n            if (type == 'bcif') {\n                uri = 'https://models.rcsb.org/' + query.toUpperCase() + '.bcif.gz';\n            }\n            else {\n                pdbUri = options && options.pdbUri ? options.pdbUri : \"https://files.rcsb.org/view/\";\n                uri = pdbUri + query + \".\" + type;\n            }\n\n        } else if (query.substring(0, 4) == 'cid:') {\n            type = \"sdf\";\n            query = query.substring(4);\n            if (!query.match(/^[0-9]+$/)) {\n                alert(\"Wrong Compound ID\"); return;\n            }\n            uri = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\" + query +\n                \"/SDF?record_type=3d\";\n        } else if (query.substring(0, 4) == 'url:') {\n            uri = query.substring(4);\n            type = uri;\n        }\n\n        var handler = function (ret) {\n            m.addMolData(ret, type, options);\n            viewer.zoomTo();\n            viewer.render();\n        };\n        promise = new Promise(function (resolve) {\n            if (type == 'bcif') { //binary data\n                getbin(uri)\n                    .then(function (ret) {\n                        handler(ret);\n                        resolve(m);\n                    }).catch(function () {\n                        //if mmtf server is being annoying, fallback to text\n                        pdbUri = options && options.pdbUri ? options.pdbUri : \"https://files.rcsb.org/view/\";\n                        uri = pdbUri + query + \".pdb\";\n                        type = \"pdb\";\n                        console.warn(\"falling back to pdb format\");\n                        get(uri).then(function (data) {\n                            handler(data);\n                            resolve(m);\n                        }).catch(function (e) {\n                            handler(\"\");\n                            resolve(m);\n                            console.error(\"fetch of \" + uri + \" failed: \" + e.statusText);\n                        });\n                    }); //an error msg has already been printed\n            }\n            else {\n                get(uri).then(function (data) {\n                    handler(data);\n                    resolve(m);\n                }).catch(function (e) {\n                    handler(\"\");\n                    resolve(m);\n                    console.error(\"fetch of \" + uri + \" failed: \" + e.statusText);\n                });\n            }\n        });\n    }\n    if (callback) {\n        promise.then(function (m) {\n            callback(m);\n        });\n        return m;\n    }\n    else return promise;\n};\n\n\n/**  Return proper color for atom given style\n * @param {AtomSpec} atom\n * @param {AtomStyle} style\n * @return {Color}\n */\nexport function getColorFromStyle(atom, style): Color {\n    let scheme = style.colorscheme;\n    if (typeof builtinColorSchemes[scheme] != \"undefined\") {\n        scheme = builtinColorSchemes[scheme];\n    } else if (typeof scheme == \"string\" && scheme.endsWith(\"Carbon\")) {\n        //any color you want of carbon\n        let ccolor = scheme\n            .substring(0, scheme.lastIndexOf(\"Carbon\"))\n            .toLowerCase();\n        if (typeof htmlColors[ccolor] != \"undefined\") {\n            let newscheme = { ...elementColors.defaultColors };\n            newscheme.C = htmlColors[ccolor];\n            builtinColorSchemes[scheme] = { prop: \"elem\", map: newscheme };\n            scheme = builtinColorSchemes[scheme];\n        }\n    }\n\n    let color = atom.color;\n    if (typeof style.color != \"undefined\" && style.color != \"spectrum\")\n        color = style.color;\n    if (typeof scheme != \"undefined\") {\n        let prop, val;\n        if (typeof elementColors[scheme] != \"undefined\") {\n            //name of builtin colorscheme\n            scheme = elementColors[scheme];\n            if (typeof scheme[atom[scheme.prop]] != \"undefined\") {\n                color = scheme.map[atom[scheme.prop]];\n            }\n        } else if (typeof scheme[atom[scheme.prop]] != \"undefined\") {\n            //actual color scheme provided\n            color = scheme.map[atom[scheme.prop]];\n        } else if (\n            typeof scheme.prop != \"undefined\" &&\n            typeof scheme.gradient != \"undefined\"\n        ) {\n            //apply a property mapping\n            prop = scheme.prop;\n            var grad = scheme.gradient; //redefining scheme\n            if(!(grad instanceof GradientType)) {\n                grad = getGradient(scheme);\n            }\n            let range = grad.range() || [-1, 1]; //sensible default\n            val = getAtomProperty(atom, prop);\n            if (val != null) {\n                color = grad.valueToHex(val, range);\n            }\n        } else if (\n            typeof scheme.prop != \"undefined\" &&\n            typeof scheme.map != \"undefined\"\n        ) {\n            //apply a discrete property mapping\n            prop = scheme.prop;\n            val = getAtomProperty(atom, prop);\n            if (typeof scheme.map[val] != \"undefined\") {\n                color = scheme.map[val];\n            }\n        } else if (typeof style.colorscheme[atom.elem] != \"undefined\") {\n            //actual color scheme provided\n            color = style.colorscheme[atom.elem];\n        } else {\n            console.warn(\"Could not interpret colorscheme \" + scheme);\n        }\n    } else if (typeof style.colorfunc != \"undefined\") {\n        //this is a user provided function for turning an atom into a color\n        color = style.colorfunc(atom);\n    }\n\n    let C = CC.color(color);\n    return C;\n};\n\n//given a string selector, element, or jquery object, return the HTMLElement\nexport function getElement(element): HTMLElement | null {\n    let ret = element;\n    if (typeof (element) === \"string\") {\n        ret = document.querySelector(\"#\" + element);\n    } else if (typeof element === 'object' && element.get) { //jquery\n        ret = element.get(0);\n    }\n    return ret;\n}\n\nexport function inflateString(str: string | ArrayBuffer, tostring: Boolean = true): (string | ArrayBuffer) {\n    let data: Data;\n\n    if (typeof str === 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(str);\n    } else {\n        data = new Uint8Array(str);\n    }\n\n    const inflatedData = inflate(data, {\n        to: tostring ? 'string' : null\n    } as InflateFunctionOptions & { to: 'string' });\n\n    return inflatedData;\n}\n", "!function(r,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t(r.MMTF=r.MMTF||{})}(this,function(r){\"use strict\";function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else{if(!(1114112>o))throw new Error(\"bad codepoint \"+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128)}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else{if(!(1114112>i))throw new Error(\"bad codepoint \"+i);t+=4}}return t}function e(r,i,o){var a=typeof r;if(\"string\"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if(\"number\"===a){if(!isFinite(r))throw new Error(\"Number not finite: \"+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error(\"Number too big 0x\"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error(\"Number too small -0x\"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if(\"boolean\"===a)return i.setUint8(o,r?195:194),1;if(\"object\"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else{var d=Object.keys(r);u=d.length}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var g=d[l];f+=e(g,i,o+f),f+=e(r[g],i,o+f)}return f}throw new Error(\"Unknown type \"+a)}function i(r){var t=typeof r;if(\"string\"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(\"number\"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error(\"Number too big 0x\"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error(\"Number too small -0x\"+r.toString(16).substr(1))}if(\"boolean\"===t||null===r)return 1;if(\"object\"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a])}else{var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s])}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error(\"Array or object too long 0x\"+e.toString(16))}throw new Error(\"Unknown type \"+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function g(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function v(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i)}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u)}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:u>0?(a+=Math.ceil(u/e),u%e===0&&(a+=1)):(a+=Math.ceil(u/i),u%i===0&&(a+=1))}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return[n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=g(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n])}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o()}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join(\"\")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error(\"Unknown type 0x\"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return v(t);case 5:return s(t);case 6:return p(v(t),new Uint8Array(n));case 7:return p(v(t));case 8:return A(v(t));case 9:return M(v(t),v(e)[0]);case 10:return O(l(t),v(e)[0]);case 11:return y(l(t),v(e)[0]);case 12:return N(l(t),v(e)[0]);case 13:return N(f(t),v(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o)}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\\0/g,\"\")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,g=t.onAtom,v=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k})}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z})}for(u=0;q>u;++u){if(g){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),g({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R})}m+=1}if(v){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)v({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]})}y+=1}h+=1}if(p=U+1,U=m-1,v&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&v({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null})}L+=1}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r)}catch(t){e(t)}}var o=new XMLHttpRequest;o.addEventListener(\"load\",i,!0),o.addEventListener(\"error\",e,!0),o.responseType=\"arraybuffer\",o.open(\"GET\",t+r.toUpperCase()),o.send()}function $(r,t,n){Z(r,or,t,n)}function _(r,t,n){Z(r,ar,t,n)}var rr=[\"mmtfVersion\",\"mmtfProducer\",\"unitCell\",\"spaceGroup\",\"structureId\",\"title\",\"depositionDate\",\"releaseDate\",\"experimentalMethods\",\"resolution\",\"rFree\",\"rWork\",\"bioAssemblyList\",\"ncsOperatorList\",\"entityList\",\"groupList\",\"numBonds\",\"numAtoms\",\"numGroups\",\"numChains\",\"numModels\",\"groupsPerChain\",\"chainsPerModel\"],tr=[\"xCoordList\",\"yCoordList\",\"zCoordList\",\"groupIdList\",\"groupTypeList\",\"chainIdList\",\"bFactorList\",\"atomIdList\",\"altLocList\",\"occupancyList\",\"secStructList\",\"insCodeList\",\"sequenceIndexList\",\"chainNameList\",\"bondAtomList\",\"bondOrderList\"],nr=rr.concat(tr),er=\"v1.0.1\",ir=\"//mmtf.rcsb.org/v1.0/\",or=ir+\"full/\",ar=ir+\"reduced/\";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X});", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "", "// startup\n// Load entry module and return exports\n__webpack_require__(\"./src/index.ts\");\n__webpack_require__(\"./src/SurfaceWorker.js\");\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/exporter.js\");\n", ""],
  "mappings": "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K;oBAAK;oBAAK;oBAAO;oBAAK;oBAAO;oBAAO;oBAAO;oBAAK;oBAAK;oBACjE;oBAAM;oBAAK;oBAAM;oBAAK;oBAAM;oBAAK;oBAAK;oBAAK;oBAAO;oBAAK;oBAAO;oBAC9D;oBAAO;oBAAK;oBAAK;oBAAK;oBAAM;oBAAK;oBAAK;oBAAK;oBAAO;oBAAK;oBAAK;oBAAM;oBAClE;oBAAK;oBAAO;oBAAO;oBAAO;oBAAK;oBAAM;oBAAM;oBAAM;oBAAK;oBAAO;oBAC7D;oBAAO;oBAAK;oBAAO;oBAAO;oBAAM;oBAAO;oBAAO;oBAAO;oBAAO;oBAAK;oBACjE;oBAAK;oBAAK;oBAAK;oBAAM;oBAAK;oBAAO;oBAAK;oBAAK;oBAAK;oBAAO;oBAAM;oBAC7D;oBAAO;oBAAO;oBAAK;oBAAM;oBAAK;oBAAO;oBAAM;oBAAM;oBAAM;oBAAM;oBAAK;oBAClE;oBAAK;oBAAO;oBAAO;oBAAO;oBAAO;oBAAO;oBAAK;oBAAK;oBAAK;oBAAM;oBAAK;oBAClE;oBAAK;oBAAO;oBAAK;oBAAK;oBAAM;oBAAO;oBAAM;oBAAO;oBAAO;oBAAO;oBAC9D;oBAAM;oBAAO;oBAAM;oBAAO;oBAAO;oBAAO;oBAAM;oBAAO;oBAAO;oBAC5D;oBAAO;oBAAO;oBAAO;oBAAO;oBAAO;oBAAK;oBAAK;oBAAK;oBAAK;oBAAK;oBAAK;oBACjE;oBAAO;oBAAK;oBAAK;oBAAM;oBAAO;oBAAM;oBAAO;oBAAM;oBAAO;oBAAK;oBAAK;oBAClE;oBAAO;oBAAK;oBAAO;oBAAO;oBAAO;oBAAK;oBAAM;oBAAO;oBAAO;oBAAO;oBACjE;oBAAO;oBAAO;oBAAK;oBAAK;oBAAM;oBAAO;oBAAK;oBAAO;oBAAO;oBAAO;oBAC/D;oBAAO;oBAAM;oBAAO;oBAAO;oBAAO;oBAAM;oBAAO;oBAAO;oBAAO;oBAC7D;oBAAO;oBAAO;oBAAO;oBAAO;oBAAO;oBAAO;oBAAO;oBAAM;oBAAM;oBAC7D;oBAAO;oBAAO;oBAAO;oBAAK;oBAAK;oBAAK;oBAAK;oBAAM;oBAAO;oBAAM;oBAC5D;oBAAM;oBAAM;oBAAO;oBAAO;oBAAM;oBAAM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BACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,GAAG;kBACH,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,GAAG;kBACH,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,GAAG;kBACH,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,GAAG;kBACH,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;kBACJ,IAAI;;;gBAGN;gBACA,eAAe,OAAA,OAAA,CAAA,GACV,MAAM;gBAEX,aAAa,OAAA,OAAA,OAAA,OAAA,CAAA,GACR,MAAM,GAAA,EACT,GAAG,MAAQ,CAAA;gBAEb,YAAY,OAAA,OAAA,OAAA,OAAA,CAAA,GACP,MAAM,GAAA,EACT,GAAG,MAAQ,CAAA;gBAEb,eAAe,OAAA,OAAA,OAAA,OAAA,CAAA,GACV,MAAM,GAAA,EACT,GAAG,SAAQ,CAAA;gBAEb,cAAc,OAAA,OAAA,OAAA,OAAA,CAAA,GACT,MAAM,GAAA,EACT,GAAG,SAAQ,CAAA;gBAEb,aAAa,OAAA,OAAA,OAAA,OAAA,CAAA,GACR,MAAM,GAAA,EACT,GAAG,SAAQ,CAAA;gBAEb,cAAc,OAAA,OAAA,OAAA,OAAA,CAAA,GACT,MAAM,GAAA,EACT,GAAG,SAAQ,CAAA;gBAEb,cAAc,OAAA,OAAA,OAAA,OAAA,CAAA,GACT,MAAM,GAAA,EACT,GAAG,QAAQ,CAAA;gBAEb,YAAY,OAAA,OAAA,OAAA,OAAA,CAAA,GACP,MAAM,GAAA,EACT,GAAG,IAAQ,CAAA;;AAIR,oBAAM,WAAW;;gBAGtB,OAAO;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;;;gBAIP,SAAS;kBACP,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;kBACL,KAAK;;;gBAIP,SAAS;kBACP,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;;;AAIA,oBAAM,SAAS;;gBAEpB,MAAM;kBACJ,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;;;gBAIL,QAAQ;kBACN,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;kBACH,GAAG;;;AAoCA,oBAAM,sBAAsB;;gBAEjC,SAAS,EAAE,MAAM,MAAM,KAAK,SAAS,MAAK;gBAC1C,QAAQ,EAAE,MAAM,MAAM,KAAK,SAAS,KAAI;gBACxC,MAAM,EAAE,MAAM,QAAQ,KAAK,cAAc,KAAI;gBAC7C,OAAO,EAAE,MAAM,QAAQ,KAAK,SAAS,MAAK;gBAC1C,SAAS,EAAE,MAAM,QAAQ,KAAK,SAAS,QAAO;gBAC9C,SAAS,EAAE,MAAM,QAAQ,KAAK,SAAS,QAAO;gBAC9C,OAAO,EAAE,MAAM,SAAS,KAAK,OAAO,KAAI;gBACxC,QAAQ,EAAE,MAAM,QAAQ,KAAK,cAAc,OAAM;gBACjD,SAAS,EAAE,MAAM,QAAQ,KAAK,cAAc,cAAa;gBACzD,aAAa,EAAE,MAAM,QAAQ,KAAK,cAAc,YAAW;gBAC3D,aAAa,EAAE,MAAM,SAAS,KAAK,OAAO,OAAM;gBAChD,YAAY,EAAE,MAAM,QAAQ,KAAK,cAAc,WAAU;gBACzD,eAAe,EAAE,MAAM,QAAQ,KAAK,cAAc,cAAa;gBAC/D,cAAc,EAAE,MAAM,QAAQ,KAAK,cAAc,aAAY;gBAC7D,aAAa,EAAE,MAAM,QAAQ,KAAK,cAAc,YAAW;gBAC3D,cAAc,EAAE,MAAM,QAAQ,KAAK,cAAc,aAAY;gBAC7D,cAAc,EAAE,MAAM,QAAQ,KAAK,cAAc,aAAY;gBAC7D,YAAY,EAAE,MAAM,QAAQ,KAAK,cAAc,WAAU;;;;;ACh1B3D,kBAA8B,OAAAjB,QAAA,YAAA,UAAA;AAE9B,gBAAAA,QAAA,UAAA,OAAA;cACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuDC;AAIM,uBAAS,iBAAiB,SAAS,KAAG;AACzC,oBAAI,MAAM,CAAA;AACV,oBAAI,SAAS;AACb,yBAAS,CAAA;AACT,uBAAO,KAAK,QAAQ,CAAC,CAAC;AAEtB,oBAAI,GAAG,KAAK;AACZ,oBAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,qBAAK,IAAI,GAAG,MAAM,QAAQ,SAAS,GAAG,IAAI,KAAK,KAAK;AAChD,uBAAK,QAAQ,CAAC;AACd,uBAAK,QAAQ,IAAI,CAAC;AAClB,sBAAI,GAAG,UAAU;AACb,wBAAI,KAAK,IAAI,yCAAA,SAAS,GAAG,IAAI,GAAG,KAAK,IAChC,GAAG,IAAI,GAAG,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC;AACxC,uBAAG,OAAO,GAAG;AACb,2BAAO,KAAK,EAAE;kBAClB;AAEI,2BAAO,KAAK,EAAE;gBACtB;AACA,uBAAO,KAAK,QAAQ,QAAQ,SAAS,CAAC,CAAC;AAEvC,qBAAK,IAAI,IAAI,OAAO,OAAO,QAAQ,KAAK,OAAO,GAAG,KAAK;AACnD,uBAAK,OAAQ,MAAM,KAAM,IAAI,CAAC;AAC9B,uBAAK,OAAO,IAAI,CAAC;AACjB,uBAAK,OAAO,IAAI,CAAC;AACjB,uBAAK,OAAQ,MAAM,OAAO,IAAK,OAAO,IAAI,IAAI,CAAC;AAC/C,uBAAK,IAAI,yCAAA,QAAO,EAAG,WAAW,IAAI,EAAE,EAAE,eAAe,GAAG;AACxD,uBAAK,IAAI,yCAAA,QAAO,EAAG,WAAW,IAAI,EAAE,EAAE,eAAe,GAAG;AACxD,sBAAI,GAAG;AACH;AAEJ,2BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,wBAAI,IAAI,IAAM,MAAM;AACpB,wBAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KACzB,KAAK,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,KAClD,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACrC,wBAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KACzB,KAAK,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,KAClD,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACrC,wBAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KACzB,KAAK,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,KAClD,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAErC,wBAAI,KAAK,IAAI,yCAAA,QAAQ,GAAG,GAAG,CAAC;AAC5B,wBAAI,IAAI,MAAM,GAAG;AACb,yBAAG,OAAO,GAAG;oBACjB,OAAO;AACH,yBAAG,OAAO,GAAG;oBACjB;AAEA,wBAAI,KAAK,EAAE;kBACf;gBACJ;AACA,oBAAI,KAAK,OAAO,OAAO,SAAS,CAAC,CAAC;AAClC,uBAAO;cACX;AAAC;AAGD,oBAAM,YAAY;AAClB,oBAAM,kBAAkB;AACxB,oBAAM,mBAAmB;AACzB,oBAAM,mBAAmB;AACzB,oBAAM,gBAAgB;AAEtB,uBAAS,cAAc,KAAe,IAAI,IAAI,QAAM;AAEhD,oBAAI,QAAQ;AACZ,oBAAI,OAAO;AAEX,yBAAS,IAAI,GAAG,MAAM,GAAG,QAAQ,IAAI,KAAK,KAAK;AAE3C,2BAAS,KAAK,MAAM,KAAK,OAAO,SAAS,KAAK,GAAG;AACjD,0BAAQ,qCAAA,GAAG,MAAM,OAAO,MAAM,CAAC;AAE/B,sBAAI,WAAW,IAAI,eAAe,CAAC;AACnC,sBAAI,cAAc,SAAS;AAC3B,sBAAI,aAAa,SAAS;AAC1B,sBAAI,YAAY,SAAS;AACzB,2BAAS,SAAS;AAClB,+BAAa,SAAS;AAEtB,8BAAY,UAAU,IAAI,GAAG,CAAC,EAAE;AAChC,8BAAY,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,8BAAY,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AAEpC,8BAAY,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,8BAAY,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,8BAAY,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AAEpC,2BAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACxB,+BAAW,aAAa,IAAI,CAAC,IAAI,MAAM;AACvC,+BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,+BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;kBAC/C;AAEA,sBAAI,IAAI,GAAG;AACP,wBAAI,QAAQ,CAAC,QAAQ,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AACvD,wBAAI,aAAa,SAAS;AAE1B,8BAAU,UAAU,IAAI,MAAM,CAAC;AAC/B,8BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,8BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,8BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,8BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,8BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AAEnC,6BAAS,WAAW;kBACxB;AAEA,2BAAS,YAAY;gBACzB;cAEJ;AAAC;AAED,uBAAS,eAAe,KAAe,QAAQ,QAAQ,KAAK,WAAW,SAAS,OAAK;AAIjF,oBAAI,GAAG,GAAG,KAAK;AACf,sBAAM,OAAO;AACb,oBAAI,MAAM,KAAK,OAAO,CAAC,EAAE,SAAS;AAC9B;AAEJ,qBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AAEtB,yBAAO,CAAC,IAAI,iBAAiB,OAAO,CAAC,GAAG,GAAG;gBAC/C;AACA,sBAAM,OAAO,CAAC,EAAE;AAEhB,oBAAI,CAAC;AAED,yBAAO,cAAc,KAAK,OAAO,CAAC,GAAG,OAAO,MAAM,CAAC,GAAG,MAAM;AAEhE,oBAAI,MAAM,UAAU,WAAW,QAAQ,gBAAgB;AAGvD,oBAAI,aAAa,CAAA,GAAI,eAAe,CAAA,GAAI,cAAc,CAAA;AACtD,qBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,6BAAW,KAAK,OAAO,MACnB,KAAK,MAAM,MAAM,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC,CAAC,KAAK,MAAM,EAAE;AACzD,+BAAa,KAAK,GAAG;AACrB,8BAAY,KAAK,KAAK,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,IAAI,OAAO,GAAG;gBAC/D;AAeA,oBAAI,YAAY,CAAA;AAChB,qBAAK,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,KAAK;AAM9B,4BAAU,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,GAAG;gBAC1D;AAGA,0BAAU,MAAM,IAAI,CAAC,IAAI;kBAAC;kBAAG,IAAI,IAAI,IAAI;kBAAK,IAAI,IAAI,IAAI;kBACtD,IAAI,IAAI;gBAAG;AAEf,oBAAI,UAAU,WAAW;AACzB,oBAAI;AACJ,oBAAI,OAAO;AACX,oBAAI,aAAa,YAAY,WAAW;AACxC,oBAAI,WAAW,IAAI,eAAc;AAEjC,qBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,sBAAI,OAAO,IAAI;AACf,sBAAI,cAAc;AAClB,6BAAW,IAAI,eAAe,IAAI,GAAG;AACrC,sBAAI,QAAQ,IAAI,UAAU,IAAI,GAAG;AAG7B,wBAAI,IAAI;AACR,kCAAc;kBAClB;AACA,2BAAS,KAAK,MAAM,KAAK,OAAO,SAAS,KAAK,GAAG;AACjD,0BAAQ,qCAAA,GAAG,MAAM,OAAO,MAAM,CAAC;AAE/B,mCAAiB;AACjB,gCAAc;AACd,8BAAY,CAAA;AACZ,2BAAS,CAAA;AACT,yBAAO,CAAA;AAEP,sBAAI,OAAO,CAAC,EAAE,CAAC,EAAE,SAAS,QAE1B;AACI,kCAAc,OAAO,CAAC,EAAE,CAAC,EAAE;AAC3B,wBAAI,UAAU;AACV,iCAAW;6BACN,UAAU;AACf,iCAAW;6BACN,UAAU;AACf,iCAAW;kBACnB;AACA,sBAAI,CAAC;AACD,+BAAW;AAIf,sBAAI,QAAQ;AACZ,uBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,wBAAI,IAAI,MAAM;AACV,+BAAS,OAAO,CAAC,EAAE,IAAI,CAAC,EAAE,MAAK,EAAG,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;;AAElD,+BAAS,OAAO,CAAC,EAAE,IAAI,CAAC,EAAE,MAAK,EAAG,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,EAC7C,OAAM;AAEf,wBAAI,IAAI,MAAM;AACV,+BAAS,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE,MAAK,EAAG,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;;AAElD,+BAAS,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE,MAAK,EAAG,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,EAC7C,OAAM;AAEf,yBAAK,CAAC,IAAI,OAAO,MAAM,MAAM,EAAE,UAAS,EAAG,eACvC,YAAY,SAAS,CAAC,CAAC;kBAC/B;AAIA,uBAAK,IAAI,GAAG,IAAI,KAAK;AACjB,8BAAU,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE,MAAK,EAAG,IAChC,KAAK,CAAC,EAAE,MAAK,EAAG,OAAM,CAAE;AAChC,uBAAK,IAAI,GAAG,IAAI,KAAK;AACjB,2BAAO,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE,MAAK,EAAG,IAAI,KAAK,CAAC,CAAC;AAahD,gCAAc,SAAS;AACvB,+BAAa,SAAS;AACtB,8BAAY,SAAS;AACrB,6BAAW,SAAS;AACpB,8BAAY,WAAW;AAIvB,uBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,gCAAY,YAAY,IAAI,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE;AAClD,gCAAY,YAAY,IAAI,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE;AAClD,gCAAY,YAAY,IAAI,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE;kBACtD;AAKA,uBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,gCAAY,YAAY,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,IAAI,CAAC,EAAE;AACnE,gCAAY,YAAY,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,IAAI,CAAC,EAAE;AACnE,gCAAY,YAAY,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,IAAI,CAAC,EAAE;kBACvE;AAEA,uBAAK,IAAI,GAAG,IAAI,IAAI,KAAK,EAAE,GAAG;AAC1B,+BAAW,YAAY,IAAI,IAAI,CAAC,IAAI,MAAM;AAC1C,+BAAW,YAAY,IAAI,IAAI,CAAC,IAAI,MAAM;AAC1C,+BAAW,YAAY,IAAI,IAAI,CAAC,IAAI,MAAM;kBAC9C;AAEA,sBAAI,IAAI,KAAK,CAAC,aAAa;AAEvB,yBAAK,IAAI,GAAG,IAAI,MAAM,GAAG,KAAK;AAI1B,6BAAO;wBAAC,WAAW,UAAU,CAAC,EAAE,CAAC;wBACjC,WAAW,UAAU,CAAC,EAAE,CAAC;wBACzB,WAAW,UAAU,CAAC,EAAE,CAAC;wBACzB,WAAW,UAAU,CAAC,EAAE,CAAC;sBAAC;AAE1B,iCAAW,SAAS;AAGpB,gCAAU,QAAQ,IAAI,KAAK,CAAC;AAC5B,gCAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,gCAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,gCAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,gCAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,gCAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,+BAAS,WAAW;oBAIxB;AAEA,wBAAI,YAAY,aAAa,YAAY,WAAW;AAChD,0BAAI,QAAQ,CAAA;AAEZ,4BAAM,KAAK,IAAI,2CAAA,SAAS,eAAe,CAAC,GACpC,UAAU,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,CAAC;AACrC,4BAAM,KAAK,IAAI,2CAAA,SAAS,eAAe,CAAC,GACpC,UAAU,MAAM,CAAC,GAAG,eAAe,MAAM,CAAC,CAAC,CAAC;AAEhD,4BAAM,KAAK,IAAI,2CAAA,SAAS,eAAe,MAAM,CAAC,GAC1C,UAAU,MAAM,CAAC,GAAG,OAAO,MAAM,CAAC,CAAC,CAAC;AACxC,4BAAM,KAAK,IAAI,2CAAA,SAAS,eAAe,MAAM,CAAC,GAC1C,OAAO,MAAM,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;AAE1C,4BAAM,KAAK,IAAI,2CAAA,SAAS,OAAO,CAAC,GAAG,YAAY,CAAC,GAC5C,YAAY,MAAM,CAAC,CAAC,CAAC;AACzB,4BAAM,KAAK,IAAI,2CAAA,SAAS,OAAO,MAAM,CAAC,GAAG,OAAO,CAAC,GAC7C,YAAY,MAAM,CAAC,CAAC,CAAC;AAEzB,4BAAM,KAAK,IAAI,2CAAA,SAAS,UAAU,CAAC,GAC/B,eAAe,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC;AACtC,4BAAM,KAAK,IAAI,2CAAA,SAAS,OAAO,CAAC,GAAG,UAAU,CAAC,GAC1C,YAAY,CAAC,CAAC,CAAC;AAEnB,2BAAK,KAAK,OAAO;AACb,oCAAY,kBAAkB,SAAS,KAAK,MAAM,CAAC,CAAC;sBACxD;oBACJ;kBACJ;AAEA,2BAAS,YAAY,IAAI;gBAC7B;AAGA,8BAAc,SAAS;AACvB,6BAAa,SAAS;AACtB,4BAAY,SAAS;AACrB,2BAAW,SAAS;AACpB,4BAAY,WAAW;AACvB,2BAAW,SAAS;AAEpB,qBAAK,IAAI,GAAG,IAAI,MAAM,GAAG,KACzB;AACI,yBAAO,CAAC,GAAG,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,CAAC;AAElD,6BAAW,SAAS;AAEpB,4BAAU,QAAQ,IAAI,KAAK,CAAC;AAC5B,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,2BAAS,WAAW;gBACxB;AAEA,qBAAK,IAAI,GAAG,IAAI,MAAM,GAAG,KACzB;AACI,yBAAO;oBAAC,WAAW,IAAI;oBAAG,WAAW,IAAI;oBACzC,WAAW,IAAI,MAAM,IAAI;oBAAG,WAAW,IAAI,MAAM;kBAAC;AAElD,6BAAW,SAAS;AAEpB,4BAAU,QAAQ,IAAI,KAAK,CAAC;AAC5B,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAChC,4BAAU,WAAW,CAAC,IAAI,KAAK,CAAC;AAEhC,2BAAS,WAAW;gBACxB;cAEJ;AAAC;AAED,uBAAS,eAAe,KAAK,QAAQ,QAAQ,KAAK,WAAW,SAAO;AAChE,oBAAK,OAAO,SAAU;AAClB;AAEJ,oBAAI,IAAI;AACR,qBAAK,OAAO,CAAC;AACb,qBAAK,OAAO,OAAO,SAAS,CAAC;AAE7B,qBAAK,iBAAiB,IAAI,GAAG;AAC7B,qBAAK,iBAAiB,IAAI,GAAG;AAC7B,oBAAI,CAAC;AACD,yBAAO,cAAc,KAAK,IAAI,IAAI,MAAM;AAG5C,oBAAI,KAAK,CAAA;AACT,oBAAI,MAAM,KAAK,KAAK,KAAK;AAEzB,oBAAI,QAAQ;kBAAC,CAAC,GAAG,GAAG,IAAI,EAAE;kBAAG,CAAC,IAAI,IAAI,GAAG,CAAC;kBAAG,CAAC,GAAG,IAAI,IAAI,CAAC;kBAC1D,CAAC,IAAI,GAAG,GAAG,EAAE;gBAAC;AAEd,oBAAI,QAAQ,YAAY;AACxB,oBAAI,OAAO;AACX,oBAAI,aAAa;AACjB,oBAAI,GAAG,KAAK;AACZ,oBAAI,OAAO,OAAO;AAClB,oBAAI,UAAU,aAAa,YAAY;AAEvC,qBAAK,IAAI,GAAG,MAAM,GAAG,QAAQ,IAAI,KAAK,KAAK;AAEvC,2BAAS,KAAK,MAAM,KAAK,OAAO,SAAS,KAAK,GAAG;AACjD,0BAAQ,qCAAA,GAAG,MAAM,OAAO,MAAM,CAAC;AAE/B,qBAAG,KAAK,MAAM,GAAG,CAAC,CAAC;AACnB,qBAAG,KAAK,GAAG;AACX,qBAAG,KAAK,MAAM,GAAG,CAAC,CAAC;AACnB,qBAAG,KAAK,GAAG;AACX,sBAAI,IAAI,MAAM,GAAG;AACb,wBAAI,SAAS,GAAG,IAAI,CAAC,EAAE,MAAK,EAAG,IAAI,GAAG,CAAC,CAAC;AACxC,wBAAI,SAAS,GAAG,CAAC,EAAE,MAAK,EAAG,IAAI,GAAG,CAAC,CAAC;AACpC,2BAAO,OAAO,MAAM,MAAM,EAAE,UAAS,EAAG,eACpC,SAAS;kBACjB;AACA,qBAAG,KAAK,MAAM,GAAG,CAAC,EAAE,MAAK,EAAG,IAAI,IAAI,CAAC;AACrC,qBAAG,KAAK,GAAG;AACX,qBAAG,KAAK,MAAM,GAAG,CAAC,EAAE,MAAK,EAAG,IAAI,IAAI,CAAC;AACrC,qBAAG,KAAK,GAAG;AAEX,sBAAI,IAAI,SAAS;AACb,kCAAc,IAAI;AAEtB,6BAAW,IAAI,eAAe,CAAC;AAC/B,gCAAc,SAAS;AACvB,+BAAa,SAAS;AACtB,8BAAY,SAAS;AACrB,2BAAS,SAAS;AAClB,+BAAa,SAAS;AAEtB,8BAAY,UAAU,IAAI,IAAI;AAC9B,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,CAAC,IAAI,IAAI;AAClC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AACnC,8BAAY,aAAa,EAAE,IAAI,IAAI;AAEnC,uBAAK,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACpB,+BAAW,aAAa,IAAI,CAAC,IAAI,MAAM;AACvC,+BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,+BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;kBAC/C;AAEA,sBAAI,IAAI,GAAG;AAGP,wBAAI,YAAc,aAAa,UAAa,gBAAgB,UAAc,SAAS,WAAW,YAAY;AAE1G,yBAAK,IAAI,GAAG,IAAI,GAAG,KAAK;AAEpB,0BAAI,OAAO;wBAAC,SAAS,MAAM,CAAC,EAAE,CAAC;wBAAG,SAAS,MAAM,CAAC,EAAE,CAAC;wBACrD,SAAS,MAAM,CAAC,EAAE,CAAC;wBAAG,SAAS,MAAM,CAAC,EAAE,CAAC;sBAAC;AAE1C,mCAAa,SAAS;AAEtB,gCAAU,UAAU,IAAI,KAAK,CAAC;AAC9B,gCAAU,aAAa,CAAC,IAAI,KAAK,CAAC;AAClC,gCAAU,aAAa,CAAC,IAAI,KAAK,CAAC;AAClC,gCAAU,aAAa,CAAC,IAAI,KAAK,CAAC;AAClC,gCAAU,aAAa,CAAC,IAAI,KAAK,CAAC;AAClC,gCAAU,aAAa,CAAC,IAAI,KAAK,CAAC;AAElC,+BAAS,WAAW;AAEpB,0BAAI,YAAY,aAAa,SAAS,aAAa,YAAY,aAAa,SAAS,WAAW;AAE5F,4BAAI,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE,MAAK,GAAI,MAAM,GAAG,KAAK,CAAC,CAAC,EAC1C,MAAK,GAAI,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE,MAAK,GAAI,MAAM,GAAG,KAAK,CAAC,CAAC,EAChD,MAAK;AAEd,4BAAI,OAAO,GAAG,KAAK,CAAC,CAAC,EAAE,QAAQ;AAE/B,4BAAI,OAAO,GAAG,KAAK,CAAC,CAAC,EAAE,QAAQ;AAE/B,4BAAI,OAAO,GAAG,KAAK,CAAC,CAAC,EAAE,QAAQ;AAE/B,4BAAI,OAAO,GAAG,KAAK,CAAC,CAAC,EAAE,QAAQ;AAE/B,4BAAI,WAAW;AACX,8BAAI,KAAK,IAAI,MAAK,EAAG,IAAI,GAAG,EAAE,eAAe,GAAG;AAChD,8BAAI,KAAK,IAAI,MAAK,EAAG,IAAI,GAAG,EAAE,eAAe,GAAG;AAChD,8BAAI,IAAI,IAAI,MAAK,EAAG,IAAI,GAAG,EAAE,eAAe,GAAG;AAE/C,8BAAI,IAAI,MAAM,GAAG;AACb,gCAAI,SAAS,aAAa,SAAS,WAAW;AAC1C,sCAAQ,IAAI,2CAAA,SAAS,IAAI,GAAG,GAAG;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,IAAI,KAAK,CAAC;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,GAAG,KAAK,GAAG;AAChC,uCAAS,kBAAkB,SACtB,KAAK,KAAK;AACf,uCAAS,kBAAkB,SACtB,KAAK,KAAK;AACf,uCAAS,kBAAkB,SACtB,KAAK,KAAK;4BACnB;AAEA,gCAAI,YAAY,aAAa,YAAY,WAAW;AAChD,sCAAQ,IAAI,2CAAA,SAAS,KAAK,KAAK,CAAC;AAChC,sCAAQ,IAAI,2CAAA,SAAS,KAAK,IAAI,CAAC;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,KAAK,GAAG,EAAE;AAC/B,0CAAY,kBAAkB,SACzB,KAAK,KAAK;AACf,0CAAY,kBAAkB,SACzB,KAAK,KAAK;AACf,0CAAY,kBAAkB,SACzB,KAAK,KAAK;4BACnB;0BACJ,OAAO;AACH,gCAAI,YAAY,aAAa,YAAY,WAAW;AAChD,sCAAQ,IAAI,2CAAA,SAAS,IAAI,GAAG,GAAG;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,IAAI,KAAK,CAAC;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,GAAG,KAAK,GAAG;AAChC,0CAAY,kBAAkB,SACzB,KAAK,KAAK;AACf,0CAAY,kBAAkB,SACzB,KAAK,KAAK;AACf,0CAAY,kBAAkB,SACzB,KAAK,KAAK;4BACnB;AAEA,gCAAI,SAAS,aAAa,SAAS,WAAW;AAC1C,sCAAQ,IAAI,2CAAA,SAAS,KAAK,KAAK,CAAC;AAChC,sCAAQ,IAAI,2CAAA,SAAS,KAAK,IAAI,CAAC;AAC/B,sCAAQ,IAAI,2CAAA,SAAS,KAAK,GAAG,EAAE;AAC/B,uCAAS,kBAAkB,SACtB,KAAK,KAAK;AACf,uCAAS,kBAAkB,SACtB,KAAK,KAAK;AACf,uCAAS,kBAAkB,SACtB,KAAK,KAAK;4BACnB;0BACJ;wBAEJ,WAGS,YAAY,aAAa,YAAY,WAAW;AACrD,kCAAQ,IAAI,2CAAA,SAAS,KAAK,KAAK,GAAG;AAClC,kCAAQ,IAAI,2CAAA,SAAS,KAAK,KAAK,GAAG;AAClC,sCAAY,kBAAkB,SAAS,KAAK,KAAK;AACjD,sCAAY,kBAAkB,SAAS,KAAK,KAAK;wBACrD;sBAEJ;oBAEJ;kBACJ;AAEA,2BAAS,YAAY;AACrB,6BAAW;gBACf;AAEA,oBAAI,QAAQ,GAAG,SAAS;AAExB,2BAAW,IAAI,eAAe,CAAC;AAC/B,8BAAc,SAAS;AACvB,6BAAa,SAAS;AACtB,4BAAY,SAAS;AACrB,yBAAS,SAAS;AAClB,6BAAa,SAAS;AACtB,6BAAa,SAAS;AAEtB,qBAAK,IAAI,GAAG,IAAI,GAAG,KAAK;AACpB,qBAAG,KAAK,GAAG,IAAI,CAAC,CAAC;AACjB,qBAAG,KAAK,GAAG,QAAQ,IAAI,CAAC,CAAC;AAEzB,sBAAI,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,QAAQ,IAAI,CAAC;AAEzC,8BAAY,aAAa,IAAI,CAAC,IAAI,GAAG;AACrC,8BAAY,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG;AACzC,8BAAY,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG;AACzC,8BAAY,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG;AACzC,8BAAY,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG;AACzC,8BAAY,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG;AAEzC,6BAAW,aAAa,IAAI,CAAC,IAAI,MAAM;AACvC,6BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,6BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,6BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,6BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;AAC3C,6BAAW,aAAa,IAAI,IAAI,CAAC,IAAI,MAAM;gBAE/C;AAEA,yBAAS;AAET,wBAAQ,CAAC,QAAQ,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AACnD,wBAAQ,CAAC,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AAEvD,0BAAU,UAAU,IAAI,MAAM,CAAC;AAC/B,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,CAAC,IAAI,MAAM,CAAC;AACnC,0BAAU,aAAa,EAAE,IAAI,MAAM,CAAC;AACpC,0BAAU,aAAa,EAAE,IAAI,MAAM,CAAC;AAEpC,yBAAS,WAAW;AACpB,yBAAS,YAAY;cAGzB;AAAC;AAGD,uBAAS,UAAU,KAAK,QAAQ,QAAQ,KAAK,WAAW,SAAS,OAAK;AAClE,oBAAI,CAAC,SAAS,UAAU;AACpB,0BAAQ;AACZ,oBAAI,UAAU;AACV,iCAAe,KAAK,QAAQ,QAAQ,KAAK,WAAW,OAAO;yBACtD,UAAU,eAAe,UAAU,UAAU,UAAU;AAC5D,iCAAe,KAAK,QAAQ,QAAQ,KAAK,WAAW,SAAS,KAAK;cAC1E;AAAC;AAGD,uBAAS,cAAc,MAAI;AACvB,uBAAO,QAAQ,KAAK,SAAS,OAAO,KAAK,SAAS;cAGtD;AAAC;AAID,uBAAS,oBAAoB,GAAG,GAAC;AAC7B,oBAAI,KAAK,KAAK,EAAE,UAAU,EAAE,OAAO;AAC/B,sBAAI,CAAC,EAAE,WAAW,CAAC,EAAE,WAAY,EAAE,aAAa,EAAE,aAC7C,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;AAC1C,2BAAO;AACX,sBAAI,EAAE,OAAO,EAAE,MAAM;AAIjB,wBAAI,KAAK,EAAE,IAAI,EAAE;AACjB,wBAAI,KAAK,EAAE,IAAI,EAAE;AACjB,wBAAI,KAAK,EAAE,IAAI,EAAE;AACjB,wBAAI,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK;AACpC,wBAAI,EAAE,QAAQ,QAAQ,EAAE,QAAQ,QAAQ,OAAO;AAC3C,6BAAO;8BACD,EAAE,QAAQ,OAAO,EAAE,QAAQ,QAAQ,OAAO;AAChD,6BAAO;kBACf;gBACJ;AAEA,uBAAO;cACX;AAAC;AAGD,uBAAS,OAAO,OAAO,KAAK,SAAS,SAAS,YAAU;AAEpD,oBAAI,OAAO,QAAQ,IAAI,YAAY;AAAG;AACtC,oBAAI,YAAY;AACZ,sBAAI,gBAAe;AACnB,sBAAI,aAAY;gBACpB;AAEA,oBAAI,kBAAkB,IAAI,oCAAA,0BAAyB;AACnD,gCAAgB,eAAe,oCAAA,SAAS;AACxC,oBAAI,OAAQ,YAAa,YAAY,WAAW,KAAK,UAAU,GAAG;AAC9D,kCAAgB,cAAc;AAC9B,kCAAgB,UAAU;gBAC9B;AACA,gCAAgB,UAAU;AAC1B,oBAAI,cAAc,IAAI,oCAAA,KAAK,KAAK,eAA2B;AAC3D,sBAAM,IAAI,WAAW;cACzB;AAAC;AAED,uBAAS,kBAAkB,QAAQ,KAAK,UAAU,YAC9C,UAAU,cAAc,cAAc,OAAO,OAAK;AAClD,oBAAI,aAAa,GAAG,OAAO,GAAG,gBAAgB;AAE9C,oBAAI,CAAC,cAAc,CAAC,YAAY,CAAC;AAC7B;AAIJ,oBAAI,UAAU,SAAS,IAAI,UAAU;AACrC,wBAAQ,UAAS;AAGjB,oBAAI,aAAa,MAAM,KAAK;AAC5B,qBAAK,IAAI,QAAQ,GAAG,IAAI,MAAM,QAAQ,KAAK;AACvC,+BAAa,MAAM,CAAC;AACpB,sBAAI,WAAW,QAAQ,aAAa;AAChC;gBACR;AAGA,6BAAa,aAAa,IAAI,yCAAA,QAAQ,WAAW,GAC7C,WAAW,GAAG,WAAW,CAAC,IAAI,IAAI,yCAAA,QAAQ,GAAG,GAAG,CAAC;AACrD,2BAAW,IAAI,UAAU;AAGzB,oBAAI,aAAa,OAAO,eAAe;AACnC,sBAAI,aAAa,WAAW,MAAK,EAAG,eAAe,GAAG,EAAE,MACpD,QAAQ;AACZ,6BAAW,IAAI,UAAU;AAEzB,sBAAI,QAAQ,WAAW,MAAK,EAAG,MAAM,OAAO,EAAE,UAAS;AACvD,0BAAQ,kBAAkB,OAAO,IAAI;gBACzC;AAKA,oBAAI,aAAa,MAAM,QAAQ,QAAQ;AACnC,gCAAc,aAAa,MAAM,QAAQ,aAAa;gBAE1D,OAEA;AACI,sBAAI,CAAC,aAAa,MAAM,QAAQ,OAAO;AACnC,wBAAI,aAAa,OAAO,KAAK;AACzB,0BAAI,aAAa,SAAS;AACtB,sCAAc;;AAEd,sCAAc;oBACtB,WAAW,aAAa,OAAO,eAAe;AAC1C,oCAAc;AACd,uCAAiB;oBAErB,WAAW,aAAa,OAAO;AAC3B,oCAAc;6BAET,aAAa,OAAO,OACzB,aAAa,MAAM,QAAQ,SAC3B,aAAa,OAAO;AACpB,oCAAc;;AAGd,oCAAc;kBACtB;AACI,kCAAc,aAAa,MAAM,QAAQ;gBACjD;AAGA,oBAAI,gBAAgB,QAAQ,QAAQ,IAAI,YAAY,IAAI;AACpD,0BAAQ,OAAM;AAElB,wBAAQ,eAAe,WAAW;AAClC,qBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AAItB,0BAAQ,KAAK,IAAI,KAAK,MAAM;AAC5B,sBAAI,IAAI,yCAAA,QAAQ,WAAW,IAAI,QAAQ,QAAQ,GAC3C,WAAW,IAAI,QAAQ,QAAQ,GAAG,WAAW,IAAI,QAAQ,QAAQ,CAAC;AACtE,oBAAE,OAAO;AACT,sBAAI,YAAY,aAAa,OAAO;AAChC,sBAAE,WAAW;AACjB,yBAAO,CAAC,EAAE,KAAK,CAAC;gBAIpB;AAEA,oBAAI,gBAAgB;AAEhB,0BAAQ,eAAe,CAAC;AACxB,uBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,4BAAQ,KAAK,IAAI,KAAK,MAAM;AAC5B,wBAAI,IAAI,yCAAA,QAAQ,WAAW,IAAI,QAAQ,QAAQ,GAC3C,WAAW,IAAI,QAAQ,QAAQ,GAAG,WAAW,IAAI,QAAQ,QAAQ,CAAC;AACtE,sBAAE,OAAO;AACT,sBAAE,WAAW;AACb,sBAAE,OAAO;AACT,2BAAO,CAAC,EAAE,KAAK,CAAC;kBACpB;gBACJ;AAGA,4BAAY,aAAa,MAAM,QAAQ,SAAS;AAChD,oBAAI,OAAO,OAAO;AACd,sBAAI,OAAO,SAAS,WAAW;AAC3B,4BACK,IAAI,sDAAsD;AAC/D,2BAAO,QAAQ;kBACnB;gBAEJ;AACI,yBAAO,QAAQ;AAGnB,oBAAI,aAAa,OAAO,iBAAiB,aAAa,OAAO;AACzD,+BAAa,KAAK;AAEtB,uBAAO;cACX;AAAC;AAGD,oBAAM,eAAe;gBACjB,KAAK;gBAAM,MAAM;gBAAM,KAAK;gBAAM,KAAK;gBAAM,OAAO;gBACpD,OAAO;gBAAM,OAAO;gBAAM,OAAO;gBAAM,OAAO;gBAC9C,OAAO;gBAAM,OAAO;gBAAM,OAAO;gBAAM,OAAO;gBAC9C,OAAO;gBAAM,MAAM;gBAAM,MAAM;;AAEnC,oBAAM,WAAW,EAAE,MAAM,MAAM,MAAM,MAAM,KAAK,MAAM,KAAK,KAAI;AAC/D,oBAAM,WAAW,EAAE,MAAM,MAAM,MAAM,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,KAAI;AAC1E,oBAAM,UAAU,EAAE,MAAM,MAAM,MAAM,MAAM,KAAK,MAAM,KAAK,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,KAAI;AAGhH,uBAAS,YAAY,OAAO,UAAU,eAAe,UAAU,IAAE;AAEpE,oBAAI,MAAM;AACV,oBAAI,MAAM;AAEV,oBAAI,SAAS,MAAM,MAAM,MAAM,WAAW,WAAW,WAAW;AAChE,oBAAI,YAAY,UAAU,cAAc,YAAY,cAAc,aAAa;AAC/E,oBAAI,WAAW,SAAS;AACxB,oBAAI,WAAW,IAAI,oCAAA,SAAS,IAAI;AAChC,oBAAI,MAAM,IAAI,oCAAA,SAAS,IAAI;AAC3B,oBAAI,SAAS,CAAA;AACb,oBAAI,SAAc,CAAA;AAClB,oBAAI,UAAU;AACd,oBAAI,UAAU;AAEd,oBAAI,YAAiB,CAAA;AACrB,yBAAS,KAAK,uCAAA,SAAS,kBAAkB;AACrC,sBAAI,uCAAA,SAAS,iBAAiB,eAAe,CAAC,GAAG;AAE7C,8BAAU,CAAC,IAAI,IAAI,uCAAA,SAAS,iBAAiB,CAAC,EAAE,cAAc,CAAC,GAAG,cAAc,CAAC,CAAC;kBACtF;gBACJ;AAEA,oBAAI,eAAe,SAAU6B,OAAMoC,UAAO;AACtC,sBAAI,iBAAiBA,SAAQ,UAAU,YAAY;AAC/C,wBAAIA,SAAQ,eAAe,WAAW;AAClC,6BAAO,UAAUA,SAAQ,WAAW,EAAE,WAAWpC,MAAK,IAAI;oBAC9D,OAAO;AACH,6BAAO,UAAU,QAAQ,WAAWA,MAAK,IAAI;oBACjD;kBACJ,OACK;AACD,4BAAO,GAAA,wCAAA,mBAAkBA,OAAMoC,QAAO,EAAE,OAAM;kBAClD;gBACJ;AAEA,qBAAK,IAAI,GAAG,IAAI,KAAK;AACjB,yBAAO,CAAC,IAAI,CAAA;AAGhB,oBAAI,UAAU;AACd,oBAAI,UAAU;AACd,oBAAI,QAAQ,CAAA;AACZ,qBAAK,KAAK,UAAU;AAChB,yBAAO,SAAS,CAAC;AACjB,sBAAI,KAAK,SAAS,OAAO,KAAK,SAAS,MAAM;AACzC,wBAAI,YAAY,oBAAoB,MAAM,IAAI;AAG9C,wBAAI,aAAa,KAAK,OAAO,KAAK;AAC9B,gCAAU;oBACd,WAAW,SAAS;AAChB,0BAAI,QAAQ,QAAQ,KAAK,MAAM,QAAQ,UAAU,KAAK,MAAM,QAAQ,QAAQ;AACxE,6BAAK,KAAK;AACV,6BAAK,KAAK;sBACd;AACA,gCAAU;oBACd;AAGA,wBAAI,cAAc,KAAK,OAAO,OAAO,KAAK,MAAM,iBAAiB,KAAK,MAAM,QAAQ,OAAO;AACvF,0BAAI,CAAC,WAAW,KAAK,MAAM,gBAAgB,KAAK,MAAM,QAAQ,OAAO;AACjE,6BAAK,KAAK;AACV,kCAAU;sBACd;oBACJ,WAAW,SAAS;AAChB,0BAAI,KAAK,OAAO,cAAc;AAC1B,6BAAK,KAAK;sBACd,WAAW,QAAQ,KAAK,MAAM,QAAQ,OAAO;AACzC,6BAAK,KAAK;sBACd;AACA,gCAAU;oBACd;AACA,2BAAO;AACP,2BAAO;kBACX;AACA,sBAAI,QAAQ,KAAK,QAAQ,cAAc;AACnC,0BAAM,KAAK,IAAI;kBACnB;gBACJ;AACA,oBAAI,WAAW,KAAK,MAAM,QAAQ,OAAO;AACrC,uBAAK,KAAK;AACV,4BAAU;gBACd;AAEA,oBAAI,YAAY,SAAU,SAAO;AAE7B,sBAAI,OAAO,CAAC,EAAE,SAAS,GAAG;AACtB,8BAAU,KAAK,QAAQ,QAAQ,KAAK,WAAW,SAAS,OAAO,KAAK;kBACxE;AAEA,sBAAI,QAAQ,CAAA,GAAI,SAAS;AACzB,sBAAI,SAAS;AAET,yBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,4BAAM,CAAC,IAAI,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,SAAS,CAAC;oBAC7C;AACA,6BAAS,OAAO,OAAO,SAAS,CAAC;kBACrC;AACA,2BAAS,CAAA;AACT,uBAAK,IAAI,GAAG,IAAI,KAAK;AACjB,2BAAO,CAAC,IAAI,CAAA;AAChB,2BAAS,CAAA;AAET,sBAAI,SAAS;AACT,yBAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACtB,6BAAO,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC;oBAC3B;AACA,2BAAO,KAAK,MAAM;kBACtB;AAEA,yBAAO,OAAO,KAAK,SAAS,SAAS,IAAI;AACzC,yBAAO,OAAO,UAAU,SAAS,SAAS,KAAK;AAC/C,wBAAM,IAAI,oCAAA,SAAS,IAAI;AACvB,6BAAW,IAAI,oCAAA,SAAS,IAAI;gBAChC;AAGA,uBAAO;AACP,oBAAI,cAAc,CAAA;AAClB,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,yBAAO,MAAM,CAAC;AAEd,sBAAI,WAAW,KAAK,KAAK,KAAI;AAC7B,sBAAI,gBAAgB,YAAY;AAChC,4BAAU;AAEV,4BAAU,KAAK,MAAM;AACrB,sBAAI,QAAQ,KAAK,MAAM;AACnB,8BAAU,KAAK,MAAM,QAAQ;AACjC,sBAAI,QAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,QAAQ;AACjD,8BAAU,KAAK,MAAM,QAAQ;AAKjC,sBAAI,QAAQ,KAAK,MAAM,YAAY,CAAC,KAAK,MAAM,WAC3C,KAAK,MAAM,QAAQ,WAAW,KAAK,MAAM,QAAQ,UAAU;AAC3D,8BAAU,KAAK,SAAS,KAAK,KAAK;kBACtC;AAGA,sBAAI,QAAQ,QAAQ,CAAC,oBAAoB,MAAM,IAAI,KAAK,KAAK,SACzD,KAAK,SAAS,KAAK,SAAS,CAAC,KAAK,WAAW,CAAC,KAAK,WACnD,KAAK,WAAW,KAAK,KAAK,UAAU;AACpC,gCAAY,KAAK,CAAC,MAAM,IAAI,CAAC;kBACjC;AAEA,sBAAI,QAAQ,UAAU,SAEtB;AAMI,wBAAI,KAAK,SAAS;AACd;oBACJ,WAAW,KAAK,SAAS,OAAO,KAAK,SAAS,QAC1C,iBAAiB,KAAK,SAAS,OAC/B,KAAK,SAAS,MAAM;AAEpB,kCAAY,aAAa,MAAM,OAAO;AAGtC,2BAAI,GAAA,wCAAA,WAAU,QAAQ,SAAS;AAC3B,oCAAY,QAAQ;;AAEpB,oCAAY;AAEhB,0BAAI,oBAAoB,MAAM,IAAI,GAAG;AAEjC,4BAAI,aAAa,WAAW;AACxB,8BAAI,QAAQ,qCAAA,GAAG,MAAM,SAAS;AAC9B,+DAAA,OAAO,aAAa,UAAU,MAAM,MAChC,WAAW,OAAO,GAAG,CAAC;wBAC9B,OAIA;AACI,8BAAI,WAAW,IAAI,yCAAA,QAAO,EAAG,WACzB,MAAM,IAAI,EAAE,eAAe,GAAG;AAClC,8BAAI,SAAS,qCAAA,GAAG,MAAM,SAAS;AAC/B,8BAAI,SAAS,qCAAA,GAAG,MAAM,SAAS;AAC/B,+DAAA,OAAO,aAAa,UAAU,MAC1B,UAAU,WAAW,QAAQ,GAAG,CAAC;AACrC,+DAAA,OAAO,aAAa,UAAU,UAC1B,MAAM,WAAW,QAAQ,GAAG,CAAC;wBACrC;sBAEJ;AAEA,2BAAK,KAAK,cAAc,QAAQ,KAAK,cAAe,KAAK,sBAAsB,QAAY;AAEvF,4BAAI,SAAS,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC/C,6BAAK,kBAAkB,OAAO,KAAK,IAAI,2CAAA,OAAO,QAAQ,SAAS,CAAC;sBACpE;AAEA,6BAAO;AACP,kCAAY;oBAChB;kBACJ,OACA;AAEI,wBAAI,cAAc,IAAI,KAAK,kBAAkB,KAAK,SAAS,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAI;AAC7F,0BAAI,aAAa;AACb,4BAAI,KAAK,OAAO,YAAY;AACxB,wCAAc;AACd,oCAAU,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC5C,+DAAA,OAAO,aAAa,UAAU,WAC1B,SAAS,GAAG,qCAAA,GAAG,MAAM,SAAS,GAAG,GACjC,CAAC;AACL,+BAAK,KAAK;wBAEd,WACS,KAAK,SAAS,KAAK,SAAS,KAAK,OAAO,YAAY;AACzD,wCAAc;AACd,+BAAK,KAAK;AACV,oCAAU,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC5C,+DAAA,OAAO,aAAa,UAAU,WAC1B,SAAS,GAAG,qCAAA,GAAG,MAAM,SAAS,GAAG,GACjC,CAAC;wBACT;AAEI;sBAER;AAGA,0BAAI,SAAS,CAAC,oBAAoB,MAAM,IAAI,KAAK,KAAK,OAAO,eAAe;AACxE,4BAAI,KAAK,OAAO,cAAc;AAC1B,wCAAc;AACd,sCAAY,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GACjC,KAAK,CAAC;AACV,+BAAK,KAAK;wBACd;AAEA,4BAAI,WACJ;AACI,8BAAI;AACA,0CAAc,IAAI,yCAAA,QAAO,EAAG,WACxB,MAAM,UAAU,EAAE,eAAe,GAAG;;AAExC,0CAAc,IAAI,yCAAA,QAAQ,KAAK,GAC3B,KAAK,GAAG,KAAK,CAAC;AAEtB,+DAAA,OAAO,aAAa,UAAU,aAC1B,WAAW,eAAe,qCAAA,GACrB,MAAM,UAAU,KAAK,GAAG,GAAG,CAAC;AACrC,4CAAkB,QAAQ,KACtB,MAAM,YAAY,cAClB,cAAc,MAAM,OAAO,CAAC;AAChC,iCAAO,KAAK,SAAS;AAErB,wCAAc;AACd,sCAAY;wBAChB;AAGA,4BAAI,OAAO,CAAC,EAAE,SAAS;AACnB,oCAAU,KAAK,QAAQ,QAAQ,KAAK,WAChC,SAAS,OAAO,KAAK;AAG7B,iCAAS,CAAA;AACT,6BAAK,IAAI,GAAG,IAAI,KAAK;AACjB,iCAAO,CAAC,IAAI,CAAA;AAChB,iCAAS,CAAA;sBACb;AAGA,0BAAI,SAAS,UAAa,KAAK,WAAW,KAAK,WAAW,KAAK,QAAQ,KAAK,MAAM;AAC9E,4BAAI,aAAa,QAAQ,QACzB;AAGI,wCAAc,IAAI,yCAAA,QAAO,EAAG,WAAW,MACnC,IAAI,EAAE,eAAe,GAAG;AAC5B,8BAAI,WAAW,YAAY,MAAK,EAAG,IAAI,SAAS,EAC3C,eAAe,IAAI;AAGxB,sCAAY,IAAI,QAAQ;AAExB,+DAAA,OAAO,aAAa,UAAU,aAC1B,WAAW,eAAe,qCAAA,GACrB,MAAM,UAAU,KAAK,GAAG,GAAG,CAAC;AACrC,wCAAc;AACd,sCAAY;wBAChB;AAIA,oCAAY,aAAa,MAAM,OAAO;AACtC,+BAAO,KAAK,SAAS;AACrB,6BAAI,GAAA,wCAAA,WAAU,QAAQ,SAAS;AAC3B,sCAAY,QAAQ;;AAEpB,sCAAY;AAEhB,+BAAO;AACP,qCAAa,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC/C,mCAAW,OAAO,KAAK;AACvB,oCAAY;sBAChB;AAGA,2BAAK,KAAK,cAAc,QAAQ,KAAK,cAAc,UAC9C,KAAK,sBAAsB,UAAa,KAAK,kBAAkB,aAAa;AAC7E,6BAAK,oBAAoB;0BACrB,QAAQ;0BACR,UAAU,CAAA;0BACV,MAAM,CAAA;0BACN,UAAU,CAAA;;oBAEtB,WAES,QAAQ,WAAc,cAAc,IAAI,KAAK,KAAK,SAAS,OAChE,iBAAiB,KAAK,SAAS,QAC9B,KAAK,SAAS,SAAS,KAAK,SAAS,UACtC,iBAAiB,KAAK,KAAK,QAAQ,IAAI,KAAK,KAC5C,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAI;AAC/B,iCAAW,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC7C,+BAAS,OAAO,KAAK;AACrB,0BAAI,KAAK,SAAS,SAAS,KAAK,SAAS;AAErC,uCAAe,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GACpC,KAAK,CAAC;oBAClB,WAIS,iBAAiB,KAAK,KAAK,QAAQ,IAAI,KAAK,GAAG;AACpD,mCAAa,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;oBACnD,WAIU,KAAK,SAAS,QAAS,YAAY,YACxC,KAAK,SAAS,QAAS,YAAY,UAAY;AAChD,kCAAY,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC9C,gCAAU,SAAQ,GAAA,wCAAA,mBAAkB,MAAM,OAAO,EAC5C,OAAM;oBACf;AAIA,wBAAI,YAAY,cAAc,SAAS,SAAS,WAAW,MAAM;AAC7D,wCAAkB,QAAQ,KAAK,MAC3B,YAAY,UAAU,cAAc,MAAM,OAC1C,CAAC;AACL,qCAAe;AACf,mCAAa;AACb,iCAAW;AACX,6BAAO,KAAK,SAAS;oBACzB;kBACJ;gBAEJ;AAEA,oBAAI,WACJ;AACI,sBAAI;AACA,kCAAc,IAAI,yCAAA,QAAO,EAAG,WAAW,MAAM,UAAU,EAClD,eAAe,GAAG;;AAEvB,kCAAc,IAAI,yCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAEpD,uDAAA,OAAO,aAAa,UAAU,aAAa,WAAW,eAClD,qCAAA,GAAG,MAAM,UAAU,KAAK,GAAG,GAAG,CAAC;AACnC,oCAAkB,QAAQ,KAAK,MAAM,YACjC,cAAc,cAAc,MAAM,OAAO,CAAC;AAC9C,yBAAO,KAAK,SAAS;gBACzB;AAGA,0BAAU,KAAK;AAGf,oBAAI,UAAU,SAAU,OAAiB,KAAa;AAClD,sBAAI,MAAM,MAAM,QAAQ,aACpB,MAAM,MAAM,QAAQ,aAAa,IAAI,MAAM,QAAQ,WAAW;AAC9D,wBAAI,MAAM,MAAM,MAAM,QAAQ;AAC9B,wBAAI,MAAM,IAAI,OAAO,MAAM;AAC3B,wBAAI,MAAM,KAAK,MAAM,KAAK;AAEtB,0BAAI,SAAS;AACb,0BAAI,QAAQ,IAAI,IAAE,MAAM;AACxB,0BAAI,QAAQ,IAAI,IAAE,MAAM;AACxB,0BAAI,QAAQ,IAAI,IAAE,MAAM;AAExB,0BAAI,YAAY,KAAK,KAAK,QAAM,QAAM,QAAM,QAAM,QAAM,KAAK;AAC7D,0BAAI,iBAAiB,aAAW,IAAE;AAElC,0BAAI,YAAY,IAAI,yCAAA,QAAQ,MAAM,GAAE,MAAM,GAAE,MAAM,CAAC;AACnD,0BAAIC,OAAM,YAAU;AACpB,0BAAI,aAAa,IAAI,yCAAA,SAAS,IAAI,IAAI,MAAM,KAAKA,OAAM,IAAI,IAAI,MAAM,KAAKA,OAAM,IAAI,IAAI,MAAM,KAAKA,IAAG;AAEtG,gCAAU,IAAI,EAAC,GAAE,WAAW,IAAE,GAAE,GAAE,WAAW,IAAE,GAAE,GAAE,WAAW,IAAE,EAAC,CAAC;AAClE,0BAAI,UAAU,UAAU,MAAK,EAAG,IAAI,UAAU;AAC9C,iCAAW,eAAe,CAAC;AAC3B,0BAAI,WAAU,GAAA,wCAAA,QAAO,CAAA,GAAG,KAAK;AAC7B,+BAAS,QAAQ,GAAG,QAAQ,KAAK,SAAS;AACtC,gCAAQ,QAAQ;AAChB,4BAAIC,SAAQ,aAAa,SAAS,QAAQ,MAAM,OAAO;AACvD,6DAAA,OAAO,aAAa,UAAU,WAAW,SAAS,QAAQ,qCAAA,GAAG,MAAMA,MAAK,GAAG,qCAAA,IAAI,MAAM,qCAAA,IAAI,IAAI;AAC7F,kCAAU,IAAI,UAAU;AACxB,gCAAQ,IAAI,UAAU;sBAC1B;AACA,gCAAU,KAAK;oBACnB;kBAEJ;gBACJ;AAEA,yBAAS,QAAQ,aAAa;AAC1B,0BAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;gBAC5B;cACJ;AAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7xCD,kBAAI,QAAQ;AAER,uBAAO,SAASC;cACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cCIA,MAAM,aAAY;gBAGhB,YAAY,WAAS;AAFrB,uBAAA,IAA4D,CAAA;AAG1D,sBAAI,WAAW;AACb,wBAAI,MAAM,UAAU,SAAS,SAAS;AACtC,wBAAI,MAAM,UAAU,SAAS,WAAW;AACxC,wBAAI,MAAM,UAAU,SAAS,WAAW;AACxC,wBAAI,SAAS,UAAU,SAAS,aAAa;AAE7C,6BAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,0BAAI,OAAO,IAAI,CAAC;AAChB,0BAAI,KAAK,IAAI,CAAC;AACd,0BAAI,KAAK,IAAI,CAAC;AACd,0BAAI,QAAQ,OAAO,CAAC;AACpB,0BAAI,IAAI;AACR,0BAAI,SAAS;AAAQ,4BAAI;+BAChB,SAAS;AAAQ,4BAAI;AAE9B,0BAAI,KAAK,EAAE,IAAI,KAAK,QAAW;AAC7B,6BAAK,EAAE,IAAI,IAAI,CAAA;sBACjB;AACA,0BAAI,KAAK,EAAE,IAAI,EAAE,EAAE,KAAK,QAAW;AACjC,6BAAK,EAAE,IAAI,EAAE,EAAE,IAAI,CAAA;sBACrB;AACA,0BAAI,KAAK,EAAE,IAAI,EAAE,EAAE,KAAK,QAAW;AACjC,6BAAK,EAAE,IAAI,EAAE,EAAE,IAAI,CAAA;sBACrB;AACA,2BAAK,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,IAAI;AACvB,2BAAK,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,IAAI;oBACzB;kBACF;gBACF;;gBAGA,MAAM,MAAc,OAAe,OAAa;AAC9C,sBAAI,KAAK,EAAE,IAAI,MAAM,QAAW;AAC9B,wBAAI,KAAK,EAAE,IAAI,EAAE,KAAK,MAAM,QAAW;AACrC,0BAAI,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,MAAM,QAAW;AAC5C,+BAAO,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK;sBAClC;oBACF;kBACF;AACA,yBAAO;gBACT;;cAIF,MAAM,WAAU;gBAGd,YAAY,aAAW;AAFhB,uBAAA,IAA4E,CAAA;AAGjF,sBAAG,aAAa;AAEd,wBAAI,QAAQ,YAAY,SAAS,cAAc;AAC/C,wBAAI,SAAS,YAAY,SAAS,qBAAqB;AACvD,wBAAI,QAAQ,YAAY,SAAS,oBAAoB;AACrD,wBAAI,QAAQ,YAAY,SAAS,qBAAqB;AACtD,wBAAI,KAAK,YAAY,SAAS,qBAAqB;AACnD,wBAAI,SAAS,YAAY,SAAS,qBAAqB;AACvD,wBAAI,QAAQ,YAAY,SAAS,oBAAoB;AACrD,wBAAI,QAAQ,YAAY,SAAS,qBAAqB;AACtD,wBAAI,KAAK,YAAY,SAAS,qBAAqB;AACnD,wBAAI,KAAK,YAAY,SAAS,kBAAkB;AAEhD,6BAAQ,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACpC,0BAAG,MAAM,CAAC,KAAK,YAAY,MAAM,CAAC,KAAK,UAAU;AAC/C,4BAAI,IAAI,KAAM,GAAG,CAAC,KAAK,KAAK,IAAG,SAAS,GAAG,CAAC,CAAC,IAAK;AAClD,6BAAK,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,GAAE,MAAM,CAAC,GAAE,MAAM,CAAC,GAAE,GAAG,CAAC,CAAC,GAAE,CAAC,OAAO,CAAC,GAAE,MAAM,CAAC,GAAE,MAAM,CAAC,GAAE,GAAG,CAAC,CAAC,GAAE,CAAC,CAAC;sBACzF;oBACF;kBAEF;gBACF;;cAIF,MAAM,SAAQ;gBAEZ,cAAA;AADA,uBAAA,IAAqE,CAAA;gBAGrE;gBAEA,IAAI,GAAW;AACb,sBAAI,KAAK,EAAE,EAAE,MAAM,KAAK;AAAW,yBAAK,EAAE,EAAE,MAAM,IAAI,CAAA;AACtD,sBAAI,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,KAAK;AAAW,yBAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,IAAI,CAAA;AACxE,sBAAI,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,KAAK;AAAW,yBAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,IAAI,CAAA;AAC1F,uBAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC;AACzC,uBAAK,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,IAAI,IAAI;gBAC/C;gBAEQ,KAAK,CAAC,IAAG,MAAK,MAAK,KAAK,GAAgC;AAC9D,sBAAG,KAAK,EAAE,EAAE,MAAM,UAChB,KAAK,EAAE,EAAE,EAAE,IAAI,MAAM,UACrB,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,MAAM,QAAW;AACpC,2BAAO,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK;kBACrC;AACF,yBAAO;gBACT;gBAEA,SAAS,GAAiB,IAAc;AACtC,2BAAQ,MAAM,KAAK,GAAG;AACpB,6BAAQ,QAAQ,KAAK,EAAE,EAAE,GAAG;AAC1B,+BAAQ,QAAQ,KAAK,EAAE,EAAE,EAAE,IAAI,GAAG;AAChC,4BAAI,QAAQ,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI;AACjC,iCAAQ,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACpC,mCAAQ,IAAI,IAAE,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,gCAAI,KAAK,MAAM,CAAC;AAChB,gCAAI,KAAK,MAAM,CAAC;AAChB,gCAAI,KAAK,EAAE,MAAM,MAAK,GAAG,MAAK,GAAG,IAAI;AACrC,gCAAG,GAAG,UAAU,GAAG,UAAU,GAAG,UAAU,MAAM,GAAG,UAAU,IAAI;AAC/D,mCAAK;4BACP;AACA,gCAAG,KAAK,GAAG;AACT,iCAAG,MAAM,KAAK,GAAG,KAAK;AACtB,iCAAG,MAAM,KAAK,GAAG,KAAK;AACtB,iCAAG,UAAU,KAAK,EAAE;AACpB,iCAAG,UAAU,KAAK,EAAE;4BACtB;0BACF;wBACF;sBACF;oBACF;kBACF;AAEA,2BAAQ,QAAQ,GAAG,GAAG;AACpB,wBAAI,KAAK,KAAK,CAAC;AACf,wBAAI,KAAK,KAAK,CAAC;AACf,wBAAI,KAAK,KAAK,CAAC;AACf,wBAAI,QAAQ,KAAK,KAAK,EAAE;AACxB,wBAAI,QAAQ,KAAK,KAAK,EAAE;AACxB,wBAAG,SAAS,UAAa,SAAS,QAAW;AAC3C,4BAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,4BAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,4BAAM,UAAU,KAAK,EAAE;AACvB,4BAAM,UAAU,KAAK,EAAE;oBACzB;kBACF;gBAEF;;AASK,uBAAS,KAAK,SAAc,SAA0B;AAE3D,oBAAI,MAAM,CAAC,QAAQ;AACnB,oBAAI,YAAY,QAAQ,SAAS,QAAQ,SAAS;AAClD,oBAAI,gBAAgB,CAAC,QAAQ;AAE7B,sBAAM,aAAa,CAAC,QAAQ;AAC5B,sBAAM,cACJ,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AAErD,oBAAI,OAAQ,WAAY,UAAU;AAEhC,sBAAI;AACF,+BAAU,GAAA,wCAAA,eAAc,OAAO;kBACjC,SAAS,OAAO;AAEd,0BAAM,UAAU,IAAI,YAAW;AAC/B,8BAAU,QAAQ,OAAO,OAAO;kBAClC;gBACF,OAAO;AACL,4BAAU,IAAI,WAAW,OAAO;gBAClC;AAEA,oBAAI,WAAW,KAAK,cAAc,OAAO;AACzC,oBAAI,YAAY,IAAI;AAElB,6BAAU,GAAA,wCAAA,eAAc,SAAS,KAAK;AACtC,6BAAW,KAAK,cAAc,OAAO;gBACvC;AAEA,oBAAI,QAAuC,CAAA;AAC3C,oBAAI,YAAmB,MAAM,YAAY,CAAA;AAGzC,oBAAI,YAAY,SAAS,WAAW;AACpC,oBAAI,aAAa;AAAG,yBAAO;AAC3B,oBAAI,CAAC,QAAQ;AAAY,8BAAY;AAKrC,yBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,sBAAI,SAAS,MAAM;AACnB,wBAAM,gBAAoC,CAAA;AAC1C,4BAAU,KAAK,EAAE,YAAY,CAAA,EAAE,CAAE;AACjC,wBAAM,KAAK,CAAA,CAAE;AAEb,wBAAM,QAAQ,SAAS,WAAW,CAAC;AACnC,wBAAM,OAAO,uBAAO,OAAO,IAAI;AAC/B,6BAAW,OAAO,MAAM,YAAY;AAClC,yBAAK,IAAI,KAAK,OAAO,CAAC,CAAC,KAAI,GAAA,gDAAA,UAAS,GAAG;kBACzC;AAKA,sBAAI,WAAW,CAAA;AACf,sBAAI,UAAU,KAAK;AACnB,sBAAI,SAAS;AACX,wBAAI,SAAS,QAAQ,SAAS,cAAc;AAC5C,wBAAI,SAAS,QAAQ,SAAS,mBAAmB;AACjD,wBAAI,SAAS,QAAQ,SAAS,kBAAkB;AAChD,wBAAI,OAAO,QAAQ,SAAS,kBAAkB;AAE9C,6BAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,0BAAI,OAAO,CAAC,EAAE,WAAW,GAAG,GAAG;AAC7B,4BAAI,KAAK,OAAO,CAAC;AACjB,4BAAI,YAAY,OAAO,CAAC;AACxB,4BAAI,UAAU,KAAK,CAAC;AACpB,4BAAI,EAAE,MAAM,WAAW;AACrB,mCAAS,EAAE,IAAI,CAAA;wBACjB;AACA,iCAAS,EAAE,EAAE,SAAS,IAAI;AAC1B,iCAAS,MAAM,YAAY,GAAG,MAAM,SAAS,OAAO;AAClD,mCAAS,EAAE,EAAE,GAAG,IAAI;wBACtB;AACA,iCAAS,EAAE,EAAE,OAAO,IAAI;sBAC1B;oBACF;kBACF;AAEA,sBAAI,UAAU,KAAK;AACnB,sBAAI,SAAS;AACX,wBAAI,OAAO,QAAQ,SAAS,IAAI;AAChC,wBAAI,SAAS,QAAQ,SAAS,mBAAmB;AACjD,wBAAI,SAAS,QAAQ,SAAS,kBAAkB;AAChD,wBAAI,OAAO,QAAQ,SAAS,kBAAkB;AAE9C,6BAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,0BAAI,KAAK,OAAO,CAAC;AACjB,0BAAI,YAAY,OAAO,CAAC;AACxB,0BAAI,UAAU,KAAK,CAAC;AACpB,0BAAI,EAAE,MAAM,WAAW;AACrB,iCAAS,EAAE,IAAI,CAAA;sBACjB;AACA,+BAAS,EAAE,EAAE,SAAS,IAAI;AAC1B,+BAAS,MAAM,YAAY,GAAG,MAAM,SAAS,OAAO;AAClD,iCAAS,EAAE,EAAE,GAAG,IAAI;sBACtB;AACA,+BAAS,EAAE,EAAE,OAAO,IAAI;oBAE1B;kBACF;AAGA,sBAAI,YAAY,KAAK;AACrB,sBAAI,QAAQ,UAAU,SAAS,IAAI;AACnC,sBAAI,SAAS,CAAC,YAAY;AACxB,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,WAAW,UAAU,SAAS,cAAc;AAChD,wBAAI,UAAU,UAAU,SAAS,WAAW;AAC5C,wBAAI,UAAU,UAAU,SAAS,WAAW;AAC5C,wBAAI,UAAU,UAAU,SAAS,WAAW;AAE5C,6BAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,4BAAM,SAAS,IAAI,oCAAA,QACjB,SAAS,CAAC,GACV,SAAS,CAAC,GACV,SAAS,CAAC,GACV,QAAQ,CAAC,GACT,SAAS,CAAC,GACV,SAAS,CAAC,GACV,SAAS,CAAC,GACV,QAAQ,CAAC,GACT,SAAS,CAAC,GACV,SAAS,CAAC,GACV,SAAS,CAAC,GACV,QAAQ,CAAC,CAAC;AAEZ,gCAAU,UAAU,SAAS,CAAC,EAAE,WAAW,KAAK,MAAM;oBACxD;kBACF;AAGA,sBAAI,UAAU,IAAI,aAAa,KAAK,cAAc;AAClD,sBAAI,WAAW,IAAI,SAAQ;AAC3B,sBAAI,WAAW,IAAI,WAAW,KAAK,WAAW;AAG9C,sBAAI,SAAS,KAAK;AAClB,sBAAI,YAAY,OAAO;AACvB,sBAAI,YAAY,OAAO,SAAS,WAAW;AAC3C,sBAAI,UAAU,OAAO,SAAS,SAAS;AACvC,sBAAI,UAAU,OAAO,SAAS,SAAS;AACvC,sBAAI,UAAU,OAAO,SAAS,SAAS;AACvC,sBAAI,eAAe,OAAO,SAAS,cAAc;AACjD,sBAAI,gBAAgB,OAAO,SAAS,eAAe;AACnD,sBAAI,cAAc,OAAO,SAAS,aAAa;AAC/C,sBAAI,eAAe,OAAO,SAAS,cAAc;AACjD,sBAAI,eAAe,OAAO,SAAS,cAAc;AACjD,sBAAI,gBAAgB,OAAO,SAAS,eAAe;AACnD,sBAAI,eAAe,OAAO,SAAS,cAAc;AACjD,sBAAI,gBAAgB,OAAO,SAAS,eAAe;AACnD,sBAAI,cAAc,OAAO,SAAS,aAAa;AAC/C,sBAAI,WAAW,OAAO,SAAS,gBAAgB;AAC/C,sBAAI,UAAU,OAAO,SAAS,IAAI;AAClC,sBAAI,SAAS,OAAO,SAAS,cAAc;AAC3C,sBAAI,YAAY,OAAO,SAAS,oBAAoB;AACpD,sBAAI,WAAW,YAAY,UAAU,CAAC,IAAI;AAE1C,2BAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,wBAAI,cAAc,UAChB,UAAU,CAAC,MAAM;AAEjB;AAEF,wBAAI,aAAa,UAAU,CAAC,KAAK,UAAU;AACzC,iCAAW,UAAU,CAAC;AACtB,0BAAI,QAAQ,YAAY;AACtB,4BAAI,CAAC,QAAQ,QAAQ;AACnB,gCAAM,KAAK,CAAA,CAAE;AACb,oCAAU,KAAK,UAAU,UAAU,SAAS,CAAC,CAAC;AAC9C,qCAAW,UAAU,CAAC;AACtB,mCAAS,SAAS,SAAS,QAAQ;AACnC,qCAAW,IAAI,SAAQ;wBACzB;sBACF,OAAO;AACL;sBACF;oBACF;AAEA,0BAAM,OAAiB,CAAA;AACvB,yBAAK,IAAI,QAAQ,CAAC;AAClB,yBAAK,IAAI,QAAQ,CAAC;AAClB,yBAAK,IAAI,QAAQ,CAAC;AAElB,yBAAK,QAAQ,eACT,aAAa,CAAC,IACd,gBACE,cAAc,CAAC,IACf;AACN,yBAAK,SAAS,gBACV,cAAc,CAAC,IACf;AACJ,yBAAK,OAAO,cACR,YAAY,CAAC,IACb,eACE,aAAa,CAAC,IACd;AACN,yBAAK,QAAQ,eACT,aAAa,CAAC,IACd;AACJ,yBAAK,OAAO,eACR,aAAa,CAAC,EAAE,KAAI,IACpB,gBACE,cAAc,CAAC,EAAE,KAAI,IACrB;AACN,yBAAK,QAAQ,gBAAgB,cAAc,CAAC,EAAE,KAAI,IAAK;AACvD,yBAAK,OAAO,eACR,aAAa,CAAC,EAAE,QAAQ,OAAO,EAAE,IACjC,gBACE,cAAc,CAAC,EAAE,QAAQ,OAAO,EAAE,IAClC;AAEN,yBAAK,QAAQ,SAAS,OAAO,CAAC,IAAI;AAClC,yBAAK,SAAS,KAAK;AACnB,yBAAK,UACH,CAAC,aACD,UAAU,CAAC,MAAM,UACjB,UAAU,CAAC,MAAM;AACnB,wBAAI,OAAO;AACX,wBAAI,aAAa;AACf,6BAAO,YAAY,CAAC,EAAE,QAAQ,eAAe,EAAE;oBACjD;AAEA,yBAAK,OAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,GAAG,CAAC,EAAE,YAAW;AACpE,wBAAI;AAAU,2BAAK,IAAI,SAAS,CAAC;AAEjC,wBAAI,OAAO,KAAK,QAAQ,KAAK;AAC3B;oBACF;AACA,wBAAI,KAAK,UAAU,MAAM,KAAK,UAAU,aAAa,aAAa,KAAK;AACrE;oBACF;AAEA,yBAAK,QAAQ,CAAA;AACb,yBAAK,KAAK;AACV,yBAAK,SAAS,QAAQ,CAAC;AACvB,yBAAK,QAAQ;AACb,yBAAK,YAAY,CAAA;AACjB,yBAAK,aAAa,CAAA;AAClB,yBAAK,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACrC,kCAAc,KAAK,MAAM,IAAI,CAAC,MAAM,QAAQ,KAAK,KAAK;AACtD,0BAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;AACjC,6BAAS,IAAI,IAAI;kBAEnB;AAEA,2BAAS,SAAS,SAAS,QAAQ;AAEnC,sBAAI,EAAC,GAAA,4CAAA,SAAQ,QAAQ,GAAG;AACtB,6BAAS,KAAK,QAAQ,KAAK,MAAM,QAAQ,MAAM;AAC7C,0BAAI,SAAS,MAAM,EAAE;AACrB,+BAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,8BAAM,OAAO,OAAO,CAAC;AACrB,4BAAI,SAAS;AAAW;AACxB,4BAAI,KAAK,UAAU,YAAY,KAAK,SAAS,SAAS,KAAK,MAAM,GAAG;AAClE,gCAAM,OAAO,SAAS,KAAK,MAAM,EAAE,KAAK,KAAK;AAC7C,+BAAK,KAAK,KAAK,CAAC;AAChB,8BAAI,KAAK,SAAS,GAAG;AACnB,gCAAI,KAAK,CAAC,KAAK;AAAK,mCAAK,UAAU;qCAC1B,KAAK,CAAC,KAAK;AAAK,mCAAK,QAAQ;0BACxC;wBACF;sBACF;oBACF;kBACF;AAEA,sBAAI,QAAQ,cAAc,IAAI,YAAY,GAAG;AAC3C,wBAAI,CAAC,QAAQ,QAAQ;AACnB,4BAAM,KAAK,CAAA,CAAE;AACb,gCAAU,KAAK,EAAE,YAAY,CAAA,EAAE,CAAE;oBACnC;kBACF;gBACF;AAEA,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,sBACE,eACA,EAAE,QAAQ,0BAA0B,CAAC,QAAQ,6BAC7C;AACA,qBAAA,GAAA,mDAAA,gBAAe,MAAM,CAAC,GAAG,OAAO;kBAClC;AAEA,sBAAI,eAAe;AACjB,qBAAA,GAAA,8DAAA,2BAA0B,MAAM,CAAC,GAAG,QAAQ,WAAW;kBACzD;AAEA,mBAAA,GAAA,sDAAA,mBACE,UAAU,CAAC,EAAE,YACb,MAAM,CAAC,GACP,SACA,UAAU,CAAC,EAAE,KAAK;AAEpB,sBACE,QAAQ,0BACR,CAAC,QAAQ,8BACT;AAEA,qBAAA,GAAA,mDAAA,gBAAe,MAAM,CAAC,GAAG,OAAO;gBACpC;AACA,uBAAO;cAET;AAAC;;;;;;;;;;;;;AC5cM,uBAAS,OAAO,KAAa,SAA0B;AAC5D,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,OAAO,QAAQ,UAAU;AAE3B,wBAAM,KAAK,MAAM,GAAG;gBACtB;AACA,oBAAI,YAAa,IAAY;AAC7B,oBAAI,cAAc,UAAU,CAAC,EAAE;AAC/B,oBAAI,cAAc,UAAU,CAAC,EAAE;AAE/B,oBAAI,SAAS,UAAU,CAAC,EAAE;AAC1B,oBAAI,aACF,YAAY,UAAa,QAAQ,eAAe,SAC5C,QAAQ,aACR,WAAW;AAEjB,oBAAI,SAAS,MAAM,MAAM,SAAS,CAAC,EAAE;AAGrC,yBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,sBAAI,cAAc,YAAY,CAAC;AAC/B,sBAAI,OAA4B,CAAA;AAChC,uBAAK,KAAK,YAAY;AAEtB,uBAAK,IAAI,YAAY;AACrB,uBAAK,IAAI,YAAY;AACrB,uBAAK,IAAI,YAAY,KAAK;AAE1B,uBAAK,QAAQ,CAAA;AACb,uBAAK,YAAY,CAAA;AAEjB,sBAAI,OAAO,YAAY,KAAK;AAC5B,uBAAK,OAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;AAEjE,uBAAK,SAAS,MAAM,MAAM,SAAS,CAAC,EAAE;AACtC,sBAAI,YAAY;AACd,yBAAK,QAAQ,OAAO,YAAY,KAAK,CAAC;kBACxC;AACA,wBAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;gBACnC;AACA,yBAASpD,KAAI,GAAGA,KAAI,YAAY,QAAQA,MAAK;AAC3C,sBAAI,cAAc,YAAYA,EAAC;AAC/B,sBAAI,aAAa,YAAY,IAAI;AACjC,sBAAI,WAAW,YAAY,IAAI;AAC/B,sBAAI,YAAY,YAAY,KAAK;AAEjC,sBAAI,YAAY,MAAM,MAAM,SAAS,CAAC,EAAE,UAAU;AAClD,sBAAI,aAAa,MAAM,MAAM,SAAS,CAAC,EAAE,QAAQ;AAEjD,4BAAU,MAAM,KAAK,QAAQ;AAC7B,4BAAU,UAAU,KAAK,SAAS;AAClC,6BAAW,MAAM,KAAK,UAAU;AAChC,6BAAW,UAAU,KAAK,SAAS;gBACrC;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3DA,oBAAM,wBAAwB,SAC5B,MACA,GACA,GACA,GAAS;AAET,uBAAO,IAAI,oCAAA,QAAQ,GAAG,GAAG,CAAC,EAAE,aAAa,IAAI;cAC/C;AASO,uBAAS,IAAI,KAAa,UAA6B,CAAA,GAAE;AAC9D,sBAAM,QAAqD,CAAA;AAC3D,sBAAM,aAAa,CAAC,QAAQ;AAC5B,sBAAM,YAAa,MAAM,YAAY,CAAA;AACrC,sBAAM,cACJ,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AAGrD,yBAAS,sBAAsB,QAAgB,WAAiB;AAC9D,wBAAM,WAAqB,CAAA;AAC3B,sBAAI,eAAe;AACnB,sBAAI,aAAa;AACjB,yBAAO,aAAa,OAAO,QAAQ;AACjC,2BACE,OAAO,UAAU,YAAY,aAAa,UAAU,MAAM,MACxD,aACF,aAAa,OAAO,QACpB;AAEA,0BAAI,OAAO,UAAU,MAAM,KAAK;AAC9B;AACA,+BAAO,aAAa,OAAO,UAAU,OAAO,UAAU,MAAM,KAAK;AAC/D;wBACF;AAEA,+BACE,OAAO,UAAU,YAAY,aAAa,UAAU,MAAM,MACxD,aACF,aAAa,OAAO,QACpB;AACA;wBACF;sBACF,WAAW,OAAO,UAAU,MAAM,KAAK;AACrC;AACA,+BAAO,aAAa,OAAO,UAAU,OAAO,UAAU,MAAM,KAAK;AAC/D;wBACF;AACA;sBACF,OAAO;AACL;sBACF;oBACF;AACA,6BAAS,KAAK,OAAO,UAAU,cAAc,UAAU,CAAC;AACxD,mCAAe,aAAa,aAAa,UAAU;kBACrD;AACA,yBAAO;gBACT;AAEA,sBAAM,QAAQ,IAAI,MAAM,UAAU;AAElC,sBAAM,gBAA0B,CAAA;AAChC,oBAAI,eAAe;AACnB,yBAASqD,WAAU,GAAGA,WAAU,MAAM,QAAQA,YAAW;AAIvD,sBAAI,OAAO,MAAMA,QAAO,EAAE,MAAM,GAAG,EAAE,CAAC;AAKtC,sBAAI,cAAc;AAChB,wBAAI,KAAK,CAAC,MAAM,KAAK;AACnB,qCAAe;oBACjB;kBACF,OAAO;AACL,wBAAI,KAAK,CAAC,MAAM,KAAK;AACnB,qCAAe;oBACjB;kBACF;AAEA,sBAAI,gBAAgB,SAAS,IAAI;AAC/B,wBAAI,CAAC,cAAc;AACjB,6BAAO,KAAK,KAAI;AAChB,0BAAI,KAAK,CAAC,MAAM,KAAK;AAGnB,8BAAM,MAAM,KAAK,MAAM,IAAI,EAAE,CAAC,EAAE,QAAQ,GAAG;AAC3C,4BAAI,MAAM,IAAI;AACZ,8BAAI,UAAU,KAAK,MAAM,EAAE;AAC3B,kCAAQ,GAAG,IAAI;AACf,iCAAO,QAAQ,KAAK,EAAE;AACtB,iCAAO,KAAK,UAAU,GAAG,GAAG,IAAI,MAAM,KAAK,UAAU,MAAM,CAAC;wBAC9D;sBACF;oBACF;AACA,kCAAc,KAAK,IAAI;kBACzB;gBACF;AAEA,oBAAI,UAAU;AACd,uBAAO,UAAU,cAAc,QAAQ;AACrC,yBACE,CAAC,cAAc,OAAO,EAAE,WAAW,OAAO,KAC1C,cAAc,OAAO,MAAM,eAC3B;AACA;kBACF;AACA;AAGA,wBAAM,QAA6B,CAAA;AACnC,yBACE,UAAU,cAAc,UACxB,CAAC,cAAc,OAAO,EAAE,WAAW,OAAO,GAC1C;AACA,wBAAI,cAAc,OAAO,EAAE,CAAC,MAAM,QAAW;AAC3C;oBACF,WAAW,cAAc,OAAO,EAAE,CAAC,MAAM,KAAK;AAC5C,4BAAM,eAAe,cAAc,OAAO,EACvC,MAAM,IAAI,EAAE,CAAC,EACb,YAAW;AACd,4BAAM,WAAY,MAAM,YAAY,IAAI,MAAM,YAAY,KAAK,CAAA;AAG/D,4BAAM,aAAa,cAAc,OAAO,EAAE,UACxC,cAAc,OAAO,EAAE,QAAQ,YAAY,IAAI,aAAa,MAAM;AAEpE,0BAAI,eAAe,IAAI;AACrB;AACA,4BAAI,cAAc,OAAO,EAAE,CAAC,MAAM,KAAK;AACrC,8BAAI,YAAY,cAAc,OAAO,EAAE,UAAU,CAAC;AAClD;AACA,iCAAO,cAAc,OAAO,MAAM,KAAK;AACrC,wCAAY,YAAY,OAAO,cAAc,OAAO;AACpD;0BACF;AACA,mCAAS,KAAK,SAAS;wBACzB,OAAO;AACL,mCAAS,KAAK,cAAc,OAAO,CAAC;wBACtC;sBACF,OAAO;AACL,iCAAS,KAAK,WAAW,KAAI,CAAE;sBACjC;AACA;oBACF,WAAW,cAAc,OAAO,EAAE,UAAU,GAAG,CAAC,MAAM,SAAS;AAC7D;AACA,4BAAM,YAAY,CAAA;AAClB,6BACE,cAAc,OAAO,MAAM,MAC3B,cAAc,OAAO,EAAE,CAAC,MAAM,KAC9B;AACA,4BAAI,cAAc,OAAO,MAAM,IAAI;AACjC,8BAAI,eAAe,cAAc,OAAO,EACrC,MAAM,IAAI,EAAE,CAAC,EACb,YAAW;AACd,8BAAI,WAAY,MAAM,YAAY,IAAI,MAAM,YAAY,KAAK,CAAA;AAC7D,oCAAU,KAAK,QAAQ;wBACzB;AACA;sBACF;AAEA,0BAAI,kBAAkB;AACtB,6BACE,UAAU,cAAc,UACxB,cAAc,OAAO,EAAE,CAAC,MAAM,OAC9B,CAAC,cAAc,OAAO,EAAE,WAAW,OAAO,KAC1C,CAAC,cAAc,OAAO,EAAE,WAAW,OAAO,GAC1C;AACA,4BAAIC,QAAO,sBAAsB,cAAc,OAAO,GAAG,GAAG;AAC5D,iCAAS,QAAQ,GAAG,QAAQA,MAAK,QAAQ,SAAS;AAChD,8BAAIA,MAAK,KAAK,MAAM,IAAI;AACtB,sCAAU,eAAe,EAAE,KAAKA,MAAK,KAAK,CAAC;AAC3C,+CAAmB,kBAAkB,KAAK,UAAU;0BACtD;wBACF;AACA;sBACF;oBACF,OAAO;AACL;oBACF;kBACF;AAEA,4BAAU,KAAK,EAAE,YAAY,CAAA,EAAE,CAAE;AAGjC,wBAAM,KAAK,CAAA,CAAE;AACb,wBAAM,YACJ,MAAM,kBAAkB,SACpB,MAAM,cAAc,SACpB,MAAM,iBAAiB;AAE7B,sBAAI;AACJ,sBAAI,MAAM,mBAAmB,QAAW;AACtC,0BAAM,IAAI,WAAW,MAAM,cAAc;AACzC,0BAAM,IAAI,WAAW,MAAM,cAAc;AACzC,0BAAM,IAAI,WAAW,MAAM,cAAc;AACzC,0BAAM,YAAY,WAAW,MAAM,iBAAiB,KAAK;AACzD,0BAAM,WAAW,WAAW,MAAM,gBAAgB,KAAK;AACvD,0BAAM,YAAY,WAAW,MAAM,iBAAiB,KAAK;AAEzD,wCAAmB,GAAA,oCAAA,mBACjB,GACA,GACA,GACA,WACA,UACA,SAAS;AAEX,8BAAU,UAAU,SAAS,CAAC,EAAE,QAAQ;sBACtC;sBACA;sBACA;sBACA,OAAO;sBACP,MAAM;sBACN,OAAO;;kBAEX;AAEA,2BAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,wBACE,MAAM,yBAAyB,UAC/B,MAAM,qBAAqB,CAAC,MAAM;AAElC;AACF,0BAAM,OAAiB,CAAA;AACvB,wBAAI,MAAM,uBAAuB,QAAW;AAC1C,2BAAK,IAAI,WAAW,MAAM,mBAAmB,CAAC,CAAC;AAC/C,2BAAK,IAAI,WAAW,MAAM,mBAAmB,CAAC,CAAC;AAC/C,2BAAK,IAAI,WAAW,MAAM,mBAAmB,CAAC,CAAC;oBACjD,OAAO;AACL,4BAAM,SAAS,sBACb,kBACA,WAAW,MAAM,mBAAmB,CAAC,CAAC,GACtC,WAAW,MAAM,mBAAmB,CAAC,CAAC,GACtC,WAAW,MAAM,mBAAmB,CAAC,CAAC,CAAC;AAEzC,2BAAK,IAAI,OAAO;AAChB,2BAAK,IAAI,OAAO;AAChB,2BAAK,IAAI,OAAO;oBAClB;AACA,yBAAK,QAAQ,MAAM,0BACf,MAAM,wBAAwB,CAAC,IAC/B,MAAM,2BACN,MAAM,yBAAyB,CAAC,IAChC;AACJ,yBAAK,SAAS,MAAM,2BAChB,MAAM,yBAAyB,CAAC,IAChC;AACJ,yBAAK,OAAO,MAAM,yBACd,SAAS,MAAM,uBAAuB,CAAC,CAAC,IACxC,MAAM,0BACN,MAAM,wBAAwB,CAAC,IAC/B;AACJ,yBAAK,OAAO,MAAM,0BACd,MAAM,wBAAwB,CAAC,EAAE,KAAI,IACrC,MAAM,2BACN,MAAM,yBAAyB,CAAC,EAAE,KAAI,IACtC;AACJ,yBAAK,OAAO,MAAM,0BACd,MAAM,wBAAwB,CAAC,EAAE,QAAQ,OAAO,EAAE,IAClD,MAAM,2BACN,MAAM,yBAAyB,CAAC,EAAE,QAAQ,OAAO,EAAE,IACnD;AACJ,yBAAK,UACH,CAAC,MAAM,wBACP,MAAM,qBAAqB,CAAC,MAAM,UAClC,MAAM,qBAAqB,CAAC,MAAM;AACpC,wBAAG,MAAM,2BAA4B;AACnC,2BAAK,IAAI,WAAW,MAAM,0BAA0B,CAAC,CAAC;oBACxD;AACA,wBAAI,OAAO;AACX,wBAAI,MAAM,wBAAwB;AAChC,6BAAO,MAAM,uBAAuB,CAAC,EAAE,QAAQ,eAAe,EAAE;oBAClE,WAAW,MAAM,kBAAkB;AAGjC,6BAAO,MAAM,iBAAiB,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,QAAQ,YAAY,EAAE;oBACvE;AACA,yBAAK,OAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,GAAG,CAAC,EAAE,YAAW;AACpE,yBAAK,QAAQ,CAAA;AACb,yBAAK,KAAK;AACV,yBAAK,SAAS;AACd,yBAAK,YAAY,CAAA;AACjB,yBAAK,aAAa,CAAA;AAClB,0BAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;kBACnC;AAEA,sBAAI,MAAM,8BAA8B,UAAa,CAAC,YAAY;AAChE,6BAAS,IAAI,GAAG,IAAI,MAAM,0BAA0B,QAAQ,KAAK;AAC/D,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,UAAU,WACd,MAAM,kCAAkC,EAAE,CAAC,CAAC;AAE9C,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,UAAU,WACd,MAAM,kCAAkC,EAAE,CAAC,CAAC;AAE9C,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,WAAW,WACf,MAAM,qCAAqC,EAAE,CAAC,CAAC;AAEjD,4BAAM,UAAU,WACd,MAAM,kCAAkC,EAAE,CAAC,CAAC;AAG9C,4BAAM,SAAS,IAAI,oCAAA,QACjB,UACA,UACA,UACA,SACA,UACA,UACA,UACA,SACA,UACA,UACA,UACA,OAAO;AAET,gCAAU,UAAU,SAAS,CAAC,EAAE,WAAW,KAAK,MAAM;oBACxD;kBACF;AACA,wBAAM,YAAY,SAAU,MAAY;AACtC,0BAAM,WAAW,KAAK,MAAM,GAAG;AAC/B,2BAAO,KAAK,QAAQ,WAAW,EAAE;AACjC,0BAAM,gBAAgB,KAAK,MAAM,GAAG;AAEpC,wBAAI,WAAmB;AACvB,wBAAI,cAAc,CAAC,MAAM,QAAW;AAClC,oCAAc;oBAChB,OAAO;AACL,oCAAc,SAAS,cAAc,CAAC,CAAC;oBACzC;AACA,wBAAI,cAAc,CAAC,MAAM,IAAI;AAC3B,kCAAY;oBACd,OAAO;AACL,kCAAY,SAAS,cAAc,CAAC,CAAC;oBACvC;AACA,2BAAQ,YAAY,eAAgB,WAAW,KAAK;kBACtD;AACA,sBAAI,MAAM,+BAA+B,UAAa,CAAC,YAAY;AACjE,6BAAS,MAAM,GAAG,MAAM,MAAM,2BAA2B,QAAQ,OAAO;AACtE,4BAAM,YAAY,MAAM,2BAA2B,GAAG,EAAE,QACtD,UACA,EAAE;AAEJ,4BAAM,mBAAmB,UACtB,MAAM,GAAG,EACT,IAAI,SAAU,KAAW;AACxB,+BAAO,IAAI,QAAQ,MAAM,IAAI;sBAC/B,CAAC;AACH,0BAAI,SAAS,IAAI,oCAAA,QACf,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,CAAC;AAEH,+BAAS,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACtC,8BAAM,QAAQ,iBAAiB,KAAK,EAAE,MAAM,GAAG;AAC/C,iCAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,gCAAM,OAAO,MAAM,CAAC;AACpB,8BAAI,SAAS;AAAI;AACjB,gCAAM,cAAc,UAAU,IAAI;AAClC,8BAAI,KAAK,MAAM,GAAG,GAAG;AACnB,mCAAO,SAAS,QAAQ,CAAC,IAAI;0BAC/B,WAAW,KAAK,MAAM,GAAG,GAAG;AAC1B,mCAAO,SAAS,QAAQ,CAAC,IAAI;0BAC/B,WAAW,KAAK,MAAM,GAAG,GAAG;AAC1B,mCAAO,SAAS,QAAQ,CAAC,IAAI;0BAC/B,OAAO;AACL,mCAAO,SAAS,QAAQ,EAAE,IAAI;0BAChC;wBACF;sBACF;AACA,4BAAM,oBAAoB,iBAAiB,WAAU;AACrD,4BAAM,oBAAoB,IAAI,oCAAA,QAAO,EAAG,WACtC,mBACA,IAAI;AAEN,+BAAS,IAAI,oCAAA,QAAO,EAAG,iBAAiB,QAAQ,iBAAiB;AACjE,+BAAS,IAAI,oCAAA,QAAO,EAAG,iBAAiB,mBAAmB,MAAM;AACjE,gCAAU,UAAU,SAAS,CAAC,EAAE,WAAW,KAAK,MAAM;oBACxD;kBACF;gBACF;AACA,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,sBACE,eACA,EAAE,QAAQ,0BAA0B,CAAC,QAAQ,6BAC7C;AACA,qBAAA,GAAA,mDAAA,gBAAe,MAAM,CAAC,GAAG,OAAO;kBAClC;AACA,mBAAA,GAAA,8DAAA,2BAA0B,MAAM,CAAC,GAAG,QAAQ,WAAW;AACvD,mBAAA,GAAA,sDAAA,mBACE,UAAU,CAAC,EAAE,YACb,MAAM,CAAC,GACP,SACA,UAAU,CAAC,EAAE,KAAK;AAEpB,sBACE,QAAQ,0BACR,CAAC,QAAQ,8BACT;AAEA,qBAAA,GAAA,mDAAA,gBAAe,MAAM,CAAC,GAAG,OAAO;gBACpC;AAEA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;;;;;AC5bO,uBAAS,KAAK,KAAa,SAA0B;AAC1D,0BAAU,WAAW,CAAA;AACrB,sBAAM,QAAqD,CAAC,CAAA,CAAE;AAC9D,oBAAI,QAAQ,IAAI,MAAM,OAAO;AAC7B,sBAAM,cACJ,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AAErD,oBAAI,MAAM,SAAS;AAAG,yBAAO;AAE7B,oBAAI,UAAU,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AAEzE,sBAAM,SAAS,KAAK,IAAI,WAAW,QAAQ,CAAC,CAAC,CAAC;AAE9C,oBAAI,QAAmE;kBACrE,QAAQ;kBACR,MAAM;kBACN,MAAM;kBACN,SAAS;kBACT,QAAQ;;AAGV,sBAAM,SAAU,MAAM,SAAS,IAAI,oCAAA,QACjC,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,CAAC;AAGxB,0BAAU,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AACrE,0BAAU,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AASrE,sBAAM,aAAc,QAAQ,CAAC,IAAY,IAAI,WAAW;AACxD,uBAAO,eAAe,UAAU;AAEhC,sBAAM,KAAK,KAAK,IAAI,QAAQ,CAAC,CAAQ;AACrC,sBAAM,OAAO,IAAI,oCAAA,QACf,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,CAAC,EACtB,eAAe,UAAU;AAE3B,0BAAU,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AACrE,sBAAM,KAAK,KAAK,IAAI,QAAQ,CAAC,CAAQ;AACrC,sBAAM,OAAO,IAAI,oCAAA,QACf,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,CAAC,EACtB,eAAe,UAAU;AAE3B,0BAAU,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AACrE,sBAAM,KAAK,KAAK,IAAI,QAAQ,CAAC,CAAQ;AACrC,sBAAM,OAAO,IAAI,oCAAA,QACf,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,GACrB,WAAW,QAAQ,CAAC,CAAC,CAAC,EACtB,eAAe,UAAU;AAE3B,sBAAM,OAAO,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE;AAClC,sBAAM,OAAO,IAAI,oCAAA,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAE/C,oBACE,KAAK,KAAK,KACV,KAAK,KAAK,KACV,KAAK,KAAK,KACV,KAAK,KAAK,KACV,KAAK,KAAK,KACV,KAAK,KAAK,GACV;AAEA,wBAAM,UAAU,IAAI,oCAAA,QAClB,KAAK,GACL,KAAK,GACL,KAAK,GACL,GACA,KAAK,GACL,KAAK,GACL,KAAK,GACL,GACA,KAAK,GACL,KAAK,GACL,KAAK,GACL,GACA,GACA,GACA,GACA,CAAC;AAGH,sBAAI,IAAI,IAAI,oCAAA,QAAO,EAAG,gBAAgB,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC;AAClE,wBAAM,UAAU,MAAM,QAAQ,iBAAiB,GAAG,MAAM,OAAO;AAC/D,wBAAM,SAAS,MAAM,QAAQ,mBAAkB;AAE/C,wBAAM,SAAS,IAAI,oCAAA,QAAQ,GAAG,GAAG,CAAC;AAClC,wBAAM,OAAO,IAAI,oCAAA,QAAQ,GAAG,GAAG,CAAC;gBAClC;AAEA,sBAAM,YAAY,CAAC,EAAE,MAAY,CAAE;AAGnC,wBAAQ,MAAM,OAAO,GAAG,MAAM;AAE9B,oBAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,oBAAI,MAAM,QAAQ,MAAM;AAExB,yBAAS,IAAI,OAAO,IAAI,KAAK,EAAE,GAAG;AAChC,sBAAI,OAA4B,CAAA;AAChC,uBAAK,SAAS;AACd,sBAAI,OAAO,MAAM,IAAI,KAAK;AAC1B,sBAAI,SAAS,KAAK,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AACpE,uBAAK,OAAO,iDAAA,aAAa,OAAO,CAAC,CAAC;AAClC,uBAAK,IAAI,WAAW,OAAO,CAAC,CAAC,IAAI;AACjC,uBAAK,IAAI,WAAW,OAAO,CAAC,CAAC,IAAI;AACjC,uBAAK,IAAI,WAAW,OAAO,CAAC,CAAC,IAAI;AAEjC,uBAAK,UAAU;AACf,uBAAK,QAAQ,CAAA;AACb,uBAAK,YAAY,CAAA;AACjB,uBAAK,aAAa,CAAA;AAClB,wBAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;gBACnC;AAEA,oBAAI,aAAa;AACf,2BAAStD,KAAI,GAAGA,KAAI,MAAM,QAAQA;AAAK,qBAAA,GAAA,gDAAA,aAAY,MAAMA,EAAC,GAAG,OAAO;gBACtE;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;AClIO,uBAAS,IAAI,KAAa,SAA0B;AACzD,sBAAM,WAA8C,CAAA;AACpD,sBAAM,QAAQ,IAAI,MAAM,UAAU;AAClC,uBAAO,MAAM,SAAS,GAAG;AACvB,wBAAM,YAAY,SAAS,MAAM,CAAC,CAAC;AACnC,wBAAM,iBACJ,MAAM,SAAS,KACf,MAAM,SAAS,KACf,aAAa,KACb,MAAM,SAAS,YAAY;AAC7B,sBAAI;AAAgB;AACpB,wBAAM,QAAoB,CAAA;AAC1B,2BAAS,KAAK,KAAK;AACnB,sBAAI,SAAS;AACb,wBAAM,QAAQ,MAAM;AACpB,wBAAM,MAAM,QAAQ;AACpB,2BAAS,IAAI,OAAO,IAAI,KAAK,KAAK;AAChC,0BAAM,OAAO,MAAM,QAAQ;AAC3B,0BAAM,OAAiB,CAAA;AACvB,yBAAK,SAAS;AACd,yBAAK,OAAO,KAAK,MAAM,IAAI,EAAE,EAAE,KAAI;AACnC,yBAAK,QAAO,GAAA,mDAAA,gBAAe,KAAK,MAAM,IAAI;AAE1C,yBAAK,IAAI,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;AAC7C,yBAAK,IAAI,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;AAC7C,yBAAK,IAAI,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;AAC7C,yBAAK,OAAO,SAAS,KAAK,MAAM,GAAG,CAAC,CAAC;AACrC,yBAAK,OAAO,KAAK,MAAM,GAAG,EAAE,EAAE,KAAI;AAClC,yBAAK,QAAQ,CAAA;AACb,yBAAK,YAAY,CAAA;AACjB,yBAAK,aAAa,CAAA;AAClB,wBAAI,KAAK,SAAS,IAAI;AACpB,2BAAK,KAAK,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;AAC9C,2BAAK,KAAK,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;AAC9C,2BAAK,KAAK,KAAO,WAAW,KAAK,MAAM,IAAI,EAAE,CAAC;oBAChD;AACA,0BAAM,CAAC,IAAI;kBACb;AAEA,sBAAI,MAAM,UAAU,SAAS,GAAG;AAE9B,0BAAM,OAAO,MAAM,QAAQ;AAC3B,0BAAM,MAAM,KAAK,KAAI,EAAG,MAAM,KAAK;AACnC,wBAAI,IAAI,WAAW,GAAG;AACpB,+BAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,4BAAI,CAAC,KAAK,WAAW,IAAI,CAAC,CAAC,IAAI,IAAM,SAAQ;sBAC/C;AACA,+BAAS,MAAM;oBACjB;kBACF;AACA,wBAAM,OAAO,GAAG,EAAE,MAAM;gBAC1B;AAEA,yBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,mBAAA,GAAA,mDAAA,gBAAe,SAAS,CAAC,GAAG,OAAO;gBACrC;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;AC9DA,oBAAM,MAA6B;gBAC/B,IAAI;gBACJ,MAAM;gBACN,SAAS;gBACT,GAAG;gBACH,QAAQ;gBACR,GAAG;gBACH,IAAI;gBACJ,IAAI;gBACJ,KAAK;gBACL,GAAG;gBACH,IAAI;gBACJ,IAAI;gBACJ,KAAK;gBACL,GAAG;gBACH,IAAI;gBACJ,IAAI;gBACJ,KAAK;;AAGF,uBAAS,UAAU,KAAa,SAA0B;AAC/D,sBAAM,QAAsB,CAAA;AAC5B,sBAAM,QAAQ,IAAI,MAAM,UAAU;AAClC,oBAAI,SAAS;AACb,oBAAI,YAAY;AAChB,oBAAI,QAAQ;AACZ,uBAAO,QAAQ,MAAM,SAAS,GAAG;AAC/B,2BAAS,IAAI,OAAO,IAAI,MAAM,QAAQ,KAAK;AACzC,wBAAI,MAAM,CAAC,EAAE,MAAM,uBAAuB;AACxC,kCAAY,SAAS,MAAM,IAAI,CAAC,CAAC;AACnC,wBAAI,MAAM,CAAC,EAAE,MAAM,aAAa,GAAG;AACjC,+BAAS,IAAI;AACb;oBACF;kBACF;AACA,wBAAM,QAAQ,MAAM,SAAS,CAAC,EAAE,QAAQ,gBAAgB,EAAE,EAAE,MAAM,GAAG;AACrE,wBAAM,KAAK,CAAA,CAAE;AACb,2BAASE,KAAI,QAAQA,KAAI,SAAS,WAAWA,MAAK;AAChD,0BAAM,OAAiB,CAAA;AACvB,0BAAM,aAAa,CAAA;AACnB,0BAAM,SAAS,MAAMA,EAAC,EAAE,MAAM,GAAG;AACjC,6BAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,4BAAM,OAAO,IAAI,MAAM,CAAC,CAAC;AACzB,0BAAI,SAAS,QAAW;AACtB,4BAAI,SAAS;AAAU,+BAAK,IAAI,IAAI,SAAS,OAAO,CAAC,CAAC;iCAC7C,SAAS,OAAO,SAAS,OAAO,SAAS;AAChD,+BAAK,IAAI,IAAI,WAAW,OAAO,CAAC,CAAC;iCAC1B,SAAS,YAAY,SAAS;AACrC,qCAAW,IAAI,IAAI,WAAW,OAAO,CAAC,CAAC;;AACpC,+BAAK,IAAI,IAAI,OAAO,CAAC;sBAC5B;AACA,2BAAK,aAAa;AAClB,2BAAK,QAAQ,CAAA;AACb,2BAAK,YAAY,CAAA;oBACnB;AACA,0BAAM,MAAM,SAAS,CAAC,EAAEA,KAAI,MAAM,IAAI;kBACxC;AACA,0BAAQ,SAAS,YAAY;gBAC/B;AACA,oBAAI,QAAQ,aAAa;AACvB,2BAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAAK,qBAAA,GAAA,gDAAA,aAAY,MAAM,CAAC,GAAG,OAAO;gBACtE;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DA,kBAAI,eAAe,SAAU,eAAkB;AAC3C,uBAAO,OAAO,aAAa,MAAM,MAAM,aAAa,EAAE,QAAQ,OAAO,EAAE;cAC3E;AAEA,kBAAI,YAAY,SAAU,KAAqB;AAY3C,oBAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AAAG,yBAAO;AAC7C,oBAAI,OAAO;AAAG,yBAAO;AACrB,uBAAO;cACX;AAEA,kBAAI,kBAAkB,oBAAI,IAAI;gBAC1B;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;eAAa;AAOV,uBAAS,WAAW,SAAc,SAA0B;AAE/D,oBAAI,MAAM,CAAC,QAAQ;AACnB,oBAAI,YAAY,QAAQ,SAAS,QAAQ,SAAS;AAClD,oBAAI,eAAe,CAAC,CAAC,QAAQ;AAC7B,oBAAI,gBAAgB,CAAC,QAAQ;AAE7B,oBAAI,aAAa,CAAC,QAAQ;AAC1B,oBAAI,gBAAgB,QAAQ,gBAAgB,QAAQ,gBAAgB;AAEpE,oBAAI,OAAQ,WAAY,UAAU;AAE9B,6BAAU,GAAA,wCAAA,eAAc,OAAO;gBACnC,OAAO;AACH,4BAAU,IAAI,WAAW,OAAO;gBACpC;AAEA,oBAAI,WAAW,KAAK,OAAO,OAAO;AAElC,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,YAAmB,MAAM,YAAY,CAAA;AAGzC,oBAAI,aAAa;AACjB,oBAAI,aAAa;AACjB,oBAAI,YAAY;AAGhB,oBAAI,gBAAgB,SAAS;AAC7B,oBAAI,cAAc,SAAS;AAC3B,oBAAI,aAAa,SAAS;AAC1B,oBAAI,gBAAgB,SAAS;AAC7B,oBAAI,eAAe,SAAS;AAC5B,oBAAI,gBAAgB,SAAS;AAE7B,oBAAI,YAAY,SAAS;AACzB,oBAAI,aAAa;AAAG,yBAAO;AAC3B,oBAAI,CAAC,QAAQ;AAAY,8BAAY;AAErC,oBAAI,GAAW,GAAW,GAAW,IAAY,GAAW;AAI5D,oBAAI,aAAwB,CAAA;AAC5B,oBAAI,CAAC,cAAc,SAAS,mBAAmB,SAAS,gBAAgB,SAAS,GAAG;AAChF,sBAAI,aAAa,SAAS,gBAAgB,aAAa,EAAE;AACzD,uBAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAK;AAC3C,wBAAI,SAAS,IAAI,oCAAA,QAAQ,WAAW,CAAC,EAAE,MAAM;AAC7C,2BAAO,UAAS;AAChB,+BAAW,KAAK,MAAM;kBAC1B;gBACJ;AACA,oBAAI,WAAW;AAEf,oBAAI,SAAS,UAAU;AACnB,sBAAI,IAAI,SAAS;AACjB,6BAAW,EAAE,KAAK,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAC;gBAC5F;AAEA,oBAAI,iBAA4B,CAAA;AAChC,yBAAS,WAAW,QAAQ,CAAC,WAAoD;AAC7E,yBAAO,eAAe,QAAQ,QAAK;AAC/B,mCAAe,EAAE,IAAI,OAAO,QAAQ;kBACxC,CAAC;gBACL,CAAC;AACD,oBAAI,oBAAoB;AAExB,qBAAK,IAAI,GAAG,IAAI,WAAW,KAAK;AAC5B,sBAAI,kBAAkB,SAAS,eAAe,CAAC;AAC/C,sBAAI,SAAS,MAAM,MAAM,SAAS,CAAC;AACnC,sBAAI,gBAA0B,CAAA;AAE9B,4BAAU,KAAK,EAAE,YAAwB,OAAO,SAAQ,CAAE;AAC1D,uBAAK,IAAI,GAAG,IAAI,iBAAiB,EAAE,GAAG;AAElC,wBAAI,kBAAkB,SAAS,eAAe,UAAU;AACxD,wBAAI,UAAU,aACV,SAAS,YAAY,SAAS,aAAa,GAAG,aAAa,IAAI,CAAC,CAAC;AAErE,wBAAI,SAAS,eAAe;AACxB,gCAAU,aACN,SAAS,cAAc,SAAS,aAAa,GAAG,aAAa,IAAI,CAAC,CAAC;oBAE3E;AAEA,wBAAI,aAAa;AACjB,wBAAI,SAAS;AACb,yBAAK,IAAI,GAAG,IAAI,iBAAiB,EAAE,GAAG;AAElC,0BAAI,YAAY,SAAS,UAAU,SAAS,cAAc,UAAU,CAAC;AACrE,0BAAI,iBAAiB,UAAU,aAAa;AAC5C,0BAAI,YAAY;AAChB,0BAAI,iBAAiB;AACrB,0BAAI,eAAe;AAEnB,0BAAI,eAAe;AACf,oCAAY,cAAc,UAAU;AACpC,4BAAI,SAAS,UAAU,SAAS;AAChC,4BAAI,cAAc,KAAK,UAAU,QAAQ;AACrC,2CAAiB;wBACrB;AACA,iCAAS;AACT,4BAAI,YAAY,aAAa;AAC7B,4BAAI,aAAa,cAAc,UAAU,UAAU,cAAc,SAAS,KAAK,MAAM,GAAG;AACpF,yCAAe;wBACnB;sBACJ;AACA,0BAAI,UAAU,SAAS,YAAY,UAAU;AAC7C,0BAAI,YAAY,UAAU;AAC1B,0BAAI,YAAY,UAAU;AAC1B,0BAAI,YAAY;AAGhB,0BAAI,WAAW,gBAAgB,IAAI,SAAS,KAAK,CAAC,eAAe,UAAU;AAE3E,2BAAK,IAAI,GAAG,IAAI,gBAAgB,EAAE,GAAG;AAEjC,4BAAI,UAAU,UAAU,YAAY,CAAC;AACrC,4BAAI,OAAO,WAAW,KAAK;AACvB,uCAAa;AACb;wBACJ;AAEA,4BAAI,UAAU;AACd,4BAAI,aAAa;AACb,oCAAU,YAAY,SAAS;wBACnC;AACA,4BAAI,SAAS;AACb,4BAAI,cAAc,WAAW,SAAS,GAAG;AACrC,mCAAS,OAAO,aAAa,WAAW,SAAS,CAAC;wBACtD;AACA,4BAAI,YAAY;AAChB,4BAAI,eAAe;AACf,sCAAY,cAAc,SAAS;wBACvC;AAEA,4BAAI,UAAU,MAAM,UAAU,aAAa,aAAa,KAAK;AACzD,uCAAa;AACb;wBACJ;AAEA,4BAAI,SAAS,SAAS,WAAW,SAAS;AAC1C,4BAAI,WAAW,UAAU,aAAa,CAAC;AACvC,4BAAI,aAAa;AACjB,4BAAI,UAAU;AAAgB,uCAAa,UAAU,eAAe,CAAC;AACrE,4BAAI,SAAS,SAAS,WAAW,SAAS;AAC1C,4BAAI,SAAS,SAAS,WAAW,SAAS;AAC1C,4BAAI,SAAS,SAAS,WAAW,SAAS;AAE1C,sCAAc,SAAS,IAAI,OAAO;AAClC,+BAAO,KAAK;0BACR,QAAQ;0BACR,KAAK;0BACL,KAAK;0BACL,KAAK;0BACL,QAAQ;0BACR,WAAW;0BACX,SAAS;0BACT,QAAQ;0BACR,SAAS;0BACT,WAAW,WAAW,UAAU,MAAM,MAAM,SAAS;;;;;0BAIrD,UAAU;0BACV,UAAU;0BACV,SAAS;0BACT,QAAQ;0BACR,SAAS,CAAA;0BACT,MAAM,UAAU,SAAS;0BACzB,WAAW;0BACX,SAAS;0BACT,aAAa,CAAA;0BACb,cAAc,EAAE,QAAQ,YAAY,UAAoB;0BACxD,KAAK;yBACR;AAED,qCAAa;sBACjB;AAGA,0BAAI,oBAAoB,UAAU;AAClC,2BAAK,IAAI,GAAG,KAAK,UAAU,cAAc,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC1D,4BAAI,aAAa,YAAY,kBAAkB,IAAI,CAAC;AACpD,4BAAI,aAAa,YAAY,kBAAkB,IAAI,IAAI,CAAC;AACxD,4BAAI,YAAY,UAAU,cAAc,CAAC;AAGzC,4BAAI,KAAK,cAAc,UAAU;AACjC,4BAAI,KAAK,cAAc,UAAU;AACjC,4BAAI,KAAK,OAAO,EAAE;AAClB,4BAAI,KAAK,OAAO,EAAE;AAClB,4BAAI,MAAM,IAAI;AACV,6BAAG,MAAM,KAAK,EAAE;AAChB,6BAAG,UAAU,KAAK,SAAS;AAC3B,6BAAG,MAAM,KAAK,EAAE;AAChB,6BAAG,UAAU,KAAK,SAAS;wBAC/B;sBACJ;AAEA,oCAAc;oBAClB;AAGA,iCAAa;AACb,yBAAK,IAAI,GAAG,IAAI,iBAAiB,EAAE,GAAG;AAElC,oCAAc;oBAElB;AAEA,kCAAc;kBAClB;AAIA,sBAAI,cAAc;AACd,6BAASqD,KAAI,mBAAmBC,MAAK,aAAa,QAAQD,KAAIC,KAAID,MAAK,GAAG;AACtE,0BAAIE,cAAa,aAAaF,EAAC;AAC/B,0BAAIG,cAAa,aAAaH,KAAI,CAAC;AACnC,0BAAII,aAAY,gBAAgB,cAAcJ,KAAI,CAAC,IAAI;AAEvD,0BAAIE,eAAc,WAAW;AACzB,4CAAoBF;AACpB;sBACJ;AAEA,0BAAIK,MAAK,cAAcH,WAAU;AACjC,0BAAII,MAAK,cAAcH,WAAU;AACjC,0BAAII,MAAK,OAAOF,GAAE;AAClB,0BAAIG,MAAK,OAAOF,GAAE;AAClB,0BAAIC,OAAMC,KAAI;AACV,wBAAAD,IAAG,MAAM,KAAKD,GAAE;AAChB,wBAAAC,IAAG,UAAU,KAAKH,UAAS;AAC3B,wBAAAI,IAAG,MAAM,KAAKH,GAAE;AAChB,wBAAAG,IAAG,UAAU,KAAKJ,UAAS;sBAC/B;oBACJ;kBACJ;AAEA,sBAAI,QAAQ,YAAY;AACpB,wBAAI,CAAC,QAAQ;AAAQ,4BAAM,KAAK,CAAA,CAAE;kBACtC;gBACJ;AAEA,oBAAI,CAAC,YAAY;AACb,2BAASK,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK;AACnC,qBAAA,GAAA,sDAAA,mBAAkB,UAAUA,EAAC,EAAE,YAAY,MAAMA,EAAC,GAAG,SAAS,UAAUA,EAAC,EAAE,KAAK;kBACpF;gBACJ;AAEA,oBAAI,iBAAiB,CAAC,cAAc;AAChC,mBAAA,GAAA,8DAAA,2BAA0B,OAAc,QAAQ,WAAW;gBAC/D;AAEA,uBAAO;cACX;AAAC;;;;;;;;;;;;;AChTD,kBAAI,cAAkB;gBACpB,OAAO;gBACP,MAAM;gBACN,OAAO;gBACP,MAAM;gBACN,OAAO;gBACP,MAAM;gBACN,QAAQ;gBACR,OAAO;gBACP,SAAS;gBACT,QAAQ;gBACR,SAAS;gBACT,QAAO;gBACP,SAAQ;gBACR,QAAQ;gBACR,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,QAAO;gBACP,OAAM;gBACN,QAAO;gBACP,OAAM;gBACN,SAAQ;gBACR,QAAO;gBACP,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,SAAQ;gBACR,QAAO;gBACP,SAAQ;gBACR,QAAO;gBACP,SAAQ;gBACR,QAAO;gBACP,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,OAAM;gBACN,MAAK;gBACL,QAAO;gBACP,OAAM;;AAaD,uBAAS,KAAK,KAAa,SAA0B;AAC1D,oBAAI,QAAsC,CAAC,CAAA,CAAE;AAC7C,oBAAI,MAAM;AACV,oBAAI,OAAO,QAAQ,UAAU;AAAa,wBAAM,CAAC,QAAQ;AAIzD,oBAAI,UAAU,IAAI,OAAO,mBAAmB;AAC5C,oBAAI,WAAW,IAAI,OAAO,eAAe;AAGzC,oBAAI,WAAW,MAAM,YAAY;AAAI,yBAAO;AAE5C,oBAAI,QAAQ,IAAI,UAAU,OAAO,EAAE,MAAM,UAAU;AACnD,uBAAO,MAAM,SAAS,GAAG;AAEvB,sBAAI,gBAA0B,CAAA;AAC9B,sBAAI,SAAS,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AACxE,sBAAI,SAAS,SAAS,OAAO,CAAC,CAAC;AAC/B,sBAAI,SAAS;AAEb,sBAAI,OAAO,SAAS;AAAG,6BAAS,SAAS,OAAO,CAAC,CAAC;AAElD,sBAAI,SAAS;AACb,sBAAI;AAEJ,uBAAK,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACjC,wBAAI,MAAM,CAAC,KAAK,iBAAiB;AAC/B,+BAAS,IAAI;AACb;oBACF;kBACF;AAEA,sBAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,sBAAI,MAAM,QAAQ;AAClB,sBAAI;AAEJ,uBAAK,IAAI,OAAO,IAAI,KAAK,KAAK;AAC5B,2BAAO,MAAM,QAAQ;AACrB,6BAAS,KAAK,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AAChE,wBAAI,OAA4B,CAAA;AAEhC,wBAAI,OAAO,OAAO,CAAC;AACnB,wBAAG,YAAY,IAAI,MAAM,QAAW;AAClC,6BAAO,YAAY,IAAI;oBACzB,OAAO;AACL,6BAAO,KAAK,MAAM,GAAG,EAAE,CAAC;AACxB,6BAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;oBAC9D;AAEA,yBAAK,OAAO,OAAO,CAAC;AACpB,yBAAK,OAAO;AAEZ,wBAAI,KAAK,QAAQ,OAAO,KAAK;oBAE7B,OAAO;AAIL,0BAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,0BAAI,SAAS,SAAS,OAAO,CAAC,CAAC;AAC/B,2BAAK,SAAS;AAGd,2BAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,2BAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,2BAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,2BAAK,OAAO,OAAO,CAAC;AACpB,0BAAI,SAAS,WAAW,OAAO,CAAC,CAAC;AAEjC,2BAAK,QAAQ;AACb,2BAAK,QAAQ,CAAA;AACb,2BAAK,YAAY,CAAA;AACjB,2BAAK,aAAa;wBAChB;wBACA,eAAe;;AAEjB,oCAAc,MAAM,IAAI;AAExB,4BAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;oBACnC;kBACF;AAGA,sBAAI,cAAc;AAClB,yBAAO,SAAS,MAAM,QAAQ;AAC5B,wBAAI,MAAM,QAAQ,KAAK,iBAAiB;AACtC,oCAAc;AACd;oBACF;kBACF;AAEA,sBAAI,eAAe,QAAQ;AACzB,yBAAK,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC3B,6BAAO,MAAM,QAAQ;AAErB,+BAAS,KAAK,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,GAAG,EAAE,MAAM,GAAG;AAChE,0BAAI,OAAO,SAAS,OAAO,CAAC,CAAC;AAC7B,0BAAI,WAAW,MAAM,MAAM,SAAS,CAAC,EAAE,cAAc,IAAI,CAAC;AAC1D,0BAAI,KAAK,SAAS,OAAO,CAAC,CAAC;AAC3B,0BAAI,SAAS,MAAM,MAAM,SAAS,CAAC,EAAE,cAAc,EAAE,CAAC;AAGtD,0BAAI,QAAQ,SAAS,OAAO,CAAC,CAAC;AAC9B,0BAAI,MAAM,KAAK;AAAG,gCAAQ;AAE1B,0BAAI,aAAa,UAAa,WAAW,QAAW;AAClD,iCAAS,MAAM,KAAK,cAAc,EAAE,CAAC;AACrC,iCAAS,UAAU,KAAK,KAAK;AAC7B,+BAAO,MAAM,KAAK,cAAc,IAAI,CAAC;AACrC,+BAAO,UAAU,KAAK,KAAK;sBAC7B;oBACF;kBACF;AACA,sBAAI,QAAQ,YAAY;AACtB,wBAAI,CAAC,QAAQ;AAAQ,4BAAM,KAAK,CAAA,CAAE;AAClC,0BAAM,OAAO,GAAG,MAAM;AACtB,0BAAM,MAAM,KAAK,IAAI;AACrB;kBACF,OAAO;AACL;kBACF;gBACF;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;AC5KO,uBAAS,IAAI,KAAa,SAA0B;AACzD,0BAAU,WAAW,CAAA;AACrB,oBAAI,QAAqC,CAAA;AACzC,oBAAI,WAAW,CAAA;AACf,sBAAM,YAAY,CAAA;AAClB,oBAAI,QAAa,IAAI,MAAM,UAAU;AACrC,uBAAO,MAAM,SAAS,GAAG;AACvB,sBAAI,WAAU,GAAA,iDAAA,cAAa,OAAO,SAAS,QAAQ;AACnD,sBAAI,aAAa,QAAQ,CAAC;AAC1B,sBAAI,YAAY,QAAQ,CAAC;AACzB,0BAAQ,QAAQ,CAAC;AAEjB,sBAAI,WAAW,UAAU,GAAG;AAC1B;kBACF;AACA,sBAAI,QAAQ,cAAc,QAAQ,UAAU,MAAM,SAAS,GAAG;AAE5D,wBAAI,MAAM,MAAM,CAAC,EAAE;AACnB,6BAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAE1C,0BAAI,OAAO,WAAW,CAAC;AACvB,2BAAK,QAAQ;AACb,+BAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,6BAAK,MAAM,CAAC,KAAK;sBACnB;AACA,4BAAM,CAAC,EAAE,KAAK,IAAI;oBACpB;kBACF,OAAO;AACL,0BAAM,UAAU,KAAK,SAAS;AAC9B,0BAAM,KAAK,UAAU;kBACvB;AAEA,sBAAI,CAAC,QAAQ,YAAY;AACvB;kBACF;gBACF;AAEA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;ACtCO,uBAAS,IAAI,KAAa,SAA0B;AACrD,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,gBAAgB,CAAC,QAAQ;AAC7B,sBAAM,YAAY,CAAC,EAAC,YAAW,CAAA,EAAE,CAAC;AAClC,oBAAI,gBAA0B,CAAA;AAC9B,oBAAI,QAAQ,IAAI,MAAM,UAAU;AAChC,oBAAI;AACJ,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,yBAAO,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE;AAClC,sBAAI,aAAa,KAAK,UAAU,GAAG,CAAC;AAEpC,sBAAI,WAAW,QAAQ,KAAK,KAAK,GAAG;AAChC,wBAAI,QAAQ,YAAY;AACpB,0BAAI,CAAC,QAAQ;AACT,8BAAM,KAAK,CAAA,CAAE;AACjB;oBACJ,OACK;AACD;oBACJ;kBACJ,WACS,cAAc,YAAY,cAAc,UAAU;AAIvD,wBAAI;AACJ,wBAAI,SAAS,SAAS,KAAK,UAAU,GAAG,EAAE,CAAC;AAC3C,wBAAI,OAAO,KAAK,UAAU,IAAI,EAAE,EAAE,QAAQ,MAAM,EAAE;AAClD,wBAAI,OAAO,KAAK,UAAU,IAAI,EAAE,EAAE,KAAI;AACtC,wBAAI,QAAQ,KAAK,UAAU,IAAI,EAAE;AACjC,wBAAI,OAAO,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AAI1C,wBAAI,OAAO,KAAK,UAAU,EAAE,EAAE,KAAI,EAAG,MAAM,KAAK;AAChD,wBAAI,IAAI,WAAW,KAAK,CAAC,CAAC;AAC1B,wBAAI,IAAI,WAAW,KAAK,CAAC,CAAC;AAC1B,wBAAI,IAAI,WAAW,KAAK,CAAC,CAAC;AAC1B,wBAAI,SAAS,WAAW,KAAK,CAAC,CAAC;AAC/B,wBAAI,SAAS,WAAW,KAAK,CAAC,CAAC;AAE/B,wBAAI,OAAO,KAAK,CAAC;AACjB,wBAAI,KAAK,SAAS,KAAK,KAAK,CAAC,EAAE,YAAW,KAAM,KAAK,CAAC,GAAG;AAGrD,6BAAO,KAAK,UAAU,GAAG,CAAC;oBAC9B;AAEA,wBAAI,KAAK,CAAC,KAAK;AACX,gCAAU;;AAEV,gCAAU;AACd,kCAAc,MAAM,IAAI,MAAM,MAAM,SAAO,CAAC,EAAE;AAC9C,0BAAM,MAAM,SAAO,CAAC,EAAE,KAAK;sBACvB,QAAS;sBACT,KAAM;sBACN,KAAM;sBACN,KAAM;sBACN,QAAS;sBACT,WAAY;sBACZ,SAAU;sBACV,QAAS;sBACT,UAAW;sBACX,QAAS;sBACT,SAAU,CAAA;sBACV,MAAO;sBACP,aAAc,CAAA;sBACd,cAAe;wBACX,UAAW;wBACX,iBAAkB;wBAClB,UAAW;;sBAEf,WAAY;qBACf;kBACL,WAAW,cAAc,UAAU;AAI/B,wBAAI,OAAO,SAAS,KAAK,UAAU,GAAG,EAAE,CAAC;AACzC,wBAAI,WAAW,MAAM,MAAM,SAAO,CAAC,EAAE,cAAc,IAAI,CAAC;AACxD,6BAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,0BAAI,KAAK,SAAS,KAAK,UAAU,CAAE,IAAI,IAAI,IAAI,EAAE,EAAG,CAAC,GAAG,CAAE,IAAI,IAAI,IAAI,EAAE,EAAG,CAAC,IAAI,CAAC,CAAC;AAClF,0BAAI,SAAS,MAAM,MAAM,SAAO,CAAC,EAAE,cAAc,EAAE,CAAC;AACpD,0BAAI,aAAa,UAAa,WAAW,QAAW;AAChD,iCAAS,MAAM,KAAK,cAAc,EAAE,CAAC;AACrC,iCAAS,UAAU,KAAK,CAAC;sBAC7B;oBACJ;kBACJ;gBACJ;AAGA,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,mBAAA,GAAA,mDAAA,gBAAe,MAAM,CAAC,GAAE,OAAO;AAC/B,sBAAI;AACA,qBAAA,GAAA,8DAAA,2BAA0B,MAAM,CAAC,GAAE,QAAQ,WAAW;gBAC9D;AAEA,uBAAO;cACX;AAAC;;;;;;;;;;;;;ACtGI,uBAAS,OAAO,KAAyB;AAC9C,oBAAI,QAAQ,CAAA;AACZ,oBAAI;AACJ,oBAAI,QAAQ;AACZ,oBAAI,QAAQ,IAAI,MAAM,UAAU;AAChC,oBAAI,MAAM,SAAS,KAAK,MAAM,CAAC,EAAE,SAAS,SAAS,GAAG;AACpD,sBAAI,cAAc,MAAM,OAAO,SAAU,MAAI;AAE3C,2BACE,KAAK,SAAS,UAAU,KACxB,KAAK,SAAS,WAAW,KACzB,KAAK,SAAS,QAAQ,KACtB,KAAK,SAAS,OAAO,KACrB,KAAK,SAAS,oBAAoB,KAClC,KAAK,SAAS,wBAAwB,KACtC,KAAK,SAAS,eAAe,KAC7B,KAAK,SAAS,iBAAiB;kBAEnC,CAAC;AACD,sBAAI,QAAQ,SAAS,UAAU;AAC/B,sBAAI,SAAS;AAAI,2BAAO,CAAA;AACxB,sBAAI,MAAM,cAAc,KAAK;AAC7B,sBAAI,YAAY,SAAS,MAAM,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC;AAC1D,sBAAI,WAAW,SAAS,MAAM,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;AACvE,sBAAI,MAAM,SAAS,KAAK,aAAa;AAAG,2BAAO,CAAA;AAC/C,0BAAQ,SAAS,WAAW;AAC5B,sBAAI,SAAS;AAAI,2BAAO,CAAA;AACxB,wBAAM,cAAc,KAAK;AACzB,sBAAI,UAAU,IAAI,CAAC;AACnB,2BAAS,IAAI,GAAG,IAAI,YAAY,IAAI,CAAC,GAAG,KAAK;AAC3C,wBAAI,KAAK,SAAS,YAAY,IAAI,CAAC,CAAC;AAAG,gCAAU,YAAY,IAAI,CAAC;AAClE,6BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,0BAAI,OAAO,CAAA;AACX,0BAAI,aAAa,EAAE,QAAQ,IAAI,OAAO,GAAE;AACxC,2BAAK,SAAS;AACd,2BAAK,IAAI;AACT,2BAAK,IAAI;AACT,2BAAK,IAAI;AACT,2BAAK,OAAO,MAAM,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,EAAE,KAAI;AACrE,2BAAK,OAAO,MAAM,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,KAAI;AACnE,2BAAK,aAAa;AAClB,2BAAK,QAAQ,CAAA;AACb,2BAAK,YAAY,CAAA;AACjB,2BAAK,QAAQ,MAAM;AAEnB,4BAAM,KAAK,IAAI;AACf;oBACF;AACA;kBACF;AACA,0BAAQ,SAAS,QAAQ;AACzB,sBAAI,SAAS,IAAI;AACf,0BAAM,cAAc,KAAK;AACzB,4BAAQ;AACR,8BAAU,IAAI,CAAC;AACf,6BAAS,IAAI,GAAG,IAAI,YAAY,IAAI,CAAC,GAAG,KAAK;AAC3C,0BAAI,KAAK,SAAS,YAAY,IAAI,CAAC,CAAC;AAAG,kCAAU,YAAY,IAAI,CAAC;AAClE,+BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,8BAAM,KAAK,EAAE,WAAW,SAAS,WAC/B,MAAM,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AAEtD;sBACF;AACA;oBACF;kBACF;AAEA,0BAAQ,SAAS,iBAAiB;AAClC,sBAAI,YAAY,CAAA;AAChB,sBAAI,SAAS,IAAI;AACf,0BAAM,cAAc,KAAK;AACzB,8BAAU,IAAI,CAAC;AACf,6BAAS;AACT,6BAAS,IAAI,GAAG,IAAI,WAAW,IAAI,CAAC,GAAG,KAAK;AAC1C,0BAAI,KAAK,SAAS,WAAW,IAAI,CAAC,CAAC;AAAG,kCAAU,WAAW,IAAI,CAAC;AAChE,+BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,kCAAU,KAAK,SAAS,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;sBAC3E;AACA;oBACF;AACA,4BAAQ,SAAS,eAAe;AAChC,wBAAI,SAAS,IAAI;AACf,0BAAI,WAAW,CAAA;AACf,4BAAM,cAAc,KAAK;AACzB,gCAAU,IAAI,CAAC;AACf,+BAAS;AACT,+BAAS,IAAI,GAAG,IAAI,WAAW,IAAI,CAAC,GAAG,KAAK;AAC1C,4BAAI,KAAK,SAAS,WAAW,IAAI,CAAC,CAAC;AAAG,oCAAU,WAAW,IAAI,CAAC;AAChE,iCAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,mCAAS,KAAK,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,EAAE,KAAI,CAAE;wBACvE;AACA;sBACF;AAEA,0BAAI,SAAS;AACb,0BAAI,OAAO;AACX,0BAAI,OAAO;AACX,gCAAU,KAAK,MAAM,SAAO,CAAC;AAC7B,+BAAQ,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACpC,4BAAG,IAAE,KAAK,UAAU,MAAM,GAAG;AAC3B,iCAAO,SAAS,MAAM;AACtB,oCAAU;AACV,kCAAQ;wBACV;AACA,8BAAM,CAAC,EAAE,OAAO;AAChB,8BAAM,CAAC,EAAE,OAAO;sBAClB;oBACF;kBACF;AACA,0BAAQ,SAAS,OAAO;AACxB,sBAAI,SAAS,IAAI;AACf,0BAAM,cAAc,KAAK;AACzB,4BAAQ;AACR,8BAAU,IAAI,CAAC;AACf,6BAAS,IAAI,GAAG,IAAI,YAAY,IAAI,CAAC,GAAG,KAAK;AAC3C,0BAAI,KAAK,SAAS,YAAY,IAAI,CAAC,CAAC;AAAG,kCAAU,YAAY,IAAI,CAAC;AAClE,+BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,8BAAM,KAAK,EAAE,WAAW,QAAQ,WAC9B,MAAM,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AAEtD;sBACF;AACA;oBACF;kBACF;AACA,0BAAQ,SAAS,wBAAwB;AACzC,sBAAI,SAAS,IAAI;AACf,0BAAM,cAAc,KAAK;AACzB,4BAAQ;AACR,8BAAU,IAAI,CAAC;AACf,4BAAQ,QAAQ;AAChB,2BAAO,CAAC,MAAM,KAAK,EAAE,MAAM,QAAQ,GAAG;AACpC,0BAAI,MAAM,QAAQ,CAAC,EAAE,MAAM,QAAQ;AAEjC,kCAAU,YAAY,IAAI,CAAC;AAC7B,+BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,4BAAI,QAAQ,KAAK,GAAG;AAClB,sCAAY,SACV,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,IAAI,CAAC;wBAExD,WAAW,QAAQ,KAAK,GAAG;AACzB,gCAAM,SAAS,EAAE,MAAM,KACrB,SAAS,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,IAAI,CAAC,CAAC;AAEhE,gCAAM,SAAS,EAAE,UAAU,KAAK,CAAC;wBACnC;AACA;sBACF;AACA;oBACF;kBACF;AACA,0BAAQ,SAAS,oBAAoB;AACrC,sBAAI,SAAS,IAAI;AACf,0BAAM,cAAc,KAAK;AACzB,4BAAQ;AACR,8BAAU,IAAI,CAAC;AACf,4BAAQ,QAAQ;AAChB,2BAAO,CAAC,MAAM,KAAK,EAAE,MAAM,QAAQ,GAAG;AACpC,0BAAI,MAAM,QAAQ,CAAC,EAAE,MAAM,QAAQ;AAEjC,kCAAU,YAAY,IAAI,CAAC;AAC7B,+BAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,4BAAI,QAAQ,KAAK,GAAG;AAClB,sCAAY,SACV,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,IAAI,CAAC;wBAExD,WAAW,QAAQ,KAAK,GAAG;AACzB,gCAAM,SAAS,EAAE,MAAM,KACrB,SAAS,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,IAAI,CAAC,CAAC;AAEhE,gCAAM,SAAS,EAAE,MAAM,KAAK,CAAC;wBAC/B;AACA;sBACF;AACA;oBACF;kBACF;gBACF,OAAO;AACL,yBAAO,CAAA;gBACT;AAEA,yBAAS,SAAS,SAAO;AACvB,sBAAItD,SAAQ,MAAM,QAChB,YAAY,OAAO,SAAU,MAAI;AAC/B,2BAAO,KAAK,SAAS,OAAO;kBAC9B,CAAC,EAAE,CAAC,CAAC;AAEP,sBAAI,OAAO,UAAUA,MAAK,KAAKA,SAAQ,GAAG;AACxC,2BAAO,CAAC,MAAMA,MAAK,EAAE,SAAS,QAAQ;AAEpC,sBAAAA;AACF,2BAAOA;kBACT,OAAO;AACL,2BAAO;kBACT;gBACF;AACA,yBAAS,cAAc,GAAC;AACtB,sBAAI,cAAc,MAAM,CAAC,EAAE,MAAM,YAAY;AAC7C,sBAAI,cAAc,MAAM,CAAC,EAAE,MAAM,oBAAoB;AACrD,sBAAI,eAAe,MAAM;AACvB,kCAAc,MAAM,CAAC,EAAE,MAAM,yBAAyB;kBACxD;AACA,yBAAO,CAAC,SAAS,YAAY,CAAC,CAAC,GAAG,SAAS,YAAY,CAAC,CAAC,CAAC;gBAC5D;AACA,uBAAO,CAAC,KAAK;cACf;;;;;;;;;;;;;ACvNA,kBAAI,aAAa,SAAU,OAAY,SAA0B;AAC/D,oBAAI,QAAmC,CAAC,CAAA,CAAE;AAC1C,oBAAI,MAAM;AACV,oBAAI,OAAO,QAAQ,UAAU;AAAa,wBAAM,CAAC,QAAQ;AAEzD,uBAAO,MAAM,SAAS,GAAG;AACvB,sBAAI,MAAM,SAAS;AAAG;AACtB,sBAAI,YAAY,SAAS,MAAM,CAAC,EAAE,UAAU,GAAG,CAAC,CAAC;AACjD,sBAAI,MAAM,SAAS,KAAK,aAAa;AAAG;AACxC,sBAAI,YAAY,SAAS,MAAM,CAAC,EAAE,UAAU,GAAG,CAAC,CAAC;AACjD,sBAAI,SAAS;AACb,sBAAI,MAAM,SAAS,IAAI,YAAY;AAAW;AAG9C,sBAAI,gBAA0B,CAAA;AAC9B,sBAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,sBAAI,MAAM,QAAQ;AAClB,sBAAI,GAAW;AACf,uBAAK,IAAI,OAAO,IAAI,KAAK,KAAK,UAAU;AACtC,2BAAO,MAAM,MAAM;AACnB,wBAAI,OAA4B,CAAA;AAChC,wBAAI,OAAO,KAAK,UAAU,IAAI,EAAE,EAAE,QAAQ,MAAM,EAAE;AAClD,yBAAK,OAAO,KAAK,OACf,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;AAEvD,wBAAI,KAAK,SAAS,OAAO,CAAC,KAAK;AAC7B,2BAAK,SAAS;AACd,oCAAc,CAAC,IAAI,MAAM,MAAM,SAAS,CAAC,EAAE;AAC3C,2BAAK,IAAI,WAAW,KAAK,UAAU,GAAG,EAAE,CAAC;AACzC,2BAAK,IAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AAC1C,2BAAK,IAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AAC1C,2BAAK,UAAU;AACf,2BAAK,QAAQ,CAAA;AACb,2BAAK,YAAY,CAAA;AACjB,2BAAK,aAAa,CAAA;AAClB,2BAAK,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACrC,4BAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;oBACnC;kBACF;AAEA,uBAAK,IAAI,GAAG,IAAI,WAAW,KAAK,UAAU;AACxC,2BAAO,MAAM,MAAM;AACnB,wBAAI,OAAO,cAAc,SAAS,KAAK,UAAU,GAAG,CAAC,CAAC,IAAI,IAAI,KAAK;AACnE,wBAAI,KAAK,cAAc,SAAS,KAAK,UAAU,GAAG,CAAC,CAAC,IAAI,IAAI,KAAK;AACjE,wBAAI,QAAQ,WAAW,KAAK,UAAU,CAAC,CAAC;AACxC,wBAAI,OAAO,QAAQ,eAAe,OAAO,MAAM,aAAa;AAC1D,4BAAM,MAAM,SAAS,CAAC,EAAE,IAAI,EAAE,MAAM,KAAK,EAAE;AAC3C,4BAAM,MAAM,SAAS,CAAC,EAAE,IAAI,EAAE,UAAU,KAAK,KAAK;AAClD,4BAAM,MAAM,SAAS,CAAC,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI;AAC3C,4BAAM,MAAM,SAAS,CAAC,EAAE,EAAE,EAAE,UAAU,KAAK,KAAK;oBAClD;kBACF;AACA,sBAAI,QAAQ,YAAY;AACtB,wBAAI,CAAC,QAAQ;AAAQ,4BAAM,KAAK,CAAA,CAAE;AAClC,2BAAO,MAAM,MAAM,MAAM,UAAU,SAAS,MAAM;AAAQ;AAC1D,0BAAM,OAAO,GAAG,EAAE,MAAM;kBAC1B,OAAO;AACL;kBACF;gBACF;AACA,uBAAO;cACT;AAQA,kBAAI,aAAa,SAAU,OAAY,SAA0B;AAC/D,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,MAAM;AACV,oBAAI,OAAO,QAAQ,UAAU;AAAa,wBAAM,CAAC,QAAQ;AAEzD,uBAAO,MAAM,SAAS,GAAG;AACvB,sBAAI,MAAM,SAAS;AAAG;AAEtB,sBAAI,CAAC,MAAM,CAAC,EAAE,WAAW,mBAAmB;AAAG;AAC/C,sBAAI,CAAC,MAAM,CAAC,EAAE,WAAW,eAAe,KAAK,MAAM,CAAC,EAAE,SAAS;AAAI;AAEnE,sBAAI,SAAS,MAAM,CAAC,EAAE,UAAU,EAAE,EAAE,MAAM,MAAM;AAEhD,sBAAI,OAAO,SAAS;AAAG;AAEvB,sBAAI,YAAY,SAAS,OAAO,CAAC,CAAC;AAClC,sBAAI,MAAM,SAAS,KAAK,aAAa;AAAG;AACxC,sBAAI,YAAY,SAAS,OAAO,CAAC,CAAC;AAClC,sBAAI,SAAS;AAEb,sBAAI,MAAM,SAAS,IAAI,YAAY;AAEjC;AAGF,sBAAI,gBAA0B,CAAA;AAC9B,sBAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,sBAAI,MAAM,QAAQ;AAClB,sBAAI,GAAW;AACf,uBAAK,IAAI,OAAO,IAAI,KAAK,KAAK,UAAU;AACtC,2BAAO,MAAM,MAAM;AACnB,wBAAI,YAAY,KAAK,UAAU,CAAC,EAAE,MAAM,MAAM;AAC9C,wBAAI,UAAW,SAAS,GAAG;AACzB,0BAAI,OAA4B,CAAA;AAChC,0BAAI,OAAO,UAAW,CAAC,EAAE,QAAQ,MAAM,EAAE;AACzC,2BAAK,OAAO,KAAK,OACf,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;AAEvD,0BAAI,KAAK,SAAS,OAAO,CAAC,KAAK;AAC7B,6BAAK,SAAS;AACd,sCAAc,CAAC,IAAI,MAAM,MAAM,SAAS,CAAC,EAAE;AAC3C,6BAAK,IAAI,WAAW,UAAW,CAAC,CAAC;AACjC,6BAAK,IAAI,WAAW,UAAW,CAAC,CAAC;AACjC,6BAAK,IAAI,WAAW,UAAW,CAAC,CAAC;AACjC,6BAAK,UAAU;AACf,6BAAK,QAAQ,CAAA;AACb,6BAAK,YAAY,CAAA;AACjB,6BAAK,aAAa,CAAA;AAClB,6BAAK,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACrC,8BAAM,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;sBACnC;oBACF;kBACF;AAEA,sBAAI,MAAM,MAAM,MAAM;AAAmB;;AACpC;AAEL,sBAAI,cAAc,KAAK,MAAM,MAAM,MAAM;AAAqB;;AACzD;AAEL,uBAAK,IAAI,GAAG,IAAI,WAAW,KAAK,UAAU;AACxC,2BAAO,MAAM,MAAM;AACnB,wBAAI,YAAY,KAAK,UAAU,CAAC,EAAE,MAAM,MAAM;AAC9C,wBAAI,UAAW,SAAS,GAAG;AACzB,0BAAI,OAAO,cAAc,SAAS,UAAW,CAAC,CAAC,IAAI,IAAI,KAAK;AAC5D,0BAAI,KAAK,cAAc,SAAS,UAAW,CAAC,CAAC,IAAI,IAAI,KAAK;AAC1D,0BAAI,QAAQ,WAAW,UAAW,CAAC,CAAC;AACpC,0BAAI,OAAO,QAAQ,eAAe,OAAO,MAAM,aAAa;AAC1D,8BAAM,MAAM,SAAS,CAAC,EAAE,IAAI,EAAE,MAAM,KAAK,EAAE;AAC3C,8BAAM,MAAM,SAAS,CAAC,EAAE,IAAI,EAAE,UAAU,KAAK,KAAK;AAClD,8BAAM,MAAM,SAAS,CAAC,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI;AAC3C,8BAAM,MAAM,SAAS,CAAC,EAAE,EAAE,EAAE,UAAU,KAAK,KAAK;sBAClD;oBACF;kBACF;AACA,sBAAI,QAAQ,YAAY;AACtB,wBAAI,CAAC,QAAQ,QAAQ;AACnB,4BAAM,KAAK,CAAA,CAAE;oBACf;AACA,2BAAO,MAAM,MAAM,MAAM,UAAU,SAAS,MAAM,QAAQ;AACxD;oBACF;AACA,0BAAM,OAAO,GAAG,EAAE,MAAM;kBAC1B,OAAO;AACL;kBACF;gBACF;AACA,uBAAO;cACT;AAUO,uBAAS,IAAI,KAAa,SAA0B;AACzD,oBAAI,YAAY;AAChB,oBAAI,QAAQ,IAAI,MAAM,UAAU;AAChC,oBAAI,MAAM,SAAS,KAAK,MAAM,CAAC,EAAE,SAAS,IAAI;AAC5C,8BAAY,MAAM,CAAC,EAAE,UAAU,IAAI,EAAE;gBACvC;AACA,oBAAI,cAAc,SAAS;AACzB,yBAAO,WAAW,OAAO,OAAO;gBAClC,WAAW,cAAc,SAAS;AAChC,yBAAO,WAAW,OAAO,OAAO;gBAClC;AACA,uBAAO,CAAC,CAAC,EAAE,CAAC;cACd;;;;;;;;;;;;;;;;;;;;;ACtKO,uBAAS,KAAK,KAAa,UAA6B,CAAA,GAAE;AAC/D,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,UAAiD,CAAA;AACrD,sBAAM,cACJ,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AAErD,oBAAI,QAAQ,IAAI,QAAQ,QAAQ,EAAE,EAAE,MAAM,OAAO;AAEjD,oBAAI,MAAM,SAAS,GAAG;AACpB,yBAAO;gBACT;AAEA,oBAAI,MAAM,CAAC,EAAE,MAAM,KAAK,GAAG;AACzB,0BAAQ,SAAS,WAAW,MAAM,CAAC,CAAC;gBACtC,OAAO;AACL,0BAAQ,IACN,kEAAkE;AAEpE,yBAAO;gBACT;AAEA,oBAAI,QAAQ,SAAS,GAAG;AACtB,0BAAQ,IACN,gFAAgF;AAElF,yBAAO;gBACT;AAEA,wBAAQ,OAAO,IAAI,aAAc,MAAM,CAAC,EAAU,QAAQ,QAAQ,EAAE,EAAE,MAAM,KAAK,CAAC;AAClF,wBAAQ,OAAO,IAAI,aAAc,MAAM,CAAC,EAAU,QAAQ,QAAQ,EAAE,EAAE,MAAM,KAAK,CAAC;AAClF,wBAAQ,OAAO,IAAI,aAAc,MAAM,CAAC,EAAU,QAAQ,QAAQ,EAAE,EAAE,MAAM,KAAK,CAAC;AAElF,oBAAI,SAAS,IAAI,oCAAA,QACf,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,GACd,QAAQ,KAAK,CAAC,CAAC;AAGjB,uBAAO,eAAe,QAAQ,MAAM;AACpC,sBAAM,YAAY,CAAC,EAAE,YAAY,CAAA,GAAI,OAAO,EAAE,OAAc,EAAE,CAAE;AAChE,oBAAI,cAAc,MAAM,CAAC,EAAE,KAAI,EAAG,MAAM,KAAK;AAC7C,oBAAI,oBAAoB,IAAI,WAC1B,MAAM,CAAC,EAAE,KAAI,EAAG,MAAM,KAAK,CAAQ;AAErC,oBAAI,WAAW,MAAM,CAAC,EAAE,KAAI;AAE5B,oBAAI,YAAY;AAChB,oBAAI,SAAS,MAAM,GAAG,GAAG;AACvB,8BAAY;AACZ,6BAAW,MAAM,CAAC,EAAE,KAAI;gBAC1B;AAEA,oBAAI,SAAS,YAAW,EAAG,CAAC,KAAK,KAAK;AACpC,6BAAW;gBACb,WAAW,SAAS,YAAW,EAAG,CAAC,KAAK,KAAK;AAC3C,6BAAW;gBACb,OAAO;AACL,0BAAQ,IACN,wFAAwF;AAE1F,yBAAO;gBACT;AAEA,oBAAI,YAAY,UAAU,kBAAkB,QAAQ;AAClD,0BAAQ,IAAI,gDAAgD;AAC5D,0BAAQ,IAAI,WAAW;AACvB,0BAAQ,IAAI,iBAAiB;AAC7B,yBAAO;gBACT;AAEA,oBAAI,WAAW;AACb,wBAAM,OAAO,GAAG,CAAC;gBACnB,OACK;AACH,wBAAM,OAAO,GAAG,CAAC;gBACnB;AAEA,oBAAI,cAAc;AAElB,yBAAS,IAAI,GAAG,MAAM,YAAY,QAAQ,IAAI,KAAK,KAAK;AACtD,sBAAI,aAAa,YAAY,CAAC;AAC9B,2BAAS,IAAI,GAAG,UAAU,kBAAkB,CAAC,GAAG,IAAI,SAAS,KAAK;AAChE,wBAAI,SAAS,IAAI,aACf,MAAM,cAAc,CAAC,EAAE,KAAI,EAAG,MAAM,KAAK,CAAQ;AAGnD,wBAAI,OAAiB,CAAA;AACpB,yBAAK,OAAe;AACrB,wBAAI,YAAY,aAAa;AAC3B,2BAAK,IAAI,QAAQ,SAAS,OAAO,CAAC;AAClC,2BAAK,IAAI,QAAQ,SAAS,OAAO,CAAC;AAClC,2BAAK,IAAI,QAAQ,SAAS,OAAO,CAAC;oBACpC,OAAO;AACL,2BAAK,IACH,QAAQ,UACP,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IACzB,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IAC1B,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC;AAC9B,2BAAK,IACH,QAAQ,UACP,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IACzB,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IAC1B,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC;AAC9B,2BAAK,IACH,QAAQ,UACP,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IACzB,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC,IAC1B,OAAO,CAAC,IAAI,QAAQ,KAAK,CAAC;oBAChC;AAEA,yBAAK,QAAQ,CAAA;AACb,yBAAK,YAAY,CAAA;AAEjB,0BAAM,CAAC,EAAE,KAAK,IAAI;kBACpB;AACA,iCAAe,kBAAkB,CAAC;gBACpC;AAEA,oBAAI,aAAa;AACf,2BAASV,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK;AACrC,qBAAA,GAAA,gDAAA,aAAY,MAAMA,EAAC,GAAG,OAAO;kBAC/B;gBACF;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;ACpIO,uBAAS,IAAI,KAAa,SAA0B;AACzD,0BAAU,WAAW,CAAA;AACrB,oBAAI,QAAuC,CAAC,CAAA,CAAE;AAC9C,oBAAI,cACF,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AACrD,oBAAI,QAAQ,IAAI,UAAS,EAAG,MAAM,UAAU;AAC5C,uBAAO,MAAM,SAAS,GAAG;AACvB,sBAAI,MAAM,SAAS;AAAG;AACtB,sBAAI,YAAY,SAAS,MAAM,CAAC,CAAC;AACjC,sBAAI,MAAM,SAAS,KAAK,aAAa;AAAG;AACxC,sBAAI,MAAM,SAAS,YAAY;AAAG;AAElC,sBAAI,aAAa;AACjB,sBAAI,gBAAgB,WAAW,KAAK,MAAM,CAAC,CAAC;AAC5C,sBAAI,iBAAiB,QAAQ,cAAc,SAAS,GAAG;AACrD,wBAAI,UAAU,IAAI,aAAa,cAAc,CAAC,EAAE,MAAM,KAAK,CAAQ;AACnE,wBAAI,SAAS,IAAI,oCAAA,QACf,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,GACT,QAAQ,CAAC,CAAC;AAEZ,0BAAM,YAAY,CAAC,EAAE,OAAO,EAAE,OAAc,EAAE,CAAE;kBAClD;AAEA,sBAAI,SAAS;AACb,sBAAI,QAAQ,MAAM,MAAM,SAAS,CAAC,EAAE;AACpC,sBAAI,MAAM,QAAQ;AAClB,2BAAS,IAAI,OAAO,IAAI,KAAK,KAAK;AAChC,wBAAI,OAAO,MAAM,QAAQ;AACzB,wBAAI,SAAS,KAAK,KAAI,EAAG,MAAM,KAAK;AACpC,wBAAI,OAA4B,CAAA;AAChC,yBAAK,SAAS;AACd,wBAAI,OAAO,OAAO,CAAC;AACnB,yBAAK,OAAO,KAAK,OACf,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,GAAG,CAAC,EAAE,YAAW;AAC1D,yBAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,yBAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,yBAAK,IAAI,WAAW,OAAO,CAAC,CAAC;AAC7B,yBAAK,UAAU;AACf,yBAAK,QAAQ,CAAA;AACb,yBAAK,YAAY,CAAA;AACjB,yBAAK,aAAa,CAAA;AAClB,0BAAM,MAAM,SAAS,CAAC,EAAE,CAAC,IAAI;AAC7B,wBAAI,OAAO,UAAU,GAAG;AACtB,2BAAK,KAAK,WAAW,OAAO,CAAC,CAAC;AAC9B,2BAAK,KAAK,WAAW,OAAO,CAAC,CAAC;AAC9B,2BAAK,KAAK,WAAW,OAAO,CAAC,CAAC;oBAChC;kBACF;AAEA,sBAAI,QAAQ,YAAY;AACtB,0BAAM,KAAK,CAAA,CAAE;AACb,0BAAM,OAAO,GAAG,MAAM;kBACxB,OAAO;AACL;kBACF;gBACF;AAEA,oBAAI,aAAa;AACf,2BAASA,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK;AACrC,qBAAA,GAAA,gDAAA,aAAY,MAAMA,EAAC,GAAG,OAAO;kBAC/B;gBACF;AAEA,oBAAI,QAAQ,QAAQ;AAClB,sBAAI,OAAO;AACX,0BAAQ,CAAA;AACR,wBAAM,KAAK,KAAK,CAAC,CAAC;AAClB,2BAASA,KAAI,GAAGA,KAAI,KAAK,QAAQA,MAAK;AACpC,wBAAIiE,UAAS,MAAM,CAAC,EAAE;AACtB,6BAAS,IAAI,GAAG,IAAI,KAAKjE,EAAC,EAAE,QAAQ,KAAK;AACvC,0BAAI,IAAI,KAAKA,EAAC,EAAE,CAAC;AACjB,+BAAS,IAAI,GAAG,IAAI,EAAE,MAAM,QAAQ,KAAK;AACvC,0BAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAIiE;sBAC5B;AACA,wBAAE,QAAQ,MAAM,CAAC,EAAE;AACnB,wBAAE,SAAS,MAAM,CAAC,EAAE;AACpB,4BAAM,CAAC,EAAE,KAAK,CAAC;oBACjB;kBACF;gBACF;AAEA,uBAAO;cACT;;;;;;;;;;;;;;;;;AClGO,uBAAS,SAAS,MAAqB;AAC5C,sBAAM,MAAM,uBAAO,OAAO,IAAI;AAC9B,sBAAM,QAAQ,uBAAO,OAAO,IAAI;AAChC,2BAAW,OAAO,KAAK;AAAS,sBAAI,IAAI,IAAI,IAAI;AAChD,uBAAO;kBACH,UAAU,KAAK;kBACf,MAAM,KAAK,KAAK,UAAU,CAAC;kBAC3B,YAAY,KAAK,QAAQ,IAAI,OAAK,EAAE,IAAI;kBACxC,SAAS,MAAI;AACT,0BAAM,MAAM,IAAI,IAAI;AACpB,wBAAI,CAAC;AAAK,6BAAO;AACjB,wBAAI,CAAC,CAAC,MAAM,IAAI;AAAG,6BAAO,MAAM,IAAI;AACpC,0BAAM,IAAI,KAAI,GAAA,sCAAA,QAAO,IAAI,IAAI;AAC7B,2BAAO,MAAM,IAAI;kBACrB;;cAEN;;;;;;;;;;;;;;;;;ACXA,oBAAM,uBAAuB,IAAI,YAAY,IAAI,WAAW,CAAC,IAAM,EAAI,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM;AAEzF,uBAAS,cAAc,MAAkB,OAAa;AACpD,sBAAM,SAAS,IAAI,YAAY,KAAK,MAAM;AAC1C,sBAAM,MAAM,IAAI,WAAW,MAAM;AACjC,yBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK,OAAO;AAClD,2BAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,wBAAI,IAAI,QAAQ,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;kBACrC;gBACF;AACA,uBAAO;cACT;AAOO,uBAAS,OAAO,MAAiB;AACtC,oBAAI,UAAe,KAAK;AACxB,yBAAS,IAAI,KAAK,SAAS,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,4BAAU,WAAW,SAAS,KAAK,SAAS,CAAC,CAAC;gBAChD;AACA,uBAAO;cACT;AAEA,uBAAS,WAAW,MAAW,UAAkB;AAC/C,wBAAQ,SAAS,MAAM;kBACrB,KAAK,aAAa;AAChB,4BAAQ,SAAS,MAAM;sBACrB,KAAK,uCAAA,SAAS,YAAY;AAAO,+BAAO;sBACxC,KAAK,uCAAA,SAAS,YAAY;AAAM,+BAAO,KAAK,IAAI;sBAChD,KAAK,uCAAA,SAAS,YAAY;AAAO,+BAAO,MAAM,IAAI;sBAClD,KAAK,uCAAA,SAAS,YAAY;AAAQ,+BAAO,OAAO,IAAI;sBACpD,KAAK,uCAAA,SAAS,YAAY;AAAO,+BAAO,MAAM,IAAI;sBAClD,KAAK,uCAAA,SAAS,YAAY;AAAQ,+BAAO,OAAO,IAAI;sBACpD,KAAK,uCAAA,SAAS,cAAc;AAAS,+BAAO,QAAQ,IAAI;sBACxD,KAAK,uCAAA,SAAS,cAAc;AAAS,+BAAO,QAAQ,IAAI;sBACxD;AAAS,8BAAM,IAAI,MAAM,aAAa;oBACxC;kBACF;kBACA,KAAK;AAAc,2BAAO,WAAW,MAAM,QAAQ;kBACnD,KAAK;AAAwB,2BAAO,qBAAqB,MAAM,QAAQ;kBACvE,KAAK;AAAa,2BAAO,UAAU,MAAM,QAAQ;kBACjD,KAAK;AAAS,2BAAO,MAAM,MAAM,QAAQ;kBACzC,KAAK;AAAkB,2BAAO,eAAe,MAAM,QAAQ;kBAC3D,KAAK;AAAe,2BAAO,YAAY,MAAM,QAAQ;gBACvD;cACF;AAEA,uBAAS,YAAY,MAA4B,MAAY;AAC3D,wBAAQ,MAAM;kBACZ,KAAK,uCAAA,SAAS,YAAY;AAAM,2BAAO,IAAI,UAAU,IAAI;kBACzD,KAAK,uCAAA,SAAS,YAAY;AAAO,2BAAO,IAAI,WAAW,IAAI;kBAC3D,KAAK,uCAAA,SAAS,YAAY;AAAO,2BAAO,IAAI,WAAW,IAAI;kBAC3D,KAAK,uCAAA,SAAS,YAAY;AAAO,2BAAO,IAAI,WAAW,IAAI;kBAC3D,KAAK,uCAAA,SAAS,YAAY;AAAQ,2BAAO,IAAI,YAAY,IAAI;kBAC7D,KAAK,uCAAA,SAAS,YAAY;AAAQ,2BAAO,IAAI,YAAY,IAAI;kBAC7D;AAAS,2BAAO,IAAI,WAAW,IAAI;gBACrC;cACF;AAEA,uBAAS,cAAc,MAA8B,MAAY;AAC/D,wBAAQ,MAAM;kBACZ,KAAK,uCAAA,SAAS,cAAc;AAAS,2BAAO,IAAI,aAAa,IAAI;kBACjE,KAAK,uCAAA,SAAS,cAAc;AAAS,2BAAO,IAAI,aAAa,IAAI;kBACjE;AAAS,2BAAO,IAAI,aAAa,IAAI;gBACvC;cACF;AAEA,uBAAS,KAAK,MAAgB;AAAI,uBAAO,IAAI,UAAU,KAAK,QAAQ,KAAK,UAAU;cAAG;AAEtF,uBAAS,KAAQ,MAAkB,UAAkB,GAAiC;AACpF,oBAAI,KAAK,cAAc,KAAK,KAAK,cAAc,KAAK,OAAO,YAAY;AACrE,yBAAO,IAAI,WAAW,IAAI;gBAC5B;AACA,oBAAI;AAAsB,yBAAO,IAAI,EAAE,KAAK,MAAqB;AACjE,uBAAO,IAAI,EAAE,cAAc,MAAM,QAAQ,CAAC;cAC5C;AAEA,uBAAS,MAAM,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,UAAU;cAAG;AACrE,uBAAS,OAAO,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,WAAW;cAAG;AACvE,uBAAS,MAAM,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,UAAU;cAAG;AACrE,uBAAS,OAAO,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,WAAW;cAAG;AACvE,uBAAS,QAAQ,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,YAAY;cAAG;AACzE,uBAAS,QAAQ,MAAgB;AAAI,uBAAO,KAAK,MAAM,GAAG,YAAY;cAAG;AAEzE,uBAAS,WAAW,MAAkB,UAA6B;AACjE,sBAAM,IAAI,KAAK;AACf,sBAAM,SAAS,cAAc,SAAS,SAAS,CAAC;AAChD,sBAAM,IAAI,IAAI,SAAS;AACvB,yBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,yBAAO,CAAC,IAAI,IAAI,KAAK,CAAC;gBACxB;AACA,uBAAO;cACT;AAEA,uBAAS,qBAAqB,MAAkB,UAAuC;AACrF,sBAAM,IAAI,KAAK;AACf,sBAAM,SAAS,cAAc,SAAS,SAAS,CAAC;AAChD,sBAAMC,UAAS,SAAS,MAAM,SAAS,QAAQ,SAAS,WAAW;AACnE,sBAAM,MAAM,SAAS;AACrB,yBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,yBAAO,CAAC,IAAI,MAAMA,SAAQ,KAAK,CAAC;gBAClC;AACA,uBAAO;cACT;AAEA,uBAAS,UAAU,MAAkB,UAA4B;AAC/D,sBAAM,SAAS,YAAY,SAAS,SAAS,SAAS,OAAO;AAC7D,oBAAI,aAAa;AACjB,yBAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,KAAK,GAAG;AAChD,wBAAM,QAAQ,KAAK,CAAC;AACpB,wBAAM,SAAS,KAAK,IAAI,CAAC;AACzB,2BAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,2BAAO,YAAY,IAAI;kBACzB;gBACF;AACA,uBAAO;cACT;AAEA,uBAAS,MAAM,MAA6C,UAAwB;AAClF,sBAAM,IAAI,KAAK;AACf,sBAAM,SAAS,YAAY,SAAS,SAAS,CAAC;AAC9C,oBAAI,CAAC;AAAG,yBAAO;AACf,uBAAO,CAAC,IAAI,KAAK,CAAC,KAAK,SAAS,SAAS;AACzC,yBAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,yBAAO,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO,IAAI,CAAC;gBACpC;AACA,uBAAO;cACT;AAEA,uBAAS,qBAAqB,MAAgC,UAAiC;AAC7F,sBAAM,aAAa,SAAS,cAAc,IAAI,MAAO;AACrD,sBAAM,aAAa,CAAC,aAAa;AACjC,sBAAM,IAAI,KAAK;AACf,sBAAM,SAAS,IAAI,WAAW,SAAS,OAAO;AAC9C,oBAAI,IAAI;AACR,oBAAI,IAAI;AACR,uBAAO,IAAI,GAAG;AACZ,sBAAI,QAAQ,GAAG,IAAI,KAAK,CAAC;AACzB,yBAAO,MAAM,cAAc,MAAM,YAAY;AAC3C,6BAAS;AACT;AACA,wBAAI,KAAK,CAAC;kBACZ;AACA,2BAAS;AACT,yBAAO,CAAC,IAAI;AACZ;AACA;gBACF;AACA,uBAAO;cACT;AAEA,uBAAS,uBAAuB,MAAkC,UAAiC;AACjG,sBAAM,aAAa,SAAS,cAAc,IAAI,MAAO;AACrD,sBAAM,IAAI,KAAK;AACf,sBAAM,SAAS,IAAI,WAAW,SAAS,OAAO;AAC9C,oBAAI,IAAI;AACR,oBAAI,IAAI;AACR,uBAAO,IAAI,GAAG;AACZ,sBAAI,QAAQ,GAAG,IAAI,KAAK,CAAC;AACzB,yBAAO,MAAM,YAAY;AACvB,6BAAS;AACT;AACA,wBAAI,KAAK,CAAC;kBACZ;AACA,2BAAS;AACT,yBAAO,CAAC,IAAI;AACZ;AACA;gBACF;AACA,uBAAO;cACT;AAEA,uBAAS,eAAe,MAA2D,UAAiC;AAClH,oBAAI,KAAK,WAAW,SAAS;AAAS,yBAAO;AAC7C,uBAAO,SAAS,aAAa,uBAAuB,MAAa,QAAQ,IAAI,qBAAqB,MAAa,QAAQ;cACzH;AAEA,uBAAS,YAAY,MAAkB,UAA8B;AACnE,sBAAM,UAAU,OAAO,EAAE,UAAU,SAAS,gBAAgB,MAAM,SAAS,QAAO,CAAE;AACpF,sBAAM,UAAU,OAAO,EAAE,UAAU,SAAS,cAAc,KAAI,CAAE;AAEhE,sBAAM,MAAM,SAAS;AACrB,sBAAM,UAAU,IAAI,MAAM,QAAQ,MAAM;AACxC,wBAAQ,CAAC,IAAI;AACb,yBAAS,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK;AAChD,0BAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC;gBACvD;AAEA,oBAAI,SAAS;AACb,sBAAM,SAAS,IAAI,MAAM,QAAQ,MAAM;AACvC,yBAAS,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK;AAChD,yBAAO,QAAQ,IAAI,QAAQ,QAAQ,CAAC,IAAI,CAAC;gBAC3C;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;ACnMO,oBAAM,UAAU;AA2ChB,kBAAU;AAAjB,eAAA,SAAiBC,WAAQ;AAErB,oBAAY;AAAZ,iBAAA,SAAYC,cAAW;AACnB,kBAAAA,aAAAA,aAAA,MAAA,IAAA,CAAA,IAAA;AACA,kBAAAA,aAAAA,aAAA,OAAA,IAAA,CAAA,IAAA;AACA,kBAAAA,aAAAA,aAAA,OAAA,IAAA,CAAA,IAAA;AACA,kBAAAA,aAAAA,aAAA,OAAA,IAAA,CAAA,IAAA;AACA,kBAAAA,aAAAA,aAAA,QAAA,IAAA,CAAA,IAAA;AACA,kBAAAA,aAAAA,aAAA,QAAA,IAAA,CAAA,IAAA;gBACJ,GAPY,cAAAD,UAAA,gBAAAA,UAAA,cAAW,CAAA,EAAA;AASvB,oBAAY;AAAZ,iBAAA,SAAYE,gBAAa;AACrB,kBAAAA,eAAAA,eAAA,SAAA,IAAA,EAAA,IAAA;AACA,kBAAAA,eAAAA,eAAA,SAAA,IAAA,EAAA,IAAA;gBACJ,GAHY,gBAAAF,UAAA,kBAAAA,UAAA,gBAAa,CAAA,EAAA;AAOzB,yBAAgB,YAAY,MAAqC;AAC7D,sBAAI;AACJ,sBAAI,gBAAgB;AAAW,8BAAUA,UAAS,YAAY;2BACrD,gBAAgB;AAAY,8BAAUA,UAAS,YAAY;2BAC3D,gBAAgB;AAAY,8BAAUA,UAAS,YAAY;2BAC3D,gBAAgB;AAAY,8BAAUA,UAAS,YAAY;2BAC3D,gBAAgB;AAAa,8BAAUA,UAAS,YAAY;2BAC5D,gBAAgB;AAAa,8BAAUA,UAAS,YAAY;2BAC5D,gBAAgB;AAAc,8BAAUA,UAAS,cAAc;2BAC/D,gBAAgB;AAAc,8BAAUA,UAAS,cAAc;;AACnE,8BAAUA,UAAS,YAAY;AACpC,yBAAO;gBACX;AAZgB,gBAAAA,UAAA,cAAW;AAc3B,yBAAgB,wBAAwB,MAAmB;AACvD,sBAAI,gBAAgB,aAAa,gBAAgB,cAAc,gBAAgB;AAAY,2BAAO;AAClG,2BAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,KAAK;AAC3C,wBAAI,IAAI;AAAG,6BAAO;kBACtB;AACA,yBAAO;gBACX;AANgB,gBAAAA,UAAA,0BAAuB;cAiE3C,GAjGiB,aAAA,WAAQ,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnClB,oBAAM,UAAU;gBACrB,MAAM,mCAAA;gBACN,MAAI,mCAAA;gBACJ,MAAM,mCAAA;gBACN,MAAI,mCAAA;gBACJ,KAAK,kCAAA;gBACL,KAAG,kCAAA;gBACH,KAAK,kCAAA;gBACL,KAAG,kCAAA;gBACH,MAAM,qCAAA;gBACN,QAAQ,qCAAA;gBACR,QAAM,qCAAA;gBACN,MAAM,kCAAA;gBACN,KAAK,kCAAA;gBACL,KAAG,kCAAA;gBACH,MAAM,mCAAA;gBACN,MAAI,mCAAA;gBACJ,KAAK,kCAAA;gBACL,KAAG,kCAAA;gBACH,OAAO,kCAAA;gBACP,OAAO,kCAAA;gBACP,KAAK,kCAAA;gBACL,KAAG,kCAAA;gBACH,MAAK,mCAAA;;gBACL,MAAK,mCAAA;gBACL,QAAQ,sCAAA;gBACR,QAAM,sCAAA;gBACN,KAAK,mCAAA;gBACL,KAAG,mCAAA;gBACH,WAAW,yCAAA;gBACX,WAAS,yCAAA;gBACT,MAAM,oCAAA;gBACN,MAAI,oCAAA;;;;;;;;;;;;;;ACnDC,oBAAM,eAAsC;gBACjD,GAAG;gBAAoI,GAAG;gBAC1I,GAAE;gBAAK,GAAE;gBAAuF,GAAG;gBAAK,GAAG;gBAAK,GAAE;gBAAK,GAAE;gBAAK,GAAE;gBAAM,IAAI;gBAC1I,IAAI;gBAAK,IAAG;gBAAoF,IAAI;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAI,IAAG;gBAAK,IAAG;gBAC1I,IAAI;gBAAI,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC1I,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC1I,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC1I,IAAG;gBAAK,IAAG;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;gBAElJ,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC3G,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,KAAI;gBAAK,KAAI;gBAAK,KAAI;;;;;;;;;;;;;;;;;;ACN/G,oBAAM,UAAU,oBAAI,IAAI,CAAC,MAAK,KAAI,MAAK,MAAK,MAAK,IAAI,CAAC;AAK/C,uBAAS,aAAa,OAAiB,OAAiB,SAA0B;AACvF,oBAAG,WAAW,QAAQ,mBAAmB,QAAQ,IAAI,MAAM,IAAI,KAAK,QAAQ,IAAI,MAAM,IAAI,IAAI;AAC5F,yBAAO;gBACT;AACA,oBAAI,SAAQ,GAAA,yCAAA,YAAW,MAAM,IAAI,KAAI,GAAA,yCAAA,YAAW,MAAM,IAAI;AAC1D,yBAAS;AACT,yBAAS;AAET,oBAAI,QAAQ,MAAM,IAAI,MAAM;AAC5B,yBAAS;AACT,oBAAI,QAAQ;AAAO,yBAAO;AAC1B,oBAAI,QAAQ,MAAM,IAAI,MAAM;AAC5B,yBAAS;AACT,oBAAI,QAAQ;AAAO,yBAAO;AAC1B,oBAAI,QAAQ,MAAM,IAAI,MAAM;AAC5B,yBAAS;AACT,oBAAI,QAAQ;AAAO,yBAAO;AAE1B,sBAAM,cAAc,QAAQ,QAAQ;AAEpC,oBACE,MAAM,WAAW,KACjB,cAAc,OACd,cAAc,SACb,MAAM,WAAW,MAAM,UAAU,MAAM,OAAO,KAAI,MAAO,MAAM,MAAM,OAAO,KAAI,MAAO;AAExF,yBAAO;AAGT,uBAAO;cACT;;;;;;;;;;;;;ACjCO,uBAAS,qBACd,YACA,aAAmB;AAEnB,sBAAM,YAAY,eAAe;AACjC,sBAAM,cAAc,YAAY;AAChC,sBAAM,QAAQ,CAAA;AAEd,yBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAK;AACjD,6BAAW,CAAC,EAAE,QAAQ;AAEtB,wBAAM,OAAO,WAAW,CAAC;AACzB,sBAAI,CAAC,KAAK,YAAY,KAAK,SAAS,OAAO,KAAK,SAAS,MAAM;AAC7D,0BAAM,KAAK,IAAI;AACf,yBAAK,aAAa;AAClB,yBAAK,kBAAkB,OAAO;kBAChC;gBACF;AAEA,sBAAM,KAAK,SAAU,GAAG,GAAC;AACvB,yBAAO,EAAE,IAAI,EAAE;gBACjB,CAAC;AACD,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC5C,wBAAM,KAAK,MAAM,CAAC;AAElB,2BAAS,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;AAC9B,0BAAM,KAAK,MAAM,CAAC;AAClB,0BAAM,QAAQ,GAAG,IAAI,GAAG;AACxB,wBAAI,QAAQ;AAEV;AACF,wBAAI,GAAG,QAAQ,GAAG;AAAM;AACxB,0BAAM,QAAQ,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAClC,wBAAI,QAAQ;AAAW;AACvB,0BAAM,QAAQ,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAClC,wBAAI,QAAQ;AAAW;AACvB,0BAAM,OAAO,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ;AACrD,wBAAI,OAAO;AAAa;AAExB,wBAAI,GAAG,SAAS,GAAG,SAAS,KAAK,IAAI,GAAG,OAAO,GAAG,IAAI,IAAI;AAAG;AAE7D,wBAAI,OAAO,GAAG,iBAAiB;AAC7B,yBAAG,aAAa;AAChB,yBAAG,kBAAkB;oBACvB;AACA,wBAAI,OAAO,GAAG,iBAAiB;AAC7B,yBAAG,aAAa;AAChB,yBAAG,kBAAkB;oBACvB;kBACF;gBACF;cACF;;;;;;;;;;;;;;;;;AClDA,oBAAM,UAAU;gBACd,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAE;gBACnB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,GAAE;gBACpB,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAC;gBACnB,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAC;gBACnB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAE;gBACnB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAE;gBACnB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;gBAClB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;;AAEpB,oBAAM,kBAAkB;AAEjB,uBAAS,YAAY,OAAmB,SAA0B;AAGvE,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAE5C,sBAAI,CAAC,MAAM,CAAC,EAAE;AAAO,0BAAM,CAAC,EAAE,QAAQ;gBACxC;AAEA,sBAAM,OAMF;kBACF,GAAG;oBACD,GAAG;sBACD,GAAG,CAAA;;;;AAKT,yBAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,wBAAM,OAAO,MAAM,KAAK;AACxB,wBAAM,IAAI,KAAK,MAAM,KAAK,IAAI,eAAe;AAC7C,wBAAM,IAAI,KAAK,MAAM,KAAK,IAAI,eAAe;AAC7C,wBAAM,IAAI,KAAK,MAAM,KAAK,IAAI,eAAe;AAC7C,sBAAI,CAAC,KAAK,CAAC,GAAG;AACZ,yBAAK,CAAC,IAAI,CAAA;kBACZ;AACA,sBAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;AACf,yBAAK,CAAC,EAAE,CAAC,IAAI,CAAA;kBACf;AACA,sBAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG;AAClB,yBAAK,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAA;kBAClB;AAEA,uBAAK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,IAAI;gBACzB;AAEA,yBAAS,gBACP,QACA,aAA4B;AAE5B,2BAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,0BAAM,QAAQ,OAAO,CAAC;AACtB,6BAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,4BAAM,QAAQ,YAAY,CAAC;AAE3B,2BAAI,GAAA,2CAAA,cAAa,OAAO,OAAO,OAAO,GAAG;AAEvC,8BAAM,MAAM,MAAM,MAAM,QAAQ,MAAM,KAAK;AAC3C,8BAAM,MAAM,MAAM,MAAM,QAAQ,MAAM,KAAK;AAC3C,4BAAI,QAAQ,MAAM,QAAQ,IAAI;AAC5B,gCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,gCAAM,UAAU,KAAK,CAAC;AACtB,gCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,gCAAM,UAAU,KAAK,CAAC;wBACxB,WAAW,QAAQ,IAAI;AACrB,gCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,gCAAM,UAAU,KAAK,MAAM,UAAU,GAAG,CAAC;wBAC3C,WAAW,QAAQ,IAAI;AACrB,gCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,gCAAM,UAAU,KAAK,MAAM,UAAU,GAAG,CAAC;wBAC3C;sBACF;oBACF;kBACF;gBACF;AAEA,yBAAS,MAAM,MAAM;AACnB,wBAAM,IAAI,SAAS,EAAE;AACrB,2BAAS,MAAM,KAAK,CAAC,GAAG;AACtB,0BAAM,IAAI,SAAS,EAAE;AACrB,6BAAS,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;AACzB,4BAAM,IAAI,SAAS,EAAE;AACrB,4BAAM,SAAS,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC;AAE3B,+BAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,8BAAM,QAAQ,OAAO,CAAC;AACtB,iCAAS,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAC1C,gCAAM,QAAQ,OAAO,CAAC;AACtB,+BAAI,GAAA,2CAAA,cAAa,OAAO,OAAM,OAAO,GAAG;AACtC,gCAAI,MAAM,MAAM,QAAQ,MAAM,KAAK,KAAK,IAAI;AAC1C,oCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,oCAAM,UAAU,KAAK,CAAC;AACtB,oCAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,oCAAM,UAAU,KAAK,CAAC;4BACxB;0BACF;wBACF;sBACF;AAEA,+BAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,8BAAM,SAAS,QAAQ,CAAC;AACxB,4BACE,CAAC,KAAK,IAAI,OAAO,CAAC,KAClB,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,KAChC,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC;AAE9C;AAEF,8BAAM,cAAc,KAAK,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC;AACjE,wCAAgB,QAAQ,WAAW;sBACrC;oBACF;kBACF;gBACF;cACF;;;;;;;;;;;;;;;;;;;;;;;;;ACtHO,uBAAS,eAAe,YAAwB,SAA0B;AAE/E,sBAAM,YAA6B,CAAA;AACnC,sBAAM,WAA4B,CAAA;AAClC,yBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAK;AACjD,wBAAM,OAAO,WAAW,CAAC;AACzB,uBAAK,QAAQ;AACb,sBAAI,KAAK,WAAW,CAAC,+CAAA,iBAAiB,IAAI,KAAK,IAAI;AAAG,6BAAS,KAAK,IAAI;;AACnE,8BAAU,KAAK,IAAI;gBAC1B;AAEA,iBAAA,GAAA,0CAAA,aAAY,UAAU,OAAO;AAG7B,0BAAU,KAAK,SAAU,GAAG,GAAC;AAC3B,sBAAI,EAAE,UAAU,EAAE;AAAO,2BAAO,EAAE,QAAQ,EAAE,QAAQ,KAAK;AACzD,yBAAO,EAAE,OAAO,EAAE;gBACpB,CAAC;AAGD,oBAAI,cAAc;AAClB,oBAAI,WAAW;AACf,oBAAI;AAEJ,yBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAAK;AAChD,wBAAM,KAAK,UAAU,CAAC;AAEtB,sBAAI,GAAG,SAAS,aAAa;AAC3B,kCAAc,GAAG;AACjB,wBAAI,CAAC;AAAkB;AAEvB,uCAAmB;kBACrB;AAEA,qBAAG,WAAW;AAEd,2BAAS,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC7C,0BAAM,KAAK,UAAU,CAAC;AACtB,wBAAI,GAAG,UAAU,GAAG,SAAS,GAAG,OAAO,GAAG,OAAO;AAAG;AAEpD,yBAAI,GAAA,2CAAA,cAAa,IAAI,IAAI,OAAO,GAAG;AACjC,0BAAI,GAAG,MAAM,QAAQ,GAAG,KAAK,MAAM,IAAI;AAErC,2BAAG,MAAM,KAAK,GAAG,KAAK;AACtB,2BAAG,UAAU,KAAK,CAAC;AACnB,2BAAG,MAAM,KAAK,GAAG,KAAK;AACtB,2BAAG,UAAU,KAAK,CAAC;sBACrB;AAEA,0BAAI,GAAG,SAAS,GAAG;AAAM,2CAAmB;oBAC9C;kBACF;gBACF;cACF;;;;;;;;;;;;;;;;;AChEO,uBAAS,eAAe,MAAc,WAAkB;AAC7D,oBAAI,OAAO,KAAK,QAAQ,MAAM,EAAE;AAChC,oBACE,KAAK,SAAS,KACd,KAAK,CAAC,MAAM,OACZ,SAAS,QACT,SAAS,QACT,SAAS,QACT,SAAS,QACT,SAAS,MACT;AACA,yBAAO;gBACT;AACA,oBAAI,KAAK,SAAS,GAAG;AACnB,yBAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;AAC5D,sBAAI,yCAAA,UAAU,IAAI,MAAM,QAAW;AAEjC,2BAAO,KAAK,CAAC;kBACf,WAAW,WAAW;AACpB,wBAAI,SAAS,MAAM;AAEjB,6BAAO;oBACT,WAAW,SAAS,MAAM;AACxB,6BAAO;oBACT;kBACF;gBACF;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;;;;;;;AC9BO,kBAAI,YAAoC;gBAC7C,GAAG;gBAAqI,IAAG;gBAC3I,IAAG;gBAAK,IAAG;gBAAqF,GAAG;gBAAK,GAAG;gBAAK,GAAG;gBAAK,GAAG;gBAAK,GAAG;gBAAK,IAAG;gBAC3I,IAAG;gBAAK,IAAG;gBAAqF,IAAG;gBAAK,IAAG;gBAAK,GAAG;gBAAK,GAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC3I,GAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,GAAG;;gBAAa,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;;gBAAa,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAC3I,IAAG;gBAAK,IAAG;gBAAK,GAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,GAAG;gBAAK,IAAG;gBAC3I,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,GAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;;;gBAAqB,IAAG;;;AAMtI,uBAAS,WAAW,MAAqB;AAC9C,uBAAO,UAAU,IAAI,KAAK;cAC5B;AAGO,uBAAS,cAAc,MAAc,QAAc;AACxD,oBAAI,SAAS;AAAG,2BAAS;AACzB,0BAAU,IAAI,IAAI;cACpB;;;;;;;;;;;;;;;;;AClBO,uBAAS,0BAA0B,YAA6B,aAAmB;AACxF,iBAAA,GAAA,mDAAA,sBAAqB,YAAY,WAAW;AAG5C,sBAAM,QAAQ,CAAA;AACd,oBAAI,GAAW,IAAY,GAAoB;AAC/C,oBAAI,MAAgB;AAGpB,qBAAK,IAAI,GAAG,KAAK,WAAW,QAAQ,IAAI,IAAI,KAAK;AAC/C,yBAAO,WAAW,CAAC;AAEnB,sBAAI,MAAM,KAAK,KAAK,MAAM;AAAW,0BAAM,KAAK,KAAK,IAAI,CAAA;AAEzD,sBAAI,SAAS,KAAK,eAAe,GAAG;AAClC,0BAAM,QAAQ,KAAK;AACnB,wBAAI,MAAM,MAAM,KAAK,MAAM;AAAW,4BAAM,MAAM,KAAK,IAAI,CAAA;AAE3D,wBAAI,KAAK,IAAI,MAAM,OAAO,KAAK,IAAI,MAAM,GAAG;AAE1C,4BAAM,KAAK,KAAK,EAAE,KAAK,IAAI,IAAI;oBACjC;kBACF;gBACF;AAGA,qBAAK,KAAK,OAAO;AACf,uBAAK,IAAI,GAAG,IAAI,MAAM,CAAC,EAAE,SAAS,GAAG,KAAK;AACxC,0BAAM,YAAY,MAAM,CAAC,EAAE,IAAI,CAAC;AAChC,0BAAM,WAAW,MAAM,CAAC,EAAE,IAAI,CAAC;AAC/B,0BAAM,MAAM,CAAC,EAAE,CAAC;AAChB,wBAAI,aAAa,OAAO,aAAa,YAAY,OAAO,WAAW;AACjE,4BAAM,CAAC,EAAE,CAAC,IAAI;oBAChB;kBACF;gBACF;AAGA,qBAAK,IAAI,GAAG,KAAK,WAAW,QAAQ,IAAI,IAAI,KAAK;AAC/C,yBAAO,WAAW,CAAC;AAEnB,sBACE,SAAS,KAAK,eAAe,KAC7B,MAAM,KAAK,KAAK,EAAE,KAAK,IAAI,KAAK,OAChC,KAAK,OAAO,KACZ;AACA,0BAAM,KAAK,KAAK,EAAE,KAAK,IAAI,IAAI;kBACjC;gBACF;AAGA,yBAASnE,KAAI,GAAGsE,MAAK,WAAW,QAAQtE,KAAIsE,KAAItE,MAAK;AACnD,yBAAO,WAAWA,EAAC;AAEnB,sBACE,SAAS,KAAK,eAAe,KAC7B,MAAM,KAAK,KAAK,EAAE,KAAK,IAAI,KAAK,cAChC;AACA,wBAAI,QAAQ,KAAK;AACjB,wBAAI,WAAW,MAAM,MAAM,KAAK,EAAE,MAAM,IAAI;AAC5C,wBAAI,YAAY,gBAAgB,YAAY,KAAK;AAE/C,4BAAM,KAAK,KAAK,EAAE,KAAK,IAAI,IAAI;AAC/B,4BAAM,MAAM,KAAK,EAAE,MAAM,IAAI,IAAI;oBACnC;kBACF;gBACF;AAGA,yBAASM,MAAK,OAAO;AACnB,2BAASiE,KAAI,GAAGA,KAAI,MAAMjE,EAAC,EAAE,SAAS,GAAGiE,MAAK;AAC5C,0BAAM,YAAY,MAAMjE,EAAC,EAAEiE,KAAI,CAAC;AAChC,0BAAM,WAAW,MAAMjE,EAAC,EAAEiE,KAAI,CAAC;AAC/B,0BAAM,MAAMjE,EAAC,EAAEiE,EAAC;AAChB,wBAAI,aAAa,OAAO,aAAa,YAAY,OAAO,WAAW;AACjE,4BAAMjE,EAAC,EAAEiE,EAAC,IAAI;oBAChB;kBACF;AACA,2BAASA,KAAI,GAAGA,KAAI,MAAMjE,EAAC,EAAE,QAAQiE,MAAK;AACxC,0BAAMtE,OAAM,MAAMK,EAAC,EAAEiE,EAAC;AACtB,wBAAItE,QAAO,OAAOA,QAAO,KAAK;AAC5B,0BAAI,MAAMK,EAAC,EAAEiE,KAAI,CAAC,KAAKtE,QAAO,MAAMK,EAAC,EAAEiE,KAAI,CAAC,KAAKtE;AAC/C,+BAAO,MAAMK,EAAC,EAAEiE,EAAC;oBACrB;kBACF;gBACF;AAGA,qBAAK,IAAI,GAAG,KAAK,WAAW,QAAQ,IAAI,IAAI,KAAK;AAC/C,yBAAO,WAAW,CAAC;AACnB,wBAAM,MAAM,KAAK,KAAK,EAAE,KAAK,IAAI;AAGjC,yBAAO,KAAK;AACZ,yBAAO,KAAK;AACZ,sBAAI,QAAQ,UAAa,QAAQ;AAAc;AAC/C,uBAAK,KAAK;AACV,sBAAI,MAAM,KAAK,KAAK,EAAE,KAAK,OAAO,CAAC,KAAK;AAAK,yBAAK,UAAU;AAC5D,sBAAI,MAAM,KAAK,KAAK,EAAE,KAAK,OAAO,CAAC,KAAK;AAAK,yBAAK,QAAQ;gBAC5D;cACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FO,uBAAS,aACd,OACA,SACA,UAAwE;AASxE,sBAAM,QAAoB,CAAA;AAC1B,sBAAM,cACJ,QAAQ,gBAAgB,SAAY,OAAO,QAAQ;AACrD,sBAAM,MAAM,CAAC,QAAQ;AACrB,sBAAM,eAAe,CAAC,CAAC,QAAQ;AAC/B,sBAAM,gBAAgB,CAAC,QAAQ;AAC/B,sBAAM,aAAa,CAAC,QAAQ;AAC5B,sBAAM,YAAY,QAAQ,SAAS,QAAQ,SAAS;AACpD,sBAAM,YAGF,EAAE,YAAY,CAAA,GAAI,OAAO,OAAS;AAEtC,oBAAI;AACJ,oBAAI,iBAAiB,CAAA;AAErB,sBAAM,gBAA0B,CAAA;AAChC,oBAAI;AACJ,sBAAM,YAAoC,CAAA;AAE1C,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,yBAAO,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE;AAClC,wBAAM,aAAa,KAAK,UAAU,GAAG,CAAC;AAEtC,sBAAI,YAAoB,WAAmB;AAE3C,sBAAI,WAAW,QAAQ,KAAK,MAAM,GAAG;AACnC,qCAAiB,MAAM,MAAM,IAAI,CAAC;AAClC,wBAAI,eAAe,OAAO;AAGxB,iCAAW,QAAQ,UAAU;AAC3B,4BAAI,SAAS,eAAe,IAAI,GAAG;AACjC,iCAAO,SAAS,IAAI;wBACtB;sBACF;oBACF;AACA;kBACF,WAAW,eAAe,YAAY,eAAe,UAAU;AAC7D,wBAAI,MACF,OACA,MACA,OACA,GACA,GACA,GACA,SACA,MACA,QACA,QACA;AACF,6BAAS,KAAK,UAAU,IAAI,EAAE;AAC9B,wBAAI,WAAW,OAAO,WAAW,aAAa,cAAc;AAAK;AACjE,6BAAS,SAAS,KAAK,UAAU,GAAG,EAAE,CAAC;AACvC,2BAAO,KAAK,UAAU,IAAI,EAAE,EAAE,QAAQ,MAAM,EAAE;AAC9C,2BAAO,KAAK,UAAU,IAAI,EAAE,EAAE,QAAQ,MAAM,EAAE;AAC9C,4BAAQ,KAAK,UAAU,IAAI,EAAE;AAC7B,2BAAO,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AACtC,4BAAQ,KAAK,UAAU,IAAI,EAAE;AAC7B,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,2BAAO,KAAK,UAAU,IAAI,EAAE,EAAE,QAAQ,MAAM,EAAE;AAC9C,wBAAI,SAAS,MAAM,yCAAA,UAAU,IAAI,MAAM,QAAW;AAEhD,8BAAO,GAAA,6CAAA,gBAAe,KAAK,UAAU,IAAI,EAAE,GAAG,KAAK,CAAC,KAAK,GAAG;oBAC9D,OAAO;AACL,6BAAO,KAAK,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC,EAAE,YAAW;oBAC9D;AAEA,wBAAI,SAAS,OAAO;AAAK;AACzB,wBAAI,WAAW,CAAC,KAAK;AAAK,gCAAU;;AAC/B,gCAAU;AACf,kCAAc,MAAM,IAAI,MAAM;AAC9B,0BAAM,KAAK;sBACT;sBACA;sBACA;sBACA;sBACA;sBACA;sBACA;sBACA;sBACA;sBACA;sBACA,SAAS,QAAQ,UAAU,MAAM,MAAM,QAAQ;;;;;sBAI/C;sBACA;sBACA,OAAO,CAAA;sBACP,IAAI;sBACJ,WAAW,CAAA;sBACX,YAAY,CAAA;sBACZ;sBACA,SAAS;qBACV;kBACH,WAAW,eAAe,UAAU;AAClC,iCAAa,KAAK,UAAU,IAAI,EAAE;AAClC,gCAAY,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AAC3C,8BAAU,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AACzC,wBAAI,EAAE,cAAc,WAAW;AAC7B,+BAAS,UAAU,IAAI,CAAA;oBACzB;AAEA,6BAAS,UAAU,EAAE,SAAS,IAAI;AAClC,6BAAS,MAAM,YAAY,GAAG,MAAM,SAAS,OAAO;AAClD,+BAAS,UAAU,EAAE,GAAG,IAAI;oBAC9B;AACA,6BAAS,UAAU,EAAE,OAAO,IAAI;kBAClC,WAAW,eAAe,UAAU;AAIlC,0BAAM,OAAO,SAAS,KAAK,UAAU,GAAG,EAAE,CAAC;AAC3C,0BAAM,YAAY,cAAc,IAAI;AACpC,0BAAM,WAAW,MAAM,SAAS;AAChC,0BAAM,WAAW,CAAC,IAAI,IAAI,IAAI,EAAE;AAChC,6BAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,4BAAM,KAAK,SAAS,KAAK,UAAU,SAAS,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;AAChE,4BAAM,UAAU,cAAc,EAAE;AAChC,0BAAI,UAAU,YAAY,MAAM;AAChC,4BAAM,SAAS,MAAM,OAAO;AAC5B,0BAAI,aAAa,UAAa,WAAW,QAAW;AAElD,4BAAI,CAAC,UAAU,OAAO,GAAG;AACvB,oCAAU,OAAO,IAAI;AACrB,8BACE,SAAS,MAAM,UAAU,KACzB,SAAS,MAAM,SAAS,MAAM,SAAS,CAAC,MAAM,SAC9C;AACA,qCAAS,MAAM,KAAK,OAAO;AAC3B,qCAAS,UAAU,KAAK,CAAC;0BAC3B;wBACF,OAAO;AAEL,oCAAU,OAAO,KAAK;AAEtB,mCAAS,KAAK,GAAG,KAAK,SAAS,MAAM,QAAQ,MAAM;AACjD,gCAAI,SAAS,MAAM,EAAE,KAAK,SAAS;AACjC,oCAAM,QAAQ,UAAU,OAAO;AAC/B,kCAAI,SAAS,GAAG;AAEd,yCAAS,UAAU,EAAE,IAAI;8BAC3B,OAAO;AACL,yCAAS,UAAU,EAAE,IAAI;8BAC3B;4BACF;0BACF;wBACF;sBACF;oBACF;kBACF,WAAW,eAAe,UAAU;AAClC,iCAAa,KAAK,UAAU,IAAI,EAAE;AAClC,gCAAY,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AAC3C,8BAAU,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC;AACzC,wBAAI,EAAE,cAAc,WAAW;AAC7B,+BAAS,UAAU,IAAI,CAAA;oBACzB;AACA,6BAAS,UAAU,EAAE,SAAS,IAAI;AAClC,6BAAS,MAAM,YAAY,GAAG,MAAM,SAAS,OAAO;AAClD,+BAAS,UAAU,EAAE,GAAG,IAAI;oBAC9B;AACA,6BAAS,UAAU,EAAE,OAAO,IAAI;kBAClC,WACE,CAAC,cACD,eAAe,YACf,KAAK,UAAU,IAAI,EAAE,MAAM,SAC3B;AACA,wBAAI;AACJ,wBAAI,SAAS,IAAI,oCAAA,QAAO;AACxB,yBAAK,IAAI,GAAG,KAAK,GAAG,KAAK;AACvB,6BAAO,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE;AAClC,0BAAI,SAAS,KAAK,UAAU,IAAI,EAAE,CAAC,KAAK,GAAG;AAMzC,+BAAO,SAAS,IAAI,CAAC,IAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AAC1D,+BAAO,SAAS,IAAI,IAAI,CAAC,IAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AAC9D,+BAAO,SAAS,IAAI,IAAI,CAAC,IAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AAC9D,+BAAO,SAAS,IAAI,IAAI,EAAE,IAAI,WAAW,KAAK,UAAU,EAAE,CAAC;AAC3D;sBACF,OAAO;AACL,+BAAO,KAAK,UAAU,IAAI,EAAE,MAAM,SAAS;AACzC;AACA,iCAAO,MAAM,CAAC,EAAE,QAAQ,QAAQ,EAAE;wBACpC;sBACF;oBACF;AACA,2BAAO,SAAS,CAAC,IAAI;AACrB,2BAAO,SAAS,CAAC,IAAI;AACrB,2BAAO,SAAS,EAAE,IAAI;AACtB,2BAAO,SAAS,EAAE,IAAI;AACtB,8BAAU,WAAW,KAAK,MAAM;AAChC;kBACF,WAAW,eAAe,UAAU;AAClC,wBAAI,GACF,GACA,GACA,OACA,MACA;AACF,wBAAI,WAAW,KAAK,UAAU,GAAG,EAAE,CAAC;AACpC,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,wBAAI,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACrC,4BAAQ,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACzC,2BAAO,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACxC,4BAAQ,WAAW,KAAK,UAAU,IAAI,EAAE,CAAC;AACzC,8BAAU,QAAQ;sBAChB;sBACA;sBACA;sBACA;sBACA;sBACA;;kBAEJ,WAAW,eAAe,UAAU;AAClC,0BAAM,SAAS,SAAS,KAAK,UAAU,GAAG,EAAE,CAAC;AAC7C,0BAAM,kBAAkB,cAAc,MAAM;AAC5C,0BAAM,aAAa,MAAM,eAAe;AACxC,wBAAI,YAAY;AACd,4BAAM,OAAO,KAAK,UAAU,EAAE,EAAE,KAAI,EAAG,MAAM,KAAK;AAClD,4BAAM,OAAO;wBACX,KAAK,SAAS,KAAK,CAAC,CAAC;wBACrB,KAAK,SAAS,KAAK,CAAC,CAAC;wBACrB,KAAK,SAAS,KAAK,CAAC,CAAC;wBACrB,KAAK,SAAS,KAAK,CAAC,CAAC;wBACrB,KAAK,SAAS,KAAK,CAAC,CAAC;wBACrB,KAAK,SAAS,KAAK,CAAC,CAAC;;AAGvB,iCAAW,OAAO;oBACpB;kBACF;gBACF;AAGA,iBAAA,GAAA,4CAAA,eAAc,OAAO,aAAa;AAElC,oBAAI;AAAa,mBAAA,GAAA,6CAAA,gBAAe,OAAO,OAAO;AAE9C,oBAAI,CAAC;AACH,mBAAA,GAAA,gDAAA,mBAAkB,UAAU,YAAY,OAAO,SAAS,UAAU,KAAK;AAEzE,oBAAI,iBAAiB,CAAC,cAAc;AAClC,mBAAA,GAAA,wDAAA,2BAA0B,OAAO,QAAQ,WAAW;gBACtD;AAGA,oBAAI,EAAC,GAAA,sCAAA,SAAQ,QAAQ,GAAG;AACtB,2BAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,0BAAMnE,QAAO,MAAM,CAAC;AACpB,wBAAIA,UAAS;AAAW;AACxB,wBAAIA,MAAK,SAAS,YAAYA,MAAK,QAAQ,SAASA,MAAK,KAAK,GAAG;AAC/D,4BAAM,OAAO,SAASA,MAAK,KAAK,EAAEA,MAAK,IAAI;AAC3C,sBAAAA,MAAK,KAAK,KAAK,CAAC;AAChB,0BAAI,KAAK,SAAS,GAAG;AACnB,4BAAI,KAAK,CAAC,KAAK;AAAK,0BAAAA,MAAK,UAAU;iCAC1B,KAAK,CAAC,KAAK;AAAK,0BAAAA,MAAK,QAAQ;sBACxC;oBACF;kBACF;gBACF;AAGA,uBAAO,CAAC,OAAO,WAAW,cAAc;cAC1C;;;;;;;;;;;;;ACrSO,uBAAS,QAAQ,KAGvB;AACC,2BAAW,KAAK,KAAK;AACnB,yBAAO;gBACT;AACA,uBAAO;cACT;;;;;;;;;;;;;;;;;ACFO,uBAAS,kBACd,cACA,OACA,SACA,OAAqE;AAErE,sBAAM,gBAAgB,CAAC,QAAQ;AAC/B,sBAAM,MAAM,MAAM;AAClB,oBAAI,SAAS;AAEb,oBAAI,mBAAmB;AACvB,oBAAI,mBAAmB;AACvB,oBAAI,SAAS;AAEb,qBAAK,QAAQ,qBAAqB,QAAQ,cAAc,OAAO;AAC7D,sCAAmB,GAAA,oCAAA,mBACjB,MAAM,GACN,MAAM,GACN,MAAM,GACN,MAAM,OACN,MAAM,MACN,MAAM,KAAK;AAEb,2BAAS,IAAI,oCAAA,QAAO;AACpB,yBAAO,YAAY,gBAAgB;gBACrC;AAEA,oBAAI,gBAAgB,SAAU,GAAU;AACtC,sBAAI,IAAI,EAAE,MAAK,EAAG,aAAa,MAAM;AACrC,wBAAM,QAAQ,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AAC5B,wBAAM,aAAa,CAAC,GAAK,GAAK,CAAG;AACjC,2BAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,2BAAO,MAAM,CAAC,IAAI,OAAQ;AACxB,4BAAM,CAAC,KAAK;AACZ,iCAAW,CAAC,KAAK;oBACnB;AACA,2BAAO,MAAM,CAAC,IAAI,OAAO;AACvB,4BAAM,CAAC,KAAK;AACZ,iCAAW,CAAC,KAAK;oBACnB;kBACF;AAEA,wBAAM,gBAAgB,IAAI,oCAAA,QACxB,WAAW,CAAC,GACZ,WAAW,CAAC,GACZ,WAAW,CAAC,CAAC;AAEf,gCAAc,aAAa,gBAAgB;AAC3C,yBAAO;gBACT;AAEA,oBAAI,QAAQ,qBAAqB,OAAO;AAOtC,2BAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAE5C,0BAAM,SAAS,IAAI,oCAAA,QAAQ,GAAG,GAAG,CAAC;AAClC,6BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,4BAAM,MAAM,IAAI,oCAAA,QAAQ,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;AAC1D,0BAAI,aAAa,aAAa,CAAC,CAAC;AAEhC,6BAAO,IAAI,GAAG;oBAChB;AACA,2BAAO,aAAa,GAAG;AAEvB,0BAAM,gBAAgB,cAAc,MAAM;AAE1C,wBACE,aAAa,CAAC,EAAE,iBAAgB,KAChC,cAAc,SAAQ,IAAK,MAC3B;AACA,yCAAmB;oBACrB;AACA,iCAAa,CAAC,EAAE,UAAU,aAAa;kBACzC;gBACF;AACA,oBAAI,CAAC,eAAe;AAElB,2BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,0BAAM,CAAC,EAAE,MAAM;kBACjB;AACA,2BAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,wBAAI,CAAC,aAAa,CAAC,EAAE,iBAAgB,KAAM,oBAAoB,GAAG;AAChE,0BAAI,MAAM,IAAI,oCAAA,QAAO;AACrB,+BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,8BAAM,WAAqB,CAAA;AAC3B,iCAAS,IAAI,GAAG,IAAI,MAAM,CAAC,EAAE,MAAM,QAAQ,KAAK;AAC9C,mCAAS,KAAK,MAAM,CAAC,EAAE,MAAM,CAAC,IAAI,MAAM;wBAC1C;AACA,4BAAI,IAAI,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;AAC1C,4BAAI,aAAa,aAAa,CAAC,CAAC;AAEhC,4BAAI,QAAQ,aAAa,OAAO;AAE9B,8BAAI,aAAa,cAAc,GAAG;AAClC,8BAAI,IAAI,UAAU;wBACpB;AAEA,8BAAM,UAAmC,CAAA;AACzC,mCAAW,KAAK,MAAM,CAAC,GAAG;AACxB,kCAAQ,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;wBACzB;AACA,gCAAQ,IAAI,IAAI;AAChB,gCAAQ,IAAI,IAAI;AAChB,gCAAQ,IAAI,IAAI;AAChB,gCAAQ,QAAQ;AAChB,gCAAQ,MAAM;AACd,gCAAQ,QAAQ,MAAM;AACtB,8BAAM,KAAK,OAAO;sBACpB;AACA,+BAAS,MAAM;oBACjB,OAAO;AACL,+BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,8BAAM,CAAC,EAAE,MAAM;sBACjB;oBACF;kBACF;AACA,sBAAI,QAAQ,aAAa,OAAO;AAG9B,wBAAI,MAAM,IAAI,oCAAA,QAAO;AACrB,6BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,0BAAI,IAAI,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;AAE1C,0BAAI,aAAa,cAAc,GAAG;AAClC,0BAAI,IAAI,UAAU;AAClB,4BAAM,CAAC,EAAE,IAAI,IAAI;AACjB,4BAAM,CAAC,EAAE,IAAI,IAAI;AACjB,4BAAM,CAAC,EAAE,IAAI,IAAI;oBACnB;kBACF;AACA,sBAAI,oBAAoB,GAAG;AAEzB,0BAAM,MAAM,IAAI,oCAAA,QAAO;AACvB,6BAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,0BAAI,IAAI,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;AAC1C,0BAAI,aAAa,aAAa,gBAAgB,CAAC;AAC/C,4BAAM,CAAC,EAAE,IAAI,IAAI;AACjB,4BAAM,CAAC,EAAE,IAAI,IAAI;AACjB,4BAAM,CAAC,EAAE,IAAI,IAAI;oBACnB;kBACF;AAEC,+BAAqB,SAAS;gBACjC,WAAW,aAAa,SAAS,GAAG;AAClC,2BAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,wBAAI,aAAwB,CAAA;AAC5B,6BAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,0BAAI,CAAC,aAAa,CAAC,EAAE,iBAAgB,GAAI;AACvC,4BAAI,SAAS,IAAI,oCAAA,QAAO;AACxB,+BAAO,IAAI,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;AAC7C,+BAAO,aAAa,aAAa,CAAC,CAAC;AACnC,mCAAW,KAAK,MAAM;sBACxB;oBACF;AACA,0BAAM,CAAC,EAAE,aAAa;kBACxB;gBACF;cACF;;;;;;;;;;;;;ACxKO,oBAAM,mBAAgC,oBAAI,IAAI;gBACnD;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;eACD;;;;;;;;;;;;;AC/DM,uBAAS,cAAc,YAAwB,eAAuB;AAC3E,yBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAK;AACjD,wBAAM,OAAO,WAAW,CAAC;AACzB,2BAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,0BAAM,MAAM,KAAK,MAAM,CAAC;AACxB,0BAAM,QAAQ,WAAW,GAAG;AAC5B,0BAAM,QAAQ,cAAc,KAAK,MAAM;AACvC,wBAAI,SAAS,OAAO;AAClB,4BAAM,MAAM,MAAM,MAAM,QAAQ,KAAK;AACrC,0BAAI,MAAM,GAAG;AACX,8BAAM,MAAM,KAAK,KAAK;AACtB,8BAAM,UAAU,KAAK,KAAK,UAAU,CAAC,CAAC;sBACxC;oBACF;kBACF;gBACF;cACF;;;;;;;;;;;;;;;;;;ACjBO,oBAAM,iBAAiB;gBAC9B,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAAS;gBACT,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,WAAW;gBACX,WAAW;gBACX,WAAW;gBACX,WAAW;gBACX,UAAU;gBACV,SAAS;gBACT,SAAS;gBACT,SAA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",
  "names": ["slice", "returnArray", "header", "rank", "module", "__webpack_require__", "UPNG", "pako", "a", "b", "exports", "CAP", "GLDraw", "idx", "a3", "self", "drawMethod", "geo", "fromCap", "toCap", "i", "val", "j", "dist", "atom", "callback", "c", "label", "atoms", "component", "index", "g", "resolve", "next", "rangle", "ret", "extent", "offsetA", "addSurfaceHelper", "atomlist", "atomsToShow", "callSyncHelper", "promises", "worker", "surfid", "_colors__WEBPACK_IMPORTED_MODULE_2__", "SurfaceType", "ProteinSurface", "str", "before", "after", "atPoint", "sprite", "Coloring", "Shading", "TextureOperations", "x", "y", "z", "x2", "y2", "z2", "LineStyle", "glviewer", "viewer", "process", "viewerdiv", "moldata", "type", "cartoon", "div", "color", "__webpack_exports__", "lineNum", "line", "k", "kl", "atomIndex1", "atomIndex2", "bondOrder", "i1", "i2", "a1", "a2", "n", "offset", "delta", "Encoding", "IntDataType", "FloatDataType", "il", "r", "m", "t", "e", "o", "u", "s", "f", "d", "l", "v", "L", "h", "p", "U", "I", "w", "C", "A", "M", "F", "S", "E", "N", "O", "T", "q", "D", "P", "B", "V", "G", "R", "H", "W", "X"]
}
